// $ANTLR 3.0 C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g 2007-08-21 22:59:24
namespace
CodeReformatter.Generators.Core
{

    using System.IO;
    using System.Diagnostics;


    using System;
    using Antlr.Runtime;
    using IList = System.Collections.IList;
    using ArrayList = System.Collections.ArrayList;
    using Stack = Antlr.Runtime.Collections.StackList;

    using IDictionary = System.Collections.IDictionary;
    using Hashtable = System.Collections.Hashtable;



    using Antlr.Runtime.Tree;

    public class ASParser : Parser
    {
        public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"COMPILATION_UNIT", 
		"TYPE_BLOCK", 
		"METHOD_DEF", 
		"VAR_DEF", 
		"ANNOTATIONS", 
		"ANNOTATION", 
		"ANNOTATION_PARAMS", 
		"MODIFIERS", 
		"NAMESPACE_DEF", 
		"ACCESSOR_ROLE", 
		"CLASS_DEF", 
		"INTERFACE_DEF", 
		"PARAMS", 
		"PARAM", 
		"TYPE_SPEC", 
		"BLOCK", 
		"ELIST", 
		"CONDITION", 
		"ARGUMENTS", 
		"EXPR_STMNT", 
		"ENCPS_EXPR", 
		"VAR_INIT", 
		"METHOD_CALL", 
		"PROPERTY_OR_IDENTIFIER", 
		"PROPERTY_ACCESS", 
		"TYPE_NAME", 
		"ARRAY_ACC", 
		"UNARY_PLUS", 
		"UNARY_MINUS", 
		"POST_INC", 
		"POST_DEC", 
		"PRE_INC", 
		"PRE_DEC", 
		"ARRAY_LITERAL", 
		"ELEMENT", 
		"OBJECT_LITERAL", 
		"OBJECT_FIELD", 
		"FUNC_DEF", 
		"FOR_INIT", 
		"FOR_CONDITION", 
		"FOR_ITERATOR", 
		"FOR_EACH", 
		"FOR_IN", 
		"SWITCH_STATEMENT_LIST", 
		"IDENTIFIER", 
		"DEFAULT_XML_NAMESPACE", 
		"SINGLELINE_COMMENT", 
		"MULTILINE_COMMENT", 
		"VIRTUAL_PLACEHOLDER", 
		"PACKAGE", 
		"LCURLY", 
		"RCURLY", 
		"SEMI", 
		"IMPORT", 
		"CLASS", 
		"INTERFACE", 
		"EXTENDS", 
		"COMMA", 
		"IMPLEMENTS", 
		"INCLUDE_DIRECTIVE", 
		"STRING_LITERAL", 
		"FUNCTION", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"USE", 
		"VAR", 
		"CONST", 
		"ASSIGN", 
		"LPAREN", 
		"RPAREN", 
		"REST", 
		"IF", 
		"ELSE", 
		"RETURN", 
		"CONTINUE", 
		"BREAK", 
		"SWITCH", 
		"CASE", 
		"COLON", 
		"DEFAULT", 
		"FOR", 
		"EACH", 
		"IN", 
		"WHILE", 
		"DO", 
		"WITH", 
		"XML", 
		"STAR", 
		"DOT", 
		"DBL_COLON", 
		"IDENT", 
		"PUBLIC", 
		"PRIVATE", 
		"PROTECTED", 
		"INTERNAL", 
		"LBRACK", 
		"RBRACK", 
		"STATIC", 
		"DYNAMIC", 
		"STAR_ASSIGN", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"PLUS_ASSIGN", 
		"MINUS_ASSIGN", 
		"SL_ASSIGN", 
		"SR_ASSIGN", 
		"BSR_ASSIGN", 
		"BAND_ASSIGN", 
		"BXOR_ASSIGN", 
		"BOR_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"QUESTION", 
		"LOR", 
		"LAND", 
		"BOR", 
		"BXOR", 
		"BAND", 
		"STRICT_EQUAL", 
		"STRICT_NOT_EQUAL", 
		"NOT_EQUAL", 
		"EQUAL", 
		"LT", 
		"GT", 
		"LE", 
		"GE", 
		"IS", 
		"AS", 
		"INSTANCEOF", 
		"SL", 
		"SR", 
		"BSR", 
		"PLUS", 
		"MINUS", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"DELETE", 
		"TYPEOF", 
		"LNOT", 
		"BNOT", 
		"E4X_DESC", 
		"E4X_ATTRI", 
		"UNDEFINED", 
		"TRUE", 
		"FALSE", 
		"NULL", 
		"HEX_LITERAL", 
		"DECIMAL_LITERAL", 
		"OCTAL_LITERAL", 
		"FLOAT_LITERAL", 
		"NEW", 
		"SL_COMMENT", 
		"ML_COMMENT", 
		"UNICODE_IDENTIFIER_START", 
		"UNICODE_IDENTIFIER_PART", 
		"ESC", 
		"HEX_DIGIT", 
		"EXPONENT", 
		"WS", 
		"NL", 
		"BOM", 
		"OCT_DIGIT", 
		"CTRLCHAR_ESC", 
		"UNICODE_ESC", 
		"OCTAL_ESC", 
		"'include'", 
		"'throw'", 
		"'try'", 
		"'catch'", 
		"'finally'", 
		"'void'", 
		"'final'", 
		"'enumerable'", 
		"'explicit'", 
		"'override'", 
		"'intrinsic'", 
		"'or'", 
		"'and'"
    };

        public const int INTERNAL = 99;
        public const int BLOCK = 19;
        public const int BOR_ASSIGN = 114;
        public const int STRING_LITERAL = 64;
        public const int GT = 128;
        public const int HEX_DIGIT = 163;
        public const int GET = 66;
        public const int UNDEFINED = 149;
        public const int SL_ASSIGN = 109;
        public const int PRE_DEC = 36;
        public const int LOR_ASSIGN = 116;
        public const int SR = 135;
        public const int IMPLEMENTS = 62;
        public const int GE = 130;
        public const int LBRACK = 100;
        public const int OCTAL_LITERAL = 155;
        public const int SL = 134;
        public const int PROPERTY_OR_IDENTIFIER = 27;
        public const int SINGLELINE_COMMENT = 50;
        public const int UNICODE_ESC = 170;
        public const int EXTENDS = 60;
        public const int NAMESPACE_DEF = 12;
        public const int FOR_IN = 46;
        public const int NOT_EQUAL = 125;
        public const int MOD_ASSIGN = 106;
        public const int LCURLY = 54;
        public const int UNARY_MINUS = 32;
        public const int LNOT = 145;
        public const int ACCESSOR_ROLE = 13;
        public const int E4X_ATTRI = 148;
        public const int MULTILINE_COMMENT = 51;
        public const int DEFAULT = 84;
        public const int STATIC = 102;
        public const int ML_COMMENT = 159;
        public const int OCTAL_ESC = 171;
        public const int STRICT_NOT_EQUAL = 124;
        public const int OCT_DIGIT = 168;
        public const int ANNOTATIONS = 8;
        public const int E4X_DESC = 147;
        public const int POST_DEC = 34;
        public const int DECIMAL_LITERAL = 154;
        public const int MOD = 140;
        public const int INTERFACE_DEF = 15;
        public const int MODIFIERS = 11;
        public const int TYPE_SPEC = 18;
        public const int DIV = 139;
        public const int UNARY_PLUS = 31;
        public const int EACH = 86;
        public const int DEFAULT_XML_NAMESPACE = 49;
        public const int LAND_ASSIGN = 115;
        public const int CONDITION = 21;
        public const int ASSIGN = 72;
        public const int NULL = 152;
        public const int PRIVATE = 97;
        public const int DO = 89;
        public const int EOF = -1;
        public const int MINUS = 138;
        public const int SWITCH_STATEMENT_LIST = 47;
        public const int PARAM = 17;
        public const int TYPE_BLOCK = 5;
        public const int VIRTUAL_PLACEHOLDER = 52;
        public const int VAR_INIT = 25;
        public const int INSTANCEOF = 133;
        public const int FUNCTION = 65;
        public const int PROPERTY_ACCESS = 28;
        public const int TYPE_NAME = 29;
        public const int INC = 141;
        public const int RETURN = 78;
        public const int ELSE = 77;
        public const int EQUAL = 126;
        public const int BXOR_ASSIGN = 113;
        public const int CTRLCHAR_ESC = 169;
        public const int BSR_ASSIGN = 111;
        public const int TRUE = 150;
        public const int DBL_COLON = 94;
        public const int IDENTIFIER = 48;
        public const int SEMI = 56;
        public const int STRICT_EQUAL = 123;
        public const int PLUS_ASSIGN = 107;
        public const int BSR = 136;
        public const int OBJECT_FIELD = 40;
        public const int ELEMENT = 38;
        public const int NEW = 157;
        public const int DIV_ASSIGN = 105;
        public const int DELETE = 143;
        public const int NL = 166;
        public const int IDENT = 95;
        public const int BAND_ASSIGN = 112;
        public const int AS = 132;
        public const int CASE = 82;
        public const int OBJECT_LITERAL = 39;
        public const int RBRACK = 101;
        public const int LPAREN = 73;
        public const int PLUS = 137;
        public const int CLASS = 58;
        public const int FUNC_DEF = 41;
        public const int ARRAY_ACC = 30;
        public const int BREAK = 80;
        public const int WHILE = 88;
        public const int CONST = 71;
        public const int RCURLY = 55;
        public const int INTERFACE = 59;
        public const int PARAMS = 16;
        public const int FOR_INIT = 42;
        public const int DEC = 142;
        public const int COMMA = 61;
        public const int COMPILATION_UNIT = 4;
        public const int LT = 127;
        public const int FOR_ITERATOR = 44;
        public const int ARGUMENTS = 22;
        public const int LE = 129;
        public const int FOR_CONDITION = 43;
        public const int CLASS_DEF = 14;
        public const int MINUS_ASSIGN = 108;
        public const int ENCPS_EXPR = 24;
        public const int LOR = 118;
        public const int WITH = 90;
        public const int REST = 75;
        public const int INCLUDE_DIRECTIVE = 63;
        public const int BAND = 122;
        public const int STAR_ASSIGN = 104;
        public const int EXPONENT = 164;
        public const int SL_COMMENT = 158;
        public const int VAR = 70;
        public const int WS = 165;
        public const int PACKAGE = 53;
        public const int STAR = 92;
        public const int FOR = 85;
        public const int FALSE = 151;
        public const int UNICODE_IDENTIFIER_PART = 161;
        public const int IMPORT = 57;
        public const int DOT = 93;
        public const int XML = 91;
        public const int ANNOTATION = 9;
        public const int QUESTION = 117;
        public const int EXPR_STMNT = 23;
        public const int PRE_INC = 35;
        public const int BOR = 120;
        public const int NAMESPACE = 68;
        public const int BOM = 167;
        public const int SWITCH = 81;
        public const int CONTINUE = 79;
        public const int ARRAY_LITERAL = 37;
        public const int USE = 69;
        public const int SR_ASSIGN = 110;
        public const int ANNOTATION_PARAMS = 10;
        public const int HEX_LITERAL = 153;
        public const int IS = 131;
        public const int METHOD_CALL = 26;
        public const int FOR_EACH = 45;
        public const int LAND = 119;
        public const int DYNAMIC = 103;
        public const int IN = 87;
        public const int BXOR = 121;
        public const int METHOD_DEF = 6;
        public const int VAR_DEF = 7;
        public const int IF = 76;
        public const int ELIST = 20;
        public const int TYPEOF = 144;
        public const int FLOAT_LITERAL = 156;
        public const int COLON = 83;
        public const int SET = 67;
        public const int PUBLIC = 96;
        public const int UNICODE_IDENTIFIER_START = 160;
        public const int POST_INC = 33;
        public const int ESC = 162;
        public const int BNOT = 146;
        public const int RPAREN = 74;
        public const int PROTECTED = 98;
        protected class InOperator_scope
        {
            protected internal Boolean allowed;
        }
        protected Stack InOperator_stack = new Stack();



        public ASParser(ITokenStream input)
            : base(input)
        {
            InitializeCyclicDFAs();
            ruleMemo = new IDictionary[339 + 1];
        }

        protected ITreeAdaptor adaptor = new CommonTreeAdaptor();

        public ITreeAdaptor TreeAdaptor
        {
            get { return this.adaptor; }
            set { this.adaptor = value; }
        }

        override public string[] TokenNames
        {
            get { return tokenNames; }
        }

        override public string GrammarFileName
        {
            get { return "C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g"; }
        }



        #region Members

        private ASLexer lexer;
        private ICharStream cs;
        public static int CHANNEL_PLACEHOLDER = 999;

        public void SetInput(ASLexer lexer, ICharStream cs)
        {
            this.lexer = lexer;
            this.cs = cs;
        }

        /*
        private CommonTree parseXMLLiteral()
        {
            return E4XHelper.parseXMLLiteral(lexer, cs, input);
        }	
        */

        #endregion


        public class compilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start compilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:93:1: compilationUnit : ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) ;
        public compilationUnit_return compilationUnit() // throws RecognitionException [1]
        {
            compilationUnit_return retval = new compilationUnit_return();
            retval.start = input.LT(1);
            int compilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            as2CompilationUnit_return as2CompilationUnit1 = null;

            as3CompilationUnit_return as3CompilationUnit2 = null;


            RewriteRuleSubtreeStream stream_as2CompilationUnit = new RewriteRuleSubtreeStream(adaptor, "rule as2CompilationUnit");
            RewriteRuleSubtreeStream stream_as3CompilationUnit = new RewriteRuleSubtreeStream(adaptor, "rule as3CompilationUnit");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 1))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:4: ( ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:4: ( as2CompilationUnit | as3CompilationUnit )
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:4: ( as2CompilationUnit | as3CompilationUnit )
                    int alt1 = 2;
                    switch (input.LA(1))
                    {
                        case SL_COMMENT:
                            {
                                switch (input.LA(2))
                                {
                                    case PACKAGE:
                                        {
                                            alt1 = 2;
                                        }
                                        break;
                                    case SL_COMMENT:
                                        {
                                            int LA1_19 = input.LA(3);

                                            if ((synpred1()))
                                            {
                                                alt1 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt1 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d1s19 =
                                                    new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 19, input);

                                                throw nvae_d1s19;
                                            }
                                        }
                                        break;
                                    case ML_COMMENT:
                                        {
                                            int LA1_20 = input.LA(3);

                                            if ((synpred1()))
                                            {
                                                alt1 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt1 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d1s20 =
                                                    new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 20, input);

                                                throw nvae_d1s20;
                                            }
                                        }
                                        break;
                                    case IMPORT:
                                    case CLASS:
                                    case INTERFACE:
                                    case IDENT:
                                    case PUBLIC:
                                    case PRIVATE:
                                    case PROTECTED:
                                    case INTERNAL:
                                    case LBRACK:
                                    case STATIC:
                                    case DYNAMIC:
                                    case 172:
                                    case 178:
                                    case 179:
                                    case 180:
                                    case 181:
                                    case 182:
                                        {
                                            alt1 = 1;
                                        }
                                        break;
                                    default:
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d1s1 =
                                            new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 1, input);

                                        throw nvae_d1s1;
                                }

                            }
                            break;
                        case ML_COMMENT:
                            {
                                switch (input.LA(2))
                                {
                                    case PACKAGE:
                                        {
                                            alt1 = 2;
                                        }
                                        break;
                                    case SL_COMMENT:
                                        {
                                            int LA1_36 = input.LA(3);

                                            if ((synpred1()))
                                            {
                                                alt1 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt1 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d1s36 =
                                                    new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 36, input);

                                                throw nvae_d1s36;
                                            }
                                        }
                                        break;
                                    case ML_COMMENT:
                                        {
                                            int LA1_37 = input.LA(3);

                                            if ((synpred1()))
                                            {
                                                alt1 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt1 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d1s37 =
                                                    new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 37, input);

                                                throw nvae_d1s37;
                                            }
                                        }
                                        break;
                                    case IMPORT:
                                    case CLASS:
                                    case INTERFACE:
                                    case IDENT:
                                    case PUBLIC:
                                    case PRIVATE:
                                    case PROTECTED:
                                    case INTERNAL:
                                    case LBRACK:
                                    case STATIC:
                                    case DYNAMIC:
                                    case 172:
                                    case 178:
                                    case 179:
                                    case 180:
                                    case 181:
                                    case 182:
                                        {
                                            alt1 = 1;
                                        }
                                        break;
                                    default:
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d1s2 =
                                            new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 2, input);

                                        throw nvae_d1s2;
                                }

                            }
                            break;
                        case IMPORT:
                        case CLASS:
                        case INTERFACE:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case LBRACK:
                        case STATIC:
                        case DYNAMIC:
                        case 172:
                        case 178:
                        case 179:
                        case 180:
                        case 181:
                        case 182:
                            {
                                alt1 = 1;
                            }
                            break;
                        case PACKAGE:
                            {
                                alt1 = 2;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d1s0 =
                                new NoViableAltException("97:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 0, input);

                            throw nvae_d1s0;
                    }

                    switch (alt1)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:6: as2CompilationUnit
                            {
                                PushFollow(FOLLOW_as2CompilationUnit_in_compilationUnit337);
                                as2CompilationUnit1 = as2CompilationUnit();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:5: as3CompilationUnit
                            {
                                PushFollow(FOLLOW_as3CompilationUnit_in_compilationUnit343);
                                as3CompilationUnit2 = as3CompilationUnit();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          as3CompilationUnit, as2CompilationUnit
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 99:5: -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:8: ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:27: ( as2CompilationUnit )?
                                if (stream_as2CompilationUnit.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_as2CompilationUnit.Next());

                                }
                                stream_as2CompilationUnit.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:47: ( as3CompilationUnit )?
                                if (stream_as3CompilationUnit.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_as3CompilationUnit.Next());

                                }
                                stream_as3CompilationUnit.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 1, compilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end compilationUnit

        public class as2CompilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2CompilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:102:1: as2CompilationUnit : ( comment | importDefinition )* as2Type ;
        public as2CompilationUnit_return as2CompilationUnit() // throws RecognitionException [1]
        {
            as2CompilationUnit_return retval = new as2CompilationUnit_return();
            retval.start = input.LT(1);
            int as2CompilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            comment_return comment3 = null;

            importDefinition_return importDefinition4 = null;

            as2Type_return as2Type5 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 2))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:4: ( ( comment | importDefinition )* as2Type )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:4: ( comment | importDefinition )* as2Type
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:4: ( comment | importDefinition )*
                    do
                    {
                        int alt2 = 3;
                        int LA2_0 = input.LA(1);

                        if (((LA2_0 >= SL_COMMENT && LA2_0 <= ML_COMMENT)))
                        {
                            alt2 = 1;
                        }
                        else if ((LA2_0 == IMPORT))
                        {
                            alt2 = 2;
                        }


                        switch (alt2)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:5: comment
                                {
                                    PushFollow(FOLLOW_comment_in_as2CompilationUnit372);
                                    comment3 = comment();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, comment3.Tree);

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:15: importDefinition
                                {
                                    PushFollow(FOLLOW_importDefinition_in_as2CompilationUnit376);
                                    importDefinition4 = importDefinition();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, importDefinition4.Tree);

                                }
                                break;

                            default:
                                goto loop2;
                        }
                    } while (true);

                loop2:
                    ;	// Stops C# compiler whinging that label 'loop2' has no statements

                    PushFollow(FOLLOW_as2Type_in_as2CompilationUnit382);
                    as2Type5 = as2Type();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, as2Type5.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 2, as2CompilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2CompilationUnit

        public class as2Type_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2Type
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:107:1: as2Type : annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] ) ;
        public as2Type_return as2Type() // throws RecognitionException [1]
        {
            as2Type_return retval = new as2Type_return();
            retval.start = input.LT(1);
            int as2Type_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotations_return annos = null;

            modifiers_return mods = null;

            as2ClassDefinition_return as2ClassDefinition6 = null;

            as2InterfaceDefinition_return as2InterfaceDefinition7 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 3))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: (annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_annotations_in_as2Type395);
                    annos = annotations();
                    followingStackPointer_--;
                    if (failed) return retval;
                    PushFollow(FOLLOW_modifiers_in_as2Type402);
                    mods = modifiers();
                    followingStackPointer_--;
                    if (failed) return retval;
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:2: ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )
                    int alt3 = 2;
                    int LA3_0 = input.LA(1);

                    if ((LA3_0 == CLASS))
                    {
                        alt3 = 1;
                    }
                    else if ((LA3_0 == INTERFACE))
                    {
                        alt3 = 2;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d3s0 =
                            new NoViableAltException("110:2: ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )", 3, 0, input);

                        throw nvae_d3s0;
                    }
                    switch (alt3)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:4: as2ClassDefinition[$annos.tree,$mods.tree]
                            {
                                PushFollow(FOLLOW_as2ClassDefinition_in_as2Type408);
                                as2ClassDefinition6 = as2ClassDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, as2ClassDefinition6.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:4: as2InterfaceDefinition[$annos.tree,$mods.tree]
                            {
                                PushFollow(FOLLOW_as2InterfaceDefinition_in_as2Type414);
                                as2InterfaceDefinition7 = as2InterfaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, as2InterfaceDefinition7.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 3, as2Type_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2Type

        public class as3CompilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as3CompilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:115:1: as3CompilationUnit : ( comment )* packageDecl ( packageBlockEntry )* EOF ;
        public as3CompilationUnit_return as3CompilationUnit() // throws RecognitionException [1]
        {
            as3CompilationUnit_return retval = new as3CompilationUnit_return();
            retval.start = input.LT(1);
            int as3CompilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EOF11 = null;
            comment_return comment8 = null;

            packageDecl_return packageDecl9 = null;

            packageBlockEntry_return packageBlockEntry10 = null;


            CommonTree EOF11_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 4))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:6: ( ( comment )* packageDecl ( packageBlockEntry )* EOF )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:6: ( comment )* packageDecl ( packageBlockEntry )* EOF
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:6: ( comment )*
                    do
                    {
                        int alt4 = 2;
                        int LA4_0 = input.LA(1);

                        if (((LA4_0 >= SL_COMMENT && LA4_0 <= ML_COMMENT)))
                        {
                            alt4 = 1;
                        }


                        switch (alt4)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: comment
                                {
                                    PushFollow(FOLLOW_comment_in_as3CompilationUnit432);
                                    comment8 = comment();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, comment8.Tree);

                                }
                                break;

                            default:
                                goto loop4;
                        }
                    } while (true);

                loop4:
                    ;	// Stops C# compiler whinging that label 'loop4' has no statements

                    PushFollow(FOLLOW_packageDecl_in_as3CompilationUnit437);
                    packageDecl9 = packageDecl();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, packageDecl9.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:118:3: ( packageBlockEntry )*
                    do
                    {
                        int alt5 = 2;
                        int LA5_0 = input.LA(1);

                        if (((LA5_0 >= SEMI && LA5_0 <= INTERFACE) || LA5_0 == FUNCTION || (LA5_0 >= NAMESPACE && LA5_0 <= CONST) || (LA5_0 >= IDENT && LA5_0 <= LBRACK) || (LA5_0 >= STATIC && LA5_0 <= DYNAMIC) || (LA5_0 >= SL_COMMENT && LA5_0 <= ML_COMMENT) || LA5_0 == 172 || (LA5_0 >= 178 && LA5_0 <= 182)))
                        {
                            alt5 = 1;
                        }


                        switch (alt5)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
                                {
                                    PushFollow(FOLLOW_packageBlockEntry_in_as3CompilationUnit441);
                                    packageBlockEntry10 = packageBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, packageBlockEntry10.Tree);

                                }
                                break;

                            default:
                                goto loop5;
                        }
                    } while (true);

                loop5:
                    ;	// Stops C# compiler whinging that label 'loop5' has no statements

                    EOF11 = (IToken)input.LT(1);
                    Match(input, EOF, FOLLOW_EOF_in_as3CompilationUnit446); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 4, as3CompilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as3CompilationUnit

        public class packageDecl_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageDecl
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:122:1: packageDecl : PACKAGE ( identifier )? packageBlock ;
        public packageDecl_return packageDecl() // throws RecognitionException [1]
        {
            packageDecl_return retval = new packageDecl_return();
            retval.start = input.LT(1);
            int packageDecl_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken PACKAGE12 = null;
            identifier_return identifier13 = null;

            packageBlock_return packageBlock14 = null;


            CommonTree PACKAGE12_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 5))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:4: ( PACKAGE ( identifier )? packageBlock )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:4: PACKAGE ( identifier )? packageBlock
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PACKAGE12 = (IToken)input.LT(1);
                    Match(input, PACKAGE, FOLLOW_PACKAGE_in_packageDecl458); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        PACKAGE12_tree = (CommonTree)adaptor.Create(PACKAGE12);
                        root_0 = (CommonTree)adaptor.BecomeRoot(PACKAGE12_tree, root_0);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:13: ( identifier )?
                    int alt6 = 2;
                    int LA6_0 = input.LA(1);

                    if (((LA6_0 >= GET && LA6_0 <= USE) || LA6_0 == XML || (LA6_0 >= IDENT && LA6_0 <= INTERNAL) || LA6_0 == DYNAMIC || (LA6_0 >= IS && LA6_0 <= AS)))
                    {
                        alt6 = 1;
                    }
                    switch (alt6)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: identifier
                            {
                                PushFollow(FOLLOW_identifier_in_packageDecl461);
                                identifier13 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier13.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_packageBlock_in_packageDecl466);
                    packageBlock14 = packageBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, packageBlock14.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 5, packageDecl_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageDecl

        public class packageBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:127:1: packageBlock : LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) ;
        public packageBlock_return packageBlock() // throws RecognitionException [1]
        {
            packageBlock_return retval = new packageBlock_return();
            retval.start = input.LT(1);
            int packageBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY15 = null;
            IToken RCURLY17 = null;
            packageBlockEntry_return packageBlockEntry16 = null;


            CommonTree LCURLY15_tree = null;
            CommonTree RCURLY17_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_packageBlockEntry = new RewriteRuleSubtreeStream(adaptor, "rule packageBlockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 6))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:128:4: ( LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:128:4: LCURLY ( packageBlockEntry )* RCURLY
                {
                    LCURLY15 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_packageBlock477); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY15);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:129:3: ( packageBlockEntry )*
                    do
                    {
                        int alt7 = 2;
                        int LA7_0 = input.LA(1);

                        if (((LA7_0 >= SEMI && LA7_0 <= INTERFACE) || LA7_0 == FUNCTION || (LA7_0 >= NAMESPACE && LA7_0 <= CONST) || (LA7_0 >= IDENT && LA7_0 <= LBRACK) || (LA7_0 >= STATIC && LA7_0 <= DYNAMIC) || (LA7_0 >= SL_COMMENT && LA7_0 <= ML_COMMENT) || LA7_0 == 172 || (LA7_0 >= 178 && LA7_0 <= 182)))
                        {
                            alt7 = 1;
                        }


                        switch (alt7)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
                                {
                                    PushFollow(FOLLOW_packageBlockEntry_in_packageBlock481);
                                    packageBlockEntry16 = packageBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_packageBlockEntry.Add(packageBlockEntry16.Tree);

                                }
                                break;

                            default:
                                goto loop7;
                        }
                    } while (true);

                loop7:
                    ;	// Stops C# compiler whinging that label 'loop7' has no statements

                    RCURLY17 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_packageBlock486); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY17);


                    // AST REWRITE
                    // elements:          packageBlockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 131:3: -> ^( BLOCK ( packageBlockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:131:6: ^( BLOCK ( packageBlockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:131:14: ( packageBlockEntry )*
                                while (stream_packageBlockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_packageBlockEntry.Next());

                                }
                                stream_packageBlockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 6, packageBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageBlock

        public class packageBlockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageBlockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:134:1: packageBlockEntry : ( ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI ) | comment );
        public packageBlockEntry_return packageBlockEntry() // throws RecognitionException [1]
        {
            packageBlockEntry_return retval = new packageBlockEntry_return();
            retval.start = input.LT(1);
            int packageBlockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI25 = null;
            annotations_return annos = null;

            modifiers_return mods = null;

            importDefinition_return importDefinition18 = null;

            classDefinition_return classDefinition19 = null;

            interfaceDefinition_return interfaceDefinition20 = null;

            variableDefinition_return variableDefinition21 = null;

            methodDefinition_return methodDefinition22 = null;

            namespaceDefinition_return namespaceDefinition23 = null;

            useNamespaceDirective_return useNamespaceDirective24 = null;

            comment_return comment26 = null;


            CommonTree SEMI25_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 7))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI ) | comment )
                int alt10 = 2;
                int LA10_0 = input.LA(1);

                if (((LA10_0 >= SEMI && LA10_0 <= INTERFACE) || LA10_0 == FUNCTION || (LA10_0 >= NAMESPACE && LA10_0 <= CONST) || (LA10_0 >= IDENT && LA10_0 <= LBRACK) || (LA10_0 >= STATIC && LA10_0 <= DYNAMIC) || LA10_0 == 172 || (LA10_0 >= 178 && LA10_0 <= 182)))
                {
                    alt10 = 1;
                }
                else if (((LA10_0 >= SL_COMMENT && LA10_0 <= ML_COMMENT)))
                {
                    alt10 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d10s0 =
                        new NoViableAltException("134:1: packageBlockEntry : ( ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI ) | comment );", 10, 0, input);

                    throw nvae_d10s0;
                }
                switch (alt10)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )
                            int alt9 = 3;
                            switch (input.LA(1))
                            {
                                case IMPORT:
                                    {
                                        alt9 = 1;
                                    }
                                    break;
                                case CLASS:
                                case INTERFACE:
                                case FUNCTION:
                                case NAMESPACE:
                                case USE:
                                case VAR:
                                case CONST:
                                case IDENT:
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                case LBRACK:
                                case STATIC:
                                case DYNAMIC:
                                case 172:
                                case 178:
                                case 179:
                                case 180:
                                case 181:
                                case 182:
                                    {
                                        alt9 = 2;
                                    }
                                    break;
                                case SEMI:
                                    {
                                        alt9 = 3;
                                    }
                                    break;
                                default:
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d9s0 =
                                        new NoViableAltException("135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )", 9, 0, input);

                                    throw nvae_d9s0;
                            }

                            switch (alt9)
                            {
                                case 1:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:6: importDefinition
                                    {
                                        PushFollow(FOLLOW_importDefinition_in_packageBlockEntry510);
                                        importDefinition18 = importDefinition();
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        if (backtracking == 0) adaptor.AddChild(root_0, importDefinition18.Tree);

                                    }
                                    break;
                                case 2:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:136:5: annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )
                                    {
                                        PushFollow(FOLLOW_annotations_in_packageBlockEntry518);
                                        annos = annotations();
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        PushFollow(FOLLOW_modifiers_in_packageBlockEntry526);
                                        mods = modifiers();
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:4: ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )
                                        int alt8 = 6;
                                        switch (input.LA(1))
                                        {
                                            case CLASS:
                                                {
                                                    alt8 = 1;
                                                }
                                                break;
                                            case INTERFACE:
                                                {
                                                    alt8 = 2;
                                                }
                                                break;
                                            case VAR:
                                            case CONST:
                                                {
                                                    alt8 = 3;
                                                }
                                                break;
                                            case FUNCTION:
                                                {
                                                    alt8 = 4;
                                                }
                                                break;
                                            case NAMESPACE:
                                                {
                                                    alt8 = 5;
                                                }
                                                break;
                                            case USE:
                                                {
                                                    alt8 = 6;
                                                }
                                                break;
                                            default:
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d8s0 =
                                                    new NoViableAltException("138:4: ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )", 8, 0, input);

                                                throw nvae_d8s0;
                                        }

                                        switch (alt8)
                                        {
                                            case 1:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:6: classDefinition[$annos.tree,$mods.tree]
                                                {
                                                    PushFollow(FOLLOW_classDefinition_in_packageBlockEntry534);
                                                    classDefinition19 = classDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, classDefinition19.Tree);

                                                }
                                                break;
                                            case 2:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:139:6: interfaceDefinition[$annos.tree,$mods.tree]
                                                {
                                                    PushFollow(FOLLOW_interfaceDefinition_in_packageBlockEntry542);
                                                    interfaceDefinition20 = interfaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, interfaceDefinition20.Tree);

                                                }
                                                break;
                                            case 3:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:140:6: variableDefinition[$annos.tree,$mods.tree]
                                                {
                                                    PushFollow(FOLLOW_variableDefinition_in_packageBlockEntry550);
                                                    variableDefinition21 = variableDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, variableDefinition21.Tree);

                                                }
                                                break;
                                            case 4:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:141:6: methodDefinition[$annos.tree,$mods.tree]
                                                {
                                                    PushFollow(FOLLOW_methodDefinition_in_packageBlockEntry558);
                                                    methodDefinition22 = methodDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, methodDefinition22.Tree);

                                                }
                                                break;
                                            case 5:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:6: namespaceDefinition[$annos.tree,$mods.tree]
                                                {
                                                    PushFollow(FOLLOW_namespaceDefinition_in_packageBlockEntry566);
                                                    namespaceDefinition23 = namespaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, namespaceDefinition23.Tree);

                                                }
                                                break;
                                            case 6:
                                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:6: useNamespaceDirective
                                                {
                                                    PushFollow(FOLLOW_useNamespaceDirective_in_packageBlockEntry574);
                                                    useNamespaceDirective24 = useNamespaceDirective();
                                                    followingStackPointer_--;
                                                    if (failed) return retval;
                                                    if (backtracking == 0) adaptor.AddChild(root_0, useNamespaceDirective24.Tree);

                                                }
                                                break;

                                        }


                                    }
                                    break;
                                case 3:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:145:5: SEMI
                                    {
                                        SEMI25 = (IToken)input.LT(1);
                                        Match(input, SEMI, FOLLOW_SEMI_in_packageBlockEntry585); if (failed) return retval;

                                    }
                                    break;

                            }


                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:147:5: comment
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_comment_in_packageBlockEntry596);
                            comment26 = comment();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, comment26.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 7, packageBlockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageBlockEntry

        public class endOfFile_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start endOfFile
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:150:1: endOfFile : EOF ;
        public endOfFile_return endOfFile() // throws RecognitionException [1]
        {
            endOfFile_return retval = new endOfFile_return();
            retval.start = input.LT(1);
            int endOfFile_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EOF27 = null;

            CommonTree EOF27_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 8))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:151:4: ( EOF )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:151:4: EOF
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    EOF27 = (IToken)input.LT(1);
                    Match(input, EOF, FOLLOW_EOF_in_endOfFile607); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 8, endOfFile_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end endOfFile

        public class importDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start importDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:154:1: importDefinition : IMPORT identifierStar semi ;
        public importDefinition_return importDefinition() // throws RecognitionException [1]
        {
            importDefinition_return retval = new importDefinition_return();
            retval.start = input.LT(1);
            int importDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IMPORT28 = null;
            identifierStar_return identifierStar29 = null;

            semi_return semi30 = null;


            CommonTree IMPORT28_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 9))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:155:4: ( IMPORT identifierStar semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:155:4: IMPORT identifierStar semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    IMPORT28 = (IToken)input.LT(1);
                    Match(input, IMPORT, FOLLOW_IMPORT_in_importDefinition619); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        IMPORT28_tree = (CommonTree)adaptor.Create(IMPORT28);
                        root_0 = (CommonTree)adaptor.BecomeRoot(IMPORT28_tree, root_0);
                    }
                    PushFollow(FOLLOW_identifierStar_in_importDefinition622);
                    identifierStar29 = identifierStar();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, identifierStar29.Tree);
                    PushFollow(FOLLOW_semi_in_importDefinition624);
                    semi30 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi30.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 9, importDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end importDefinition

        public class semi_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start semi
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:158:1: semi : SEMI ;
        public semi_return semi() // throws RecognitionException [1]
        {
            semi_return retval = new semi_return();
            retval.start = input.LT(1);
            int semi_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI31 = null;

            CommonTree SEMI31_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 10))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:159:4: ( SEMI )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:159:4: SEMI
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    SEMI31 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_semi635); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 10, semi_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end semi

        public class classDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start classDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:162:1: classDefinition[CommonTree annos, CommonTree mods] : CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) ;
        public classDefinition_return classDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            classDefinition_return retval = new classDefinition_return();
            retval.start = input.LT(1);
            int classDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CLASS32 = null;
            ident_return ident33 = null;

            classExtendsClause_return classExtendsClause34 = null;

            implementsClause_return implementsClause35 = null;

            typeBlock_return typeBlock36 = null;


            CommonTree CLASS32_tree = null;
            RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor, "token CLASS");
            RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule classExtendsClause");
            RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor, "rule implementsClause");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 11))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:163:4: ( CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:163:4: CLASS ident classExtendsClause implementsClause typeBlock
                {
                    CLASS32 = (IToken)input.LT(1);
                    Match(input, CLASS, FOLLOW_CLASS_in_classDefinition649); if (failed) return retval;
                    if (backtracking == 0) stream_CLASS.Add(CLASS32);

                    PushFollow(FOLLOW_ident_in_classDefinition651);
                    ident33 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident33.Tree);
                    PushFollow(FOLLOW_classExtendsClause_in_classDefinition655);
                    classExtendsClause34 = classExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_classExtendsClause.Add(classExtendsClause34.Tree);
                    PushFollow(FOLLOW_implementsClause_in_classDefinition659);
                    implementsClause35 = implementsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_implementsClause.Add(implementsClause35.Tree);
                    PushFollow(FOLLOW_typeBlock_in_classDefinition663);
                    typeBlock36 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock36.Tree);

                    // AST REWRITE
                    // elements:          ident, typeBlock, implementsClause, classExtendsClause
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 167:3: -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:167:6: ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_classExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_implementsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 11, classDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end classDefinition

        public class as2ClassDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2ClassDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:170:1: as2ClassDefinition[CommonTree annos, CommonTree mods] : CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) ;
        public as2ClassDefinition_return as2ClassDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            as2ClassDefinition_return retval = new as2ClassDefinition_return();
            retval.start = input.LT(1);
            int as2ClassDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CLASS37 = null;
            identifier_return identifier38 = null;

            classExtendsClause_return classExtendsClause39 = null;

            implementsClause_return implementsClause40 = null;

            typeBlock_return typeBlock41 = null;


            CommonTree CLASS37_tree = null;
            RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor, "token CLASS");
            RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule classExtendsClause");
            RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor, "rule implementsClause");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 12))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: ( CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: CLASS identifier classExtendsClause implementsClause typeBlock
                {
                    CLASS37 = (IToken)input.LT(1);
                    Match(input, CLASS, FOLLOW_CLASS_in_as2ClassDefinition695); if (failed) return retval;
                    if (backtracking == 0) stream_CLASS.Add(CLASS37);

                    PushFollow(FOLLOW_identifier_in_as2ClassDefinition697);
                    identifier38 = identifier();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_identifier.Add(identifier38.Tree);
                    PushFollow(FOLLOW_classExtendsClause_in_as2ClassDefinition701);
                    classExtendsClause39 = classExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_classExtendsClause.Add(classExtendsClause39.Tree);
                    PushFollow(FOLLOW_implementsClause_in_as2ClassDefinition705);
                    implementsClause40 = implementsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_implementsClause.Add(implementsClause40.Tree);
                    PushFollow(FOLLOW_typeBlock_in_as2ClassDefinition709);
                    typeBlock41 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock41.Tree);

                    // AST REWRITE
                    // elements:          typeBlock, implementsClause, identifier, classExtendsClause
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 175:3: -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:175:6: ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_identifier.Next());
                                adaptor.AddChild(root_1, stream_classExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_implementsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 12, as2ClassDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2ClassDefinition

        public class interfaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start interfaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:178:1: interfaceDefinition[CommonTree annos, CommonTree mods] : INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) ;
        public interfaceDefinition_return interfaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            interfaceDefinition_return retval = new interfaceDefinition_return();
            retval.start = input.LT(1);
            int interfaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INTERFACE42 = null;
            ident_return ident43 = null;

            interfaceExtendsClause_return interfaceExtendsClause44 = null;

            typeBlock_return typeBlock45 = null;


            CommonTree INTERFACE42_tree = null;
            RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor, "token INTERFACE");
            RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule interfaceExtendsClause");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 13))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: ( INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: INTERFACE ident interfaceExtendsClause typeBlock
                {
                    INTERFACE42 = (IToken)input.LT(1);
                    Match(input, INTERFACE, FOLLOW_INTERFACE_in_interfaceDefinition741); if (failed) return retval;
                    if (backtracking == 0) stream_INTERFACE.Add(INTERFACE42);

                    PushFollow(FOLLOW_ident_in_interfaceDefinition743);
                    ident43 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident43.Tree);
                    PushFollow(FOLLOW_interfaceExtendsClause_in_interfaceDefinition747);
                    interfaceExtendsClause44 = interfaceExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause44.Tree);
                    PushFollow(FOLLOW_typeBlock_in_interfaceDefinition751);
                    typeBlock45 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock45.Tree);

                    // AST REWRITE
                    // elements:          interfaceExtendsClause, ident, typeBlock
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 182:3: -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:182:6: ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 13, interfaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end interfaceDefinition

        public class as2InterfaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2InterfaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:185:1: as2InterfaceDefinition[CommonTree annos, CommonTree mods] : INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) ;
        public as2InterfaceDefinition_return as2InterfaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            as2InterfaceDefinition_return retval = new as2InterfaceDefinition_return();
            retval.start = input.LT(1);
            int as2InterfaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INTERFACE46 = null;
            identifier_return identifier47 = null;

            interfaceExtendsClause_return interfaceExtendsClause48 = null;

            typeBlock_return typeBlock49 = null;


            CommonTree INTERFACE46_tree = null;
            RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor, "token INTERFACE");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule interfaceExtendsClause");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 14))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:186:4: ( INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:186:4: INTERFACE identifier interfaceExtendsClause typeBlock
                {
                    INTERFACE46 = (IToken)input.LT(1);
                    Match(input, INTERFACE, FOLLOW_INTERFACE_in_as2InterfaceDefinition781); if (failed) return retval;
                    if (backtracking == 0) stream_INTERFACE.Add(INTERFACE46);

                    PushFollow(FOLLOW_identifier_in_as2InterfaceDefinition783);
                    identifier47 = identifier();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_identifier.Add(identifier47.Tree);
                    PushFollow(FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition787);
                    interfaceExtendsClause48 = interfaceExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause48.Tree);
                    PushFollow(FOLLOW_typeBlock_in_as2InterfaceDefinition791);
                    typeBlock49 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock49.Tree);

                    // AST REWRITE
                    // elements:          identifier, typeBlock, interfaceExtendsClause
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 189:3: -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:189:6: ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_identifier.Next());
                                adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 14, as2InterfaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2InterfaceDefinition

        public class classExtendsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start classExtendsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:192:1: classExtendsClause : ( EXTENDS identifier )? ;
        public classExtendsClause_return classExtendsClause() // throws RecognitionException [1]
        {
            classExtendsClause_return retval = new classExtendsClause_return();
            retval.start = input.LT(1);
            int classExtendsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EXTENDS50 = null;
            identifier_return identifier51 = null;


            CommonTree EXTENDS50_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 15))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:193:4: ( ( EXTENDS identifier )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:193:4: ( EXTENDS identifier )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:193:4: ( EXTENDS identifier )?
                    int alt11 = 2;
                    int LA11_0 = input.LA(1);

                    if ((LA11_0 == EXTENDS))
                    {
                        alt11 = 1;
                    }
                    switch (alt11)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:193:5: EXTENDS identifier
                            {
                                EXTENDS50 = (IToken)input.LT(1);
                                Match(input, EXTENDS, FOLLOW_EXTENDS_in_classExtendsClause821); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    EXTENDS50_tree = (CommonTree)adaptor.Create(EXTENDS50);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS50_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_classExtendsClause824);
                                identifier51 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier51.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 15, classExtendsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end classExtendsClause

        public class interfaceExtendsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start interfaceExtendsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:195:1: interfaceExtendsClause : ( EXTENDS identifier ( COMMA identifier )* )? ;
        public interfaceExtendsClause_return interfaceExtendsClause() // throws RecognitionException [1]
        {
            interfaceExtendsClause_return retval = new interfaceExtendsClause_return();
            retval.start = input.LT(1);
            int interfaceExtendsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EXTENDS52 = null;
            IToken COMMA54 = null;
            identifier_return identifier53 = null;

            identifier_return identifier55 = null;


            CommonTree EXTENDS52_tree = null;
            CommonTree COMMA54_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 16))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: ( ( EXTENDS identifier ( COMMA identifier )* )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: ( EXTENDS identifier ( COMMA identifier )* )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: ( EXTENDS identifier ( COMMA identifier )* )?
                    int alt13 = 2;
                    int LA13_0 = input.LA(1);

                    if ((LA13_0 == EXTENDS))
                    {
                        alt13 = 1;
                    }
                    switch (alt13)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:5: EXTENDS identifier ( COMMA identifier )*
                            {
                                EXTENDS52 = (IToken)input.LT(1);
                                Match(input, EXTENDS, FOLLOW_EXTENDS_in_interfaceExtendsClause837); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    EXTENDS52_tree = (CommonTree)adaptor.Create(EXTENDS52);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS52_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_interfaceExtendsClause840);
                                identifier53 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier53.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:25: ( COMMA identifier )*
                                do
                                {
                                    int alt12 = 2;
                                    int LA12_0 = input.LA(1);

                                    if ((LA12_0 == COMMA))
                                    {
                                        alt12 = 1;
                                    }


                                    switch (alt12)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:27: COMMA identifier
                                            {
                                                COMMA54 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_interfaceExtendsClause844); if (failed) return retval;
                                                PushFollow(FOLLOW_identifier_in_interfaceExtendsClause847);
                                                identifier55 = identifier();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, identifier55.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop12;
                                    }
                                } while (true);

                            loop12:
                                ;	// Stops C# compiler whinging that label 'loop12' has no statements


                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 16, interfaceExtendsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end interfaceExtendsClause

        public class implementsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start implementsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:198:1: implementsClause : ( IMPLEMENTS identifier ( COMMA identifier )* )? ;
        public implementsClause_return implementsClause() // throws RecognitionException [1]
        {
            implementsClause_return retval = new implementsClause_return();
            retval.start = input.LT(1);
            int implementsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IMPLEMENTS56 = null;
            IToken COMMA58 = null;
            identifier_return identifier57 = null;

            identifier_return identifier59 = null;


            CommonTree IMPLEMENTS56_tree = null;
            CommonTree COMMA58_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 17))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:4: ( ( IMPLEMENTS identifier ( COMMA identifier )* )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
                    int alt15 = 2;
                    int LA15_0 = input.LA(1);

                    if ((LA15_0 == IMPLEMENTS))
                    {
                        alt15 = 1;
                    }
                    switch (alt15)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:5: IMPLEMENTS identifier ( COMMA identifier )*
                            {
                                IMPLEMENTS56 = (IToken)input.LT(1);
                                Match(input, IMPLEMENTS, FOLLOW_IMPLEMENTS_in_implementsClause862); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    IMPLEMENTS56_tree = (CommonTree)adaptor.Create(IMPLEMENTS56);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(IMPLEMENTS56_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_implementsClause865);
                                identifier57 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier57.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:28: ( COMMA identifier )*
                                do
                                {
                                    int alt14 = 2;
                                    int LA14_0 = input.LA(1);

                                    if ((LA14_0 == COMMA))
                                    {
                                        alt14 = 1;
                                    }


                                    switch (alt14)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:30: COMMA identifier
                                            {
                                                COMMA58 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_implementsClause869); if (failed) return retval;
                                                PushFollow(FOLLOW_identifier_in_implementsClause872);
                                                identifier59 = identifier();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, identifier59.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop14;
                                    }
                                } while (true);

                            loop14:
                                ;	// Stops C# compiler whinging that label 'loop14' has no statements


                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 17, implementsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end implementsClause

        public class typeBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:201:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) ;
        public typeBlock_return typeBlock() // throws RecognitionException [1]
        {
            typeBlock_return retval = new typeBlock_return();
            retval.start = input.LT(1);
            int typeBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY60 = null;
            IToken RCURLY62 = null;
            typeBlockEntry_return typeBlockEntry61 = null;


            CommonTree LCURLY60_tree = null;
            CommonTree RCURLY62_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_typeBlockEntry = new RewriteRuleSubtreeStream(adaptor, "rule typeBlockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 18))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:202:4: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:202:4: LCURLY ( typeBlockEntry )* RCURLY
                {
                    LCURLY60 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_typeBlock886); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY60);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:3: ( typeBlockEntry )*
                    do
                    {
                        int alt16 = 2;
                        int LA16_0 = input.LA(1);

                        if ((LA16_0 == IMPORT || LA16_0 == INCLUDE_DIRECTIVE || LA16_0 == FUNCTION || (LA16_0 >= VAR && LA16_0 <= CONST) || (LA16_0 >= IDENT && LA16_0 <= LBRACK) || (LA16_0 >= STATIC && LA16_0 <= DYNAMIC) || (LA16_0 >= SL_COMMENT && LA16_0 <= ML_COMMENT) || LA16_0 == 172 || (LA16_0 >= 178 && LA16_0 <= 182)))
                        {
                            alt16 = 1;
                        }


                        switch (alt16)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeBlockEntry
                                {
                                    PushFollow(FOLLOW_typeBlockEntry_in_typeBlock890);
                                    typeBlockEntry61 = typeBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_typeBlockEntry.Add(typeBlockEntry61.Tree);

                                }
                                break;

                            default:
                                goto loop16;
                        }
                    } while (true);

                loop16:
                    ;	// Stops C# compiler whinging that label 'loop16' has no statements

                    RCURLY62 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_typeBlock895); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY62);


                    // AST REWRITE
                    // elements:          typeBlockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 205:3: -> ^( TYPE_BLOCK ( typeBlockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:205:6: ^( TYPE_BLOCK ( typeBlockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:205:19: ( typeBlockEntry )*
                                while (stream_typeBlockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeBlockEntry.Next());

                                }
                                stream_typeBlockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 18, typeBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeBlock

        public class typeBlockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeBlockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:208:1: typeBlockEntry : (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective | comment );
        public typeBlockEntry_return typeBlockEntry() // throws RecognitionException [1]
        {
            typeBlockEntry_return retval = new typeBlockEntry_return();
            retval.start = input.LT(1);
            int typeBlockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotations_return a = null;

            modifiers_return m = null;

            variableDefinition_return variableDefinition63 = null;

            methodDefinition_return methodDefinition64 = null;

            importDefinition_return importDefinition65 = null;

            as2IncludeDirective_return as2IncludeDirective66 = null;

            comment_return comment67 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 19))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective | comment )
                int alt18 = 4;
                switch (input.LA(1))
                {
                    case FUNCTION:
                    case VAR:
                    case CONST:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case STATIC:
                    case DYNAMIC:
                    case 172:
                    case 178:
                    case 179:
                    case 180:
                    case 181:
                    case 182:
                        {
                            alt18 = 1;
                        }
                        break;
                    case IMPORT:
                        {
                            alt18 = 2;
                        }
                        break;
                    case INCLUDE_DIRECTIVE:
                        {
                            alt18 = 3;
                        }
                        break;
                    case SL_COMMENT:
                    case ML_COMMENT:
                        {
                            alt18 = 4;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d18s0 =
                            new NoViableAltException("208:1: typeBlockEntry : (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective | comment );", 18, 0, input);

                        throw nvae_d18s0;
                }

                switch (alt18)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_annotations_in_typeBlockEntry919);
                            a = annotations();
                            followingStackPointer_--;
                            if (failed) return retval;
                            PushFollow(FOLLOW_modifiers_in_typeBlockEntry927);
                            m = modifiers();
                            followingStackPointer_--;
                            if (failed) return retval;
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:211:3: ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )
                            int alt17 = 2;
                            int LA17_0 = input.LA(1);

                            if (((LA17_0 >= VAR && LA17_0 <= CONST)))
                            {
                                alt17 = 1;
                            }
                            else if ((LA17_0 == FUNCTION))
                            {
                                alt17 = 2;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d17s0 =
                                    new NoViableAltException("211:3: ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )", 17, 0, input);

                                throw nvae_d17s0;
                            }
                            switch (alt17)
                            {
                                case 1:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:211:5: variableDefinition[$a.tree,$m.tree]
                                    {
                                        PushFollow(FOLLOW_variableDefinition_in_typeBlockEntry934);
                                        variableDefinition63 = variableDefinition(((CommonTree)a.tree), ((CommonTree)m.tree));
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        if (backtracking == 0) adaptor.AddChild(root_0, variableDefinition63.Tree);

                                    }
                                    break;
                                case 2:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:212:5: methodDefinition[$a.tree,$m.tree]
                                    {
                                        PushFollow(FOLLOW_methodDefinition_in_typeBlockEntry941);
                                        methodDefinition64 = methodDefinition(((CommonTree)a.tree), ((CommonTree)m.tree));
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        if (backtracking == 0) adaptor.AddChild(root_0, methodDefinition64.Tree);

                                    }
                                    break;

                            }


                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:214:4: importDefinition
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_importDefinition_in_typeBlockEntry951);
                            importDefinition65 = importDefinition();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, importDefinition65.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:215:4: as2IncludeDirective
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_as2IncludeDirective_in_typeBlockEntry956);
                            as2IncludeDirective66 = as2IncludeDirective();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, as2IncludeDirective66.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:216:4: comment
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_comment_in_typeBlockEntry961);
                            comment67 = comment();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, comment67.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 19, typeBlockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeBlockEntry

        public class as2IncludeDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2IncludeDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:219:1: as2IncludeDirective : INCLUDE_DIRECTIVE STRING_LITERAL ;
        public as2IncludeDirective_return as2IncludeDirective() // throws RecognitionException [1]
        {
            as2IncludeDirective_return retval = new as2IncludeDirective_return();
            retval.start = input.LT(1);
            int as2IncludeDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INCLUDE_DIRECTIVE68 = null;
            IToken STRING_LITERAL69 = null;

            CommonTree INCLUDE_DIRECTIVE68_tree = null;
            CommonTree STRING_LITERAL69_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 20))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:4: ( INCLUDE_DIRECTIVE STRING_LITERAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:4: INCLUDE_DIRECTIVE STRING_LITERAL
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    INCLUDE_DIRECTIVE68 = (IToken)input.LT(1);
                    Match(input, INCLUDE_DIRECTIVE, FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective972); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        INCLUDE_DIRECTIVE68_tree = (CommonTree)adaptor.Create(INCLUDE_DIRECTIVE68);
                        adaptor.AddChild(root_0, INCLUDE_DIRECTIVE68_tree);
                    }
                    STRING_LITERAL69 = (IToken)input.LT(1);
                    Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_as2IncludeDirective976); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        STRING_LITERAL69_tree = (CommonTree)adaptor.Create(STRING_LITERAL69);
                        adaptor.AddChild(root_0, STRING_LITERAL69_tree);
                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 20, as2IncludeDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2IncludeDirective

        public class includeDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start includeDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:224:1: includeDirective : 'include' STRING_LITERAL semi ;
        public includeDirective_return includeDirective() // throws RecognitionException [1]
        {
            includeDirective_return retval = new includeDirective_return();
            retval.start = input.LT(1);
            int includeDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal70 = null;
            IToken STRING_LITERAL71 = null;
            semi_return semi72 = null;


            CommonTree string_literal70_tree = null;
            CommonTree STRING_LITERAL71_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 21))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:225:4: ( 'include' STRING_LITERAL semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:225:4: 'include' STRING_LITERAL semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal70 = (IToken)input.LT(1);
                    Match(input, 172, FOLLOW_172_in_includeDirective987); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal70_tree = (CommonTree)adaptor.Create(string_literal70);
                        adaptor.AddChild(root_0, string_literal70_tree);
                    }
                    STRING_LITERAL71 = (IToken)input.LT(1);
                    Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeDirective991); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        STRING_LITERAL71_tree = (CommonTree)adaptor.Create(STRING_LITERAL71);
                        adaptor.AddChild(root_0, STRING_LITERAL71_tree);
                    }
                    PushFollow(FOLLOW_semi_in_includeDirective995);
                    semi72 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi72.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 21, includeDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end includeDirective

        public class methodDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start methodDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:231:1: methodDefinition[CommonTree annos, CommonTree mods] : FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) ;
        public methodDefinition_return methodDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            methodDefinition_return retval = new methodDefinition_return();
            retval.start = input.LT(1);
            int methodDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken FUNCTION73 = null;
            optionalAccessorRole_return r = null;

            ident_return ident74 = null;

            parameterDeclarationList_return parameterDeclarationList75 = null;

            typeExpression_return typeExpression76 = null;

            block_return block77 = null;

            semi_return semi78 = null;


            CommonTree FUNCTION73_tree = null;
            RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor, "token FUNCTION");
            RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor, "rule optionalAccessorRole");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclarationList");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor, "rule block");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 22))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:232:4: ( FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:232:4: FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi )
                {
                    FUNCTION73 = (IToken)input.LT(1);
                    Match(input, FUNCTION, FOLLOW_FUNCTION_in_methodDefinition1008); if (failed) return retval;
                    if (backtracking == 0) stream_FUNCTION.Add(FUNCTION73);

                    PushFollow(FOLLOW_optionalAccessorRole_in_methodDefinition1014);
                    r = optionalAccessorRole();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_optionalAccessorRole.Add(r.Tree);
                    PushFollow(FOLLOW_ident_in_methodDefinition1018);
                    ident74 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident74.Tree);
                    PushFollow(FOLLOW_parameterDeclarationList_in_methodDefinition1022);
                    parameterDeclarationList75 = parameterDeclarationList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList75.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:236:3: ( typeExpression )?
                    int alt19 = 2;
                    int LA19_0 = input.LA(1);

                    if ((LA19_0 == COLON))
                    {
                        alt19 = 1;
                    }
                    switch (alt19)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_methodDefinition1026);
                                typeExpression76 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression76.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:237:3: ( block | semi )
                    int alt20 = 2;
                    int LA20_0 = input.LA(1);

                    if ((LA20_0 == LCURLY))
                    {
                        alt20 = 1;
                    }
                    else if ((LA20_0 == SEMI))
                    {
                        alt20 = 2;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d20s0 =
                            new NoViableAltException("237:3: ( block | semi )", 20, 0, input);

                        throw nvae_d20s0;
                    }
                    switch (alt20)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:237:4: block
                            {
                                PushFollow(FOLLOW_block_in_methodDefinition1032);
                                block77 = block();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_block.Add(block77.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:237:10: semi
                            {
                                PushFollow(FOLLOW_semi_in_methodDefinition1034);
                                semi78 = semi();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_semi.Add(semi78.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          typeExpression, optionalAccessorRole, parameterDeclarationList, block, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 238:3: -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:238:6: ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:241:5: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:242:5: ( block )?
                                if (stream_block.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_block.Next());

                                }
                                stream_block.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 22, methodDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end methodDefinition

        public class optionalAccessorRole_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start optionalAccessorRole
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:245:1: optionalAccessorRole : ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) ;
        public optionalAccessorRole_return optionalAccessorRole() // throws RecognitionException [1]
        {
            optionalAccessorRole_return retval = new optionalAccessorRole_return();
            retval.start = input.LT(1);
            int optionalAccessorRole_StartIndex = input.Index();
            CommonTree root_0 = null;

            accessorRole_return accessorRole79 = null;


            RewriteRuleSubtreeStream stream_accessorRole = new RewriteRuleSubtreeStream(adaptor, "rule accessorRole");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 23))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:4: ( ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:4: ( accessorRole )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:4: ( accessorRole )?
                    int alt21 = 2;
                    int LA21_0 = input.LA(1);

                    if ((LA21_0 == GET))
                    {
                        int LA21_1 = input.LA(2);

                        if (((LA21_1 >= GET && LA21_1 <= USE) || LA21_1 == XML || LA21_1 == IDENT || LA21_1 == DYNAMIC || (LA21_1 >= IS && LA21_1 <= AS)))
                        {
                            alt21 = 1;
                        }
                    }
                    else if ((LA21_0 == SET))
                    {
                        int LA21_9 = input.LA(2);

                        if (((LA21_9 >= GET && LA21_9 <= USE) || LA21_9 == XML || LA21_9 == IDENT || LA21_9 == DYNAMIC || (LA21_9 >= IS && LA21_9 <= AS)))
                        {
                            alt21 = 1;
                        }
                    }
                    switch (alt21)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: accessorRole
                            {
                                PushFollow(FOLLOW_accessorRole_in_optionalAccessorRole1100);
                                accessorRole79 = accessorRole();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_accessorRole.Add(accessorRole79.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          accessorRole
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 247:3: -> ^( ACCESSOR_ROLE ( accessorRole )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:247:6: ^( ACCESSOR_ROLE ( accessorRole )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ACCESSOR_ROLE, "ACCESSOR_ROLE"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:247:22: ( accessorRole )?
                                if (stream_accessorRole.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_accessorRole.Next());

                                }
                                stream_accessorRole.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 23, optionalAccessorRole_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end optionalAccessorRole

        public class accessorRole_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start accessorRole
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:250:1: accessorRole : ( GET | SET );
        public accessorRole_return accessorRole() // throws RecognitionException [1]
        {
            accessorRole_return retval = new accessorRole_return();
            retval.start = input.LT(1);
            int accessorRole_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set80 = null;

            CommonTree set80_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 24))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:251:4: ( GET | SET )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set80 = (IToken)input.LT(1);
                    if ((input.LA(1) >= GET && input.LA(1) <= SET))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set80));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_accessorRole0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 24, accessorRole_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end accessorRole

        public class namespaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start namespaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:254:1: namespaceDefinition[CommonTree annos, CommonTree mods] : NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) ;
        public namespaceDefinition_return namespaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            namespaceDefinition_return retval = new namespaceDefinition_return();
            retval.start = input.LT(1);
            int namespaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NAMESPACE81 = null;
            ident_return ident82 = null;


            CommonTree NAMESPACE81_tree = null;
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 25))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:255:4: ( NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:255:4: NAMESPACE ident
                {
                    NAMESPACE81 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_namespaceDefinition1139); if (failed) return retval;
                    if (backtracking == 0) stream_NAMESPACE.Add(NAMESPACE81);

                    PushFollow(FOLLOW_ident_in_namespaceDefinition1141);
                    ident82 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident82.Tree);

                    // AST REWRITE
                    // elements:          ident, NAMESPACE
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 256:3: -> ^( NAMESPACE_DEF NAMESPACE ident )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:256:6: ^( NAMESPACE_DEF NAMESPACE ident )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_NAMESPACE.Next());
                                adaptor.AddChild(root_1, stream_ident.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 25, namespaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end namespaceDefinition

        public class useNamespaceDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start useNamespaceDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:259:1: useNamespaceDirective : USE NAMESPACE ident semi ;
        public useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
        {
            useNamespaceDirective_return retval = new useNamespaceDirective_return();
            retval.start = input.LT(1);
            int useNamespaceDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken USE83 = null;
            IToken NAMESPACE84 = null;
            ident_return ident85 = null;

            semi_return semi86 = null;


            CommonTree USE83_tree = null;
            CommonTree NAMESPACE84_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 26))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:260:4: ( USE NAMESPACE ident semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:260:4: USE NAMESPACE ident semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    USE83 = (IToken)input.LT(1);
                    Match(input, USE, FOLLOW_USE_in_useNamespaceDirective1168); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        USE83_tree = (CommonTree)adaptor.Create(USE83);
                        adaptor.AddChild(root_0, USE83_tree);
                    }
                    NAMESPACE84 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_useNamespaceDirective1170); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NAMESPACE84_tree = (CommonTree)adaptor.Create(NAMESPACE84);
                        adaptor.AddChild(root_0, NAMESPACE84_tree);
                    }
                    PushFollow(FOLLOW_ident_in_useNamespaceDirective1172);
                    ident85 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident85.Tree);
                    PushFollow(FOLLOW_semi_in_useNamespaceDirective1174);
                    semi86 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi86.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 26, useNamespaceDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end useNamespaceDirective

        public class variableDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:263:1: variableDefinition[CommonTree annos, CommonTree mods] : decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) ;
        public variableDefinition_return variableDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            variableDefinition_return retval = new variableDefinition_return();
            retval.start = input.LT(1);
            int variableDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA88 = null;
            varOrConst_return decl = null;

            variableDeclarator_return variableDeclarator87 = null;

            variableDeclarator_return variableDeclarator89 = null;

            semi_return semi90 = null;


            CommonTree COMMA88_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_varOrConst = new RewriteRuleSubtreeStream(adaptor, "rule varOrConst");
            RewriteRuleSubtreeStream stream_variableDeclarator = new RewriteRuleSubtreeStream(adaptor, "rule variableDeclarator");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 27))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:268:4: (decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:268:4: decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi
                {
                    PushFollow(FOLLOW_varOrConst_in_variableDefinition1198);
                    decl = varOrConst();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_varOrConst.Add(decl.Tree);
                    PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1200);
                    variableDeclarator87 = variableDeclarator();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_variableDeclarator.Add(variableDeclarator87.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:269:3: ( COMMA variableDeclarator )*
                    do
                    {
                        int alt22 = 2;
                        int LA22_0 = input.LA(1);

                        if ((LA22_0 == COMMA))
                        {
                            alt22 = 1;
                        }


                        switch (alt22)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:269:4: COMMA variableDeclarator
                                {
                                    COMMA88 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_variableDefinition1205); if (failed) return retval;
                                    if (backtracking == 0) stream_COMMA.Add(COMMA88);

                                    PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1207);
                                    variableDeclarator89 = variableDeclarator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_variableDeclarator.Add(variableDeclarator89.Tree);

                                }
                                break;

                            default:
                                goto loop22;
                        }
                    } while (true);

                loop22:
                    ;	// Stops C# compiler whinging that label 'loop22' has no statements

                    PushFollow(FOLLOW_semi_in_variableDefinition1213);
                    semi90 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi90.Tree);

                    // AST REWRITE
                    // elements:          variableDeclarator, decl
                    // token labels:      
                    // rule labels:       decl, retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_decl = new RewriteRuleSubtreeStream(adaptor, "token decl", (decl != null ? decl.Tree : null));
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 271:3: -> ^( VAR_DEF $decl ( variableDeclarator )+ )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:271:6: ^( VAR_DEF $decl ( variableDeclarator )+ )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_decl.Next());
                                if (!(stream_variableDeclarator.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_variableDeclarator.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_variableDeclarator.Next());

                                }
                                stream_variableDeclarator.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 27, variableDefinition_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end variableDefinition

        public class varOrConst_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start varOrConst
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:274:1: varOrConst : ( VAR | CONST );
        public varOrConst_return varOrConst() // throws RecognitionException [1]
        {
            varOrConst_return retval = new varOrConst_return();
            retval.start = input.LT(1);
            int varOrConst_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set91 = null;

            CommonTree set91_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 28))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:275:4: ( VAR | CONST )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set91 = (IToken)input.LT(1);
                    if ((input.LA(1) >= VAR && input.LA(1) <= CONST))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set91));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_varOrConst0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 28, varOrConst_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end varOrConst

        public class variableDeclarator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableDeclarator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:278:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? ;
        public variableDeclarator_return variableDeclarator() // throws RecognitionException [1]
        {
            variableDeclarator_return retval = new variableDeclarator_return();
            retval.start = input.LT(1);
            int variableDeclarator_StartIndex = input.Index();
            CommonTree root_0 = null;

            ident_return ident92 = null;

            typeExpression_return typeExpression93 = null;

            variableInitializer_return variableInitializer94 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 29))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:279:4: ( ident ( typeExpression )? ( variableInitializer )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:279:4: ident ( typeExpression )? ( variableInitializer )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_ident_in_variableDeclarator1257);
                    ident92 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(ident92.Tree, root_0);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:279:11: ( typeExpression )?
                    int alt23 = 2;
                    int LA23_0 = input.LA(1);

                    if ((LA23_0 == COLON))
                    {
                        alt23 = 1;
                    }
                    switch (alt23)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_variableDeclarator1260);
                                typeExpression93 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, typeExpression93.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:279:27: ( variableInitializer )?
                    int alt24 = 2;
                    int LA24_0 = input.LA(1);

                    if ((LA24_0 == ASSIGN))
                    {
                        alt24 = 1;
                    }
                    switch (alt24)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: variableInitializer
                            {
                                PushFollow(FOLLOW_variableInitializer_in_variableDeclarator1263);
                                variableInitializer94 = variableInitializer();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, variableInitializer94.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 29, variableDeclarator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end variableDeclarator

        public class declaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:1: declaration : varOrConst variableDeclarator declarationTail ;
        public declaration_return declaration() // throws RecognitionException [1]
        {
            declaration_return retval = new declaration_return();
            retval.start = input.LT(1);
            int declaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            varOrConst_return varOrConst95 = null;

            variableDeclarator_return variableDeclarator96 = null;

            declarationTail_return declarationTail97 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 30))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:282:4: ( varOrConst variableDeclarator declarationTail )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:282:4: varOrConst variableDeclarator declarationTail
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_varOrConst_in_declaration1274);
                    varOrConst95 = varOrConst();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(varOrConst95.Tree, root_0);
                    PushFollow(FOLLOW_variableDeclarator_in_declaration1277);
                    variableDeclarator96 = variableDeclarator();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, variableDeclarator96.Tree);
                    PushFollow(FOLLOW_declarationTail_in_declaration1281);
                    declarationTail97 = declarationTail();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, declarationTail97.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 30, declaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end declaration

        public class declarationTail_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declarationTail
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:286:1: declarationTail : ( COMMA variableDeclarator )* ;
        public declarationTail_return declarationTail() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            declarationTail_return retval = new declarationTail_return();
            retval.start = input.LT(1);
            int declarationTail_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA98 = null;
            variableDeclarator_return variableDeclarator99 = null;


            CommonTree COMMA98_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 31))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:4: ( ( COMMA variableDeclarator )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:4: ( COMMA variableDeclarator )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:4: ( COMMA variableDeclarator )*
                    do
                    {
                        int alt25 = 2;
                        int LA25_0 = input.LA(1);

                        if ((LA25_0 == COMMA))
                        {
                            alt25 = 1;
                        }


                        switch (alt25)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:5: COMMA variableDeclarator
                                {
                                    COMMA98 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_declarationTail1303); if (failed) return retval;
                                    PushFollow(FOLLOW_variableDeclarator_in_declarationTail1306);
                                    variableDeclarator99 = variableDeclarator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, variableDeclarator99.Tree);

                                }
                                break;

                            default:
                                goto loop25;
                        }
                    } while (true);

                loop25:
                    ;	// Stops C# compiler whinging that label 'loop25' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 31, declarationTail_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end declarationTail

        public class variableInitializer_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableInitializer
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:294:1: variableInitializer : ASSIGN assignmentExpression ;
        public variableInitializer_return variableInitializer() // throws RecognitionException [1]
        {
            variableInitializer_return retval = new variableInitializer_return();
            retval.start = input.LT(1);
            int variableInitializer_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN100 = null;
            assignmentExpression_return assignmentExpression101 = null;


            CommonTree ASSIGN100_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 32))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:295:4: ( ASSIGN assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:295:4: ASSIGN assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ASSIGN100 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_variableInitializer1319); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ASSIGN100_tree = (CommonTree)adaptor.Create(ASSIGN100);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN100_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_variableInitializer1322);
                    assignmentExpression101 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression101.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 32, variableInitializer_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end variableInitializer

        public class parameterDeclarationList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDeclarationList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) ;
        public parameterDeclarationList_return parameterDeclarationList() // throws RecognitionException [1]
        {
            parameterDeclarationList_return retval = new parameterDeclarationList_return();
            retval.start = input.LT(1);
            int parameterDeclarationList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN102 = null;
            IToken COMMA104 = null;
            IToken RPAREN106 = null;
            parameterDeclaration_return parameterDeclaration103 = null;

            parameterDeclaration_return parameterDeclaration105 = null;


            CommonTree LPAREN102_tree = null;
            CommonTree COMMA104_tree = null;
            CommonTree RPAREN106_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_parameterDeclaration = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclaration");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 33))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:301:4: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:301:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
                {
                    LPAREN102 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_parameterDeclarationList1335); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN102);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:302:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
                    int alt27 = 2;
                    int LA27_0 = input.LA(1);

                    if (((LA27_0 >= GET && LA27_0 <= USE) || LA27_0 == CONST || LA27_0 == REST || LA27_0 == XML || LA27_0 == IDENT || LA27_0 == DYNAMIC || (LA27_0 >= IS && LA27_0 <= AS)))
                    {
                        alt27 = 1;
                    }
                    switch (alt27)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:302:5: parameterDeclaration ( COMMA parameterDeclaration )*
                            {
                                PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1341);
                                parameterDeclaration103 = parameterDeclaration();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration103.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:303:4: ( COMMA parameterDeclaration )*
                                do
                                {
                                    int alt26 = 2;
                                    int LA26_0 = input.LA(1);

                                    if ((LA26_0 == COMMA))
                                    {
                                        alt26 = 1;
                                    }


                                    switch (alt26)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:303:5: COMMA parameterDeclaration
                                            {
                                                COMMA104 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_parameterDeclarationList1347); if (failed) return retval;
                                                if (backtracking == 0) stream_COMMA.Add(COMMA104);

                                                PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1349);
                                                parameterDeclaration105 = parameterDeclaration();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration105.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop26;
                                    }
                                } while (true);

                            loop26:
                                ;	// Stops C# compiler whinging that label 'loop26' has no statements


                            }
                            break;

                    }

                    RPAREN106 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_parameterDeclarationList1360); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN106);


                    // AST REWRITE
                    // elements:          parameterDeclaration
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 306:3: -> ^( PARAMS ( parameterDeclaration )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:306:6: ^( PARAMS ( parameterDeclaration )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAMS, "PARAMS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:306:15: ( parameterDeclaration )*
                                while (stream_parameterDeclaration.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_parameterDeclaration.Next());

                                }
                                stream_parameterDeclaration.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 33, parameterDeclarationList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterDeclarationList

        public class parameterDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:310:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
        public parameterDeclaration_return parameterDeclaration() // throws RecognitionException [1]
        {
            parameterDeclaration_return retval = new parameterDeclaration_return();
            retval.start = input.LT(1);
            int parameterDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            basicParameterDeclaration_return basicParameterDeclaration107 = null;

            parameterRestDeclaration_return parameterRestDeclaration108 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 34))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:311:4: ( basicParameterDeclaration | parameterRestDeclaration )
                int alt28 = 2;
                int LA28_0 = input.LA(1);

                if (((LA28_0 >= GET && LA28_0 <= USE) || LA28_0 == CONST || LA28_0 == XML || LA28_0 == IDENT || LA28_0 == DYNAMIC || (LA28_0 >= IS && LA28_0 <= AS)))
                {
                    alt28 = 1;
                }
                else if ((LA28_0 == REST))
                {
                    alt28 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d28s0 =
                        new NoViableAltException("310:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );", 28, 0, input);

                    throw nvae_d28s0;
                }
                switch (alt28)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:311:4: basicParameterDeclaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_basicParameterDeclaration_in_parameterDeclaration1383);
                            basicParameterDeclaration107 = basicParameterDeclaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, basicParameterDeclaration107.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:311:32: parameterRestDeclaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_parameterRestDeclaration_in_parameterDeclaration1387);
                            parameterRestDeclaration108 = parameterRestDeclaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, parameterRestDeclaration108.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 34, parameterDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterDeclaration

        public class basicParameterDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start basicParameterDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:314:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
        public basicParameterDeclaration_return basicParameterDeclaration() // throws RecognitionException [1]
        {
            basicParameterDeclaration_return retval = new basicParameterDeclaration_return();
            retval.start = input.LT(1);
            int basicParameterDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CONST109 = null;
            ident_return ident110 = null;

            typeExpression_return typeExpression111 = null;

            parameterDefault_return parameterDefault112 = null;


            CommonTree CONST109_tree = null;
            RewriteRuleTokenStream stream_CONST = new RewriteRuleTokenStream(adaptor, "token CONST");
            RewriteRuleSubtreeStream stream_parameterDefault = new RewriteRuleSubtreeStream(adaptor, "rule parameterDefault");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 35))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:4: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:4: ( CONST )?
                    int alt29 = 2;
                    int LA29_0 = input.LA(1);

                    if ((LA29_0 == CONST))
                    {
                        alt29 = 1;
                    }
                    switch (alt29)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: CONST
                            {
                                CONST109 = (IToken)input.LT(1);
                                Match(input, CONST, FOLLOW_CONST_in_basicParameterDeclaration1398); if (failed) return retval;
                                if (backtracking == 0) stream_CONST.Add(CONST109);


                            }
                            break;

                    }

                    PushFollow(FOLLOW_ident_in_basicParameterDeclaration1401);
                    ident110 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident110.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:17: ( typeExpression )?
                    int alt30 = 2;
                    int LA30_0 = input.LA(1);

                    if ((LA30_0 == COLON))
                    {
                        alt30 = 1;
                    }
                    switch (alt30)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_basicParameterDeclaration1403);
                                typeExpression111 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression111.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:33: ( parameterDefault )?
                    int alt31 = 2;
                    int LA31_0 = input.LA(1);

                    if ((LA31_0 == ASSIGN))
                    {
                        alt31 = 1;
                    }
                    switch (alt31)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: parameterDefault
                            {
                                PushFollow(FOLLOW_parameterDefault_in_basicParameterDeclaration1406);
                                parameterDefault112 = parameterDefault();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_parameterDefault.Add(parameterDefault112.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          typeExpression, parameterDefault, ident, CONST
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 316:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:316:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:316:14: ( CONST )?
                                if (stream_CONST.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_CONST.Next());

                                }
                                stream_CONST.Reset();
                                adaptor.AddChild(root_1, stream_ident.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:316:27: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:316:43: ( parameterDefault )?
                                if (stream_parameterDefault.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_parameterDefault.Next());

                                }
                                stream_parameterDefault.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 35, basicParameterDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end basicParameterDeclaration

        public class parameterDefault_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDefault
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:319:1: parameterDefault : ASSIGN assignmentExpression ;
        public parameterDefault_return parameterDefault() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            parameterDefault_return retval = new parameterDefault_return();
            retval.start = input.LT(1);
            int parameterDefault_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN113 = null;
            assignmentExpression_return assignmentExpression114 = null;


            CommonTree ASSIGN113_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 36))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:4: ( ASSIGN assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:4: ASSIGN assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ASSIGN113 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_parameterDefault1450); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ASSIGN113_tree = (CommonTree)adaptor.Create(ASSIGN113);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN113_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_parameterDefault1453);
                    assignmentExpression114 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression114.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 36, parameterDefault_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end parameterDefault

        public class parameterRestDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterRestDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:328:1: parameterRestDeclaration : REST ( ident )? -> ^( PARAM REST ( ident )? ) ;
        public parameterRestDeclaration_return parameterRestDeclaration() // throws RecognitionException [1]
        {
            parameterRestDeclaration_return retval = new parameterRestDeclaration_return();
            retval.start = input.LT(1);
            int parameterRestDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken REST115 = null;
            ident_return ident116 = null;


            CommonTree REST115_tree = null;
            RewriteRuleTokenStream stream_REST = new RewriteRuleTokenStream(adaptor, "token REST");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 37))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:329:4: ( REST ( ident )? -> ^( PARAM REST ( ident )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:329:4: REST ( ident )?
                {
                    REST115 = (IToken)input.LT(1);
                    Match(input, REST, FOLLOW_REST_in_parameterRestDeclaration1464); if (failed) return retval;
                    if (backtracking == 0) stream_REST.Add(REST115);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:329:9: ( ident )?
                    int alt32 = 2;
                    int LA32_0 = input.LA(1);

                    if (((LA32_0 >= GET && LA32_0 <= USE) || LA32_0 == XML || LA32_0 == IDENT || LA32_0 == DYNAMIC || (LA32_0 >= IS && LA32_0 <= AS)))
                    {
                        alt32 = 1;
                    }
                    switch (alt32)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: ident
                            {
                                PushFollow(FOLLOW_ident_in_parameterRestDeclaration1466);
                                ident116 = ident();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_ident.Add(ident116.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          ident, REST
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 330:3: -> ^( PARAM REST ( ident )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:330:6: ^( PARAM REST ( ident )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);

                                adaptor.AddChild(root_1, stream_REST.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:330:19: ( ident )?
                                if (stream_ident.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_ident.Next());

                                }
                                stream_ident.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 37, parameterRestDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterRestDeclaration

        public class block_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start block
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:332:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) ;
        public block_return block() // throws RecognitionException [1]
        {
            block_return retval = new block_return();
            retval.start = input.LT(1);
            int block_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY117 = null;
            IToken RCURLY119 = null;
            blockEntry_return blockEntry118 = null;


            CommonTree LCURLY117_tree = null;
            CommonTree RCURLY119_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_blockEntry = new RewriteRuleSubtreeStream(adaptor, "rule blockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 38))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:333:4: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:333:4: LCURLY ( blockEntry )* RCURLY
                {
                    LCURLY117 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_block1490); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY117);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:333:11: ( blockEntry )*
                    do
                    {
                        int alt33 = 2;
                        int LA33_0 = input.LA(1);

                        if ((LA33_0 == LCURLY || LA33_0 == SEMI || (LA33_0 >= STRING_LITERAL && LA33_0 <= CONST) || LA33_0 == LPAREN || LA33_0 == IF || (LA33_0 >= RETURN && LA33_0 <= SWITCH) || (LA33_0 >= DEFAULT && LA33_0 <= FOR) || (LA33_0 >= WHILE && LA33_0 <= XML) || (LA33_0 >= IDENT && LA33_0 <= LBRACK) || LA33_0 == DYNAMIC || LA33_0 == LT || (LA33_0 >= IS && LA33_0 <= AS) || (LA33_0 >= PLUS && LA33_0 <= DIV) || (LA33_0 >= INC && LA33_0 <= BNOT) || (LA33_0 >= E4X_ATTRI && LA33_0 <= ML_COMMENT) || (LA33_0 >= 173 && LA33_0 <= 174) || LA33_0 == 177))
                        {
                            alt33 = 1;
                        }


                        switch (alt33)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: blockEntry
                                {
                                    PushFollow(FOLLOW_blockEntry_in_block1492);
                                    blockEntry118 = blockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_blockEntry.Add(blockEntry118.Tree);

                                }
                                break;

                            default:
                                goto loop33;
                        }
                    } while (true);

                loop33:
                    ;	// Stops C# compiler whinging that label 'loop33' has no statements

                    RCURLY119 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_block1495); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY119);


                    // AST REWRITE
                    // elements:          blockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 334:3: -> ^( BLOCK ( blockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:334:6: ^( BLOCK ( blockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:334:14: ( blockEntry )*
                                while (stream_blockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_blockEntry.Next());

                                }
                                stream_blockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 38, block_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end block

        public class blockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start blockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:1: blockEntry : statement ;
        public blockEntry_return blockEntry() // throws RecognitionException [1]
        {
            blockEntry_return retval = new blockEntry_return();
            retval.start = input.LT(1);
            int blockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            statement_return statement120 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 39))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:338:4: ( statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:338:4: statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_statement_in_blockEntry1517);
                    statement120 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement120.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 39, blockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end blockEntry

        public class condition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start condition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:341:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
        public condition_return condition() // throws RecognitionException [1]
        {
            condition_return retval = new condition_return();
            retval.start = input.LT(1);
            int condition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN121 = null;
            IToken RPAREN123 = null;
            expression_return expression122 = null;


            CommonTree LPAREN121_tree = null;
            CommonTree RPAREN123_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 40))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:342:4: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:342:4: LPAREN expression RPAREN
                {
                    LPAREN121 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_condition1528); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN121);

                    PushFollow(FOLLOW_expression_in_condition1530);
                    expression122 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expression.Add(expression122.Tree);
                    RPAREN123 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_condition1532); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN123);


                    // AST REWRITE
                    // elements:          expression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 343:3: -> ^( CONDITION expression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:343:6: ^( CONDITION expression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CONDITION, "CONDITION"), root_1);

                                adaptor.AddChild(root_1, stream_expression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 40, condition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end condition

        public class statement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start statement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );
        public statement_return statement() // throws RecognitionException [1]
        {
            statement_return retval = new statement_return();
            retval.start = input.LT(1);
            int statement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI141 = null;
            block_return block124 = null;

            declarationStatement_return declarationStatement125 = null;

            expressionStatement_return expressionStatement126 = null;

            ifStatement_return ifStatement127 = null;

            forEachStatement_return forEachStatement128 = null;

            forStatement_return forStatement129 = null;

            whileStatement_return whileStatement130 = null;

            doWhileStatement_return doWhileStatement131 = null;

            withStatement_return withStatement132 = null;

            switchStatement_return switchStatement133 = null;

            breakStatement_return breakStatement134 = null;

            continueStatement_return continueStatement135 = null;

            returnStatement_return returnStatement136 = null;

            throwStatement_return throwStatement137 = null;

            tryStatement_return tryStatement138 = null;

            defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement139 = null;

            comment_return comment140 = null;


            CommonTree SEMI141_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 41))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI )
                int alt34 = 18;
                switch (input.LA(1))
                {
                    case LCURLY:
                        {
                            int LA34_1 = input.LA(2);

                            if ((LA34_1 == IDENT))
                            {
                                int LA34_50 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s50 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 50, input);

                                    throw nvae_d34s50;
                                }
                            }
                            else if ((LA34_1 == USE))
                            {
                                int LA34_51 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s51 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 51, input);

                                    throw nvae_d34s51;
                                }
                            }
                            else if ((LA34_1 == XML))
                            {
                                int LA34_52 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s52 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 52, input);

                                    throw nvae_d34s52;
                                }
                            }
                            else if ((LA34_1 == DYNAMIC))
                            {
                                int LA34_53 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s53 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 53, input);

                                    throw nvae_d34s53;
                                }
                            }
                            else if ((LA34_1 == NAMESPACE))
                            {
                                int LA34_54 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s54 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 54, input);

                                    throw nvae_d34s54;
                                }
                            }
                            else if ((LA34_1 == IS))
                            {
                                int LA34_55 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s55 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 55, input);

                                    throw nvae_d34s55;
                                }
                            }
                            else if ((LA34_1 == AS))
                            {
                                int LA34_56 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s56 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 56, input);

                                    throw nvae_d34s56;
                                }
                            }
                            else if ((LA34_1 == GET))
                            {
                                int LA34_57 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s57 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 57, input);

                                    throw nvae_d34s57;
                                }
                            }
                            else if ((LA34_1 == SET))
                            {
                                int LA34_58 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s58 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 58, input);

                                    throw nvae_d34s58;
                                }
                            }
                            else if (((LA34_1 >= HEX_LITERAL && LA34_1 <= FLOAT_LITERAL)))
                            {
                                int LA34_59 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s59 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 59, input);

                                    throw nvae_d34s59;
                                }
                            }
                            else if ((LA34_1 == RCURLY))
                            {
                                int LA34_60 = input.LA(3);

                                if ((synpred44()))
                                {
                                    alt34 = 1;
                                }
                                else if ((synpred46()))
                                {
                                    alt34 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d34s60 =
                                        new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 60, input);

                                    throw nvae_d34s60;
                                }
                            }
                            else if ((LA34_1 == LCURLY) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if (((LA34_1 >= VAR && LA34_1 <= CONST)) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == INC) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == DEC) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == MINUS) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == PLUS) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == DELETE) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == 177) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == TYPEOF) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == LNOT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == BNOT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == UNDEFINED) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == LT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == DIV) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == STRING_LITERAL) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == TRUE) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == FALSE) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == NULL) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == LBRACK) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == FUNCTION) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == NEW) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == LPAREN) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == E4X_ATTRI) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if (((LA34_1 >= PUBLIC && LA34_1 <= INTERNAL)) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == IF) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == FOR) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == WHILE) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == DO) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == WITH) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == SWITCH) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == BREAK) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == CONTINUE) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == RETURN) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == 173) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == 174) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == DEFAULT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == SL_COMMENT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == ML_COMMENT) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else if ((LA34_1 == SEMI) && (synpred44()))
                            {
                                alt34 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d34s1 =
                                    new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 1, input);

                                throw nvae_d34s1;
                            }
                        }
                        break;
                    case VAR:
                    case CONST:
                        {
                            alt34 = 2;
                        }
                        break;
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case PLUS:
                    case MINUS:
                    case DIV:
                    case INC:
                    case DEC:
                    case DELETE:
                    case TYPEOF:
                    case LNOT:
                    case BNOT:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                    case 177:
                        {
                            alt34 = 3;
                        }
                        break;
                    case IF:
                        {
                            alt34 = 4;
                        }
                        break;
                    case FOR:
                        {
                            int LA34_36 = input.LA(2);

                            if ((LA34_36 == LPAREN))
                            {
                                alt34 = 6;
                            }
                            else if ((LA34_36 == EACH))
                            {
                                alt34 = 5;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d34s36 =
                                    new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 36, input);

                                throw nvae_d34s36;
                            }
                        }
                        break;
                    case WHILE:
                        {
                            alt34 = 7;
                        }
                        break;
                    case DO:
                        {
                            alt34 = 8;
                        }
                        break;
                    case WITH:
                        {
                            alt34 = 9;
                        }
                        break;
                    case SWITCH:
                        {
                            alt34 = 10;
                        }
                        break;
                    case BREAK:
                        {
                            alt34 = 11;
                        }
                        break;
                    case CONTINUE:
                        {
                            alt34 = 12;
                        }
                        break;
                    case RETURN:
                        {
                            alt34 = 13;
                        }
                        break;
                    case 173:
                        {
                            alt34 = 14;
                        }
                        break;
                    case 174:
                        {
                            alt34 = 15;
                        }
                        break;
                    case DEFAULT:
                        {
                            alt34 = 16;
                        }
                        break;
                    case SL_COMMENT:
                    case ML_COMMENT:
                        {
                            alt34 = 17;
                        }
                        break;
                    case SEMI:
                        {
                            alt34 = 18;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d34s0 =
                            new NoViableAltException("346:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | comment | SEMI );", 34, 0, input);

                        throw nvae_d34s0;
                }

                switch (alt34)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: ( LCURLY )=> block
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_block_in_statement1558);
                            block124 = block();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, block124.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:348:4: declarationStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_declarationStatement_in_statement1563);
                            declarationStatement125 = declarationStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, declarationStatement125.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:349:4: expressionStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_expressionStatement_in_statement1568);
                            expressionStatement126 = expressionStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, expressionStatement126.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:350:4: ifStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ifStatement_in_statement1573);
                            ifStatement127 = ifStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ifStatement127.Tree);

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:352:4: forEachStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_forEachStatement_in_statement1580);
                            forEachStatement128 = forEachStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, forEachStatement128.Tree);

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:353:4: forStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_forStatement_in_statement1585);
                            forStatement129 = forStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, forStatement129.Tree);

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: whileStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_whileStatement_in_statement1593);
                            whileStatement130 = whileStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, whileStatement130.Tree);

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:359:4: doWhileStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_doWhileStatement_in_statement1601);
                            doWhileStatement131 = doWhileStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, doWhileStatement131.Tree);

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:4: withStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_withStatement_in_statement1610);
                            withStatement132 = withStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, withStatement132.Tree);

                        }
                        break;
                    case 10:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:365:4: switchStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_switchStatement_in_statement1619);
                            switchStatement133 = switchStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, switchStatement133.Tree);

                        }
                        break;
                    case 11:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:368:4: breakStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_breakStatement_in_statement1628);
                            breakStatement134 = breakStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, breakStatement134.Tree);

                        }
                        break;
                    case 12:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:371:4: continueStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_continueStatement_in_statement1636);
                            continueStatement135 = continueStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, continueStatement135.Tree);

                        }
                        break;
                    case 13:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:374:4: returnStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_returnStatement_in_statement1644);
                            returnStatement136 = returnStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, returnStatement136.Tree);

                        }
                        break;
                    case 14:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:377:4: throwStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_throwStatement_in_statement1652);
                            throwStatement137 = throwStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, throwStatement137.Tree);

                        }
                        break;
                    case 15:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:380:4: tryStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_tryStatement_in_statement1661);
                            tryStatement138 = tryStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, tryStatement138.Tree);

                        }
                        break;
                    case 16:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:383:4: defaultXMLNamespaceStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_defaultXMLNamespaceStatement_in_statement1670);
                            defaultXMLNamespaceStatement139 = defaultXMLNamespaceStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, defaultXMLNamespaceStatement139.Tree);

                        }
                        break;
                    case 17:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:386:4: comment
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_comment_in_statement1679);
                            comment140 = comment();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, comment140.Tree);

                        }
                        break;
                    case 18:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:389:4: SEMI
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            SEMI141 = (IToken)input.LT(1);
                            Match(input, SEMI, FOLLOW_SEMI_in_statement1687); if (failed) return retval;

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 41, statement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end statement

        public class declarationStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declarationStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:392:1: declarationStatement : declaration semi ;
        public declarationStatement_return declarationStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            declarationStatement_return retval = new declarationStatement_return();
            retval.start = input.LT(1);
            int declarationStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration142 = null;

            semi_return semi143 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 42))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:397:4: ( declaration semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:397:4: declaration semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_declaration_in_declarationStatement1709);
                    declaration142 = declaration();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, declaration142.Tree);
                    PushFollow(FOLLOW_semi_in_declarationStatement1711);
                    semi143 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi143.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 42, declarationStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end declarationStatement

        public class expressionStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expressionStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:400:1: expressionStatement : expressionList semi -> ^( EXPR_STMNT expressionList ) ;
        public expressionStatement_return expressionStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            expressionStatement_return retval = new expressionStatement_return();
            retval.start = input.LT(1);
            int expressionStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList144 = null;

            semi_return semi145 = null;


            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 43))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:405:4: ( expressionList semi -> ^( EXPR_STMNT expressionList ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:405:4: expressionList semi
                {
                    PushFollow(FOLLOW_expressionList_in_expressionStatement1732);
                    expressionList144 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expressionList.Add(expressionList144.Tree);
                    PushFollow(FOLLOW_semi_in_expressionStatement1734);
                    semi145 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi145.Tree);

                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 406:3: -> ^( EXPR_STMNT expressionList )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:406:6: ^( EXPR_STMNT expressionList )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);

                                adaptor.AddChild(root_1, stream_expressionList.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 43, expressionStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end expressionStatement

        public class ifStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start ifStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:409:1: ifStatement : IF condition statement ( ( ELSE )=> elseClause )? ;
        public ifStatement_return ifStatement() // throws RecognitionException [1]
        {
            ifStatement_return retval = new ifStatement_return();
            retval.start = input.LT(1);
            int ifStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IF146 = null;
            condition_return condition147 = null;

            statement_return statement148 = null;

            elseClause_return elseClause149 = null;


            CommonTree IF146_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 44))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:410:4: ( IF condition statement ( ( ELSE )=> elseClause )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:410:4: IF condition statement ( ( ELSE )=> elseClause )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    IF146 = (IToken)input.LT(1);
                    Match(input, IF, FOLLOW_IF_in_ifStatement1756); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        IF146_tree = (CommonTree)adaptor.Create(IF146);
                        root_0 = (CommonTree)adaptor.BecomeRoot(IF146_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_ifStatement1759);
                    condition147 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition147.Tree);
                    PushFollow(FOLLOW_statement_in_ifStatement1761);
                    statement148 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement148.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:3: ( ( ELSE )=> elseClause )?
                    int alt35 = 2;
                    int LA35_0 = input.LA(1);

                    if ((LA35_0 == ELSE))
                    {
                        int LA35_1 = input.LA(2);

                        if ((synpred61()))
                        {
                            alt35 = 1;
                        }
                    }
                    switch (alt35)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:4: ( ELSE )=> elseClause
                            {
                                PushFollow(FOLLOW_elseClause_in_ifStatement1770);
                                elseClause149 = elseClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, elseClause149.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 44, ifStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end ifStatement

        public class elseClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start elseClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:414:1: elseClause : ELSE statement ;
        public elseClause_return elseClause() // throws RecognitionException [1]
        {
            elseClause_return retval = new elseClause_return();
            retval.start = input.LT(1);
            int elseClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ELSE150 = null;
            statement_return statement151 = null;


            CommonTree ELSE150_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 45))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:415:4: ( ELSE statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:415:4: ELSE statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ELSE150 = (IToken)input.LT(1);
                    Match(input, ELSE, FOLLOW_ELSE_in_elseClause1783); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ELSE150_tree = (CommonTree)adaptor.Create(ELSE150);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ELSE150_tree, root_0);
                    }
                    PushFollow(FOLLOW_statement_in_elseClause1786);
                    statement151 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement151.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 45, elseClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end elseClause

        public class throwStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start throwStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:418:1: throwStatement : 'throw' expression semi ;
        public throwStatement_return throwStatement() // throws RecognitionException [1]
        {
            throwStatement_return retval = new throwStatement_return();
            retval.start = input.LT(1);
            int throwStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal152 = null;
            expression_return expression153 = null;

            semi_return semi154 = null;


            CommonTree string_literal152_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 46))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:4: ( 'throw' expression semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:4: 'throw' expression semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal152 = (IToken)input.LT(1);
                    Match(input, 173, FOLLOW_173_in_throwStatement1797); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal152_tree = (CommonTree)adaptor.Create(string_literal152);
                        root_0 = (CommonTree)adaptor.BecomeRoot(string_literal152_tree, root_0);
                    }
                    PushFollow(FOLLOW_expression_in_throwStatement1800);
                    expression153 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression153.Tree);
                    PushFollow(FOLLOW_semi_in_throwStatement1802);
                    semi154 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi154.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 46, throwStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end throwStatement

        public class tryStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start tryStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:422:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? ;
        public tryStatement_return tryStatement() // throws RecognitionException [1]
        {
            tryStatement_return retval = new tryStatement_return();
            retval.start = input.LT(1);
            int tryStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal155 = null;
            block_return block156 = null;

            catchBlock_return catchBlock157 = null;

            finallyBlock_return finallyBlock158 = null;


            CommonTree string_literal155_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 47))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:423:4: ( 'try' block ( catchBlock )* ( finallyBlock )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:423:4: 'try' block ( catchBlock )* ( finallyBlock )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal155 = (IToken)input.LT(1);
                    Match(input, 174, FOLLOW_174_in_tryStatement1813); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal155_tree = (CommonTree)adaptor.Create(string_literal155);
                        adaptor.AddChild(root_0, string_literal155_tree);
                    }
                    PushFollow(FOLLOW_block_in_tryStatement1817);
                    block156 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block156.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:425:3: ( catchBlock )*
                    do
                    {
                        int alt36 = 2;
                        int LA36_0 = input.LA(1);

                        if ((LA36_0 == 175))
                        {
                            alt36 = 1;
                        }


                        switch (alt36)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: catchBlock
                                {
                                    PushFollow(FOLLOW_catchBlock_in_tryStatement1821);
                                    catchBlock157 = catchBlock();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, catchBlock157.Tree);

                                }
                                break;

                            default:
                                goto loop36;
                        }
                    } while (true);

                loop36:
                    ;	// Stops C# compiler whinging that label 'loop36' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:426:3: ( finallyBlock )?
                    int alt37 = 2;
                    int LA37_0 = input.LA(1);

                    if ((LA37_0 == 176))
                    {
                        alt37 = 1;
                    }
                    switch (alt37)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: finallyBlock
                            {
                                PushFollow(FOLLOW_finallyBlock_in_tryStatement1826);
                                finallyBlock158 = finallyBlock();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, finallyBlock158.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 47, tryStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end tryStatement

        public class catchBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start catchBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:429:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
        public catchBlock_return catchBlock() // throws RecognitionException [1]
        {
            catchBlock_return retval = new catchBlock_return();
            retval.start = input.LT(1);
            int catchBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal159 = null;
            IToken LPAREN160 = null;
            IToken RPAREN163 = null;
            ident_return ident161 = null;

            typeExpression_return typeExpression162 = null;

            block_return block164 = null;


            CommonTree string_literal159_tree = null;
            CommonTree LPAREN160_tree = null;
            CommonTree RPAREN163_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 48))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:430:4: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:430:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal159 = (IToken)input.LT(1);
                    Match(input, 175, FOLLOW_175_in_catchBlock1838); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal159_tree = (CommonTree)adaptor.Create(string_literal159);
                        adaptor.AddChild(root_0, string_literal159_tree);
                    }
                    LPAREN160 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_catchBlock1840); if (failed) return retval;
                    PushFollow(FOLLOW_ident_in_catchBlock1843);
                    ident161 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident161.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:430:26: ( typeExpression )?
                    int alt38 = 2;
                    int LA38_0 = input.LA(1);

                    if ((LA38_0 == COLON))
                    {
                        alt38 = 1;
                    }
                    switch (alt38)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_catchBlock1845);
                                typeExpression162 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, typeExpression162.Tree);

                            }
                            break;

                    }

                    RPAREN163 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_catchBlock1848); if (failed) return retval;
                    PushFollow(FOLLOW_block_in_catchBlock1853);
                    block164 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block164.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 48, catchBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end catchBlock

        public class finallyBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start finallyBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:434:1: finallyBlock : 'finally' block ;
        public finallyBlock_return finallyBlock() // throws RecognitionException [1]
        {
            finallyBlock_return retval = new finallyBlock_return();
            retval.start = input.LT(1);
            int finallyBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal165 = null;
            block_return block166 = null;


            CommonTree string_literal165_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 49))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:435:4: ( 'finally' block )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:435:4: 'finally' block
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal165 = (IToken)input.LT(1);
                    Match(input, 176, FOLLOW_176_in_finallyBlock1864); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal165_tree = (CommonTree)adaptor.Create(string_literal165);
                        adaptor.AddChild(root_0, string_literal165_tree);
                    }
                    PushFollow(FOLLOW_block_in_finallyBlock1866);
                    block166 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block166.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 49, finallyBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end finallyBlock

        public class returnStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start returnStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:438:1: returnStatement : RETURN ( expression )? semi ;
        public returnStatement_return returnStatement() // throws RecognitionException [1]
        {
            returnStatement_return retval = new returnStatement_return();
            retval.start = input.LT(1);
            int returnStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken RETURN167 = null;
            expression_return expression168 = null;

            semi_return semi169 = null;


            CommonTree RETURN167_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 50))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:4: ( RETURN ( expression )? semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:4: RETURN ( expression )? semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    RETURN167 = (IToken)input.LT(1);
                    Match(input, RETURN, FOLLOW_RETURN_in_returnStatement1877); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        RETURN167_tree = (CommonTree)adaptor.Create(RETURN167);
                        root_0 = (CommonTree)adaptor.BecomeRoot(RETURN167_tree, root_0);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:12: ( expression )?
                    int alt39 = 2;
                    int LA39_0 = input.LA(1);

                    if ((LA39_0 == LCURLY || (LA39_0 >= STRING_LITERAL && LA39_0 <= USE) || LA39_0 == LPAREN || LA39_0 == XML || (LA39_0 >= IDENT && LA39_0 <= LBRACK) || LA39_0 == DYNAMIC || LA39_0 == LT || (LA39_0 >= IS && LA39_0 <= AS) || (LA39_0 >= PLUS && LA39_0 <= DIV) || (LA39_0 >= INC && LA39_0 <= BNOT) || (LA39_0 >= E4X_ATTRI && LA39_0 <= NEW) || LA39_0 == 177))
                    {
                        alt39 = 1;
                    }
                    switch (alt39)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expression
                            {
                                PushFollow(FOLLOW_expression_in_returnStatement1880);
                                expression168 = expression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, expression168.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_semi_in_returnStatement1883);
                    semi169 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi169.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 50, returnStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end returnStatement

        public class continueStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start continueStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:442:1: continueStatement : CONTINUE semi ;
        public continueStatement_return continueStatement() // throws RecognitionException [1]
        {
            continueStatement_return retval = new continueStatement_return();
            retval.start = input.LT(1);
            int continueStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CONTINUE170 = null;
            semi_return semi171 = null;


            CommonTree CONTINUE170_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 51))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:443:4: ( CONTINUE semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:443:4: CONTINUE semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    CONTINUE170 = (IToken)input.LT(1);
                    Match(input, CONTINUE, FOLLOW_CONTINUE_in_continueStatement1896); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        CONTINUE170_tree = (CommonTree)adaptor.Create(CONTINUE170);
                        root_0 = (CommonTree)adaptor.BecomeRoot(CONTINUE170_tree, root_0);
                    }
                    PushFollow(FOLLOW_semi_in_continueStatement1899);
                    semi171 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi171.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 51, continueStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end continueStatement

        public class breakStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start breakStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:446:1: breakStatement : BREAK semi ;
        public breakStatement_return breakStatement() // throws RecognitionException [1]
        {
            breakStatement_return retval = new breakStatement_return();
            retval.start = input.LT(1);
            int breakStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BREAK172 = null;
            semi_return semi173 = null;


            CommonTree BREAK172_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 52))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:447:4: ( BREAK semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:447:4: BREAK semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    BREAK172 = (IToken)input.LT(1);
                    Match(input, BREAK, FOLLOW_BREAK_in_breakStatement1910); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        BREAK172_tree = (CommonTree)adaptor.Create(BREAK172);
                        root_0 = (CommonTree)adaptor.BecomeRoot(BREAK172_tree, root_0);
                    }
                    PushFollow(FOLLOW_semi_in_breakStatement1913);
                    semi173 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi173.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 52, breakStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end breakStatement

        public class switchStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:450:1: switchStatement : SWITCH condition switchBlock ;
        public switchStatement_return switchStatement() // throws RecognitionException [1]
        {
            switchStatement_return retval = new switchStatement_return();
            retval.start = input.LT(1);
            int switchStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SWITCH174 = null;
            condition_return condition175 = null;

            switchBlock_return switchBlock176 = null;


            CommonTree SWITCH174_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 53))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:451:4: ( SWITCH condition switchBlock )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:451:4: SWITCH condition switchBlock
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    SWITCH174 = (IToken)input.LT(1);
                    Match(input, SWITCH, FOLLOW_SWITCH_in_switchStatement1924); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        SWITCH174_tree = (CommonTree)adaptor.Create(SWITCH174);
                        root_0 = (CommonTree)adaptor.BecomeRoot(SWITCH174_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_switchStatement1927);
                    condition175 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition175.Tree);
                    PushFollow(FOLLOW_switchBlock_in_switchStatement1931);
                    switchBlock176 = switchBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, switchBlock176.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 53, switchStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchStatement

        public class switchBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:455:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
        public switchBlock_return switchBlock() // throws RecognitionException [1]
        {
            switchBlock_return retval = new switchBlock_return();
            retval.start = input.LT(1);
            int switchBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY177 = null;
            IToken RCURLY180 = null;
            caseStatement_return caseStatement178 = null;

            defaultStatement_return defaultStatement179 = null;


            CommonTree LCURLY177_tree = null;
            CommonTree RCURLY180_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_caseStatement = new RewriteRuleSubtreeStream(adaptor, "rule caseStatement");
            RewriteRuleSubtreeStream stream_defaultStatement = new RewriteRuleSubtreeStream(adaptor, "rule defaultStatement");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 54))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
                {
                    LCURLY177 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_switchBlock1942); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY177);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:3: ( caseStatement )*
                    do
                    {
                        int alt40 = 2;
                        int LA40_0 = input.LA(1);

                        if ((LA40_0 == CASE))
                        {
                            alt40 = 1;
                        }


                        switch (alt40)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:4: caseStatement
                                {
                                    PushFollow(FOLLOW_caseStatement_in_switchBlock1947);
                                    caseStatement178 = caseStatement();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_caseStatement.Add(caseStatement178.Tree);

                                }
                                break;

                            default:
                                goto loop40;
                        }
                    } while (true);

                loop40:
                    ;	// Stops C# compiler whinging that label 'loop40' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:458:3: ( defaultStatement )?
                    int alt41 = 2;
                    int LA41_0 = input.LA(1);

                    if ((LA41_0 == DEFAULT))
                    {
                        alt41 = 1;
                    }
                    switch (alt41)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:458:4: defaultStatement
                            {
                                PushFollow(FOLLOW_defaultStatement_in_switchBlock1954);
                                defaultStatement179 = defaultStatement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_defaultStatement.Add(defaultStatement179.Tree);

                            }
                            break;

                    }

                    RCURLY180 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_switchBlock1960); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY180);


                    // AST REWRITE
                    // elements:          defaultStatement, caseStatement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 460:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:14: ( caseStatement )*
                                while (stream_caseStatement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_caseStatement.Next());

                                }
                                stream_caseStatement.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:29: ( defaultStatement )?
                                if (stream_defaultStatement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_defaultStatement.Next());

                                }
                                stream_defaultStatement.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 54, switchBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchBlock

        public class caseStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start caseStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:463:1: caseStatement : CASE expression COLON l= switchStatementList ;
        public caseStatement_return caseStatement() // throws RecognitionException [1]
        {
            caseStatement_return retval = new caseStatement_return();
            retval.start = input.LT(1);
            int caseStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CASE181 = null;
            IToken COLON183 = null;
            switchStatementList_return l = null;

            expression_return expression182 = null;


            CommonTree CASE181_tree = null;
            CommonTree COLON183_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 55))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:4: ( CASE expression COLON l= switchStatementList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:4: CASE expression COLON l= switchStatementList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    CASE181 = (IToken)input.LT(1);
                    Match(input, CASE, FOLLOW_CASE_in_caseStatement1985); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        CASE181_tree = (CommonTree)adaptor.Create(CASE181);
                        root_0 = (CommonTree)adaptor.BecomeRoot(CASE181_tree, root_0);
                    }
                    PushFollow(FOLLOW_expression_in_caseStatement1988);
                    expression182 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression182.Tree);
                    COLON183 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_caseStatement1990); if (failed) return retval;
                    PushFollow(FOLLOW_switchStatementList_in_caseStatement1995);
                    l = switchStatementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, l.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 55, caseStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end caseStatement

        public class defaultStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start defaultStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:467:1: defaultStatement : DEFAULT COLON l= switchStatementList ;
        public defaultStatement_return defaultStatement() // throws RecognitionException [1]
        {
            defaultStatement_return retval = new defaultStatement_return();
            retval.start = input.LT(1);
            int defaultStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DEFAULT184 = null;
            IToken COLON185 = null;
            switchStatementList_return l = null;


            CommonTree DEFAULT184_tree = null;
            CommonTree COLON185_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 56))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:468:4: ( DEFAULT COLON l= switchStatementList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:468:4: DEFAULT COLON l= switchStatementList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    DEFAULT184 = (IToken)input.LT(1);
                    Match(input, DEFAULT, FOLLOW_DEFAULT_in_defaultStatement2007); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        DEFAULT184_tree = (CommonTree)adaptor.Create(DEFAULT184);
                        root_0 = (CommonTree)adaptor.BecomeRoot(DEFAULT184_tree, root_0);
                    }
                    COLON185 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_defaultStatement2010); if (failed) return retval;
                    PushFollow(FOLLOW_switchStatementList_in_defaultStatement2015);
                    l = switchStatementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, l.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 56, defaultStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end defaultStatement

        public class switchStatementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchStatementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:471:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
        public switchStatementList_return switchStatementList() // throws RecognitionException [1]
        {
            switchStatementList_return retval = new switchStatementList_return();
            retval.start = input.LT(1);
            int switchStatementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            statement_return statement186 = null;


            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 57))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:4: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:4: ( statement )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:4: ( statement )*
                    do
                    {
                        int alt42 = 2;
                        int LA42_0 = input.LA(1);

                        if ((LA42_0 == DEFAULT))
                        {
                            int LA42_1 = input.LA(2);

                            if ((LA42_1 == XML))
                            {
                                alt42 = 1;
                            }


                        }
                        else if ((LA42_0 == LCURLY || LA42_0 == SEMI || (LA42_0 >= STRING_LITERAL && LA42_0 <= CONST) || LA42_0 == LPAREN || LA42_0 == IF || (LA42_0 >= RETURN && LA42_0 <= SWITCH) || LA42_0 == FOR || (LA42_0 >= WHILE && LA42_0 <= XML) || (LA42_0 >= IDENT && LA42_0 <= LBRACK) || LA42_0 == DYNAMIC || LA42_0 == LT || (LA42_0 >= IS && LA42_0 <= AS) || (LA42_0 >= PLUS && LA42_0 <= DIV) || (LA42_0 >= INC && LA42_0 <= BNOT) || (LA42_0 >= E4X_ATTRI && LA42_0 <= ML_COMMENT) || (LA42_0 >= 173 && LA42_0 <= 174) || LA42_0 == 177))
                        {
                            alt42 = 1;
                        }


                        switch (alt42)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: statement
                                {
                                    PushFollow(FOLLOW_statement_in_switchStatementList2026);
                                    statement186 = statement();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_statement.Add(statement186.Tree);

                                }
                                break;

                            default:
                                goto loop42;
                        }
                    } while (true);

                loop42:
                    ;	// Stops C# compiler whinging that label 'loop42' has no statements


                    // AST REWRITE
                    // elements:          statement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 472:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:42: ( statement )*
                                while (stream_statement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_statement.Next());

                                }
                                stream_statement.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 57, switchStatementList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchStatementList

        public class forEachStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forEachStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:475:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) ;
        public forEachStatement_return forEachStatement() // throws RecognitionException [1]
        {
            forEachStatement_return retval = new forEachStatement_return();
            retval.start = input.LT(1);
            int forEachStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken f = null;
            IToken EACH187 = null;
            IToken LPAREN188 = null;
            IToken RPAREN190 = null;
            forInClause_return forInClause189 = null;

            statement_return statement191 = null;


            CommonTree f_tree = null;
            CommonTree EACH187_tree = null;
            CommonTree LPAREN188_tree = null;
            CommonTree RPAREN190_tree = null;
            RewriteRuleTokenStream stream_EACH = new RewriteRuleTokenStream(adaptor, "token EACH");
            RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor, "token FOR");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor, "rule forInClause");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 58))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:4: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:4: f= FOR EACH LPAREN forInClause RPAREN statement
                {
                    f = (IToken)input.LT(1);
                    Match(input, FOR, FOLLOW_FOR_in_forEachStatement2049); if (failed) return retval;
                    if (backtracking == 0) stream_FOR.Add(f);

                    EACH187 = (IToken)input.LT(1);
                    Match(input, EACH, FOLLOW_EACH_in_forEachStatement2051); if (failed) return retval;
                    if (backtracking == 0) stream_EACH.Add(EACH187);

                    LPAREN188 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_forEachStatement2055); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN188);

                    PushFollow(FOLLOW_forInClause_in_forEachStatement2059);
                    forInClause189 = forInClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_forInClause.Add(forInClause189.Tree);
                    RPAREN190 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_forEachStatement2063); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN190);

                    PushFollow(FOLLOW_statement_in_forEachStatement2067);
                    statement191 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_statement.Add(statement191.Tree);

                    // AST REWRITE
                    // elements:          forInClause, statement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 481:3: -> ^( FOR_EACH[$f] forInClause statement )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:6: ^( FOR_EACH[$f] forInClause statement )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_EACH, f), root_1);

                                adaptor.AddChild(root_1, stream_forInClause.Next());
                                adaptor.AddChild(root_1, stream_statement.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 58, forEachStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end forEachStatement

        public class forStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:484:1: forStatement : f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) ;
        public forStatement_return forStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forStatement_return retval = new forStatement_return();
            retval.start = input.LT(1);
            int forStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken f = null;
            IToken LPAREN192 = null;
            IToken RPAREN194 = null;
            IToken RPAREN197 = null;
            forInClause_return forInClause193 = null;

            statement_return statement195 = null;

            traditionalForClause_return traditionalForClause196 = null;

            statement_return statement198 = null;


            CommonTree f_tree = null;
            CommonTree LPAREN192_tree = null;
            CommonTree RPAREN194_tree = null;
            CommonTree RPAREN197_tree = null;
            RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor, "token FOR");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            RewriteRuleSubtreeStream stream_traditionalForClause = new RewriteRuleSubtreeStream(adaptor, "rule traditionalForClause");
            RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor, "rule forInClause");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 59))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:489:4: (f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:489:4: f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
                {
                    f = (IToken)input.LT(1);
                    Match(input, FOR, FOLLOW_FOR_in_forStatement2103); if (failed) return retval;
                    if (backtracking == 0) stream_FOR.Add(f);

                    LPAREN192 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_forStatement2107); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN192);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
                    int alt43 = 2;
                    switch (input.LA(1))
                    {
                        case VAR:
                        case CONST:
                            {
                                switch (input.LA(2))
                                {
                                    case IDENT:
                                        {
                                            int LA43_36 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s36 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 36, input);

                                                throw nvae_d43s36;
                                            }
                                        }
                                        break;
                                    case USE:
                                        {
                                            int LA43_37 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s37 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 37, input);

                                                throw nvae_d43s37;
                                            }
                                        }
                                        break;
                                    case XML:
                                        {
                                            int LA43_38 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s38 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 38, input);

                                                throw nvae_d43s38;
                                            }
                                        }
                                        break;
                                    case DYNAMIC:
                                        {
                                            int LA43_39 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s39 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 39, input);

                                                throw nvae_d43s39;
                                            }
                                        }
                                        break;
                                    case NAMESPACE:
                                        {
                                            int LA43_40 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s40 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 40, input);

                                                throw nvae_d43s40;
                                            }
                                        }
                                        break;
                                    case IS:
                                        {
                                            int LA43_41 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s41 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 41, input);

                                                throw nvae_d43s41;
                                            }
                                        }
                                        break;
                                    case AS:
                                        {
                                            int LA43_42 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s42 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 42, input);

                                                throw nvae_d43s42;
                                            }
                                        }
                                        break;
                                    case GET:
                                        {
                                            int LA43_43 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s43 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 43, input);

                                                throw nvae_d43s43;
                                            }
                                        }
                                        break;
                                    case SET:
                                        {
                                            int LA43_44 = input.LA(3);

                                            if ((synpred69()))
                                            {
                                                alt43 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt43 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d43s44 =
                                                    new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 44, input);

                                                throw nvae_d43s44;
                                            }
                                        }
                                        break;
                                    default:
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s1 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 1, input);

                                        throw nvae_d43s1;
                                }

                            }
                            break;
                        case IDENT:
                            {
                                int LA43_2 = input.LA(2);

                                if ((LA43_2 == SEMI || LA43_2 == COMMA || (LA43_2 >= ASSIGN && LA43_2 <= LPAREN) || (LA43_2 >= STAR && LA43_2 <= DBL_COLON) || LA43_2 == LBRACK || (LA43_2 >= STAR_ASSIGN && LA43_2 <= DEC) || LA43_2 == E4X_DESC || (LA43_2 >= 183 && LA43_2 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_2 == IN))
                                {
                                    int LA43_55 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s55 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 55, input);

                                        throw nvae_d43s55;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s2 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 2, input);

                                    throw nvae_d43s2;
                                }
                            }
                            break;
                        case USE:
                            {
                                int LA43_3 = input.LA(2);

                                if ((LA43_3 == SEMI || LA43_3 == COMMA || (LA43_3 >= ASSIGN && LA43_3 <= LPAREN) || (LA43_3 >= STAR && LA43_3 <= DOT) || LA43_3 == LBRACK || (LA43_3 >= STAR_ASSIGN && LA43_3 <= DEC) || LA43_3 == E4X_DESC || (LA43_3 >= 183 && LA43_3 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_3 == IN))
                                {
                                    int LA43_82 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s82 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 82, input);

                                        throw nvae_d43s82;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s3 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 3, input);

                                    throw nvae_d43s3;
                                }
                            }
                            break;
                        case XML:
                            {
                                int LA43_4 = input.LA(2);

                                if ((LA43_4 == SEMI || LA43_4 == COMMA || (LA43_4 >= ASSIGN && LA43_4 <= LPAREN) || (LA43_4 >= STAR && LA43_4 <= DOT) || LA43_4 == LBRACK || (LA43_4 >= STAR_ASSIGN && LA43_4 <= DEC) || LA43_4 == E4X_DESC || (LA43_4 >= 183 && LA43_4 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_4 == IN))
                                {
                                    int LA43_109 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s109 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 109, input);

                                        throw nvae_d43s109;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s4 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 4, input);

                                    throw nvae_d43s4;
                                }
                            }
                            break;
                        case DYNAMIC:
                            {
                                int LA43_5 = input.LA(2);

                                if ((LA43_5 == SEMI || LA43_5 == COMMA || (LA43_5 >= ASSIGN && LA43_5 <= LPAREN) || (LA43_5 >= STAR && LA43_5 <= DOT) || LA43_5 == LBRACK || (LA43_5 >= STAR_ASSIGN && LA43_5 <= DEC) || LA43_5 == E4X_DESC || (LA43_5 >= 183 && LA43_5 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_5 == IN))
                                {
                                    int LA43_136 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s136 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 136, input);

                                        throw nvae_d43s136;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s5 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 5, input);

                                    throw nvae_d43s5;
                                }
                            }
                            break;
                        case NAMESPACE:
                            {
                                int LA43_6 = input.LA(2);

                                if ((LA43_6 == IN))
                                {
                                    int LA43_154 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s154 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 154, input);

                                        throw nvae_d43s154;
                                    }
                                }
                                else if ((LA43_6 == SEMI || LA43_6 == COMMA || (LA43_6 >= ASSIGN && LA43_6 <= LPAREN) || (LA43_6 >= STAR && LA43_6 <= DOT) || LA43_6 == LBRACK || (LA43_6 >= STAR_ASSIGN && LA43_6 <= DEC) || LA43_6 == E4X_DESC || (LA43_6 >= 183 && LA43_6 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s6 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 6, input);

                                    throw nvae_d43s6;
                                }
                            }
                            break;
                        case IS:
                            {
                                int LA43_7 = input.LA(2);

                                if ((LA43_7 == SEMI || LA43_7 == COMMA || (LA43_7 >= ASSIGN && LA43_7 <= LPAREN) || (LA43_7 >= STAR && LA43_7 <= DOT) || LA43_7 == LBRACK || (LA43_7 >= STAR_ASSIGN && LA43_7 <= DEC) || LA43_7 == E4X_DESC || (LA43_7 >= 183 && LA43_7 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_7 == IN))
                                {
                                    int LA43_190 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s190 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 190, input);

                                        throw nvae_d43s190;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s7 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 7, input);

                                    throw nvae_d43s7;
                                }
                            }
                            break;
                        case AS:
                            {
                                int LA43_8 = input.LA(2);

                                if ((LA43_8 == SEMI || LA43_8 == COMMA || (LA43_8 >= ASSIGN && LA43_8 <= LPAREN) || (LA43_8 >= STAR && LA43_8 <= DOT) || LA43_8 == LBRACK || (LA43_8 >= STAR_ASSIGN && LA43_8 <= DEC) || LA43_8 == E4X_DESC || (LA43_8 >= 183 && LA43_8 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_8 == IN))
                                {
                                    int LA43_217 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s217 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 217, input);

                                        throw nvae_d43s217;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s8 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 8, input);

                                    throw nvae_d43s8;
                                }
                            }
                            break;
                        case GET:
                            {
                                int LA43_9 = input.LA(2);

                                if ((LA43_9 == IN))
                                {
                                    int LA43_235 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s235 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 235, input);

                                        throw nvae_d43s235;
                                    }
                                }
                                else if ((LA43_9 == SEMI || LA43_9 == COMMA || (LA43_9 >= ASSIGN && LA43_9 <= LPAREN) || (LA43_9 >= STAR && LA43_9 <= DOT) || LA43_9 == LBRACK || (LA43_9 >= STAR_ASSIGN && LA43_9 <= DEC) || LA43_9 == E4X_DESC || (LA43_9 >= 183 && LA43_9 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s9 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 9, input);

                                    throw nvae_d43s9;
                                }
                            }
                            break;
                        case SET:
                            {
                                int LA43_10 = input.LA(2);

                                if ((LA43_10 == SEMI || LA43_10 == COMMA || (LA43_10 >= ASSIGN && LA43_10 <= LPAREN) || (LA43_10 >= STAR && LA43_10 <= DOT) || LA43_10 == LBRACK || (LA43_10 >= STAR_ASSIGN && LA43_10 <= DEC) || LA43_10 == E4X_DESC || (LA43_10 >= 183 && LA43_10 <= 184)))
                                {
                                    alt43 = 2;
                                }
                                else if ((LA43_10 == IN))
                                {
                                    int LA43_271 = input.LA(3);

                                    if ((synpred69()))
                                    {
                                        alt43 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt43 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d43s271 =
                                            new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 271, input);

                                        throw nvae_d43s271;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d43s10 =
                                        new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 10, input);

                                    throw nvae_d43s10;
                                }
                            }
                            break;
                        case LCURLY:
                        case SEMI:
                        case STRING_LITERAL:
                        case FUNCTION:
                        case LPAREN:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case LBRACK:
                        case LT:
                        case PLUS:
                        case MINUS:
                        case DIV:
                        case INC:
                        case DEC:
                        case DELETE:
                        case TYPEOF:
                        case LNOT:
                        case BNOT:
                        case E4X_ATTRI:
                        case UNDEFINED:
                        case TRUE:
                        case FALSE:
                        case NULL:
                        case HEX_LITERAL:
                        case DECIMAL_LITERAL:
                        case OCTAL_LITERAL:
                        case FLOAT_LITERAL:
                        case NEW:
                        case 177:
                            {
                                alt43 = 2;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d43s0 =
                                new NoViableAltException("491:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 43, 0, input);

                            throw nvae_d43s0;
                    }

                    switch (alt43)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:491:5: ( forInClauseDecl IN )=> forInClause RPAREN statement
                            {
                                PushFollow(FOLLOW_forInClause_in_forStatement2119);
                                forInClause193 = forInClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_forInClause.Add(forInClause193.Tree);
                                RPAREN194 = (IToken)input.LT(1);
                                Match(input, RPAREN, FOLLOW_RPAREN_in_forStatement2121); if (failed) return retval;
                                if (backtracking == 0) stream_RPAREN.Add(RPAREN194);

                                PushFollow(FOLLOW_statement_in_forStatement2123);
                                statement195 = statement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_statement.Add(statement195.Tree);

                                // AST REWRITE
                                // elements:          statement, forInClause
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 492:4: -> ^( FOR_IN[$f] forInClause statement )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:492:7: ^( FOR_IN[$f] forInClause statement )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_IN, f), root_1);

                                            adaptor.AddChild(root_1, stream_forInClause.Next());
                                            adaptor.AddChild(root_1, stream_statement.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:494:5: traditionalForClause RPAREN statement
                            {
                                PushFollow(FOLLOW_traditionalForClause_in_forStatement2144);
                                traditionalForClause196 = traditionalForClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_traditionalForClause.Add(traditionalForClause196.Tree);
                                RPAREN197 = (IToken)input.LT(1);
                                Match(input, RPAREN, FOLLOW_RPAREN_in_forStatement2146); if (failed) return retval;
                                if (backtracking == 0) stream_RPAREN.Add(RPAREN197);

                                PushFollow(FOLLOW_statement_in_forStatement2148);
                                statement198 = statement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_statement.Add(statement198.Tree);

                                // AST REWRITE
                                // elements:          f, statement, traditionalForClause
                                // token labels:      f
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleTokenStream stream_f = new RewriteRuleTokenStream(adaptor, "token f", f);
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 495:4: -> ^( $f traditionalForClause statement )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:495:7: ^( $f traditionalForClause statement )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(stream_f.Next(), root_1);

                                            adaptor.AddChild(root_1, stream_traditionalForClause.Next());
                                            adaptor.AddChild(root_1, stream_statement.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 59, forStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forStatement

        public class traditionalForClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start traditionalForClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:499:1: traditionalForClause : a= forInit SEMI b= forCond SEMI c= forIter ;
        public traditionalForClause_return traditionalForClause() // throws RecognitionException [1]
        {
            traditionalForClause_return retval = new traditionalForClause_return();
            retval.start = input.LT(1);
            int traditionalForClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI199 = null;
            IToken SEMI200 = null;
            forInit_return a = null;

            forCond_return b = null;

            forIter_return c = null;


            CommonTree SEMI199_tree = null;
            CommonTree SEMI200_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 60))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:4: (a= forInit SEMI b= forCond SEMI c= forIter )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:4: a= forInit SEMI b= forCond SEMI c= forIter
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_forInit_in_traditionalForClause2179);
                    a = forInit();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, a.Tree);
                    SEMI199 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_traditionalForClause2181); if (failed) return retval;
                    PushFollow(FOLLOW_forCond_in_traditionalForClause2189);
                    b = forCond();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, b.Tree);
                    SEMI200 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_traditionalForClause2191); if (failed) return retval;
                    PushFollow(FOLLOW_forIter_in_traditionalForClause2199);
                    c = forIter();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, c.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 60, traditionalForClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end traditionalForClause

        public class forInClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:505:1: forInClause : forInClauseDecl IN forInClauseTail ;
        public forInClause_return forInClause() // throws RecognitionException [1]
        {
            forInClause_return retval = new forInClause_return();
            retval.start = input.LT(1);
            int forInClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IN202 = null;
            forInClauseDecl_return forInClauseDecl201 = null;

            forInClauseTail_return forInClauseTail203 = null;


            CommonTree IN202_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 61))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:4: ( forInClauseDecl IN forInClauseTail )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:4: forInClauseDecl IN forInClauseTail
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_forInClauseDecl_in_forInClause2211);
                    forInClauseDecl201 = forInClauseDecl();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, forInClauseDecl201.Tree);
                    IN202 = (IToken)input.LT(1);
                    Match(input, IN, FOLLOW_IN_in_forInClause2213); if (failed) return retval;
                    PushFollow(FOLLOW_forInClauseTail_in_forInClause2216);
                    forInClauseTail203 = forInClauseTail();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, forInClauseTail203.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 61, forInClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end forInClause

        public class forInClauseDecl_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClauseDecl
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:509:1: forInClauseDecl : ( declaration | ident );
        public forInClauseDecl_return forInClauseDecl() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInClauseDecl_return retval = new forInClauseDecl_return();
            retval.start = input.LT(1);
            int forInClauseDecl_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration204 = null;

            ident_return ident205 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 62))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:4: ( declaration | ident )
                int alt44 = 2;
                int LA44_0 = input.LA(1);

                if (((LA44_0 >= VAR && LA44_0 <= CONST)))
                {
                    alt44 = 1;
                }
                else if (((LA44_0 >= GET && LA44_0 <= USE) || LA44_0 == XML || LA44_0 == IDENT || LA44_0 == DYNAMIC || (LA44_0 >= IS && LA44_0 <= AS)))
                {
                    alt44 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d44s0 =
                        new NoViableAltException("509:1: forInClauseDecl : ( declaration | ident );", 44, 0, input);

                    throw nvae_d44s0;
                }
                switch (alt44)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:4: declaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_declaration_in_forInClauseDecl2237);
                            declaration204 = declaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, declaration204.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:18: ident
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ident_in_forInClauseDecl2241);
                            ident205 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ident205.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 62, forInClauseDecl_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInClauseDecl

        public class forInClauseTail_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClauseTail
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:1: forInClauseTail : expressionList ;
        public forInClauseTail_return forInClauseTail() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInClauseTail_return retval = new forInClauseTail_return();
            retval.start = input.LT(1);
            int forInClauseTail_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList206 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 63))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:523:4: ( expressionList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:523:4: expressionList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_expressionList_in_forInClauseTail2263);
                    expressionList206 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expressionList206.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 63, forInClauseTail_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInClauseTail

        public class forInit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:527:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
        public forInit_return forInit() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInit_return retval = new forInit_return();
            retval.start = input.LT(1);
            int forInit_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration207 = null;

            expressionList_return expressionList208 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");
            RewriteRuleSubtreeStream stream_declaration = new RewriteRuleSubtreeStream(adaptor, "rule declaration");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 64))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:4: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:4: ( declaration | expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:4: ( declaration | expressionList )?
                    int alt45 = 3;
                    int LA45_0 = input.LA(1);

                    if (((LA45_0 >= VAR && LA45_0 <= CONST)))
                    {
                        alt45 = 1;
                    }
                    else if ((LA45_0 == LCURLY || (LA45_0 >= STRING_LITERAL && LA45_0 <= USE) || LA45_0 == LPAREN || LA45_0 == XML || (LA45_0 >= IDENT && LA45_0 <= LBRACK) || LA45_0 == DYNAMIC || LA45_0 == LT || (LA45_0 >= IS && LA45_0 <= AS) || (LA45_0 >= PLUS && LA45_0 <= DIV) || (LA45_0 >= INC && LA45_0 <= BNOT) || (LA45_0 >= E4X_ATTRI && LA45_0 <= NEW) || LA45_0 == 177))
                    {
                        alt45 = 2;
                    }
                    switch (alt45)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:5: declaration
                            {
                                PushFollow(FOLLOW_declaration_in_forInit2287);
                                declaration207 = declaration();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_declaration.Add(declaration207.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:19: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forInit2291);
                                expressionList208 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList208.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          declaration, expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 533:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:533:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:533:17: ( declaration )?
                                if (stream_declaration.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_declaration.Next());

                                }
                                stream_declaration.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:533:30: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 64, forInit_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInit

        public class forCond_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forCond
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:536:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
        public forCond_return forCond() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forCond_return retval = new forCond_return();
            retval.start = input.LT(1);
            int forCond_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList209 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 65))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( expressionList )?
                    int alt46 = 2;
                    int LA46_0 = input.LA(1);

                    if ((LA46_0 == LCURLY || (LA46_0 >= STRING_LITERAL && LA46_0 <= USE) || LA46_0 == LPAREN || LA46_0 == XML || (LA46_0 >= IDENT && LA46_0 <= LBRACK) || LA46_0 == DYNAMIC || LA46_0 == LT || (LA46_0 >= IS && LA46_0 <= AS) || (LA46_0 >= PLUS && LA46_0 <= DIV) || (LA46_0 >= INC && LA46_0 <= BNOT) || (LA46_0 >= E4X_ATTRI && LA46_0 <= NEW) || LA46_0 == 177))
                    {
                        alt46 = 1;
                    }
                    switch (alt46)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forCond2329);
                                expressionList209 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList209.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 542:3: -> ^( FOR_CONDITION ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:6: ^( FOR_CONDITION ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:22: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 65, forCond_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forCond

        public class forIter_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forIter
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:545:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
        public forIter_return forIter() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forIter_return retval = new forIter_return();
            retval.start = input.LT(1);
            int forIter_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList210 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 66))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( expressionList )?
                    int alt47 = 2;
                    int LA47_0 = input.LA(1);

                    if ((LA47_0 == LCURLY || (LA47_0 >= STRING_LITERAL && LA47_0 <= USE) || LA47_0 == LPAREN || LA47_0 == XML || (LA47_0 >= IDENT && LA47_0 <= LBRACK) || LA47_0 == DYNAMIC || LA47_0 == LT || (LA47_0 >= IS && LA47_0 <= AS) || (LA47_0 >= PLUS && LA47_0 <= DIV) || (LA47_0 >= INC && LA47_0 <= BNOT) || (LA47_0 >= E4X_ATTRI && LA47_0 <= NEW) || LA47_0 == 177))
                    {
                        alt47 = 1;
                    }
                    switch (alt47)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forIter2362);
                                expressionList210 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList210.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 551:3: -> ^( FOR_ITERATOR ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:6: ^( FOR_ITERATOR ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:21: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 66, forIter_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forIter

        public class whileStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start whileStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:554:1: whileStatement : WHILE condition statement ;
        public whileStatement_return whileStatement() // throws RecognitionException [1]
        {
            whileStatement_return retval = new whileStatement_return();
            retval.start = input.LT(1);
            int whileStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken WHILE211 = null;
            condition_return condition212 = null;

            statement_return statement213 = null;


            CommonTree WHILE211_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 67))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:555:4: ( WHILE condition statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:555:4: WHILE condition statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    WHILE211 = (IToken)input.LT(1);
                    Match(input, WHILE, FOLLOW_WHILE_in_whileStatement2385); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        WHILE211_tree = (CommonTree)adaptor.Create(WHILE211);
                        root_0 = (CommonTree)adaptor.BecomeRoot(WHILE211_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_whileStatement2388);
                    condition212 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition212.Tree);
                    PushFollow(FOLLOW_statement_in_whileStatement2390);
                    statement213 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement213.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 67, whileStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end whileStatement

        public class doWhileStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start doWhileStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:558:1: doWhileStatement : DO statement WHILE condition semi ;
        public doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
        {
            doWhileStatement_return retval = new doWhileStatement_return();
            retval.start = input.LT(1);
            int doWhileStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DO214 = null;
            IToken WHILE216 = null;
            statement_return statement215 = null;

            condition_return condition217 = null;

            semi_return semi218 = null;


            CommonTree DO214_tree = null;
            CommonTree WHILE216_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 68))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:559:4: ( DO statement WHILE condition semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:559:4: DO statement WHILE condition semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    DO214 = (IToken)input.LT(1);
                    Match(input, DO, FOLLOW_DO_in_doWhileStatement2401); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        DO214_tree = (CommonTree)adaptor.Create(DO214);
                        root_0 = (CommonTree)adaptor.BecomeRoot(DO214_tree, root_0);
                    }
                    PushFollow(FOLLOW_statement_in_doWhileStatement2404);
                    statement215 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement215.Tree);
                    WHILE216 = (IToken)input.LT(1);
                    Match(input, WHILE, FOLLOW_WHILE_in_doWhileStatement2406); if (failed) return retval;
                    PushFollow(FOLLOW_condition_in_doWhileStatement2409);
                    condition217 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition217.Tree);
                    PushFollow(FOLLOW_semi_in_doWhileStatement2411);
                    semi218 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi218.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 68, doWhileStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end doWhileStatement

        public class withStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start withStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:562:1: withStatement : WITH condition statement ;
        public withStatement_return withStatement() // throws RecognitionException [1]
        {
            withStatement_return retval = new withStatement_return();
            retval.start = input.LT(1);
            int withStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken WITH219 = null;
            condition_return condition220 = null;

            statement_return statement221 = null;


            CommonTree WITH219_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 69))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:563:4: ( WITH condition statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:563:4: WITH condition statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    WITH219 = (IToken)input.LT(1);
                    Match(input, WITH, FOLLOW_WITH_in_withStatement2422); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        WITH219_tree = (CommonTree)adaptor.Create(WITH219);
                        root_0 = (CommonTree)adaptor.BecomeRoot(WITH219_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_withStatement2425);
                    condition220 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition220.Tree);
                    PushFollow(FOLLOW_statement_in_withStatement2427);
                    statement221 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement221.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 69, withStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end withStatement

        public class defaultXMLNamespaceStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start defaultXMLNamespaceStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:566:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
        public defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement() // throws RecognitionException [1]
        {
            defaultXMLNamespaceStatement_return retval = new defaultXMLNamespaceStatement_return();
            retval.start = input.LT(1);
            int defaultXMLNamespaceStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DEFAULT222 = null;
            IToken XML223 = null;
            IToken NAMESPACE224 = null;
            IToken ASSIGN225 = null;
            expression_return expression226 = null;

            semi_return semi227 = null;


            CommonTree DEFAULT222_tree = null;
            CommonTree XML223_tree = null;
            CommonTree NAMESPACE224_tree = null;
            CommonTree ASSIGN225_tree = null;
            RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor, "token XML");
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleTokenStream stream_DEFAULT = new RewriteRuleTokenStream(adaptor, "token DEFAULT");
            RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor, "token ASSIGN");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 70))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:567:4: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:567:4: DEFAULT XML NAMESPACE ASSIGN expression semi
                {
                    DEFAULT222 = (IToken)input.LT(1);
                    Match(input, DEFAULT, FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2438); if (failed) return retval;
                    if (backtracking == 0) stream_DEFAULT.Add(DEFAULT222);

                    XML223 = (IToken)input.LT(1);
                    Match(input, XML, FOLLOW_XML_in_defaultXMLNamespaceStatement2440); if (failed) return retval;
                    if (backtracking == 0) stream_XML.Add(XML223);

                    NAMESPACE224 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2442); if (failed) return retval;
                    if (backtracking == 0) stream_NAMESPACE.Add(NAMESPACE224);

                    ASSIGN225 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2444); if (failed) return retval;
                    if (backtracking == 0) stream_ASSIGN.Add(ASSIGN225);

                    PushFollow(FOLLOW_expression_in_defaultXMLNamespaceStatement2446);
                    expression226 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expression.Add(expression226.Tree);
                    PushFollow(FOLLOW_semi_in_defaultXMLNamespaceStatement2448);
                    semi227 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi227.Tree);

                    // AST REWRITE
                    // elements:          expression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 568:3: -> ^( DEFAULT_XML_NAMESPACE expression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:6: ^( DEFAULT_XML_NAMESPACE expression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);

                                adaptor.AddChild(root_1, stream_expression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 70, defaultXMLNamespaceStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end defaultXMLNamespaceStatement

        public class typeExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:571:1: typeExpression : c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) ;
        public typeExpression_return typeExpression() // throws RecognitionException [1]
        {
            typeExpression_return retval = new typeExpression_return();
            retval.start = input.LT(1);
            int typeExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken c = null;
            IToken string_literal229 = null;
            IToken STAR230 = null;
            identifier_return identifier228 = null;


            CommonTree c_tree = null;
            CommonTree string_literal229_tree = null;
            CommonTree STAR230_tree = null;
            RewriteRuleTokenStream stream_177 = new RewriteRuleTokenStream(adaptor, "token 177");
            RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor, "token STAR");
            RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor, "token COLON");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 71))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:4: (c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:4: c= COLON ( identifier | 'void' | STAR )
                {
                    c = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_typeExpression2471); if (failed) return retval;
                    if (backtracking == 0) stream_COLON.Add(c);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:574:3: ( identifier | 'void' | STAR )
                    int alt48 = 3;
                    switch (input.LA(1))
                    {
                        case GET:
                        case SET:
                        case NAMESPACE:
                        case USE:
                        case XML:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case DYNAMIC:
                        case IS:
                        case AS:
                            {
                                alt48 = 1;
                            }
                            break;
                        case 177:
                            {
                                alt48 = 2;
                            }
                            break;
                        case STAR:
                            {
                                alt48 = 3;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d48s0 =
                                new NoViableAltException("574:3: ( identifier | 'void' | STAR )", 48, 0, input);

                            throw nvae_d48s0;
                    }

                    switch (alt48)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:574:4: identifier
                            {
                                PushFollow(FOLLOW_identifier_in_typeExpression2479);
                                identifier228 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_identifier.Add(identifier228.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:574:17: 'void'
                            {
                                string_literal229 = (IToken)input.LT(1);
                                Match(input, 177, FOLLOW_177_in_typeExpression2483); if (failed) return retval;
                                if (backtracking == 0) stream_177.Add(string_literal229);


                            }
                            break;
                        case 3:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:574:26: STAR
                            {
                                STAR230 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_typeExpression2487); if (failed) return retval;
                                if (backtracking == 0) stream_STAR.Add(STAR230);


                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          177, STAR, identifier
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 575:3: -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:575:6: ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_SPEC, c), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:575:22: ( identifier )?
                                if (stream_identifier.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_identifier.Next());

                                }
                                stream_identifier.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:575:34: ( 'void' )?
                                if (stream_177.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_177.Next());

                                }
                                stream_177.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:575:42: ( STAR )?
                                if (stream_STAR.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_STAR.Next());

                                }
                                stream_STAR.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 71, typeExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeExpression

        public class identifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start identifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:1: identifier : qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) ;
        public identifier_return identifier() // throws RecognitionException [1]
        {
            identifier_return retval = new identifier_return();
            retval.start = input.LT(1);
            int identifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT232 = null;
            qualifiedIdent_return qualifiedIdent231 = null;

            qualifiedIdent_return qualifiedIdent233 = null;


            CommonTree DOT232_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 72))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:579:4: ( qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:579:4: qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )*
                {
                    PushFollow(FOLLOW_qualifiedIdent_in_identifier2519);
                    qualifiedIdent231 = qualifiedIdent();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent231.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:3: ( options {greedy=true; } : DOT qualifiedIdent )*
                    do
                    {
                        int alt49 = 2;
                        int LA49_0 = input.LA(1);

                        if ((LA49_0 == DOT))
                        {
                            alt49 = 1;
                        }


                        switch (alt49)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:6: DOT qualifiedIdent
                                {
                                    DOT232 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_identifier2537); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT232);

                                    PushFollow(FOLLOW_qualifiedIdent_in_identifier2539);
                                    qualifiedIdent233 = qualifiedIdent();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent233.Tree);

                                }
                                break;

                            default:
                                goto loop49;
                        }
                    } while (true);

                loop49:
                    ;	// Stops C# compiler whinging that label 'loop49' has no statements


                    // AST REWRITE
                    // elements:          qualifiedIdent
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 583:3: -> ^( IDENTIFIER ( qualifiedIdent )+ )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:583:6: ^( IDENTIFIER ( qualifiedIdent )+ )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);

                                if (!(stream_qualifiedIdent.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_qualifiedIdent.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_qualifiedIdent.Next());

                                }
                                stream_qualifiedIdent.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 72, identifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end identifier

        public class qualifiedIdent_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start qualifiedIdent
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:586:1: qualifiedIdent : ( namespaceName DBL_COLON )? ident ;
        public qualifiedIdent_return qualifiedIdent() // throws RecognitionException [1]
        {
            qualifiedIdent_return retval = new qualifiedIdent_return();
            retval.start = input.LT(1);
            int qualifiedIdent_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DBL_COLON235 = null;
            namespaceName_return namespaceName234 = null;

            ident_return ident236 = null;


            CommonTree DBL_COLON235_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 73))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( ( namespaceName DBL_COLON )? ident )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( namespaceName DBL_COLON )? ident
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( namespaceName DBL_COLON )?
                    int alt50 = 2;
                    int LA50_0 = input.LA(1);

                    if ((LA50_0 == IDENT))
                    {
                        int LA50_1 = input.LA(2);

                        if ((LA50_1 == DBL_COLON))
                        {
                            alt50 = 1;
                        }
                    }
                    else if (((LA50_0 >= PUBLIC && LA50_0 <= INTERNAL)))
                    {
                        alt50 = 1;
                    }
                    switch (alt50)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:5: namespaceName DBL_COLON
                            {
                                PushFollow(FOLLOW_namespaceName_in_qualifiedIdent2567);
                                namespaceName234 = namespaceName();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, namespaceName234.Tree);
                                DBL_COLON235 = (IToken)input.LT(1);
                                Match(input, DBL_COLON, FOLLOW_DBL_COLON_in_qualifiedIdent2569); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    DBL_COLON235_tree = (CommonTree)adaptor.Create(DBL_COLON235);
                                    adaptor.AddChild(root_0, DBL_COLON235_tree);
                                }

                            }
                            break;

                    }

                    PushFollow(FOLLOW_ident_in_qualifiedIdent2573);
                    ident236 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident236.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 73, qualifiedIdent_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end qualifiedIdent

        public class namespaceName_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start namespaceName
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:590:1: namespaceName : ( IDENT | reservedNamespace );
        public namespaceName_return namespaceName() // throws RecognitionException [1]
        {
            namespaceName_return retval = new namespaceName_return();
            retval.start = input.LT(1);
            int namespaceName_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IDENT237 = null;
            reservedNamespace_return reservedNamespace238 = null;


            CommonTree IDENT237_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 74))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:591:4: ( IDENT | reservedNamespace )
                int alt51 = 2;
                int LA51_0 = input.LA(1);

                if ((LA51_0 == IDENT))
                {
                    alt51 = 1;
                }
                else if (((LA51_0 >= PUBLIC && LA51_0 <= INTERNAL)))
                {
                    alt51 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d51s0 =
                        new NoViableAltException("590:1: namespaceName : ( IDENT | reservedNamespace );", 51, 0, input);

                    throw nvae_d51s0;
                }
                switch (alt51)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:591:4: IDENT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IDENT237 = (IToken)input.LT(1);
                            Match(input, IDENT, FOLLOW_IDENT_in_namespaceName2585); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IDENT237_tree = (CommonTree)adaptor.Create(IDENT237);
                                adaptor.AddChild(root_0, IDENT237_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:591:12: reservedNamespace
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_reservedNamespace_in_namespaceName2589);
                            reservedNamespace238 = reservedNamespace();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, reservedNamespace238.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 74, namespaceName_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end namespaceName

        public class reservedNamespace_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start reservedNamespace
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:594:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
        public reservedNamespace_return reservedNamespace() // throws RecognitionException [1]
        {
            reservedNamespace_return retval = new reservedNamespace_return();
            retval.start = input.LT(1);
            int reservedNamespace_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set239 = null;

            CommonTree set239_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 75))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:595:4: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set239 = (IToken)input.LT(1);
                    if ((input.LA(1) >= PUBLIC && input.LA(1) <= INTERNAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set239));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_reservedNamespace0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 75, reservedNamespace_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end reservedNamespace

        public class identifierStar_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start identifierStar
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:1: identifierStar : ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) ;
        public identifierStar_return identifierStar() // throws RecognitionException [1]
        {
            identifierStar_return retval = new identifierStar_return();
            retval.start = input.LT(1);
            int identifierStar_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT241 = null;
            IToken DOT243 = null;
            IToken STAR244 = null;
            ident_return ident240 = null;

            ident_return ident242 = null;


            CommonTree DOT241_tree = null;
            CommonTree DOT243_tree = null;
            CommonTree STAR244_tree = null;
            RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor, "token STAR");
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 76))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:602:4: ( ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:602:4: ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )?
                {
                    PushFollow(FOLLOW_ident_in_identifierStar2626);
                    ident240 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident240.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:603:3: ( options {greedy=true; } : DOT ident )*
                    do
                    {
                        int alt52 = 2;
                        int LA52_0 = input.LA(1);

                        if ((LA52_0 == DOT))
                        {
                            int LA52_1 = input.LA(2);

                            if (((LA52_1 >= GET && LA52_1 <= USE) || LA52_1 == XML || LA52_1 == IDENT || LA52_1 == DYNAMIC || (LA52_1 >= IS && LA52_1 <= AS)))
                            {
                                alt52 = 1;
                            }


                        }


                        switch (alt52)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:604:5: DOT ident
                                {
                                    DOT241 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_identifierStar2643); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT241);

                                    PushFollow(FOLLOW_ident_in_identifierStar2645);
                                    ident242 = ident();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_ident.Add(ident242.Tree);

                                }
                                break;

                            default:
                                goto loop52;
                        }
                    } while (true);

                loop52:
                    ;	// Stops C# compiler whinging that label 'loop52' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:606:3: ( DOT STAR )?
                    int alt53 = 2;
                    int LA53_0 = input.LA(1);

                    if ((LA53_0 == DOT))
                    {
                        alt53 = 1;
                    }
                    switch (alt53)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:606:5: DOT STAR
                            {
                                DOT243 = (IToken)input.LT(1);
                                Match(input, DOT, FOLLOW_DOT_in_identifierStar2657); if (failed) return retval;
                                if (backtracking == 0) stream_DOT.Add(DOT243);

                                STAR244 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_identifierStar2659); if (failed) return retval;
                                if (backtracking == 0) stream_STAR.Add(STAR244);


                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          STAR, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 608:3: -> ^( IDENTIFIER ( ident )+ ( STAR )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:608:6: ^( IDENTIFIER ( ident )+ ( STAR )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);

                                if (!(stream_ident.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_ident.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_ident.Next());

                                }
                                stream_ident.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:608:26: ( STAR )?
                                if (stream_STAR.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_STAR.Next());

                                }
                                stream_STAR.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 76, identifierStar_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end identifierStar

        public class annotations_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotations
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:611:1: annotations : ( annotation | includeDirective )* -> ^( ANNOTATIONS ( annotation )* ) ;
        public annotations_return annotations() // throws RecognitionException [1]
        {
            annotations_return retval = new annotations_return();
            retval.start = input.LT(1);
            int annotations_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotation_return annotation245 = null;

            includeDirective_return includeDirective246 = null;


            RewriteRuleSubtreeStream stream_includeDirective = new RewriteRuleSubtreeStream(adaptor, "rule includeDirective");
            RewriteRuleSubtreeStream stream_annotation = new RewriteRuleSubtreeStream(adaptor, "rule annotation");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 77))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:4: ( ( annotation | includeDirective )* -> ^( ANNOTATIONS ( annotation )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:4: ( annotation | includeDirective )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:4: ( annotation | includeDirective )*
                    do
                    {
                        int alt54 = 3;
                        int LA54_0 = input.LA(1);

                        if ((LA54_0 == LBRACK))
                        {
                            alt54 = 1;
                        }
                        else if ((LA54_0 == 172))
                        {
                            alt54 = 2;
                        }


                        switch (alt54)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:6: annotation
                                {
                                    PushFollow(FOLLOW_annotation_in_annotations2691);
                                    annotation245 = annotation();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_annotation.Add(annotation245.Tree);

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:613:5: includeDirective
                                {
                                    PushFollow(FOLLOW_includeDirective_in_annotations2697);
                                    includeDirective246 = includeDirective();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_includeDirective.Add(includeDirective246.Tree);

                                }
                                break;

                            default:
                                goto loop54;
                        }
                    } while (true);

                loop54:
                    ;	// Stops C# compiler whinging that label 'loop54' has no statements


                    // AST REWRITE
                    // elements:          annotation
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 615:3: -> ^( ANNOTATIONS ( annotation )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:615:6: ^( ANNOTATIONS ( annotation )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATIONS, "ANNOTATIONS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:615:20: ( annotation )*
                                while (stream_annotation.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotation.Next());

                                }
                                stream_annotation.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 77, annotations_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotations

        public class annotation_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotation
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
        public annotation_return annotation() // throws RecognitionException [1]
        {
            annotation_return retval = new annotation_return();
            retval.start = input.LT(1);
            int annotation_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK247 = null;
            IToken RBRACK250 = null;
            ident_return ident248 = null;

            annotationParamList_return annotationParamList249 = null;


            CommonTree LBRACK247_tree = null;
            CommonTree RBRACK250_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleSubtreeStream stream_annotationParamList = new RewriteRuleSubtreeStream(adaptor, "rule annotationParamList");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 78))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:619:4: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:619:4: LBRACK ident ( annotationParamList )? RBRACK
                {
                    LBRACK247 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_annotation2724); if (failed) return retval;
                    if (backtracking == 0) stream_LBRACK.Add(LBRACK247);

                    PushFollow(FOLLOW_ident_in_annotation2728);
                    ident248 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident248.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:3: ( annotationParamList )?
                    int alt55 = 2;
                    int LA55_0 = input.LA(1);

                    if ((LA55_0 == LPAREN))
                    {
                        alt55 = 1;
                    }
                    switch (alt55)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotationParamList
                            {
                                PushFollow(FOLLOW_annotationParamList_in_annotation2732);
                                annotationParamList249 = annotationParamList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_annotationParamList.Add(annotationParamList249.Tree);

                            }
                            break;

                    }

                    RBRACK250 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_annotation2737); if (failed) return retval;
                    if (backtracking == 0) stream_RBRACK.Add(RBRACK250);


                    // AST REWRITE
                    // elements:          annotationParamList, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 623:3: -> ^( ANNOTATION ident ( annotationParamList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:623:6: ^( ANNOTATION ident ( annotationParamList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);

                                adaptor.AddChild(root_1, stream_ident.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:623:25: ( annotationParamList )?
                                if (stream_annotationParamList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotationParamList.Next());

                                }
                                stream_annotationParamList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 78, annotation_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotation

        public class annotationParamList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotationParamList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:626:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
        public annotationParamList_return annotationParamList() // throws RecognitionException [1]
        {
            annotationParamList_return retval = new annotationParamList_return();
            retval.start = input.LT(1);
            int annotationParamList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN251 = null;
            IToken COMMA253 = null;
            IToken RPAREN255 = null;
            annotationParam_return annotationParam252 = null;

            annotationParam_return annotationParam254 = null;


            CommonTree LPAREN251_tree = null;
            CommonTree COMMA253_tree = null;
            CommonTree RPAREN255_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_annotationParam = new RewriteRuleSubtreeStream(adaptor, "rule annotationParam");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 79))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:628:3: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:628:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
                {
                    LPAREN251 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_annotationParamList2763); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN251);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:629:3: ( annotationParam ( COMMA annotationParam )* )?
                    int alt57 = 2;
                    int LA57_0 = input.LA(1);

                    if ((LA57_0 == STRING_LITERAL || (LA57_0 >= GET && LA57_0 <= USE) || LA57_0 == XML || LA57_0 == IDENT || LA57_0 == DYNAMIC || LA57_0 == LT || (LA57_0 >= IS && LA57_0 <= AS) || LA57_0 == DIV || (LA57_0 >= TRUE && LA57_0 <= FLOAT_LITERAL)))
                    {
                        alt57 = 1;
                    }
                    switch (alt57)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:629:5: annotationParam ( COMMA annotationParam )*
                            {
                                PushFollow(FOLLOW_annotationParam_in_annotationParamList2769);
                                annotationParam252 = annotationParam();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_annotationParam.Add(annotationParam252.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:630:4: ( COMMA annotationParam )*
                                do
                                {
                                    int alt56 = 2;
                                    int LA56_0 = input.LA(1);

                                    if ((LA56_0 == COMMA))
                                    {
                                        alt56 = 1;
                                    }


                                    switch (alt56)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:630:5: COMMA annotationParam
                                            {
                                                COMMA253 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_annotationParamList2775); if (failed) return retval;
                                                if (backtracking == 0) stream_COMMA.Add(COMMA253);

                                                PushFollow(FOLLOW_annotationParam_in_annotationParamList2777);
                                                annotationParam254 = annotationParam();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) stream_annotationParam.Add(annotationParam254.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop56;
                                    }
                                } while (true);

                            loop56:
                                ;	// Stops C# compiler whinging that label 'loop56' has no statements


                            }
                            break;

                    }

                    RPAREN255 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_annotationParamList2788); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN255);


                    // AST REWRITE
                    // elements:          annotationParam
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 633:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:26: ( annotationParam )*
                                while (stream_annotationParam.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotationParam.Next());

                                }
                                stream_annotationParam.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 79, annotationParamList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotationParamList

        public class annotationParam_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotationParam
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );
        public annotationParam_return annotationParam() // throws RecognitionException [1]
        {
            annotationParam_return retval = new annotationParam_return();
            retval.start = input.LT(1);
            int annotationParam_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN257 = null;
            ident_return ident256 = null;

            constant_return constant258 = null;

            constant_return constant259 = null;

            ident_return ident260 = null;


            CommonTree ASSIGN257_tree = null;
            RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor, "token ASSIGN");
            RewriteRuleSubtreeStream stream_constant = new RewriteRuleSubtreeStream(adaptor, "rule constant");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 80))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:649:3: ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident )
                int alt58 = 3;
                switch (input.LA(1))
                {
                    case IDENT:
                        {
                            int LA58_1 = input.LA(2);

                            if ((LA58_1 == EOF || LA58_1 == COMMA || LA58_1 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_1 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s1 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 1, input);

                                throw nvae_d58s1;
                            }
                        }
                        break;
                    case USE:
                        {
                            int LA58_2 = input.LA(2);

                            if ((LA58_2 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else if ((LA58_2 == EOF || LA58_2 == COMMA || LA58_2 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s2 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 2, input);

                                throw nvae_d58s2;
                            }
                        }
                        break;
                    case XML:
                        {
                            int LA58_3 = input.LA(2);

                            if ((LA58_3 == EOF || LA58_3 == COMMA || LA58_3 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_3 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s3 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 3, input);

                                throw nvae_d58s3;
                            }
                        }
                        break;
                    case DYNAMIC:
                        {
                            int LA58_4 = input.LA(2);

                            if ((LA58_4 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else if ((LA58_4 == EOF || LA58_4 == COMMA || LA58_4 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s4 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 4, input);

                                throw nvae_d58s4;
                            }
                        }
                        break;
                    case NAMESPACE:
                        {
                            int LA58_5 = input.LA(2);

                            if ((LA58_5 == EOF || LA58_5 == COMMA || LA58_5 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_5 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s5 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 5, input);

                                throw nvae_d58s5;
                            }
                        }
                        break;
                    case IS:
                        {
                            int LA58_6 = input.LA(2);

                            if ((LA58_6 == EOF || LA58_6 == COMMA || LA58_6 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_6 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s6 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 6, input);

                                throw nvae_d58s6;
                            }
                        }
                        break;
                    case AS:
                        {
                            int LA58_7 = input.LA(2);

                            if ((LA58_7 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else if ((LA58_7 == EOF || LA58_7 == COMMA || LA58_7 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s7 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 7, input);

                                throw nvae_d58s7;
                            }
                        }
                        break;
                    case GET:
                        {
                            int LA58_8 = input.LA(2);

                            if ((LA58_8 == EOF || LA58_8 == COMMA || LA58_8 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_8 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s8 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 8, input);

                                throw nvae_d58s8;
                            }
                        }
                        break;
                    case SET:
                        {
                            int LA58_9 = input.LA(2);

                            if ((LA58_9 == EOF || LA58_9 == COMMA || LA58_9 == RPAREN))
                            {
                                alt58 = 3;
                            }
                            else if ((LA58_9 == ASSIGN))
                            {
                                alt58 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d58s9 =
                                    new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 9, input);

                                throw nvae_d58s9;
                            }
                        }
                        break;
                    case STRING_LITERAL:
                    case LT:
                    case DIV:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt58 = 2;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d58s0 =
                            new NoViableAltException("647:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 58, 0, input);

                        throw nvae_d58s0;
                }

                switch (alt58)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:649:3: ident ASSIGN constant
                        {
                            PushFollow(FOLLOW_ident_in_annotationParam2815);
                            ident256 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_ident.Add(ident256.Tree);
                            ASSIGN257 = (IToken)input.LT(1);
                            Match(input, ASSIGN, FOLLOW_ASSIGN_in_annotationParam2817); if (failed) return retval;
                            if (backtracking == 0) stream_ASSIGN.Add(ASSIGN257);

                            PushFollow(FOLLOW_constant_in_annotationParam2819);
                            constant258 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_constant.Add(constant258.Tree);

                            // AST REWRITE
                            // elements:          ident, ASSIGN, constant
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 649:25: -> ^( ASSIGN ident constant )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:649:28: ^( ASSIGN ident constant )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_ident.Next());
                                        adaptor.AddChild(root_1, stream_constant.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:650:4: constant
                        {
                            PushFollow(FOLLOW_constant_in_annotationParam2834);
                            constant259 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_constant.Add(constant259.Tree);

                            // AST REWRITE
                            // elements:          constant
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 650:13: -> constant
                                {
                                    adaptor.AddChild(root_0, stream_constant.Next());

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:651:4: ident
                        {
                            PushFollow(FOLLOW_ident_in_annotationParam2843);
                            ident260 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_ident.Add(ident260.Tree);

                            // AST REWRITE
                            // elements:          ident
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 651:10: -> ident
                                {
                                    adaptor.AddChild(root_0, stream_ident.Next());

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 80, annotationParam_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotationParam

        public class modifiers_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start modifiers
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:654:1: modifiers : ( modifier )* -> ^( MODIFIERS ( modifier )* ) ;
        public modifiers_return modifiers() // throws RecognitionException [1]
        {
            modifiers_return retval = new modifiers_return();
            retval.start = input.LT(1);
            int modifiers_StartIndex = input.Index();
            CommonTree root_0 = null;

            modifier_return modifier261 = null;


            RewriteRuleSubtreeStream stream_modifier = new RewriteRuleSubtreeStream(adaptor, "rule modifier");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 81))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:4: ( ( modifier )* -> ^( MODIFIERS ( modifier )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:4: ( modifier )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:4: ( modifier )*
                    do
                    {
                        int alt59 = 2;
                        int LA59_0 = input.LA(1);

                        if (((LA59_0 >= IDENT && LA59_0 <= INTERNAL) || (LA59_0 >= STATIC && LA59_0 <= DYNAMIC) || (LA59_0 >= 178 && LA59_0 <= 182)))
                        {
                            alt59 = 1;
                        }


                        switch (alt59)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: modifier
                                {
                                    PushFollow(FOLLOW_modifier_in_modifiers2858);
                                    modifier261 = modifier();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_modifier.Add(modifier261.Tree);

                                }
                                break;

                            default:
                                goto loop59;
                        }
                    } while (true);

                loop59:
                    ;	// Stops C# compiler whinging that label 'loop59' has no statements


                    // AST REWRITE
                    // elements:          modifier
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 656:3: -> ^( MODIFIERS ( modifier )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:656:6: ^( MODIFIERS ( modifier )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MODIFIERS, "MODIFIERS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:656:18: ( modifier )*
                                while (stream_modifier.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_modifier.Next());

                                }
                                stream_modifier.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 81, modifiers_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end modifiers

        public class modifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start modifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:659:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
        public modifier_return modifier() // throws RecognitionException [1]
        {
            modifier_return retval = new modifier_return();
            retval.start = input.LT(1);
            int modifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STATIC263 = null;
            IToken string_literal264 = null;
            IToken string_literal265 = null;
            IToken string_literal266 = null;
            IToken string_literal267 = null;
            IToken DYNAMIC268 = null;
            IToken string_literal269 = null;
            namespaceName_return namespaceName262 = null;


            CommonTree STATIC263_tree = null;
            CommonTree string_literal264_tree = null;
            CommonTree string_literal265_tree = null;
            CommonTree string_literal266_tree = null;
            CommonTree string_literal267_tree = null;
            CommonTree DYNAMIC268_tree = null;
            CommonTree string_literal269_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 82))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:660:4: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
                int alt60 = 8;
                switch (input.LA(1))
                {
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                        {
                            alt60 = 1;
                        }
                        break;
                    case STATIC:
                        {
                            alt60 = 2;
                        }
                        break;
                    case 178:
                        {
                            alt60 = 3;
                        }
                        break;
                    case 179:
                        {
                            alt60 = 4;
                        }
                        break;
                    case 180:
                        {
                            alt60 = 5;
                        }
                        break;
                    case 181:
                        {
                            alt60 = 6;
                        }
                        break;
                    case DYNAMIC:
                        {
                            alt60 = 7;
                        }
                        break;
                    case 182:
                        {
                            alt60 = 8;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d60s0 =
                            new NoViableAltException("659:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );", 60, 0, input);

                        throw nvae_d60s0;
                }

                switch (alt60)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:660:4: namespaceName
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_namespaceName_in_modifier2881);
                            namespaceName262 = namespaceName();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, namespaceName262.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:661:4: STATIC
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STATIC263 = (IToken)input.LT(1);
                            Match(input, STATIC, FOLLOW_STATIC_in_modifier2886); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STATIC263_tree = (CommonTree)adaptor.Create(STATIC263);
                                adaptor.AddChild(root_0, STATIC263_tree);
                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:662:4: 'final'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal264 = (IToken)input.LT(1);
                            Match(input, 178, FOLLOW_178_in_modifier2891); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal264_tree = (CommonTree)adaptor.Create(string_literal264);
                                adaptor.AddChild(root_0, string_literal264_tree);
                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:663:4: 'enumerable'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal265 = (IToken)input.LT(1);
                            Match(input, 179, FOLLOW_179_in_modifier2896); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal265_tree = (CommonTree)adaptor.Create(string_literal265);
                                adaptor.AddChild(root_0, string_literal265_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:664:4: 'explicit'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal266 = (IToken)input.LT(1);
                            Match(input, 180, FOLLOW_180_in_modifier2901); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal266_tree = (CommonTree)adaptor.Create(string_literal266);
                                adaptor.AddChild(root_0, string_literal266_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:4: 'override'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal267 = (IToken)input.LT(1);
                            Match(input, 181, FOLLOW_181_in_modifier2906); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal267_tree = (CommonTree)adaptor.Create(string_literal267);
                                adaptor.AddChild(root_0, string_literal267_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:666:4: DYNAMIC
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            DYNAMIC268 = (IToken)input.LT(1);
                            Match(input, DYNAMIC, FOLLOW_DYNAMIC_in_modifier2911); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                DYNAMIC268_tree = (CommonTree)adaptor.Create(DYNAMIC268);
                                adaptor.AddChild(root_0, DYNAMIC268_tree);
                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:667:4: 'intrinsic'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal269 = (IToken)input.LT(1);
                            Match(input, 182, FOLLOW_182_in_modifier2916); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal269_tree = (CommonTree)adaptor.Create(string_literal269);
                                adaptor.AddChild(root_0, string_literal269_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 82, modifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end modifier

        public class arguments_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start arguments
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:670:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );
        public arguments_return arguments() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            arguments_return retval = new arguments_return();
            retval.start = input.LT(1);
            int arguments_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN270 = null;
            IToken RPAREN272 = null;
            IToken LPAREN273 = null;
            IToken RPAREN274 = null;
            expressionList_return expressionList271 = null;


            CommonTree LPAREN270_tree = null;
            CommonTree RPAREN272_tree = null;
            CommonTree LPAREN273_tree = null;
            CommonTree RPAREN274_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 83))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:675:4: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS )
                int alt61 = 2;
                int LA61_0 = input.LA(1);

                if ((LA61_0 == LPAREN))
                {
                    int LA61_1 = input.LA(2);

                    if ((LA61_1 == RPAREN))
                    {
                        alt61 = 2;
                    }
                    else if ((LA61_1 == LCURLY || (LA61_1 >= STRING_LITERAL && LA61_1 <= USE) || LA61_1 == LPAREN || LA61_1 == XML || (LA61_1 >= IDENT && LA61_1 <= LBRACK) || LA61_1 == DYNAMIC || LA61_1 == LT || (LA61_1 >= IS && LA61_1 <= AS) || (LA61_1 >= PLUS && LA61_1 <= DIV) || (LA61_1 >= INC && LA61_1 <= BNOT) || (LA61_1 >= E4X_ATTRI && LA61_1 <= NEW) || LA61_1 == 177))
                    {
                        alt61 = 1;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d61s1 =
                            new NoViableAltException("670:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 61, 1, input);

                        throw nvae_d61s1;
                    }
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d61s0 =
                        new NoViableAltException("670:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 61, 0, input);

                    throw nvae_d61s0;
                }
                switch (alt61)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:675:4: LPAREN expressionList RPAREN
                        {
                            LPAREN270 = (IToken)input.LT(1);
                            Match(input, LPAREN, FOLLOW_LPAREN_in_arguments2937); if (failed) return retval;
                            if (backtracking == 0) stream_LPAREN.Add(LPAREN270);

                            PushFollow(FOLLOW_expressionList_in_arguments2939);
                            expressionList271 = expressionList();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_expressionList.Add(expressionList271.Tree);
                            RPAREN272 = (IToken)input.LT(1);
                            Match(input, RPAREN, FOLLOW_RPAREN_in_arguments2941); if (failed) return retval;
                            if (backtracking == 0) stream_RPAREN.Add(RPAREN272);


                            // AST REWRITE
                            // elements:          expressionList
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 676:3: -> ^( ARGUMENTS expressionList )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:676:6: ^( ARGUMENTS expressionList )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

                                        adaptor.AddChild(root_1, stream_expressionList.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:677:4: LPAREN RPAREN
                        {
                            LPAREN273 = (IToken)input.LT(1);
                            Match(input, LPAREN, FOLLOW_LPAREN_in_arguments2956); if (failed) return retval;
                            if (backtracking == 0) stream_LPAREN.Add(LPAREN273);

                            RPAREN274 = (IToken)input.LT(1);
                            Match(input, RPAREN, FOLLOW_RPAREN_in_arguments2958); if (failed) return retval;
                            if (backtracking == 0) stream_RPAREN.Add(RPAREN274);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 678:3: -> ARGUMENTS
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(ARGUMENTS, "ARGUMENTS"));

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 83, arguments_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end arguments

        public class element_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start element
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:682:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
        public element_return element() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            element_return retval = new element_return();
            retval.start = input.LT(1);
            int element_StartIndex = input.Index();
            CommonTree root_0 = null;

            assignmentExpression_return assignmentExpression275 = null;


            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 84))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:687:4: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:687:4: assignmentExpression
                {
                    PushFollow(FOLLOW_assignmentExpression_in_element2988);
                    assignmentExpression275 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression275.Tree);

                    // AST REWRITE
                    // elements:          assignmentExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 688:3: -> ^( ELEMENT assignmentExpression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:688:6: ^( ELEMENT assignmentExpression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELEMENT, "ELEMENT"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 84, element_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end element

        public class arrayLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start arrayLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:692:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) ;
        public arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
        {
            arrayLiteral_return retval = new arrayLiteral_return();
            retval.start = input.LT(1);
            int arrayLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK276 = null;
            IToken RBRACK278 = null;
            elementList_return elementList277 = null;


            CommonTree LBRACK276_tree = null;
            CommonTree RBRACK278_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleSubtreeStream stream_elementList = new RewriteRuleSubtreeStream(adaptor, "rule elementList");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 85))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:4: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:4: LBRACK ( elementList )? RBRACK
                {
                    LBRACK276 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_arrayLiteral3010); if (failed) return retval;
                    if (backtracking == 0) stream_LBRACK.Add(LBRACK276);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:11: ( elementList )?
                    int alt62 = 2;
                    int LA62_0 = input.LA(1);

                    if ((LA62_0 == LCURLY || (LA62_0 >= STRING_LITERAL && LA62_0 <= USE) || LA62_0 == LPAREN || LA62_0 == XML || (LA62_0 >= IDENT && LA62_0 <= LBRACK) || LA62_0 == DYNAMIC || LA62_0 == LT || (LA62_0 >= IS && LA62_0 <= AS) || (LA62_0 >= PLUS && LA62_0 <= DIV) || (LA62_0 >= INC && LA62_0 <= BNOT) || (LA62_0 >= E4X_ATTRI && LA62_0 <= NEW) || LA62_0 == 177))
                    {
                        alt62 = 1;
                    }
                    switch (alt62)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: elementList
                            {
                                PushFollow(FOLLOW_elementList_in_arrayLiteral3012);
                                elementList277 = elementList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_elementList.Add(elementList277.Tree);

                            }
                            break;

                    }

                    RBRACK278 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_arrayLiteral3015); if (failed) return retval;
                    if (backtracking == 0) stream_RBRACK.Add(RBRACK278);


                    // AST REWRITE
                    // elements:          elementList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 694:3: -> ^( ARRAY_LITERAL ( elementList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:694:6: ^( ARRAY_LITERAL ( elementList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:694:22: ( elementList )?
                                if (stream_elementList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_elementList.Next());

                                }
                                stream_elementList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 85, arrayLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end arrayLiteral

        public class elementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start elementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:697:1: elementList : nonemptyElementList ( COMMA ( nonemptyElementList )? )* ;
        public elementList_return elementList() // throws RecognitionException [1]
        {
            elementList_return retval = new elementList_return();
            retval.start = input.LT(1);
            int elementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA280 = null;
            nonemptyElementList_return nonemptyElementList279 = null;

            nonemptyElementList_return nonemptyElementList281 = null;


            CommonTree COMMA280_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 86))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:4: ( nonemptyElementList ( COMMA ( nonemptyElementList )? )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:4: nonemptyElementList ( COMMA ( nonemptyElementList )? )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_nonemptyElementList_in_elementList3037);
                    nonemptyElementList279 = nonemptyElementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList279.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:24: ( COMMA ( nonemptyElementList )? )*
                    do
                    {
                        int alt64 = 2;
                        int LA64_0 = input.LA(1);

                        if ((LA64_0 == COMMA))
                        {
                            alt64 = 1;
                        }


                        switch (alt64)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:25: COMMA ( nonemptyElementList )?
                                {
                                    COMMA280 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_elementList3040); if (failed) return retval;
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:32: ( nonemptyElementList )?
                                    int alt63 = 2;
                                    int LA63_0 = input.LA(1);

                                    if ((LA63_0 == LCURLY || (LA63_0 >= STRING_LITERAL && LA63_0 <= USE) || LA63_0 == LPAREN || LA63_0 == XML || (LA63_0 >= IDENT && LA63_0 <= LBRACK) || LA63_0 == DYNAMIC || LA63_0 == LT || (LA63_0 >= IS && LA63_0 <= AS) || (LA63_0 >= PLUS && LA63_0 <= DIV) || (LA63_0 >= INC && LA63_0 <= BNOT) || (LA63_0 >= E4X_ATTRI && LA63_0 <= NEW) || LA63_0 == 177))
                                    {
                                        alt63 = 1;
                                    }
                                    switch (alt63)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: nonemptyElementList
                                            {
                                                PushFollow(FOLLOW_nonemptyElementList_in_elementList3043);
                                                nonemptyElementList281 = nonemptyElementList();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList281.Tree);

                                            }
                                            break;

                                    }


                                }
                                break;

                            default:
                                goto loop64;
                        }
                    } while (true);

                loop64:
                    ;	// Stops C# compiler whinging that label 'loop64' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 86, elementList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end elementList

        public class nonemptyElementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start nonemptyElementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:701:1: nonemptyElementList : assignmentExpression ( COMMA assignmentExpression )* ;
        public nonemptyElementList_return nonemptyElementList() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            nonemptyElementList_return retval = new nonemptyElementList_return();
            retval.start = input.LT(1);
            int nonemptyElementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA283 = null;
            assignmentExpression_return assignmentExpression282 = null;

            assignmentExpression_return assignmentExpression284 = null;


            CommonTree COMMA283_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 87))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:4: ( assignmentExpression ( COMMA assignmentExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:4: assignmentExpression ( COMMA assignmentExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3068);
                    assignmentExpression282 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression282.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:25: ( COMMA assignmentExpression )*
                    do
                    {
                        int alt65 = 2;
                        int LA65_0 = input.LA(1);

                        if ((LA65_0 == COMMA))
                        {
                            switch (input.LA(2))
                            {
                                case INC:
                                    {
                                        int LA65_4 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case DEC:
                                    {
                                        int LA65_5 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case MINUS:
                                    {
                                        int LA65_6 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case PLUS:
                                    {
                                        int LA65_7 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case DELETE:
                                    {
                                        int LA65_8 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case 177:
                                    {
                                        int LA65_9 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case TYPEOF:
                                    {
                                        int LA65_10 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case LNOT:
                                    {
                                        int LA65_11 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case BNOT:
                                    {
                                        int LA65_12 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case UNDEFINED:
                                    {
                                        int LA65_13 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case LT:
                                    {
                                        int LA65_14 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA65_15 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA65_16 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA65_17 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA65_18 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA65_19 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA65_20 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA65_21 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA65_22 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA65_23 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA65_24 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA65_25 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA65_26 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA65_27 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA65_28 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case USE:
                                    {
                                        int LA65_29 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case XML:
                                    {
                                        int LA65_30 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA65_31 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA65_32 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case IS:
                                    {
                                        int LA65_33 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case AS:
                                    {
                                        int LA65_34 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case GET:
                                    {
                                        int LA65_35 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;
                                case SET:
                                    {
                                        int LA65_36 = input.LA(3);

                                        if ((synpred104()))
                                        {
                                            alt65 = 1;
                                        }


                                    }
                                    break;

                            }

                        }


                        switch (alt65)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:26: COMMA assignmentExpression
                                {
                                    COMMA283 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_nonemptyElementList3071); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        COMMA283_tree = (CommonTree)adaptor.Create(COMMA283);
                                        adaptor.AddChild(root_0, COMMA283_tree);
                                    }
                                    PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3073);
                                    assignmentExpression284 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression284.Tree);

                                }
                                break;

                            default:
                                goto loop65;
                        }
                    } while (true);

                loop65:
                    ;	// Stops C# compiler whinging that label 'loop65' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 87, nonemptyElementList_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end nonemptyElementList

        public class objectLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start objectLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:710:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
        public objectLiteral_return objectLiteral() // throws RecognitionException [1]
        {
            objectLiteral_return retval = new objectLiteral_return();
            retval.start = input.LT(1);
            int objectLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY285 = null;
            IToken RCURLY287 = null;
            fieldList_return fieldList286 = null;


            CommonTree LCURLY285_tree = null;
            CommonTree RCURLY287_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_fieldList = new RewriteRuleSubtreeStream(adaptor, "rule fieldList");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 88))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:711:4: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:711:4: LCURLY ( fieldList )? RCURLY
                {
                    LCURLY285 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_objectLiteral3088); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY285);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:711:11: ( fieldList )?
                    int alt66 = 2;
                    int LA66_0 = input.LA(1);

                    if (((LA66_0 >= GET && LA66_0 <= USE) || LA66_0 == XML || LA66_0 == IDENT || LA66_0 == DYNAMIC || (LA66_0 >= IS && LA66_0 <= AS) || (LA66_0 >= HEX_LITERAL && LA66_0 <= FLOAT_LITERAL)))
                    {
                        alt66 = 1;
                    }
                    switch (alt66)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: fieldList
                            {
                                PushFollow(FOLLOW_fieldList_in_objectLiteral3090);
                                fieldList286 = fieldList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_fieldList.Add(fieldList286.Tree);

                            }
                            break;

                    }

                    RCURLY287 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_objectLiteral3093); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY287);


                    // AST REWRITE
                    // elements:          fieldList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 712:3: -> ^( OBJECT_LITERAL ( fieldList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:6: ^( OBJECT_LITERAL ( fieldList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:23: ( fieldList )?
                                if (stream_fieldList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_fieldList.Next());

                                }
                                stream_fieldList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 88, objectLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end objectLiteral

        public class fieldList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fieldList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:1: fieldList : literalField ( COMMA ( literalField )? )* ;
        public fieldList_return fieldList() // throws RecognitionException [1]
        {
            fieldList_return retval = new fieldList_return();
            retval.start = input.LT(1);
            int fieldList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA289 = null;
            literalField_return literalField288 = null;

            literalField_return literalField290 = null;


            CommonTree COMMA289_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 89))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:4: ( literalField ( COMMA ( literalField )? )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:4: literalField ( COMMA ( literalField )? )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_literalField_in_fieldList3116);
                    literalField288 = literalField();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, literalField288.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:17: ( COMMA ( literalField )? )*
                    do
                    {
                        int alt68 = 2;
                        int LA68_0 = input.LA(1);

                        if ((LA68_0 == COMMA))
                        {
                            alt68 = 1;
                        }


                        switch (alt68)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:18: COMMA ( literalField )?
                                {
                                    COMMA289 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_fieldList3119); if (failed) return retval;
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:25: ( literalField )?
                                    int alt67 = 2;
                                    int LA67_0 = input.LA(1);

                                    if (((LA67_0 >= GET && LA67_0 <= USE) || LA67_0 == XML || LA67_0 == IDENT || LA67_0 == DYNAMIC || (LA67_0 >= IS && LA67_0 <= AS) || (LA67_0 >= HEX_LITERAL && LA67_0 <= FLOAT_LITERAL)))
                                    {
                                        alt67 = 1;
                                    }
                                    switch (alt67)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: literalField
                                            {
                                                PushFollow(FOLLOW_literalField_in_fieldList3122);
                                                literalField290 = literalField();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, literalField290.Tree);

                                            }
                                            break;

                                    }


                                }
                                break;

                            default:
                                goto loop68;
                        }
                    } while (true);

                loop68:
                    ;	// Stops C# compiler whinging that label 'loop68' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 89, fieldList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fieldList

        public class literalField_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start literalField
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:719:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
        public literalField_return literalField() // throws RecognitionException [1]
        {
            literalField_return retval = new literalField_return();
            retval.start = input.LT(1);
            int literalField_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COLON292 = null;
            fieldName_return fieldName291 = null;

            element_return element293 = null;


            CommonTree COLON292_tree = null;
            RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor, "token COLON");
            RewriteRuleSubtreeStream stream_element = new RewriteRuleSubtreeStream(adaptor, "rule element");
            RewriteRuleSubtreeStream stream_fieldName = new RewriteRuleSubtreeStream(adaptor, "rule fieldName");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 90))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:720:5: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:720:5: fieldName COLON element
                {
                    PushFollow(FOLLOW_fieldName_in_literalField3139);
                    fieldName291 = fieldName();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_fieldName.Add(fieldName291.Tree);
                    COLON292 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_literalField3141); if (failed) return retval;
                    if (backtracking == 0) stream_COLON.Add(COLON292);

                    PushFollow(FOLLOW_element_in_literalField3143);
                    element293 = element();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_element.Add(element293.Tree);

                    // AST REWRITE
                    // elements:          fieldName, element
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 721:3: -> ^( OBJECT_FIELD fieldName element )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:6: ^( OBJECT_FIELD fieldName element )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);

                                adaptor.AddChild(root_1, stream_fieldName.Next());
                                adaptor.AddChild(root_1, stream_element.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 90, literalField_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end literalField

        public class fieldName_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fieldName
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:724:1: fieldName : ( ident | number );
        public fieldName_return fieldName() // throws RecognitionException [1]
        {
            fieldName_return retval = new fieldName_return();
            retval.start = input.LT(1);
            int fieldName_StartIndex = input.Index();
            CommonTree root_0 = null;

            ident_return ident294 = null;

            number_return number295 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 91))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:4: ( ident | number )
                int alt69 = 2;
                int LA69_0 = input.LA(1);

                if (((LA69_0 >= GET && LA69_0 <= USE) || LA69_0 == XML || LA69_0 == IDENT || LA69_0 == DYNAMIC || (LA69_0 >= IS && LA69_0 <= AS)))
                {
                    alt69 = 1;
                }
                else if (((LA69_0 >= HEX_LITERAL && LA69_0 <= FLOAT_LITERAL)))
                {
                    alt69 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d69s0 =
                        new NoViableAltException("724:1: fieldName : ( ident | number );", 69, 0, input);

                    throw nvae_d69s0;
                }
                switch (alt69)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:4: ident
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ident_in_fieldName3167);
                            ident294 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ident294.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:726:4: number
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_number_in_fieldName3172);
                            number295 = number();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, number295.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 91, fieldName_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fieldName

        public class expression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:730:1: expression : assignmentExpression ;
        public expression_return expression() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            expression_return retval = new expression_return();
            retval.start = input.LT(1);
            int expression_StartIndex = input.Index();
            CommonTree root_0 = null;

            assignmentExpression_return assignmentExpression296 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 92))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:735:4: ( assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:735:4: assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_expression3194);
                    assignmentExpression296 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression296.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 92, expression_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end expression

        public class expressionList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expressionList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:739:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) ;
        public expressionList_return expressionList() // throws RecognitionException [1]
        {
            expressionList_return retval = new expressionList_return();
            retval.start = input.LT(1);
            int expressionList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA298 = null;
            assignmentExpression_return assignmentExpression297 = null;

            assignmentExpression_return assignmentExpression299 = null;


            CommonTree COMMA298_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 93))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:4: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:4: assignmentExpression ( COMMA assignmentExpression )*
                {
                    PushFollow(FOLLOW_assignmentExpression_in_expressionList3206);
                    assignmentExpression297 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression297.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:25: ( COMMA assignmentExpression )*
                    do
                    {
                        int alt70 = 2;
                        int LA70_0 = input.LA(1);

                        if ((LA70_0 == COMMA))
                        {
                            alt70 = 1;
                        }


                        switch (alt70)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:26: COMMA assignmentExpression
                                {
                                    COMMA298 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_expressionList3209); if (failed) return retval;
                                    if (backtracking == 0) stream_COMMA.Add(COMMA298);

                                    PushFollow(FOLLOW_assignmentExpression_in_expressionList3211);
                                    assignmentExpression299 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression299.Tree);

                                }
                                break;

                            default:
                                goto loop70;
                        }
                    } while (true);

                loop70:
                    ;	// Stops C# compiler whinging that label 'loop70' has no statements


                    // AST REWRITE
                    // elements:          assignmentExpression, COMMA, assignmentExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 740:55: -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:58: ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELIST, "ELIST"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:87: ( COMMA assignmentExpression )*
                                while (stream_assignmentExpression.HasNext() || stream_COMMA.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_COMMA.Next());
                                    adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                }
                                stream_assignmentExpression.Reset();
                                stream_COMMA.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 93, expressionList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end expressionList

        public class assignmentExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start assignmentExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
        public assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
        {
            assignmentExpression_return retval = new assignmentExpression_return();
            retval.start = input.LT(1);
            int assignmentExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            conditionalExpression_return conditionalExpression300 = null;

            assignmentOperator_return assignmentOperator301 = null;

            assignmentExpression_return assignmentExpression302 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 94))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:745:4: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:745:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression3240);
                    conditionalExpression300 = conditionalExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, conditionalExpression300.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:2: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
                    do
                    {
                        int alt71 = 2;
                        int LA71_0 = input.LA(1);

                        if ((LA71_0 == ASSIGN || (LA71_0 >= STAR_ASSIGN && LA71_0 <= LOR_ASSIGN)))
                        {
                            int LA71_9 = input.LA(2);

                            if ((synpred110()))
                            {
                                alt71 = 1;
                            }


                        }


                        switch (alt71)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:4: ( assignmentOperator )=> assignmentOperator assignmentExpression
                                {
                                    PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression3250);
                                    assignmentOperator301 = assignmentOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentOperator301.Tree);
                                    PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression3254);
                                    assignmentExpression302 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression302.Tree);

                                }
                                break;

                            default:
                                goto loop71;
                        }
                    } while (true);

                loop71:
                    ;	// Stops C# compiler whinging that label 'loop71' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 94, assignmentExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end assignmentExpression

        public class assignmentOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start assignmentOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:751:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
        public assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
        {
            assignmentOperator_return retval = new assignmentOperator_return();
            retval.start = input.LT(1);
            int assignmentOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set303 = null;

            CommonTree set303_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 95))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:4: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set303 = (IToken)input.LT(1);
                    if (input.LA(1) == ASSIGN || (input.LA(1) >= STAR_ASSIGN && input.LA(1) <= LOR_ASSIGN))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set303));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_assignmentOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 95, assignmentOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end assignmentOperator

        public class conditionalExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start conditionalExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:769:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
        public conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
        {
            conditionalExpression_return retval = new conditionalExpression_return();
            retval.start = input.LT(1);
            int conditionalExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken QUESTION305 = null;
            logicalOrExpression_return logicalOrExpression304 = null;

            conditionalSubExpression_return conditionalSubExpression306 = null;


            CommonTree QUESTION305_tree = null;
            RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream(adaptor, "token QUESTION");
            RewriteRuleSubtreeStream stream_logicalOrExpression = new RewriteRuleSubtreeStream(adaptor, "rule logicalOrExpression");
            RewriteRuleSubtreeStream stream_conditionalSubExpression = new RewriteRuleSubtreeStream(adaptor, "rule conditionalSubExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 96))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:770:4: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:770:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:770:4: ( logicalOrExpression -> logicalOrExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:770:5: logicalOrExpression
                    {
                        PushFollow(FOLLOW_logicalOrExpression_in_conditionalExpression3348);
                        logicalOrExpression304 = logicalOrExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_logicalOrExpression.Add(logicalOrExpression304.Tree);

                        // AST REWRITE
                        // elements:          logicalOrExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 770:25: -> logicalOrExpression
                            {
                                adaptor.AddChild(root_0, stream_logicalOrExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:771:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
                    int alt72 = 2;
                    int LA72_0 = input.LA(1);

                    if ((LA72_0 == QUESTION))
                    {
                        alt72 = 1;
                    }
                    switch (alt72)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:772:4: QUESTION conditionalSubExpression
                            {
                                QUESTION305 = (IToken)input.LT(1);
                                Match(input, QUESTION, FOLLOW_QUESTION_in_conditionalExpression3362); if (failed) return retval;
                                if (backtracking == 0) stream_QUESTION.Add(QUESTION305);

                                PushFollow(FOLLOW_conditionalSubExpression_in_conditionalExpression3367);
                                conditionalSubExpression306 = conditionalSubExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_conditionalSubExpression.Add(conditionalSubExpression306.Tree);

                                // AST REWRITE
                                // elements:          conditionalExpression, conditionalSubExpression, QUESTION
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 774:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:774:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.Next(), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());
                                            adaptor.AddChild(root_1, stream_conditionalSubExpression.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 96, conditionalExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end conditionalExpression

        public class conditionalSubExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start conditionalSubExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:777:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
        public conditionalSubExpression_return conditionalSubExpression() // throws RecognitionException [1]
        {
            conditionalSubExpression_return retval = new conditionalSubExpression_return();
            retval.start = input.LT(1);
            int conditionalSubExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COLON308 = null;
            assignmentExpression_return assignmentExpression307 = null;

            assignmentExpression_return assignmentExpression309 = null;


            CommonTree COLON308_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 97))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:778:4: ( assignmentExpression COLON assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:778:4: assignmentExpression COLON assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3396);
                    assignmentExpression307 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression307.Tree);
                    COLON308 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_conditionalSubExpression3398); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        COLON308_tree = (CommonTree)adaptor.Create(COLON308);
                        root_0 = (CommonTree)adaptor.BecomeRoot(COLON308_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3401);
                    assignmentExpression309 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression309.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 97, conditionalSubExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end conditionalSubExpression

        public class logicalOrExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalOrExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:784:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
        public logicalOrExpression_return logicalOrExpression() // throws RecognitionException [1]
        {
            logicalOrExpression_return retval = new logicalOrExpression_return();
            retval.start = input.LT(1);
            int logicalOrExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            logicalAndExpression_return logicalAndExpression310 = null;

            logicalOrOperator_return logicalOrOperator311 = null;

            logicalAndExpression_return logicalAndExpression312 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 98))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:785:4: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:785:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3415);
                    logicalAndExpression310 = logicalAndExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression310.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:3: ( logicalOrOperator logicalAndExpression )*
                    do
                    {
                        int alt73 = 2;
                        int LA73_0 = input.LA(1);

                        if ((LA73_0 == LOR || LA73_0 == 183))
                        {
                            alt73 = 1;
                        }


                        switch (alt73)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:4: logicalOrOperator logicalAndExpression
                                {
                                    PushFollow(FOLLOW_logicalOrOperator_in_logicalOrExpression3420);
                                    logicalOrOperator311 = logicalOrOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(logicalOrOperator311.Tree, root_0);
                                    PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3423);
                                    logicalAndExpression312 = logicalAndExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression312.Tree);

                                }
                                break;

                            default:
                                goto loop73;
                        }
                    } while (true);

                loop73:
                    ;	// Stops C# compiler whinging that label 'loop73' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 98, logicalOrExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalOrExpression

        public class logicalOrOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalOrOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:789:1: logicalOrOperator : ( LOR | 'or' );
        public logicalOrOperator_return logicalOrOperator() // throws RecognitionException [1]
        {
            logicalOrOperator_return retval = new logicalOrOperator_return();
            retval.start = input.LT(1);
            int logicalOrOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set313 = null;

            CommonTree set313_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 99))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:790:4: ( LOR | 'or' )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set313 = (IToken)input.LT(1);
                    if (input.LA(1) == LOR || input.LA(1) == 183)
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set313));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_logicalOrOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 99, logicalOrOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalOrOperator

        public class logicalAndExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalAndExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:794:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
        public logicalAndExpression_return logicalAndExpression() // throws RecognitionException [1]
        {
            logicalAndExpression_return retval = new logicalAndExpression_return();
            retval.start = input.LT(1);
            int logicalAndExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            bitwiseOrExpression_return bitwiseOrExpression314 = null;

            logicalAndOperator_return logicalAndOperator315 = null;

            bitwiseOrExpression_return bitwiseOrExpression316 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 100))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:795:4: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:795:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3452);
                    bitwiseOrExpression314 = bitwiseOrExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression314.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:796:3: ( logicalAndOperator bitwiseOrExpression )*
                    do
                    {
                        int alt74 = 2;
                        int LA74_0 = input.LA(1);

                        if ((LA74_0 == LAND || LA74_0 == 184))
                        {
                            alt74 = 1;
                        }


                        switch (alt74)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:796:4: logicalAndOperator bitwiseOrExpression
                                {
                                    PushFollow(FOLLOW_logicalAndOperator_in_logicalAndExpression3457);
                                    logicalAndOperator315 = logicalAndOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(logicalAndOperator315.Tree, root_0);
                                    PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3460);
                                    bitwiseOrExpression316 = bitwiseOrExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression316.Tree);

                                }
                                break;

                            default:
                                goto loop74;
                        }
                    } while (true);

                loop74:
                    ;	// Stops C# compiler whinging that label 'loop74' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 100, logicalAndExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalAndExpression

        public class logicalAndOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalAndOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:799:1: logicalAndOperator : ( LAND | 'and' );
        public logicalAndOperator_return logicalAndOperator() // throws RecognitionException [1]
        {
            logicalAndOperator_return retval = new logicalAndOperator_return();
            retval.start = input.LT(1);
            int logicalAndOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set317 = null;

            CommonTree set317_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 101))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:800:4: ( LAND | 'and' )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set317 = (IToken)input.LT(1);
                    if (input.LA(1) == LAND || input.LA(1) == 184)
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set317));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_logicalAndOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 101, logicalAndOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalAndOperator

        public class bitwiseOrExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseOrExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:804:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
        public bitwiseOrExpression_return bitwiseOrExpression() // throws RecognitionException [1]
        {
            bitwiseOrExpression_return retval = new bitwiseOrExpression_return();
            retval.start = input.LT(1);
            int bitwiseOrExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BOR319 = null;
            bitwiseXorExpression_return bitwiseXorExpression318 = null;

            bitwiseXorExpression_return bitwiseXorExpression320 = null;


            CommonTree BOR319_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 102))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:805:4: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:805:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3489);
                    bitwiseXorExpression318 = bitwiseXorExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression318.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:806:3: ( BOR bitwiseXorExpression )*
                    do
                    {
                        int alt75 = 2;
                        int LA75_0 = input.LA(1);

                        if ((LA75_0 == BOR))
                        {
                            alt75 = 1;
                        }


                        switch (alt75)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:806:4: BOR bitwiseXorExpression
                                {
                                    BOR319 = (IToken)input.LT(1);
                                    Match(input, BOR, FOLLOW_BOR_in_bitwiseOrExpression3494); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BOR319_tree = (CommonTree)adaptor.Create(BOR319);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BOR319_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3497);
                                    bitwiseXorExpression320 = bitwiseXorExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression320.Tree);

                                }
                                break;

                            default:
                                goto loop75;
                        }
                    } while (true);

                loop75:
                    ;	// Stops C# compiler whinging that label 'loop75' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 102, bitwiseOrExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseOrExpression

        public class bitwiseXorExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseXorExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:810:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
        public bitwiseXorExpression_return bitwiseXorExpression() // throws RecognitionException [1]
        {
            bitwiseXorExpression_return retval = new bitwiseXorExpression_return();
            retval.start = input.LT(1);
            int bitwiseXorExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BXOR322 = null;
            bitwiseAndExpression_return bitwiseAndExpression321 = null;

            bitwiseAndExpression_return bitwiseAndExpression323 = null;


            CommonTree BXOR322_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 103))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:811:4: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:811:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3511);
                    bitwiseAndExpression321 = bitwiseAndExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression321.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:812:3: ( BXOR bitwiseAndExpression )*
                    do
                    {
                        int alt76 = 2;
                        int LA76_0 = input.LA(1);

                        if ((LA76_0 == BXOR))
                        {
                            alt76 = 1;
                        }


                        switch (alt76)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:812:4: BXOR bitwiseAndExpression
                                {
                                    BXOR322 = (IToken)input.LT(1);
                                    Match(input, BXOR, FOLLOW_BXOR_in_bitwiseXorExpression3516); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BXOR322_tree = (CommonTree)adaptor.Create(BXOR322);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BXOR322_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3519);
                                    bitwiseAndExpression323 = bitwiseAndExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression323.Tree);

                                }
                                break;

                            default:
                                goto loop76;
                        }
                    } while (true);

                loop76:
                    ;	// Stops C# compiler whinging that label 'loop76' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 103, bitwiseXorExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseXorExpression

        public class bitwiseAndExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseAndExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
        public bitwiseAndExpression_return bitwiseAndExpression() // throws RecognitionException [1]
        {
            bitwiseAndExpression_return retval = new bitwiseAndExpression_return();
            retval.start = input.LT(1);
            int bitwiseAndExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BAND325 = null;
            equalityExpression_return equalityExpression324 = null;

            equalityExpression_return equalityExpression326 = null;


            CommonTree BAND325_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 104))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:817:4: ( equalityExpression ( BAND equalityExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:817:4: equalityExpression ( BAND equalityExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3533);
                    equalityExpression324 = equalityExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, equalityExpression324.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:818:3: ( BAND equalityExpression )*
                    do
                    {
                        int alt77 = 2;
                        int LA77_0 = input.LA(1);

                        if ((LA77_0 == BAND))
                        {
                            alt77 = 1;
                        }


                        switch (alt77)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:818:4: BAND equalityExpression
                                {
                                    BAND325 = (IToken)input.LT(1);
                                    Match(input, BAND, FOLLOW_BAND_in_bitwiseAndExpression3538); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BAND325_tree = (CommonTree)adaptor.Create(BAND325);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BAND325_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3541);
                                    equalityExpression326 = equalityExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, equalityExpression326.Tree);

                                }
                                break;

                            default:
                                goto loop77;
                        }
                    } while (true);

                loop77:
                    ;	// Stops C# compiler whinging that label 'loop77' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 104, bitwiseAndExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseAndExpression

        public class equalityExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start equalityExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:822:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
        public equalityExpression_return equalityExpression() // throws RecognitionException [1]
        {
            equalityExpression_return retval = new equalityExpression_return();
            retval.start = input.LT(1);
            int equalityExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            relationalExpression_return relationalExpression327 = null;

            equalityOperator_return equalityOperator328 = null;

            relationalExpression_return relationalExpression329 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 105))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:823:4: ( relationalExpression ( equalityOperator relationalExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:823:4: relationalExpression ( equalityOperator relationalExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_relationalExpression_in_equalityExpression3555);
                    relationalExpression327 = relationalExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, relationalExpression327.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:2: ( equalityOperator relationalExpression )*
                    do
                    {
                        int alt78 = 2;
                        int LA78_0 = input.LA(1);

                        if (((LA78_0 >= STRICT_EQUAL && LA78_0 <= EQUAL)))
                        {
                            alt78 = 1;
                        }


                        switch (alt78)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:4: equalityOperator relationalExpression
                                {
                                    PushFollow(FOLLOW_equalityOperator_in_equalityExpression3560);
                                    equalityOperator328 = equalityOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(equalityOperator328.Tree, root_0);
                                    PushFollow(FOLLOW_relationalExpression_in_equalityExpression3565);
                                    relationalExpression329 = relationalExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, relationalExpression329.Tree);

                                }
                                break;

                            default:
                                goto loop78;
                        }
                    } while (true);

                loop78:
                    ;	// Stops C# compiler whinging that label 'loop78' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 105, equalityExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end equalityExpression

        public class equalityOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start equalityOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:829:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
        public equalityOperator_return equalityOperator() // throws RecognitionException [1]
        {
            equalityOperator_return retval = new equalityOperator_return();
            retval.start = input.LT(1);
            int equalityOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set330 = null;

            CommonTree set330_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 106))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:830:4: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set330 = (IToken)input.LT(1);
                    if ((input.LA(1) >= STRICT_EQUAL && input.LA(1) <= EQUAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set330));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_equalityOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 106, equalityOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end equalityOperator

        public class relationalExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start relationalExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:834:1: relationalExpression : shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* ;
        public relationalExpression_return relationalExpression() // throws RecognitionException [1]
        {
            relationalExpression_return retval = new relationalExpression_return();
            retval.start = input.LT(1);
            int relationalExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            shiftExpression_return shiftExpression331 = null;

            relationalOperator_return relationalOperator332 = null;

            shiftExpression_return shiftExpression333 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 107))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:835:4: ( shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:835:4: shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_shiftExpression_in_relationalExpression3605);
                    shiftExpression331 = shiftExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, shiftExpression331.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:3: ( ( relationalOperator )=> relationalOperator shiftExpression )*
                    do
                    {
                        int alt79 = 2;
                        int LA79_0 = input.LA(1);

                        if ((LA79_0 == IN))
                        {
                            switch (input.LA(2))
                            {
                                case INC:
                                    {
                                        int LA79_25 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case DEC:
                                    {
                                        int LA79_26 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case MINUS:
                                    {
                                        int LA79_27 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case PLUS:
                                    {
                                        int LA79_28 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case DELETE:
                                    {
                                        int LA79_29 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case 177:
                                    {
                                        int LA79_30 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case TYPEOF:
                                    {
                                        int LA79_31 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case LNOT:
                                    {
                                        int LA79_32 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case BNOT:
                                    {
                                        int LA79_33 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case UNDEFINED:
                                    {
                                        int LA79_34 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case LT:
                                    {
                                        int LA79_35 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA79_36 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA79_37 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA79_38 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA79_39 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA79_40 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA79_41 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA79_42 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA79_43 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA79_44 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA79_45 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA79_46 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA79_47 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA79_48 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA79_49 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case USE:
                                    {
                                        int LA79_50 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case XML:
                                    {
                                        int LA79_51 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA79_52 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA79_53 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case IS:
                                    {
                                        int LA79_54 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case AS:
                                    {
                                        int LA79_55 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case GET:
                                    {
                                        int LA79_56 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;
                                case SET:
                                    {
                                        int LA79_57 = input.LA(3);

                                        if (((synpred136() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt79 = 1;
                                        }


                                    }
                                    break;

                            }

                        }
                        else if ((LA79_0 == LT) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == GT) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == LE) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == GE) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == IS) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == AS) && (synpred136()))
                        {
                            alt79 = 1;
                        }
                        else if ((LA79_0 == INSTANCEOF) && (synpred136()))
                        {
                            alt79 = 1;
                        }


                        switch (alt79)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:4: ( relationalOperator )=> relationalOperator shiftExpression
                                {
                                    PushFollow(FOLLOW_relationalOperator_in_relationalExpression3615);
                                    relationalOperator332 = relationalOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(relationalOperator332.Tree, root_0);
                                    PushFollow(FOLLOW_shiftExpression_in_relationalExpression3618);
                                    shiftExpression333 = shiftExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, shiftExpression333.Tree);

                                }
                                break;

                            default:
                                goto loop79;
                        }
                    } while (true);

                loop79:
                    ;	// Stops C# compiler whinging that label 'loop79' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 107, relationalExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end relationalExpression

        public class relationalOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start relationalOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:839:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );
        public relationalOperator_return relationalOperator() // throws RecognitionException [1]
        {
            relationalOperator_return retval = new relationalOperator_return();
            retval.start = input.LT(1);
            int relationalOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IN334 = null;
            IToken LT335 = null;
            IToken GT336 = null;
            IToken LE337 = null;
            IToken GE338 = null;
            IToken IS339 = null;
            IToken AS340 = null;
            IToken INSTANCEOF341 = null;

            CommonTree IN334_tree = null;
            CommonTree LT335_tree = null;
            CommonTree GT336_tree = null;
            CommonTree LE337_tree = null;
            CommonTree GE338_tree = null;
            CommonTree IS339_tree = null;
            CommonTree AS340_tree = null;
            CommonTree INSTANCEOF341_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 108))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:840:4: ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF )
                int alt80 = 8;
                switch (input.LA(1))
                {
                    case IN:
                        {
                            alt80 = 1;
                        }
                        break;
                    case LT:
                        {
                            alt80 = 2;
                        }
                        break;
                    case GT:
                        {
                            alt80 = 3;
                        }
                        break;
                    case LE:
                        {
                            alt80 = 4;
                        }
                        break;
                    case GE:
                        {
                            alt80 = 5;
                        }
                        break;
                    case IS:
                        {
                            alt80 = 6;
                        }
                        break;
                    case AS:
                        {
                            alt80 = 7;
                        }
                        break;
                    case INSTANCEOF:
                        {
                            alt80 = 8;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d80s0 =
                            new NoViableAltException("839:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );", 80, 0, input);

                        throw nvae_d80s0;
                }

                switch (alt80)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:840:4: {...}? IN
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            if (!(((InOperator_scope)InOperator_stack.Peek()).allowed))
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                throw new FailedPredicateException(input, "relationalOperator", "$InOperator::allowed");
                            }
                            IN334 = (IToken)input.LT(1);
                            Match(input, IN, FOLLOW_IN_in_relationalOperator3633); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IN334_tree = (CommonTree)adaptor.Create(IN334);
                                adaptor.AddChild(root_0, IN334_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:4: LT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            LT335 = (IToken)input.LT(1);
                            Match(input, LT, FOLLOW_LT_in_relationalOperator3638); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                LT335_tree = (CommonTree)adaptor.Create(LT335);
                                adaptor.AddChild(root_0, LT335_tree);
                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:9: GT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            GT336 = (IToken)input.LT(1);
                            Match(input, GT, FOLLOW_GT_in_relationalOperator3642); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                GT336_tree = (CommonTree)adaptor.Create(GT336);
                                adaptor.AddChild(root_0, GT336_tree);
                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:14: LE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            LE337 = (IToken)input.LT(1);
                            Match(input, LE, FOLLOW_LE_in_relationalOperator3646); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                LE337_tree = (CommonTree)adaptor.Create(LE337);
                                adaptor.AddChild(root_0, LE337_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:19: GE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            GE338 = (IToken)input.LT(1);
                            Match(input, GE, FOLLOW_GE_in_relationalOperator3650); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                GE338_tree = (CommonTree)adaptor.Create(GE338);
                                adaptor.AddChild(root_0, GE338_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:24: IS
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IS339 = (IToken)input.LT(1);
                            Match(input, IS, FOLLOW_IS_in_relationalOperator3654); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IS339_tree = (CommonTree)adaptor.Create(IS339);
                                adaptor.AddChild(root_0, IS339_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:29: AS
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            AS340 = (IToken)input.LT(1);
                            Match(input, AS, FOLLOW_AS_in_relationalOperator3658); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                AS340_tree = (CommonTree)adaptor.Create(AS340);
                                adaptor.AddChild(root_0, AS340_tree);
                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:34: INSTANCEOF
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            INSTANCEOF341 = (IToken)input.LT(1);
                            Match(input, INSTANCEOF, FOLLOW_INSTANCEOF_in_relationalOperator3662); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                INSTANCEOF341_tree = (CommonTree)adaptor.Create(INSTANCEOF341);
                                adaptor.AddChild(root_0, INSTANCEOF341_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 108, relationalOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end relationalOperator

        public class shiftExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shiftExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
        public shiftExpression_return shiftExpression() // throws RecognitionException [1]
        {
            shiftExpression_return retval = new shiftExpression_return();
            retval.start = input.LT(1);
            int shiftExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            additiveExpression_return additiveExpression342 = null;

            shiftOperator_return shiftOperator343 = null;

            additiveExpression_return additiveExpression344 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 109))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:846:4: ( additiveExpression ( shiftOperator additiveExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:846:4: additiveExpression ( shiftOperator additiveExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_additiveExpression_in_shiftExpression3674);
                    additiveExpression342 = additiveExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, additiveExpression342.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:3: ( shiftOperator additiveExpression )*
                    do
                    {
                        int alt81 = 2;
                        int LA81_0 = input.LA(1);

                        if (((LA81_0 >= SL && LA81_0 <= BSR)))
                        {
                            alt81 = 1;
                        }


                        switch (alt81)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:4: shiftOperator additiveExpression
                                {
                                    PushFollow(FOLLOW_shiftOperator_in_shiftExpression3679);
                                    shiftOperator343 = shiftOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(shiftOperator343.Tree, root_0);
                                    PushFollow(FOLLOW_additiveExpression_in_shiftExpression3682);
                                    additiveExpression344 = additiveExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, additiveExpression344.Tree);

                                }
                                break;

                            default:
                                goto loop81;
                        }
                    } while (true);

                loop81:
                    ;	// Stops C# compiler whinging that label 'loop81' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 109, shiftExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shiftExpression

        public class shiftOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shiftOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:1: shiftOperator : ( SL | SR | BSR );
        public shiftOperator_return shiftOperator() // throws RecognitionException [1]
        {
            shiftOperator_return retval = new shiftOperator_return();
            retval.start = input.LT(1);
            int shiftOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set345 = null;

            CommonTree set345_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 110))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:851:4: ( SL | SR | BSR )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set345 = (IToken)input.LT(1);
                    if ((input.LA(1) >= SL && input.LA(1) <= BSR))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set345));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_shiftOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 110, shiftOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shiftOperator

        public class additiveExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start additiveExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:855:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
        public additiveExpression_return additiveExpression() // throws RecognitionException [1]
        {
            additiveExpression_return retval = new additiveExpression_return();
            retval.start = input.LT(1);
            int additiveExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            multiplicativeExpression_return multiplicativeExpression346 = null;

            additiveOperator_return additiveOperator347 = null;

            multiplicativeExpression_return multiplicativeExpression348 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 111))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:4: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3715);
                    multiplicativeExpression346 = multiplicativeExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression346.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:857:3: ( additiveOperator multiplicativeExpression )*
                    do
                    {
                        int alt82 = 2;
                        int LA82_0 = input.LA(1);

                        if (((LA82_0 >= PLUS && LA82_0 <= MINUS)))
                        {
                            alt82 = 1;
                        }


                        switch (alt82)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:857:4: additiveOperator multiplicativeExpression
                                {
                                    PushFollow(FOLLOW_additiveOperator_in_additiveExpression3720);
                                    additiveOperator347 = additiveOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(additiveOperator347.Tree, root_0);
                                    PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3723);
                                    multiplicativeExpression348 = multiplicativeExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression348.Tree);

                                }
                                break;

                            default:
                                goto loop82;
                        }
                    } while (true);

                loop82:
                    ;	// Stops C# compiler whinging that label 'loop82' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 111, additiveExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end additiveExpression

        public class additiveOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start additiveOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:860:1: additiveOperator : ( PLUS | MINUS );
        public additiveOperator_return additiveOperator() // throws RecognitionException [1]
        {
            additiveOperator_return retval = new additiveOperator_return();
            retval.start = input.LT(1);
            int additiveOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set349 = null;

            CommonTree set349_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 112))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:861:4: ( PLUS | MINUS )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set349 = (IToken)input.LT(1);
                    if ((input.LA(1) >= PLUS && input.LA(1) <= MINUS))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set349));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_additiveOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 112, additiveOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end additiveOperator

        public class multiplicativeExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start multiplicativeExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:865:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
        public multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
        {
            multiplicativeExpression_return retval = new multiplicativeExpression_return();
            retval.start = input.LT(1);
            int multiplicativeExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            unaryExpression_return unaryExpression350 = null;

            multiplicativeOperator_return multiplicativeOperator351 = null;

            unaryExpression_return unaryExpression352 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 113))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:4: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:4: unaryExpression ( multiplicativeOperator unaryExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3753);
                    unaryExpression350 = unaryExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, unaryExpression350.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:867:3: ( multiplicativeOperator unaryExpression )*
                    do
                    {
                        int alt83 = 2;
                        int LA83_0 = input.LA(1);

                        if ((LA83_0 == STAR || (LA83_0 >= DIV && LA83_0 <= MOD)))
                        {
                            alt83 = 1;
                        }


                        switch (alt83)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:867:5: multiplicativeOperator unaryExpression
                                {
                                    PushFollow(FOLLOW_multiplicativeOperator_in_multiplicativeExpression3759);
                                    multiplicativeOperator351 = multiplicativeOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(multiplicativeOperator351.Tree, root_0);
                                    PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3765);
                                    unaryExpression352 = unaryExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, unaryExpression352.Tree);

                                }
                                break;

                            default:
                                goto loop83;
                        }
                    } while (true);

                loop83:
                    ;	// Stops C# compiler whinging that label 'loop83' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 113, multiplicativeExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end multiplicativeExpression

        public class multiplicativeOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start multiplicativeOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:872:1: multiplicativeOperator : ( STAR | DIV | MOD );
        public multiplicativeOperator_return multiplicativeOperator() // throws RecognitionException [1]
        {
            multiplicativeOperator_return retval = new multiplicativeOperator_return();
            retval.start = input.LT(1);
            int multiplicativeOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set353 = null;

            CommonTree set353_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 114))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:873:4: ( STAR | DIV | MOD )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set353 = (IToken)input.LT(1);
                    if (input.LA(1) == STAR || (input.LA(1) >= DIV && input.LA(1) <= MOD))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set353));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_multiplicativeOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 114, multiplicativeOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end multiplicativeOperator

        public class unaryExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start unaryExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:877:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );
        public unaryExpression_return unaryExpression() // throws RecognitionException [1]
        {
            unaryExpression_return retval = new unaryExpression_return();
            retval.start = input.LT(1);
            int unaryExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken iin = null;
            IToken dde = null;
            IToken MINUS356 = null;
            IToken PLUS358 = null;
            unaryExpression_return unaryExpression354 = null;

            unaryExpression_return unaryExpression355 = null;

            unaryExpression_return unaryExpression357 = null;

            unaryExpression_return unaryExpression359 = null;

            unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus360 = null;


            CommonTree iin_tree = null;
            CommonTree dde_tree = null;
            CommonTree MINUS356_tree = null;
            CommonTree PLUS358_tree = null;
            RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream(adaptor, "token PLUS");
            RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor, "token INC");
            RewriteRuleTokenStream stream_MINUS = new RewriteRuleTokenStream(adaptor, "token MINUS");
            RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor, "token DEC");
            RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule unaryExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 115))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:878:4: (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus )
                int alt84 = 5;
                switch (input.LA(1))
                {
                    case INC:
                        {
                            alt84 = 1;
                        }
                        break;
                    case DEC:
                        {
                            alt84 = 2;
                        }
                        break;
                    case MINUS:
                        {
                            alt84 = 3;
                        }
                        break;
                    case PLUS:
                        {
                            alt84 = 4;
                        }
                        break;
                    case LCURLY:
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case DIV:
                    case DELETE:
                    case TYPEOF:
                    case LNOT:
                    case BNOT:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                    case 177:
                        {
                            alt84 = 5;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d84s0 =
                            new NoViableAltException("877:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );", 84, 0, input);

                        throw nvae_d84s0;
                }

                switch (alt84)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:878:4: iin= INC unaryExpression
                        {
                            iin = (IToken)input.LT(1);
                            Match(input, INC, FOLLOW_INC_in_unaryExpression3803); if (failed) return retval;
                            if (backtracking == 0) stream_INC.Add(iin);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3805);
                            unaryExpression354 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression354.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 878:28: -> ^( PRE_INC[$iin] unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:878:31: ^( PRE_INC[$iin] unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_INC, iin), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:879:4: dde= DEC unaryExpression
                        {
                            dde = (IToken)input.LT(1);
                            Match(input, DEC, FOLLOW_DEC_in_unaryExpression3821); if (failed) return retval;
                            if (backtracking == 0) stream_DEC.Add(dde);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3823);
                            unaryExpression355 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression355.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 879:28: -> ^( PRE_DEC[$dde] unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:879:31: ^( PRE_DEC[$dde] unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_DEC, dde), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:880:4: MINUS unaryExpression
                        {
                            MINUS356 = (IToken)input.LT(1);
                            Match(input, MINUS, FOLLOW_MINUS_in_unaryExpression3837); if (failed) return retval;
                            if (backtracking == 0) stream_MINUS.Add(MINUS356);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3839);
                            unaryExpression357 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression357.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 880:26: -> ^( UNARY_MINUS unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:880:29: ^( UNARY_MINUS unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:881:4: PLUS unaryExpression
                        {
                            PLUS358 = (IToken)input.LT(1);
                            Match(input, PLUS, FOLLOW_PLUS_in_unaryExpression3852); if (failed) return retval;
                            if (backtracking == 0) stream_PLUS.Add(PLUS358);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3854);
                            unaryExpression359 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression359.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 881:25: -> ^( UNARY_PLUS unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:881:28: ^( UNARY_PLUS unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_PLUS, "UNARY_PLUS"), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:4: unaryExpressionNotPlusMinus
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3867);
                            unaryExpressionNotPlusMinus360 = unaryExpressionNotPlusMinus();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus360.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 115, unaryExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end unaryExpression

        public class unaryExpressionNotPlusMinus_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start unaryExpressionNotPlusMinus
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:885:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
        public unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus() // throws RecognitionException [1]
        {
            unaryExpressionNotPlusMinus_return retval = new unaryExpressionNotPlusMinus_return();
            retval.start = input.LT(1);
            int unaryExpressionNotPlusMinus_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DELETE361 = null;
            IToken string_literal363 = null;
            IToken TYPEOF365 = null;
            IToken LNOT367 = null;
            IToken BNOT369 = null;
            postfixExpression_return postfixExpression362 = null;

            unaryExpression_return unaryExpression364 = null;

            unaryExpression_return unaryExpression366 = null;

            unaryExpression_return unaryExpression368 = null;

            unaryExpression_return unaryExpression370 = null;

            postfixExpression_return postfixExpression371 = null;


            CommonTree DELETE361_tree = null;
            CommonTree string_literal363_tree = null;
            CommonTree TYPEOF365_tree = null;
            CommonTree LNOT367_tree = null;
            CommonTree BNOT369_tree = null;
            RewriteRuleTokenStream stream_177 = new RewriteRuleTokenStream(adaptor, "token 177");
            RewriteRuleTokenStream stream_BNOT = new RewriteRuleTokenStream(adaptor, "token BNOT");
            RewriteRuleTokenStream stream_LNOT = new RewriteRuleTokenStream(adaptor, "token LNOT");
            RewriteRuleTokenStream stream_TYPEOF = new RewriteRuleTokenStream(adaptor, "token TYPEOF");
            RewriteRuleTokenStream stream_DELETE = new RewriteRuleTokenStream(adaptor, "token DELETE");
            RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule unaryExpression");
            RewriteRuleSubtreeStream stream_postfixExpression = new RewriteRuleSubtreeStream(adaptor, "rule postfixExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 116))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:4: ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
                int alt85 = 6;
                switch (input.LA(1))
                {
                    case DELETE:
                        {
                            alt85 = 1;
                        }
                        break;
                    case 177:
                        {
                            alt85 = 2;
                        }
                        break;
                    case TYPEOF:
                        {
                            alt85 = 3;
                        }
                        break;
                    case LNOT:
                        {
                            alt85 = 4;
                        }
                        break;
                    case BNOT:
                        {
                            alt85 = 5;
                        }
                        break;
                    case LCURLY:
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case DIV:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                        {
                            alt85 = 6;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d85s0 =
                            new NoViableAltException("885:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );", 85, 0, input);

                        throw nvae_d85s0;
                }

                switch (alt85)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:4: DELETE postfixExpression
                        {
                            DELETE361 = (IToken)input.LT(1);
                            Match(input, DELETE, FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3878); if (failed) return retval;
                            if (backtracking == 0) stream_DELETE.Add(DELETE361);

                            PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3880);
                            postfixExpression362 = postfixExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_postfixExpression.Add(postfixExpression362.Tree);

                            // AST REWRITE
                            // elements:          postfixExpression, DELETE
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 886:29: -> ^( DELETE postfixExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:32: ^( DELETE postfixExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_DELETE.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_postfixExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:4: 'void' unaryExpression
                        {
                            string_literal363 = (IToken)input.LT(1);
                            Match(input, 177, FOLLOW_177_in_unaryExpressionNotPlusMinus3893); if (failed) return retval;
                            if (backtracking == 0) stream_177.Add(string_literal363);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3895);
                            unaryExpression364 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression364.Tree);

                            // AST REWRITE
                            // elements:          177, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 887:27: -> ^( 'void' unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:30: ^( 'void' unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_177.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:888:4: TYPEOF unaryExpression
                        {
                            TYPEOF365 = (IToken)input.LT(1);
                            Match(input, TYPEOF, FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3908); if (failed) return retval;
                            if (backtracking == 0) stream_TYPEOF.Add(TYPEOF365);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3910);
                            unaryExpression366 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression366.Tree);

                            // AST REWRITE
                            // elements:          TYPEOF, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 888:27: -> ^( TYPEOF unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:888:30: ^( TYPEOF unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_TYPEOF.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:889:4: LNOT unaryExpression
                        {
                            LNOT367 = (IToken)input.LT(1);
                            Match(input, LNOT, FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3923); if (failed) return retval;
                            if (backtracking == 0) stream_LNOT.Add(LNOT367);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3925);
                            unaryExpression368 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression368.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression, LNOT
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 889:25: -> ^( LNOT unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:889:28: ^( LNOT unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:890:4: BNOT unaryExpression
                        {
                            BNOT369 = (IToken)input.LT(1);
                            Match(input, BNOT, FOLLOW_BNOT_in_unaryExpressionNotPlusMinus3938); if (failed) return retval;
                            if (backtracking == 0) stream_BNOT.Add(BNOT369);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3940);
                            unaryExpression370 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression370.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression, BNOT
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 890:25: -> ^( BNOT unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:890:28: ^( BNOT unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:891:4: postfixExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3953);
                            postfixExpression371 = postfixExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, postfixExpression371.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 116, unaryExpressionNotPlusMinus_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end unaryExpressionNotPlusMinus

        public class postfixExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start postfixExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:1: postfixExpression : ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? ;
        public postfixExpression_return postfixExpression() // throws RecognitionException [1]
        {
            postfixExpression_return retval = new postfixExpression_return();
            retval.start = input.LT(1);
            int postfixExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken iin = null;
            IToken dde = null;
            IToken DOT373 = null;
            IToken LBRACK375 = null;
            IToken RBRACK377 = null;
            IToken E4X_DESC378 = null;
            propOrIdent_return poi = null;

            primaryExpression_return primaryExpression372 = null;

            e4xExpression_return e4xExpression374 = null;

            expression_return expression376 = null;

            e4xExpression_return e4xExpression379 = null;

            arguments_return arguments380 = null;


            CommonTree iin_tree = null;
            CommonTree dde_tree = null;
            CommonTree DOT373_tree = null;
            CommonTree LBRACK375_tree = null;
            CommonTree RBRACK377_tree = null;
            CommonTree E4X_DESC378_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_E4X_DESC = new RewriteRuleTokenStream(adaptor, "token E4X_DESC");
            RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor, "token INC");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor, "token DEC");
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_arguments = new RewriteRuleSubtreeStream(adaptor, "rule arguments");
            RewriteRuleSubtreeStream stream_e4xExpression = new RewriteRuleSubtreeStream(adaptor, "rule e4xExpression");
            RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule primaryExpression");
            RewriteRuleSubtreeStream stream_propOrIdent = new RewriteRuleSubtreeStream(adaptor, "rule propOrIdent");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 117))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:4: ( ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:4: ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:4: ( primaryExpression -> primaryExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:5: primaryExpression
                    {
                        PushFollow(FOLLOW_primaryExpression_in_postfixExpression3966);
                        primaryExpression372 = primaryExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_primaryExpression.Add(primaryExpression372.Tree);

                        // AST REWRITE
                        // elements:          primaryExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 896:23: -> primaryExpression
                            {
                                adaptor.AddChild(root_0, stream_primaryExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:3: (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )*
                    do
                    {
                        int alt86 = 6;
                        switch (input.LA(1))
                        {
                            case DOT:
                                {
                                    int LA86_29 = input.LA(2);

                                    if ((LA86_29 == LPAREN || LA86_29 == STAR || LA86_29 == E4X_ATTRI))
                                    {
                                        alt86 = 2;
                                    }
                                    else if (((LA86_29 >= GET && LA86_29 <= USE) || LA86_29 == XML || (LA86_29 >= IDENT && LA86_29 <= INTERNAL) || LA86_29 == DYNAMIC || (LA86_29 >= IS && LA86_29 <= AS)))
                                    {
                                        alt86 = 1;
                                    }


                                }
                                break;
                            case LBRACK:
                                {
                                    alt86 = 3;
                                }
                                break;
                            case E4X_DESC:
                                {
                                    alt86 = 4;
                                }
                                break;
                            case LPAREN:
                                {
                                    alt86 = 5;
                                }
                                break;

                        }

                        switch (alt86)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:5: poi= propOrIdent[root_0, retval.start]
                                {
                                    PushFollow(FOLLOW_propOrIdent_in_postfixExpression3979);
                                    poi = propOrIdent(root_0, retval.start);
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_propOrIdent.Add(poi.Tree);

                                    // AST REWRITE
                                    // elements:          poi
                                    // token labels:      
                                    // rule labels:       retval, poi
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));
                                        RewriteRuleSubtreeStream stream_poi = new RewriteRuleSubtreeStream(adaptor, "token poi", (poi != null ? poi.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 897:43: -> $poi
                                        {
                                            adaptor.AddChild(root_0, stream_poi.Next());

                                        }

                                    }

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:898:5: DOT e4xExpression
                                {
                                    DOT373 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_postfixExpression3991); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT373);

                                    PushFollow(FOLLOW_e4xExpression_in_postfixExpression3993);
                                    e4xExpression374 = e4xExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_e4xExpression.Add(e4xExpression374.Tree);

                                }
                                break;
                            case 3:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:899:5: LBRACK expression RBRACK
                                {
                                    LBRACK375 = (IToken)input.LT(1);
                                    Match(input, LBRACK, FOLLOW_LBRACK_in_postfixExpression3999); if (failed) return retval;
                                    if (backtracking == 0) stream_LBRACK.Add(LBRACK375);

                                    PushFollow(FOLLOW_expression_in_postfixExpression4001);
                                    expression376 = expression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_expression.Add(expression376.Tree);
                                    RBRACK377 = (IToken)input.LT(1);
                                    Match(input, RBRACK, FOLLOW_RBRACK_in_postfixExpression4003); if (failed) return retval;
                                    if (backtracking == 0) stream_RBRACK.Add(RBRACK377);


                                    // AST REWRITE
                                    // elements:          postfixExpression, expression
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 899:30: -> ^( ARRAY_ACC $postfixExpression expression )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:899:33: ^( ARRAY_ACC $postfixExpression expression )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_expression.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;
                            case 4:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:900:5: E4X_DESC e4xExpression
                                {
                                    E4X_DESC378 = (IToken)input.LT(1);
                                    Match(input, E4X_DESC, FOLLOW_E4X_DESC_in_postfixExpression4020); if (failed) return retval;
                                    if (backtracking == 0) stream_E4X_DESC.Add(E4X_DESC378);

                                    PushFollow(FOLLOW_e4xExpression_in_postfixExpression4022);
                                    e4xExpression379 = e4xExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_e4xExpression.Add(e4xExpression379.Tree);

                                }
                                break;
                            case 5:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:901:5: arguments
                                {
                                    PushFollow(FOLLOW_arguments_in_postfixExpression4028);
                                    arguments380 = arguments();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_arguments.Add(arguments380.Tree);

                                    // AST REWRITE
                                    // elements:          arguments, postfixExpression
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 901:15: -> ^( METHOD_CALL $postfixExpression arguments )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:901:18: ^( METHOD_CALL $postfixExpression arguments )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_CALL, "METHOD_CALL"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_arguments.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;

                            default:
                                goto loop86;
                        }
                    } while (true);

                loop86:
                    ;	// Stops C# compiler whinging that label 'loop86' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:904:3: (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
                    int alt87 = 3;
                    int LA87_0 = input.LA(1);

                    if ((LA87_0 == INC))
                    {
                        alt87 = 1;
                    }
                    else if ((LA87_0 == DEC))
                    {
                        alt87 = 2;
                    }
                    switch (alt87)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:904:6: iin= INC
                            {
                                iin = (IToken)input.LT(1);
                                Match(input, INC, FOLLOW_INC_in_postfixExpression4054); if (failed) return retval;
                                if (backtracking == 0) stream_INC.Add(iin);


                                // AST REWRITE
                                // elements:          postfixExpression
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 904:14: -> ^( POST_INC[$iin] $postfixExpression)
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:904:17: ^( POST_INC[$iin] $postfixExpression)
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_INC, iin), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:6: dde= DEC
                            {
                                dde = (IToken)input.LT(1);
                                Match(input, DEC, FOLLOW_DEC_in_postfixExpression4073); if (failed) return retval;
                                if (backtracking == 0) stream_DEC.Add(dde);


                                // AST REWRITE
                                // elements:          postfixExpression
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 905:14: -> ^( POST_DEC[$dde] $postfixExpression)
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:17: ^( POST_DEC[$dde] $postfixExpression)
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_DEC, dde), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 117, postfixExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end postfixExpression

        public class e4xExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:909:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
        public e4xExpression_return e4xExpression() // throws RecognitionException [1]
        {
            e4xExpression_return retval = new e4xExpression_return();
            retval.start = input.LT(1);
            int e4xExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STAR381 = null;
            e4xAttributeIdentifier_return e4xAttributeIdentifier382 = null;

            e4xFilterPredicate_return e4xFilterPredicate383 = null;


            CommonTree STAR381_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 118))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:4: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
                int alt88 = 3;
                switch (input.LA(1))
                {
                    case STAR:
                        {
                            alt88 = 1;
                        }
                        break;
                    case E4X_ATTRI:
                        {
                            alt88 = 2;
                        }
                        break;
                    case LPAREN:
                        {
                            alt88 = 3;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d88s0 =
                            new NoViableAltException("909:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );", 88, 0, input);

                        throw nvae_d88s0;
                }

                switch (alt88)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:4: STAR
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STAR381 = (IToken)input.LT(1);
                            Match(input, STAR, FOLLOW_STAR_in_e4xExpression4100); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STAR381_tree = (CommonTree)adaptor.Create(STAR381);
                                root_0 = (CommonTree)adaptor.BecomeRoot(STAR381_tree, root_0);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:911:4: e4xAttributeIdentifier
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xAttributeIdentifier_in_e4xExpression4106);
                            e4xAttributeIdentifier382 = e4xAttributeIdentifier();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier382.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:912:4: e4xFilterPredicate
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xFilterPredicate_in_e4xExpression4111);
                            e4xFilterPredicate383 = e4xFilterPredicate();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xFilterPredicate383.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 118, e4xExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xExpression

        public class e4xAttributeIdentifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xAttributeIdentifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:915:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
        public e4xAttributeIdentifier_return e4xAttributeIdentifier() // throws RecognitionException [1]
        {
            e4xAttributeIdentifier_return retval = new e4xAttributeIdentifier_return();
            retval.start = input.LT(1);
            int e4xAttributeIdentifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken E4X_ATTRI384 = null;
            IToken STAR386 = null;
            IToken LBRACK387 = null;
            IToken RBRACK389 = null;
            qualifiedIdent_return qualifiedIdent385 = null;

            expression_return expression388 = null;


            CommonTree E4X_ATTRI384_tree = null;
            CommonTree STAR386_tree = null;
            CommonTree LBRACK387_tree = null;
            CommonTree RBRACK389_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 119))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:916:4: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:916:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    E4X_ATTRI384 = (IToken)input.LT(1);
                    Match(input, E4X_ATTRI, FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4122); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        E4X_ATTRI384_tree = (CommonTree)adaptor.Create(E4X_ATTRI384);
                        adaptor.AddChild(root_0, E4X_ATTRI384_tree);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:917:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
                    int alt89 = 3;
                    switch (input.LA(1))
                    {
                        case GET:
                        case SET:
                        case NAMESPACE:
                        case USE:
                        case XML:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case DYNAMIC:
                        case IS:
                        case AS:
                            {
                                alt89 = 1;
                            }
                            break;
                        case STAR:
                            {
                                alt89 = 2;
                            }
                            break;
                        case LBRACK:
                            {
                                alt89 = 3;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d89s0 =
                                new NoViableAltException("917:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )", 89, 0, input);

                            throw nvae_d89s0;
                    }

                    switch (alt89)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:917:5: qualifiedIdent
                            {
                                PushFollow(FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4128);
                                qualifiedIdent385 = qualifiedIdent();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent385.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:918:5: STAR
                            {
                                STAR386 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_e4xAttributeIdentifier4134); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    STAR386_tree = (CommonTree)adaptor.Create(STAR386);
                                    adaptor.AddChild(root_0, STAR386_tree);
                                }

                            }
                            break;
                        case 3:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:919:5: LBRACK expression RBRACK
                            {
                                LBRACK387 = (IToken)input.LT(1);
                                Match(input, LBRACK, FOLLOW_LBRACK_in_e4xAttributeIdentifier4140); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    LBRACK387_tree = (CommonTree)adaptor.Create(LBRACK387);
                                    adaptor.AddChild(root_0, LBRACK387_tree);
                                }
                                PushFollow(FOLLOW_expression_in_e4xAttributeIdentifier4142);
                                expression388 = expression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, expression388.Tree);
                                RBRACK389 = (IToken)input.LT(1);
                                Match(input, RBRACK, FOLLOW_RBRACK_in_e4xAttributeIdentifier4144); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    RBRACK389_tree = (CommonTree)adaptor.Create(RBRACK389);
                                    adaptor.AddChild(root_0, RBRACK389_tree);
                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 119, e4xAttributeIdentifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xAttributeIdentifier

        public class e4xFilterPredicate_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xFilterPredicate
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:923:1: e4xFilterPredicate : LPAREN expression RPAREN ;
        public e4xFilterPredicate_return e4xFilterPredicate() // throws RecognitionException [1]
        {
            e4xFilterPredicate_return retval = new e4xFilterPredicate_return();
            retval.start = input.LT(1);
            int e4xFilterPredicate_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN390 = null;
            IToken RPAREN392 = null;
            expression_return expression391 = null;


            CommonTree LPAREN390_tree = null;
            CommonTree RPAREN392_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 120))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:4: ( LPAREN expression RPAREN )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:4: LPAREN expression RPAREN
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    LPAREN390 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_e4xFilterPredicate4159); if (failed) return retval;
                    PushFollow(FOLLOW_expression_in_e4xFilterPredicate4164);
                    expression391 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression391.Tree);
                    RPAREN392 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_e4xFilterPredicate4168); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 120, e4xFilterPredicate_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xFilterPredicate

        public class primaryExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start primaryExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
        public primaryExpression_return primaryExpression() // throws RecognitionException [1]
        {
            primaryExpression_return retval = new primaryExpression_return();
            retval.start = input.LT(1);
            int primaryExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken UNDEFINED393 = null;
            constant_return constant394 = null;

            arrayLiteral_return arrayLiteral395 = null;

            objectLiteral_return objectLiteral396 = null;

            functionDefinition_return functionDefinition397 = null;

            newFullExpression_return newFullExpression398 = null;

            newShortExpression_return newShortExpression399 = null;

            encapsulatedExpression_return encapsulatedExpression400 = null;

            e4xAttributeIdentifier_return e4xAttributeIdentifier401 = null;

            qualifiedIdent_return qualifiedIdent402 = null;


            CommonTree UNDEFINED393_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 121))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:930:4: ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
                int alt90 = 10;
                switch (input.LA(1))
                {
                    case UNDEFINED:
                        {
                            alt90 = 1;
                        }
                        break;
                    case STRING_LITERAL:
                    case LT:
                    case DIV:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt90 = 2;
                        }
                        break;
                    case LBRACK:
                        {
                            alt90 = 3;
                        }
                        break;
                    case LCURLY:
                        {
                            alt90 = 4;
                        }
                        break;
                    case FUNCTION:
                        {
                            alt90 = 5;
                        }
                        break;
                    case NEW:
                        {
                            switch (input.LA(2))
                            {
                                case UNDEFINED:
                                    {
                                        int LA90_25 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s25 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 25, input);

                                            throw nvae_d90s25;
                                        }
                                    }
                                    break;
                                case LT:
                                    {
                                        int LA90_26 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s26 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 26, input);

                                            throw nvae_d90s26;
                                        }
                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA90_27 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s27 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 27, input);

                                            throw nvae_d90s27;
                                        }
                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA90_28 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s28 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 28, input);

                                            throw nvae_d90s28;
                                        }
                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA90_29 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s29 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 29, input);

                                            throw nvae_d90s29;
                                        }
                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA90_30 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s30 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 30, input);

                                            throw nvae_d90s30;
                                        }
                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA90_31 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s31 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 31, input);

                                            throw nvae_d90s31;
                                        }
                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA90_32 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s32 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 32, input);

                                            throw nvae_d90s32;
                                        }
                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA90_33 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s33 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 33, input);

                                            throw nvae_d90s33;
                                        }
                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA90_34 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s34 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 34, input);

                                            throw nvae_d90s34;
                                        }
                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA90_35 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s35 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 35, input);

                                            throw nvae_d90s35;
                                        }
                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA90_36 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s36 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 36, input);

                                            throw nvae_d90s36;
                                        }
                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA90_37 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s37 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 37, input);

                                            throw nvae_d90s37;
                                        }
                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA90_38 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s38 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 38, input);

                                            throw nvae_d90s38;
                                        }
                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA90_39 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s39 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 39, input);

                                            throw nvae_d90s39;
                                        }
                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA90_40 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s40 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 40, input);

                                            throw nvae_d90s40;
                                        }
                                    }
                                    break;
                                case USE:
                                    {
                                        int LA90_41 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s41 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 41, input);

                                            throw nvae_d90s41;
                                        }
                                    }
                                    break;
                                case XML:
                                    {
                                        int LA90_42 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s42 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 42, input);

                                            throw nvae_d90s42;
                                        }
                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA90_43 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s43 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 43, input);

                                            throw nvae_d90s43;
                                        }
                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA90_44 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s44 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 44, input);

                                            throw nvae_d90s44;
                                        }
                                    }
                                    break;
                                case IS:
                                    {
                                        int LA90_45 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s45 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 45, input);

                                            throw nvae_d90s45;
                                        }
                                    }
                                    break;
                                case AS:
                                    {
                                        int LA90_46 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s46 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 46, input);

                                            throw nvae_d90s46;
                                        }
                                    }
                                    break;
                                case GET:
                                    {
                                        int LA90_47 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s47 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 47, input);

                                            throw nvae_d90s47;
                                        }
                                    }
                                    break;
                                case SET:
                                    {
                                        int LA90_48 = input.LA(3);

                                        if ((synpred177()))
                                        {
                                            alt90 = 6;
                                        }
                                        else if ((synpred178()))
                                        {
                                            alt90 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d90s48 =
                                                new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 48, input);

                                            throw nvae_d90s48;
                                        }
                                    }
                                    break;
                                default:
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d90s12 =
                                        new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 12, input);

                                    throw nvae_d90s12;
                            }

                        }
                        break;
                    case LPAREN:
                        {
                            alt90 = 8;
                        }
                        break;
                    case E4X_ATTRI:
                        {
                            alt90 = 9;
                        }
                        break;
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case DYNAMIC:
                    case IS:
                    case AS:
                        {
                            alt90 = 10;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d90s0 =
                            new NoViableAltException("929:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 90, 0, input);

                        throw nvae_d90s0;
                }

                switch (alt90)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:930:4: UNDEFINED
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            UNDEFINED393 = (IToken)input.LT(1);
                            Match(input, UNDEFINED, FOLLOW_UNDEFINED_in_primaryExpression4180); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                UNDEFINED393_tree = (CommonTree)adaptor.Create(UNDEFINED393);
                                adaptor.AddChild(root_0, UNDEFINED393_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:931:4: constant
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_constant_in_primaryExpression4185);
                            constant394 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, constant394.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:932:4: arrayLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_arrayLiteral_in_primaryExpression4190);
                            arrayLiteral395 = arrayLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, arrayLiteral395.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:933:4: objectLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_objectLiteral_in_primaryExpression4195);
                            objectLiteral396 = objectLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, objectLiteral396.Tree);

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:934:4: functionDefinition
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_functionDefinition_in_primaryExpression4200);
                            functionDefinition397 = functionDefinition();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, functionDefinition397.Tree);

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:4: newFullExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newFullExpression_in_primaryExpression4205);
                            newFullExpression398 = newFullExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newFullExpression398.Tree);

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: newShortExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newShortExpression_in_primaryExpression4210);
                            newShortExpression399 = newShortExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newShortExpression399.Tree);

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:937:4: encapsulatedExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_encapsulatedExpression_in_primaryExpression4215);
                            encapsulatedExpression400 = encapsulatedExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, encapsulatedExpression400.Tree);

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:938:4: e4xAttributeIdentifier
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xAttributeIdentifier_in_primaryExpression4220);
                            e4xAttributeIdentifier401 = e4xAttributeIdentifier();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier401.Tree);

                        }
                        break;
                    case 10:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:939:4: qualifiedIdent
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_qualifiedIdent_in_primaryExpression4225);
                            qualifiedIdent402 = qualifiedIdent();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent402.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 121, primaryExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end primaryExpression

        public class propOrIdent_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start propOrIdent
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:943:1: propOrIdent[CommonTree identPrimary, IToken startToken] : DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) ;
        public propOrIdent_return propOrIdent(CommonTree identPrimary, IToken startToken) // throws RecognitionException [1]
        {
            propOrIdent_return retval = new propOrIdent_return();
            retval.start = input.LT(1);
            int propOrIdent_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT403 = null;
            qualifiedIdent_return propId = null;


            CommonTree DOT403_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 122))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:3: ( DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:3: DOT propId= qualifiedIdent
                {
                    if (backtracking == 0)
                    {
                        retval.start = startToken;
                    }
                    DOT403 = (IToken)input.LT(1);
                    Match(input, DOT, FOLLOW_DOT_in_propOrIdent4245); if (failed) return retval;
                    if (backtracking == 0) stream_DOT.Add(DOT403);

                    PushFollow(FOLLOW_qualifiedIdent_in_propOrIdent4249);
                    propId = qualifiedIdent();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_qualifiedIdent.Add(propId.Tree);

                    // AST REWRITE
                    // elements:          propId
                    // token labels:      
                    // rule labels:       propId, retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_propId = new RewriteRuleSubtreeStream(adaptor, "token propId", (propId != null ? propId.Tree : null));
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 952:3: -> ^( PROPERTY_OR_IDENTIFIER $propId)
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:952:6: ^( PROPERTY_OR_IDENTIFIER $propId)
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PROPERTY_OR_IDENTIFIER, "PROPERTY_OR_IDENTIFIER"), root_1);

                                adaptor.AddChild(root_1, identPrimary);
                                adaptor.AddChild(root_1, stream_propId.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 122, propOrIdent_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end propOrIdent

        public class constant_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start constant
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:955:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );
        public constant_return constant() // throws RecognitionException [1]
        {
            constant_return retval = new constant_return();
            retval.start = input.LT(1);
            int constant_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STRING_LITERAL407 = null;
            IToken TRUE408 = null;
            IToken FALSE409 = null;
            IToken NULL410 = null;
            xmlLiteral_return xmlLiteral404 = null;

            regexpLiteral_return regexpLiteral405 = null;

            number_return number406 = null;


            CommonTree STRING_LITERAL407_tree = null;
            CommonTree TRUE408_tree = null;
            CommonTree FALSE409_tree = null;
            CommonTree NULL410_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 123))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:956:4: ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL )
                int alt91 = 7;
                switch (input.LA(1))
                {
                    case LT:
                        {
                            alt91 = 1;
                        }
                        break;
                    case DIV:
                        {
                            alt91 = 2;
                        }
                        break;
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt91 = 3;
                        }
                        break;
                    case STRING_LITERAL:
                        {
                            alt91 = 4;
                        }
                        break;
                    case TRUE:
                        {
                            alt91 = 5;
                        }
                        break;
                    case FALSE:
                        {
                            alt91 = 6;
                        }
                        break;
                    case NULL:
                        {
                            alt91 = 7;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d91s0 =
                            new NoViableAltException("955:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );", 91, 0, input);

                        throw nvae_d91s0;
                }

                switch (alt91)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:956:4: xmlLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_xmlLiteral_in_constant4277);
                            xmlLiteral404 = xmlLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, xmlLiteral404.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:957:4: regexpLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_regexpLiteral_in_constant4282);
                            regexpLiteral405 = regexpLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, regexpLiteral405.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:958:4: number
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_number_in_constant4287);
                            number406 = number();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, number406.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:959:4: STRING_LITERAL
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STRING_LITERAL407 = (IToken)input.LT(1);
                            Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_constant4292); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STRING_LITERAL407_tree = (CommonTree)adaptor.Create(STRING_LITERAL407);
                                adaptor.AddChild(root_0, STRING_LITERAL407_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:960:4: TRUE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            TRUE408 = (IToken)input.LT(1);
                            Match(input, TRUE, FOLLOW_TRUE_in_constant4297); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                TRUE408_tree = (CommonTree)adaptor.Create(TRUE408);
                                adaptor.AddChild(root_0, TRUE408_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:961:4: FALSE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            FALSE409 = (IToken)input.LT(1);
                            Match(input, FALSE, FOLLOW_FALSE_in_constant4302); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                FALSE409_tree = (CommonTree)adaptor.Create(FALSE409);
                                adaptor.AddChild(root_0, FALSE409_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:962:4: NULL
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            NULL410 = (IToken)input.LT(1);
                            Match(input, NULL, FOLLOW_NULL_in_constant4307); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                NULL410_tree = (CommonTree)adaptor.Create(NULL410);
                                adaptor.AddChild(root_0, NULL410_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 123, constant_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end constant

        public class number_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start number
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
        public number_return number() // throws RecognitionException [1]
        {
            number_return retval = new number_return();
            retval.start = input.LT(1);
            int number_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set411 = null;

            CommonTree set411_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 124))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:10: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set411 = (IToken)input.LT(1);
                    if ((input.LA(1) >= HEX_LITERAL && input.LA(1) <= FLOAT_LITERAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set411));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_number0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 124, number_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end number

        public class xmlLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start xmlLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:972:1: xmlLiteral : LT ->;
        public xmlLiteral_return xmlLiteral() // throws RecognitionException [1]
        {
            xmlLiteral_return retval = new xmlLiteral_return();
            retval.start = input.LT(1);
            int xmlLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LT412 = null;

            CommonTree LT412_tree = null;
            RewriteRuleTokenStream stream_LT = new RewriteRuleTokenStream(adaptor, "token LT");


            CommonTree xml = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 125))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:979:3: ( LT ->)
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:979:3: LT
                {
                    LT412 = (IToken)input.LT(1);
                    Match(input, LT, FOLLOW_LT_in_xmlLiteral4360); if (failed) return retval;
                    if (backtracking == 0) stream_LT.Add(LT412);

                    if (backtracking == 0)
                    {
                        /*xml=parseXMLLiteral();*/
                    }

                    // AST REWRITE
                    // elements:          
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 981:3: ->
                        {
                            adaptor.AddChild(root_0, xml);

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 125, xmlLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end xmlLiteral

        public class regexpLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start regexpLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:985:1: regexpLiteral : s= DIV -> ^() ;
        public regexpLiteral_return regexpLiteral() // throws RecognitionException [1]
        {
            regexpLiteral_return retval = new regexpLiteral_return();
            retval.start = input.LT(1);
            int regexpLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken s = null;

            CommonTree s_tree = null;
            RewriteRuleTokenStream stream_DIV = new RewriteRuleTokenStream(adaptor, "token DIV");


            CommonTree regexp = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 126))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:989:4: (s= DIV -> ^() )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:989:4: s= DIV
                {
                    s = (IToken)input.LT(1);
                    Match(input, DIV, FOLLOW_DIV_in_regexpLiteral4390); if (failed) return retval;
                    if (backtracking == 0) stream_DIV.Add(s);

                    if (backtracking == 0)
                    {
                        /*regexp=parseRegexpLiteral((LinkedListToken)s);*/
                    }

                    // AST REWRITE
                    // elements:          
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 990:3: -> ^()
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:990:6: ^()
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(regexp, root_1);

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 126, regexpLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end regexpLiteral

        public class newFullExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start newFullExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:993:1: newFullExpression : NEW fullNewSubexpression arguments ;
        public newFullExpression_return newFullExpression() // throws RecognitionException [1]
        {
            newFullExpression_return retval = new newFullExpression_return();
            retval.start = input.LT(1);
            int newFullExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NEW413 = null;
            fullNewSubexpression_return fullNewSubexpression414 = null;

            arguments_return arguments415 = null;


            CommonTree NEW413_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 127))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:994:4: ( NEW fullNewSubexpression arguments )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:994:4: NEW fullNewSubexpression arguments
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    NEW413 = (IToken)input.LT(1);
                    Match(input, NEW, FOLLOW_NEW_in_newFullExpression4411); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NEW413_tree = (CommonTree)adaptor.Create(NEW413);
                        root_0 = (CommonTree)adaptor.BecomeRoot(NEW413_tree, root_0);
                    }
                    PushFollow(FOLLOW_fullNewSubexpression_in_newFullExpression4414);
                    fullNewSubexpression414 = fullNewSubexpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, fullNewSubexpression414.Tree);
                    PushFollow(FOLLOW_arguments_in_newFullExpression4416);
                    arguments415 = arguments();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, arguments415.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 127, newFullExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end newFullExpression

        public class fullNewSubexpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fullNewSubexpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:997:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
        public fullNewSubexpression_return fullNewSubexpression() // throws RecognitionException [1]
        {
            fullNewSubexpression_return retval = new fullNewSubexpression_return();
            retval.start = input.LT(1);
            int fullNewSubexpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT417 = null;
            primaryExpression_return primaryExpression416 = null;

            qualifiedIdent_return qualifiedIdent418 = null;

            brackets_return brackets419 = null;


            CommonTree DOT417_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule primaryExpression");
            RewriteRuleSubtreeStream stream_brackets = new RewriteRuleSubtreeStream(adaptor, "rule brackets");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 128))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:4: ( ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:4: ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:4: ( primaryExpression -> primaryExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:6: primaryExpression
                    {
                        PushFollow(FOLLOW_primaryExpression_in_fullNewSubexpression4429);
                        primaryExpression416 = primaryExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_primaryExpression.Add(primaryExpression416.Tree);

                        // AST REWRITE
                        // elements:          primaryExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 998:24: -> primaryExpression
                            {
                                adaptor.AddChild(root_0, stream_primaryExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:3: ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
                    do
                    {
                        int alt92 = 3;
                        int LA92_0 = input.LA(1);

                        if ((LA92_0 == DOT))
                        {
                            int LA92_2 = input.LA(2);

                            if ((synpred190()))
                            {
                                alt92 = 1;
                            }


                        }
                        else if ((LA92_0 == LBRACK))
                        {
                            int LA92_3 = input.LA(2);

                            if ((synpred191()))
                            {
                                alt92 = 2;
                            }


                        }


                        switch (alt92)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:5: DOT qualifiedIdent
                                {
                                    DOT417 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_fullNewSubexpression4443); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT417);

                                    PushFollow(FOLLOW_qualifiedIdent_in_fullNewSubexpression4445);
                                    qualifiedIdent418 = qualifiedIdent();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent418.Tree);

                                    // AST REWRITE
                                    // elements:          qualifiedIdent, DOT, fullNewSubexpression
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 1000:24: -> ^( DOT $fullNewSubexpression qualifiedIdent )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:27: ^( DOT $fullNewSubexpression qualifiedIdent )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(stream_DOT.Next(), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_qualifiedIdent.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1001:5: brackets
                                {
                                    PushFollow(FOLLOW_brackets_in_fullNewSubexpression4462);
                                    brackets419 = brackets();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_brackets.Add(brackets419.Tree);

                                    // AST REWRITE
                                    // elements:          fullNewSubexpression, brackets
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 1001:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1001:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_brackets.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;

                            default:
                                goto loop92;
                        }
                    } while (true);

                loop92:
                    ;	// Stops C# compiler whinging that label 'loop92' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 128, fullNewSubexpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fullNewSubexpression

        public class newShortExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start newShortExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1005:1: newShortExpression : NEW shortNewSubexpression ;
        public newShortExpression_return newShortExpression() // throws RecognitionException [1]
        {
            newShortExpression_return retval = new newShortExpression_return();
            retval.start = input.LT(1);
            int newShortExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NEW420 = null;
            shortNewSubexpression_return shortNewSubexpression421 = null;


            CommonTree NEW420_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 129))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:4: ( NEW shortNewSubexpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:4: NEW shortNewSubexpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    NEW420 = (IToken)input.LT(1);
                    Match(input, NEW, FOLLOW_NEW_in_newShortExpression4490); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NEW420_tree = (CommonTree)adaptor.Create(NEW420);
                        root_0 = (CommonTree)adaptor.BecomeRoot(NEW420_tree, root_0);
                    }
                    PushFollow(FOLLOW_shortNewSubexpression_in_newShortExpression4493);
                    shortNewSubexpression421 = shortNewSubexpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, shortNewSubexpression421.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 129, newShortExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end newShortExpression

        public class shortNewSubexpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shortNewSubexpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );
        public shortNewSubexpression_return shortNewSubexpression() // throws RecognitionException [1]
        {
            shortNewSubexpression_return retval = new shortNewSubexpression_return();
            retval.start = input.LT(1);
            int shortNewSubexpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            fullNewSubexpression_return fullNewSubexpression422 = null;

            newShortExpression_return newShortExpression423 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 130))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:4: ( fullNewSubexpression | newShortExpression )
                int alt93 = 2;
                int LA93_0 = input.LA(1);

                if ((LA93_0 == LCURLY || (LA93_0 >= STRING_LITERAL && LA93_0 <= USE) || LA93_0 == LPAREN || LA93_0 == XML || (LA93_0 >= IDENT && LA93_0 <= LBRACK) || LA93_0 == DYNAMIC || LA93_0 == LT || (LA93_0 >= IS && LA93_0 <= AS) || LA93_0 == DIV || (LA93_0 >= E4X_ATTRI && LA93_0 <= FLOAT_LITERAL)))
                {
                    alt93 = 1;
                }
                else if ((LA93_0 == NEW))
                {
                    switch (input.LA(2))
                    {
                        case UNDEFINED:
                            {
                                int LA93_25 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s25 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 25, input);

                                    throw nvae_d93s25;
                                }
                            }
                            break;
                        case LT:
                            {
                                int LA93_26 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s26 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 26, input);

                                    throw nvae_d93s26;
                                }
                            }
                            break;
                        case DIV:
                            {
                                int LA93_27 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s27 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 27, input);

                                    throw nvae_d93s27;
                                }
                            }
                            break;
                        case HEX_LITERAL:
                        case DECIMAL_LITERAL:
                        case OCTAL_LITERAL:
                        case FLOAT_LITERAL:
                            {
                                int LA93_28 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s28 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 28, input);

                                    throw nvae_d93s28;
                                }
                            }
                            break;
                        case STRING_LITERAL:
                            {
                                int LA93_29 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s29 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 29, input);

                                    throw nvae_d93s29;
                                }
                            }
                            break;
                        case TRUE:
                            {
                                int LA93_30 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s30 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 30, input);

                                    throw nvae_d93s30;
                                }
                            }
                            break;
                        case FALSE:
                            {
                                int LA93_31 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s31 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 31, input);

                                    throw nvae_d93s31;
                                }
                            }
                            break;
                        case NULL:
                            {
                                int LA93_32 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s32 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 32, input);

                                    throw nvae_d93s32;
                                }
                            }
                            break;
                        case LBRACK:
                            {
                                int LA93_33 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s33 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 33, input);

                                    throw nvae_d93s33;
                                }
                            }
                            break;
                        case LCURLY:
                            {
                                int LA93_34 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s34 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 34, input);

                                    throw nvae_d93s34;
                                }
                            }
                            break;
                        case FUNCTION:
                            {
                                int LA93_35 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s35 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 35, input);

                                    throw nvae_d93s35;
                                }
                            }
                            break;
                        case NEW:
                            {
                                int LA93_36 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s36 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 36, input);

                                    throw nvae_d93s36;
                                }
                            }
                            break;
                        case LPAREN:
                            {
                                int LA93_37 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s37 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 37, input);

                                    throw nvae_d93s37;
                                }
                            }
                            break;
                        case E4X_ATTRI:
                            {
                                int LA93_38 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s38 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 38, input);

                                    throw nvae_d93s38;
                                }
                            }
                            break;
                        case IDENT:
                            {
                                int LA93_39 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s39 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 39, input);

                                    throw nvae_d93s39;
                                }
                            }
                            break;
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                            {
                                int LA93_40 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s40 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 40, input);

                                    throw nvae_d93s40;
                                }
                            }
                            break;
                        case USE:
                            {
                                int LA93_41 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s41 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 41, input);

                                    throw nvae_d93s41;
                                }
                            }
                            break;
                        case XML:
                            {
                                int LA93_42 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s42 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 42, input);

                                    throw nvae_d93s42;
                                }
                            }
                            break;
                        case DYNAMIC:
                            {
                                int LA93_43 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s43 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 43, input);

                                    throw nvae_d93s43;
                                }
                            }
                            break;
                        case NAMESPACE:
                            {
                                int LA93_44 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s44 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 44, input);

                                    throw nvae_d93s44;
                                }
                            }
                            break;
                        case IS:
                            {
                                int LA93_45 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s45 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 45, input);

                                    throw nvae_d93s45;
                                }
                            }
                            break;
                        case AS:
                            {
                                int LA93_46 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s46 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 46, input);

                                    throw nvae_d93s46;
                                }
                            }
                            break;
                        case GET:
                            {
                                int LA93_47 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s47 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 47, input);

                                    throw nvae_d93s47;
                                }
                            }
                            break;
                        case SET:
                            {
                                int LA93_48 = input.LA(3);

                                if ((synpred192()))
                                {
                                    alt93 = 1;
                                }
                                else if ((true))
                                {
                                    alt93 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d93s48 =
                                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 48, input);

                                    throw nvae_d93s48;
                                }
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d93s12 =
                                new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 12, input);

                            throw nvae_d93s12;
                    }

                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d93s0 =
                        new NoViableAltException("1009:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 93, 0, input);

                    throw nvae_d93s0;
                }
                switch (alt93)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:4: fullNewSubexpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_fullNewSubexpression_in_shortNewSubexpression4506);
                            fullNewSubexpression422 = fullNewSubexpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, fullNewSubexpression422.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1011:4: newShortExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newShortExpression_in_shortNewSubexpression4511);
                            newShortExpression423 = newShortExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newShortExpression423.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 130, shortNewSubexpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shortNewSubexpression

        public class propertyOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start propertyOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1014:1: propertyOperator : ( DOT qualifiedIdent | brackets );
        public propertyOperator_return propertyOperator() // throws RecognitionException [1]
        {
            propertyOperator_return retval = new propertyOperator_return();
            retval.start = input.LT(1);
            int propertyOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT424 = null;
            qualifiedIdent_return qualifiedIdent425 = null;

            brackets_return brackets426 = null;


            CommonTree DOT424_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 131))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1015:4: ( DOT qualifiedIdent | brackets )
                int alt94 = 2;
                int LA94_0 = input.LA(1);

                if ((LA94_0 == DOT))
                {
                    alt94 = 1;
                }
                else if ((LA94_0 == LBRACK))
                {
                    alt94 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d94s0 =
                        new NoViableAltException("1014:1: propertyOperator : ( DOT qualifiedIdent | brackets );", 94, 0, input);

                    throw nvae_d94s0;
                }
                switch (alt94)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1015:4: DOT qualifiedIdent
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            DOT424 = (IToken)input.LT(1);
                            Match(input, DOT, FOLLOW_DOT_in_propertyOperator4523); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                DOT424_tree = (CommonTree)adaptor.Create(DOT424);
                                root_0 = (CommonTree)adaptor.BecomeRoot(DOT424_tree, root_0);
                            }
                            PushFollow(FOLLOW_qualifiedIdent_in_propertyOperator4526);
                            qualifiedIdent425 = qualifiedIdent();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent425.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1016:4: brackets
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_brackets_in_propertyOperator4531);
                            brackets426 = brackets();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, brackets426.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 131, propertyOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end propertyOperator

        public class comment_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start comment
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1019:1: comment : ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) | ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) );
        public comment_return comment() // throws RecognitionException [1]
        {
            comment_return retval = new comment_return();
            retval.start = input.LT(1);
            int comment_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SL_COMMENT427 = null;
            IToken ML_COMMENT428 = null;

            CommonTree SL_COMMENT427_tree = null;
            CommonTree ML_COMMENT428_tree = null;
            RewriteRuleTokenStream stream_ML_COMMENT = new RewriteRuleTokenStream(adaptor, "token ML_COMMENT");
            RewriteRuleTokenStream stream_SL_COMMENT = new RewriteRuleTokenStream(adaptor, "token SL_COMMENT");

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 132))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1020:4: ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) | ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) )
                int alt95 = 2;
                int LA95_0 = input.LA(1);

                if ((LA95_0 == SL_COMMENT))
                {
                    alt95 = 1;
                }
                else if ((LA95_0 == ML_COMMENT))
                {
                    alt95 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d95s0 =
                        new NoViableAltException("1019:1: comment : ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) | ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) );", 95, 0, input);

                    throw nvae_d95s0;
                }
                switch (alt95)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1020:4: SL_COMMENT
                        {
                            SL_COMMENT427 = (IToken)input.LT(1);
                            Match(input, SL_COMMENT, FOLLOW_SL_COMMENT_in_comment4542); if (failed) return retval;
                            if (backtracking == 0) stream_SL_COMMENT.Add(SL_COMMENT427);


                            // AST REWRITE
                            // elements:          SL_COMMENT
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1020:15: -> ^( SINGLELINE_COMMENT SL_COMMENT )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1020:18: ^( SINGLELINE_COMMENT SL_COMMENT )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SINGLELINE_COMMENT, "SINGLELINE_COMMENT"), root_1);

                                        adaptor.AddChild(root_1, stream_SL_COMMENT.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1021:4: ML_COMMENT
                        {
                            ML_COMMENT428 = (IToken)input.LT(1);
                            Match(input, ML_COMMENT, FOLLOW_ML_COMMENT_in_comment4555); if (failed) return retval;
                            if (backtracking == 0) stream_ML_COMMENT.Add(ML_COMMENT428);


                            // AST REWRITE
                            // elements:          ML_COMMENT
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1021:15: -> ^( MULTILINE_COMMENT ML_COMMENT )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1021:18: ^( MULTILINE_COMMENT ML_COMMENT )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MULTILINE_COMMENT, "MULTILINE_COMMENT"), root_1);

                                        adaptor.AddChild(root_1, stream_ML_COMMENT.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 132, comment_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end comment

        public class brackets_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start brackets
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1025:1: brackets : LBRACK expressionList RBRACK ;
        public brackets_return brackets() // throws RecognitionException [1]
        {
            brackets_return retval = new brackets_return();
            retval.start = input.LT(1);
            int brackets_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK429 = null;
            IToken RBRACK431 = null;
            expressionList_return expressionList430 = null;


            CommonTree LBRACK429_tree = null;
            CommonTree RBRACK431_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 133))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1029:4: ( LBRACK expressionList RBRACK )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1029:4: LBRACK expressionList RBRACK
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    LBRACK429 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_brackets4580); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        LBRACK429_tree = (CommonTree)adaptor.Create(LBRACK429);
                        adaptor.AddChild(root_0, LBRACK429_tree);
                    }
                    PushFollow(FOLLOW_expressionList_in_brackets4582);
                    expressionList430 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expressionList430.Tree);
                    RBRACK431 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_brackets4584); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        RBRACK431_tree = (CommonTree)adaptor.Create(RBRACK431);
                        adaptor.AddChild(root_0, RBRACK431_tree);
                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 133, brackets_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end brackets

        public class encapsulatedExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start encapsulatedExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1032:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
        public encapsulatedExpression_return encapsulatedExpression() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            encapsulatedExpression_return retval = new encapsulatedExpression_return();
            retval.start = input.LT(1);
            int encapsulatedExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN432 = null;
            IToken RPAREN434 = null;
            assignmentExpression_return assignmentExpression433 = null;


            CommonTree LPAREN432_tree = null;
            CommonTree RPAREN434_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 134))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1037:4: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1037:4: LPAREN assignmentExpression RPAREN
                {
                    LPAREN432 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_encapsulatedExpression4605); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN432);

                    PushFollow(FOLLOW_assignmentExpression_in_encapsulatedExpression4607);
                    assignmentExpression433 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression433.Tree);
                    RPAREN434 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_encapsulatedExpression4609); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN434);


                    // AST REWRITE
                    // elements:          assignmentExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 1038:3: -> ^( ENCPS_EXPR assignmentExpression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1038:6: ^( ENCPS_EXPR assignmentExpression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 134, encapsulatedExpression_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end encapsulatedExpression

        public class functionDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start functionDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:1: functionDefinition : FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
        public functionDefinition_return functionDefinition() // throws RecognitionException [1]
        {
            functionDefinition_return retval = new functionDefinition_return();
            retval.start = input.LT(1);
            int functionDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken FUNCTION435 = null;
            parameterDeclarationList_return parameterDeclarationList436 = null;

            typeExpression_return typeExpression437 = null;

            block_return block438 = null;


            CommonTree FUNCTION435_tree = null;
            RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor, "token FUNCTION");
            RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclarationList");
            RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor, "rule block");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 135))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:4: ( FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:4: FUNCTION parameterDeclarationList ( typeExpression )? block
                {
                    FUNCTION435 = (IToken)input.LT(1);
                    Match(input, FUNCTION, FOLLOW_FUNCTION_in_functionDefinition4633); if (failed) return retval;
                    if (backtracking == 0) stream_FUNCTION.Add(FUNCTION435);

                    PushFollow(FOLLOW_parameterDeclarationList_in_functionDefinition4635);
                    parameterDeclarationList436 = parameterDeclarationList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList436.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:38: ( typeExpression )?
                    int alt96 = 2;
                    int LA96_0 = input.LA(1);

                    if ((LA96_0 == COLON))
                    {
                        alt96 = 1;
                    }
                    switch (alt96)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_functionDefinition4637);
                                typeExpression437 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression437.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_block_in_functionDefinition4640);
                    block438 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_block.Add(block438.Tree);

                    // AST REWRITE
                    // elements:          block, parameterDeclarationList, typeExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 1046:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

                                adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:42: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                adaptor.AddChild(root_1, stream_block.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 135, functionDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end functionDefinition

        public class ident_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start ident
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1050:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );
        public ident_return ident() // throws RecognitionException [1]
        {
            ident_return retval = new ident_return();
            retval.start = input.LT(1);
            int ident_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken i = null;
            IToken IDENT439 = null;

            CommonTree i_tree = null;
            CommonTree IDENT439_tree = null;
            RewriteRuleTokenStream stream_GET = new RewriteRuleTokenStream(adaptor, "token GET");
            RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor, "token XML");
            RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, "token AS");
            RewriteRuleTokenStream stream_DYNAMIC = new RewriteRuleTokenStream(adaptor, "token DYNAMIC");
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor, "token SET");
            RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor, "token IS");
            RewriteRuleTokenStream stream_USE = new RewriteRuleTokenStream(adaptor, "token USE");

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 136))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] )
                int alt97 = 9;
                switch (input.LA(1))
                {
                    case IDENT:
                        {
                            alt97 = 1;
                        }
                        break;
                    case USE:
                        {
                            alt97 = 2;
                        }
                        break;
                    case XML:
                        {
                            alt97 = 3;
                        }
                        break;
                    case DYNAMIC:
                        {
                            alt97 = 4;
                        }
                        break;
                    case NAMESPACE:
                        {
                            alt97 = 5;
                        }
                        break;
                    case IS:
                        {
                            alt97 = 6;
                        }
                        break;
                    case AS:
                        {
                            alt97 = 7;
                        }
                        break;
                    case GET:
                        {
                            alt97 = 8;
                        }
                        break;
                    case SET:
                        {
                            alt97 = 9;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d97s0 =
                            new NoViableAltException("1050:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );", 97, 0, input);

                        throw nvae_d97s0;
                }

                switch (alt97)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: IDENT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IDENT439 = (IToken)input.LT(1);
                            Match(input, IDENT, FOLLOW_IDENT_in_ident4667); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IDENT439_tree = (CommonTree)adaptor.Create(IDENT439);
                                adaptor.AddChild(root_0, IDENT439_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1052:4: i= USE
                        {
                            i = (IToken)input.LT(1);
                            Match(input, USE, FOLLOW_USE_in_ident4674); if (failed) return retval;
                            if (backtracking == 0) stream_USE.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1052:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1053:4: i= XML
                        {
                            i = (IToken)input.LT(1);
                            Match(input, XML, FOLLOW_XML_in_ident4686); if (failed) return retval;
                            if (backtracking == 0) stream_XML.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1053:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1054:4: i= DYNAMIC
                        {
                            i = (IToken)input.LT(1);
                            Match(input, DYNAMIC, FOLLOW_DYNAMIC_in_ident4698); if (failed) return retval;
                            if (backtracking == 0) stream_DYNAMIC.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1054:14: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1055:4: i= NAMESPACE
                        {
                            i = (IToken)input.LT(1);
                            Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_ident4710); if (failed) return retval;
                            if (backtracking == 0) stream_NAMESPACE.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1055:16: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: i= IS
                        {
                            i = (IToken)input.LT(1);
                            Match(input, IS, FOLLOW_IS_in_ident4722); if (failed) return retval;
                            if (backtracking == 0) stream_IS.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1056:9: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1057:4: i= AS
                        {
                            i = (IToken)input.LT(1);
                            Match(input, AS, FOLLOW_AS_in_ident4734); if (failed) return retval;
                            if (backtracking == 0) stream_AS.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1057:9: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1058:4: i= GET
                        {
                            i = (IToken)input.LT(1);
                            Match(input, GET, FOLLOW_GET_in_ident4746); if (failed) return retval;
                            if (backtracking == 0) stream_GET.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1058:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1059:4: i= SET
                        {
                            i = (IToken)input.LT(1);
                            Match(input, SET, FOLLOW_SET_in_ident4758); if (failed) return retval;
                            if (backtracking == 0) stream_SET.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1059:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 136, ident_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end ident

        // $ANTLR start synpred1
        public void synpred1_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:6: ( as2CompilationUnit )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:97:6: as2CompilationUnit
            {
                PushFollow(FOLLOW_as2CompilationUnit_in_synpred1337);
                as2CompilationUnit();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred1

        // $ANTLR start synpred44
        public void synpred44_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: ( LCURLY )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:5: LCURLY
            {
                Match(input, LCURLY, FOLLOW_LCURLY_in_synpred441554); if (failed) return;

            }
        }
        // $ANTLR end synpred44

        // $ANTLR start synpred46
        public void synpred46_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:349:4: ( expressionStatement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:349:4: expressionStatement
            {
                PushFollow(FOLLOW_expressionStatement_in_synpred461568);
                expressionStatement();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred46

        // $ANTLR start synpred61
        public void synpred61_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:4: ( ELSE )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:5: ELSE
            {
                Match(input, ELSE, FOLLOW_ELSE_in_synpred611767); if (failed) return;

            }
        }
        // $ANTLR end synpred61

        // $ANTLR start synpred69
        public void synpred69_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:491:5: ( forInClauseDecl IN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:491:6: forInClauseDecl IN
            {
                PushFollow(FOLLOW_forInClauseDecl_in_synpred692114);
                forInClauseDecl();
                followingStackPointer_--;
                if (failed) return;
                Match(input, IN, FOLLOW_IN_in_synpred692116); if (failed) return;

            }
        }
        // $ANTLR end synpred69

        // $ANTLR start synpred104
        public void synpred104_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:26: ( COMMA assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:26: COMMA assignmentExpression
            {
                Match(input, COMMA, FOLLOW_COMMA_in_synpred1043071); if (failed) return;
                PushFollow(FOLLOW_assignmentExpression_in_synpred1043073);
                assignmentExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred104

        // $ANTLR start synpred110
        public void synpred110_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:4: ( assignmentOperator )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:5: assignmentOperator
            {
                PushFollow(FOLLOW_assignmentOperator_in_synpred1103246);
                assignmentOperator();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred110

        // $ANTLR start synpred136
        public void synpred136_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:4: ( relationalOperator )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:5: relationalOperator
            {
                PushFollow(FOLLOW_relationalOperator_in_synpred1363611);
                relationalOperator();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred136

        // $ANTLR start synpred177
        public void synpred177_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:4: ( newFullExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:4: newFullExpression
            {
                PushFollow(FOLLOW_newFullExpression_in_synpred1774205);
                newFullExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred177

        // $ANTLR start synpred178
        public void synpred178_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: ( newShortExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: newShortExpression
            {
                PushFollow(FOLLOW_newShortExpression_in_synpred1784210);
                newShortExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred178

        // $ANTLR start synpred190
        public void synpred190_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:5: ( DOT qualifiedIdent )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:5: DOT qualifiedIdent
            {
                Match(input, DOT, FOLLOW_DOT_in_synpred1904443); if (failed) return;
                PushFollow(FOLLOW_qualifiedIdent_in_synpred1904445);
                qualifiedIdent();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred190

        // $ANTLR start synpred191
        public void synpred191_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1001:5: ( brackets )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1001:5: brackets
            {
                PushFollow(FOLLOW_brackets_in_synpred1914462);
                brackets();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred191

        // $ANTLR start synpred192
        public void synpred192_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:4: ( fullNewSubexpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:4: fullNewSubexpression
            {
                PushFollow(FOLLOW_fullNewSubexpression_in_synpred1924506);
                fullNewSubexpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred192

        public bool synpred46()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred46_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred110()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred110_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred44()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred44_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred1()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred1_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred136()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred136_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred192()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred192_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred69()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred69_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred191()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred191_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred104()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred104_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred190()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred190_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred61()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred61_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred178()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred178_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred177()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred177_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }


        private void InitializeCyclicDFAs()
        {
        }



        public static readonly BitSet FOLLOW_as2CompilationUnit_in_compilationUnit337 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as3CompilationUnit_in_compilationUnit343 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_comment_in_as2CompilationUnit372 = new BitSet(new ulong[] { 0x0E00000000000000UL, 0x000000DF80000000UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_importDefinition_in_as2CompilationUnit376 = new BitSet(new ulong[] { 0x0E00000000000000UL, 0x000000DF80000000UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_as2Type_in_as2CompilationUnit382 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_as2Type395 = new BitSet(new ulong[] { 0x0C00000000000000UL, 0x000000CF80000000UL, 0x007C000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_as2Type402 = new BitSet(new ulong[] { 0x0C00000000000000UL });
        public static readonly BitSet FOLLOW_as2ClassDefinition_in_as2Type408 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as2InterfaceDefinition_in_as2Type414 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_comment_in_as3CompilationUnit432 = new BitSet(new ulong[] { 0x0020000000000000UL, 0x0000000000000000UL, 0x00000000C0000000UL });
        public static readonly BitSet FOLLOW_packageDecl_in_as3CompilationUnit437 = new BitSet(new ulong[] { 0x0F00000000000000UL, 0x000000DF800000F2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_packageBlockEntry_in_as3CompilationUnit441 = new BitSet(new ulong[] { 0x0F00000000000000UL, 0x000000DF800000F2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_EOF_in_as3CompilationUnit446 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_PACKAGE_in_packageDecl458 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_packageDecl461 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_packageBlock_in_packageDecl466 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_packageBlock477 = new BitSet(new ulong[] { 0x0F80000000000000UL, 0x000000DF800000F2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_packageBlockEntry_in_packageBlock481 = new BitSet(new ulong[] { 0x0F80000000000000UL, 0x000000DF800000F2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_packageBlock486 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_importDefinition_in_packageBlockEntry510 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_packageBlockEntry518 = new BitSet(new ulong[] { 0x0C00000000000000UL, 0x000000CF800000F2UL, 0x007C000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_packageBlockEntry526 = new BitSet(new ulong[] { 0x0C00000000000000UL, 0x00000000000000F2UL });
        public static readonly BitSet FOLLOW_classDefinition_in_packageBlockEntry534 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_interfaceDefinition_in_packageBlockEntry542 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_variableDefinition_in_packageBlockEntry550 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_methodDefinition_in_packageBlockEntry558 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_namespaceDefinition_in_packageBlockEntry566 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_useNamespaceDirective_in_packageBlockEntry574 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_packageBlockEntry585 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_comment_in_packageBlockEntry596 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EOF_in_endOfFile607 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IMPORT_in_importDefinition619 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifierStar_in_importDefinition622 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_importDefinition624 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_semi635 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CLASS_in_classDefinition649 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_classDefinition651 = new BitSet(new ulong[] { 0x5040000000000000UL });
        public static readonly BitSet FOLLOW_classExtendsClause_in_classDefinition655 = new BitSet(new ulong[] { 0x4040000000000000UL });
        public static readonly BitSet FOLLOW_implementsClause_in_classDefinition659 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_classDefinition663 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CLASS_in_as2ClassDefinition695 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_as2ClassDefinition697 = new BitSet(new ulong[] { 0x5040000000000000UL });
        public static readonly BitSet FOLLOW_classExtendsClause_in_as2ClassDefinition701 = new BitSet(new ulong[] { 0x4040000000000000UL });
        public static readonly BitSet FOLLOW_implementsClause_in_as2ClassDefinition705 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_as2ClassDefinition709 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDefinition741 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_interfaceDefinition743 = new BitSet(new ulong[] { 0x1040000000000000UL });
        public static readonly BitSet FOLLOW_interfaceExtendsClause_in_interfaceDefinition747 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_interfaceDefinition751 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INTERFACE_in_as2InterfaceDefinition781 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_as2InterfaceDefinition783 = new BitSet(new ulong[] { 0x1040000000000000UL });
        public static readonly BitSet FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition787 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_as2InterfaceDefinition791 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EXTENDS_in_classExtendsClause821 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_classExtendsClause824 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EXTENDS_in_interfaceExtendsClause837 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause840 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_interfaceExtendsClause844 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause847 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_IMPLEMENTS_in_implementsClause862 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_implementsClause865 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_implementsClause869 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_implementsClause872 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_typeBlock886 = new BitSet(new ulong[] { 0x8280000000000000UL, 0x000000DF800000C2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_typeBlockEntry_in_typeBlock890 = new BitSet(new ulong[] { 0x8280000000000000UL, 0x000000DF800000C2UL, 0x007C1000C0000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_typeBlock895 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_typeBlockEntry919 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000CF800000C2UL, 0x007C000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_typeBlockEntry927 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000000000000C2UL });
        public static readonly BitSet FOLLOW_variableDefinition_in_typeBlockEntry934 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_methodDefinition_in_typeBlockEntry941 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_importDefinition_in_typeBlockEntry951 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as2IncludeDirective_in_typeBlockEntry956 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_comment_in_typeBlockEntry961 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective972 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_as2IncludeDirective976 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_172_in_includeDirective987 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_includeDirective991 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_includeDirective995 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FUNCTION_in_methodDefinition1008 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_optionalAccessorRole_in_methodDefinition1014 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_methodDefinition1018 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_parameterDeclarationList_in_methodDefinition1022 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_typeExpression_in_methodDefinition1026 = new BitSet(new ulong[] { 0x0140000000000000UL });
        public static readonly BitSet FOLLOW_block_in_methodDefinition1032 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_semi_in_methodDefinition1034 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_accessorRole_in_optionalAccessorRole1100 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_accessorRole0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDefinition1139 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_namespaceDefinition1141 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective1168 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective1170 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_useNamespaceDirective1172 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_useNamespaceDirective1174 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_varOrConst_in_variableDefinition1198 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1200 = new BitSet(new ulong[] { 0x2100000000000000UL });
        public static readonly BitSet FOLLOW_COMMA_in_variableDefinition1205 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1207 = new BitSet(new ulong[] { 0x2100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_variableDefinition1213 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_varOrConst0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_variableDeclarator1257 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000080100UL });
        public static readonly BitSet FOLLOW_typeExpression_in_variableDeclarator1260 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_variableInitializer_in_variableDeclarator1263 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_varOrConst_in_declaration1274 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_declaration1277 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_declarationTail_in_declaration1281 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_declarationTail1303 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_declarationTail1306 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_variableInitializer1319 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_variableInitializer1322 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_parameterDeclarationList1335 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008088000CBCUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1341 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_COMMA_in_parameterDeclarationList1347 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000080880008BCUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1349 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_parameterDeclarationList1360 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_basicParameterDeclaration_in_parameterDeclaration1383 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_parameterRestDeclaration_in_parameterDeclaration1387 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CONST_in_basicParameterDeclaration1398 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_basicParameterDeclaration1401 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000080100UL });
        public static readonly BitSet FOLLOW_typeExpression_in_basicParameterDeclaration1403 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_parameterDefault_in_basicParameterDeclaration1406 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_parameterDefault1450 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_parameterDefault1453 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_REST_in_parameterRestDeclaration1464 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_parameterRestDeclaration1466 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_block1490 = new BitSet(new ulong[] { 0x01C0000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_blockEntry_in_block1492 = new BitSet(new ulong[] { 0x01C0000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_RCURLY_in_block1495 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_statement_in_blockEntry1517 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_condition1528 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_condition1530 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_condition1532 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_block_in_statement1558 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declarationStatement_in_statement1563 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionStatement_in_statement1568 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ifStatement_in_statement1573 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forEachStatement_in_statement1580 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forStatement_in_statement1585 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_whileStatement_in_statement1593 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_doWhileStatement_in_statement1601 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_withStatement_in_statement1610 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_switchStatement_in_statement1619 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_breakStatement_in_statement1628 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_continueStatement_in_statement1636 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_returnStatement_in_statement1644 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_throwStatement_in_statement1652 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_tryStatement_in_statement1661 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_defaultXMLNamespaceStatement_in_statement1670 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_comment_in_statement1679 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_statement1687 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_declarationStatement1709 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_declarationStatement1711 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_expressionStatement1732 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_expressionStatement1734 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IF_in_ifStatement1756 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_condition_in_ifStatement1759 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_ifStatement1761 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000002000UL });
        public static readonly BitSet FOLLOW_elseClause_in_ifStatement1770 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ELSE_in_elseClause1783 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_elseClause1786 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_173_in_throwStatement1797 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_throwStatement1800 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_throwStatement1802 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_174_in_tryStatement1813 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_block_in_tryStatement1817 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0001800000000000UL });
        public static readonly BitSet FOLLOW_catchBlock_in_tryStatement1821 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0001800000000000UL });
        public static readonly BitSet FOLLOW_finallyBlock_in_tryStatement1826 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_175_in_catchBlock1838 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_LPAREN_in_catchBlock1840 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_catchBlock1843 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000080400UL });
        public static readonly BitSet FOLLOW_typeExpression_in_catchBlock1845 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_catchBlock1848 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_block_in_catchBlock1853 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_176_in_finallyBlock1864 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_block_in_finallyBlock1866 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_RETURN_in_returnStatement1877 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_returnStatement1880 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_returnStatement1883 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement1896 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_continueStatement1899 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_BREAK_in_breakStatement1910 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_breakStatement1913 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SWITCH_in_switchStatement1924 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_condition_in_switchStatement1927 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_switchBlock_in_switchStatement1931 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_switchBlock1942 = new BitSet(new ulong[] { 0x0080000000000000UL, 0x0000000000140000UL });
        public static readonly BitSet FOLLOW_caseStatement_in_switchBlock1947 = new BitSet(new ulong[] { 0x0080000000000000UL, 0x0000000000140000UL });
        public static readonly BitSet FOLLOW_defaultStatement_in_switchBlock1954 = new BitSet(new ulong[] { 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_switchBlock1960 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CASE_in_caseStatement1985 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_caseStatement1988 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_COLON_in_caseStatement1990 = new BitSet(new ulong[] { 0x0140000000000002UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_switchStatementList_in_caseStatement1995 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEFAULT_in_defaultStatement2007 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_COLON_in_defaultStatement2010 = new BitSet(new ulong[] { 0x0140000000000002UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_switchStatementList_in_defaultStatement2015 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_statement_in_switchStatementList2026 = new BitSet(new ulong[] { 0x0140000000000002UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_FOR_in_forEachStatement2049 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000400000UL });
        public static readonly BitSet FOLLOW_EACH_in_forEachStatement2051 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_LPAREN_in_forEachStatement2055 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000080880000FCUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_forInClause_in_forEachStatement2059 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forEachStatement2063 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_forEachStatement2067 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FOR_in_forStatement2103 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_LPAREN_in_forStatement2107 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F880002FFUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_forInClause_in_forStatement2119 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forStatement2121 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_forStatement2123 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_traditionalForClause_in_forStatement2144 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forStatement2146 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_forStatement2148 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInit_in_traditionalForClause2179 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2181 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_forCond_in_traditionalForClause2189 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2191 = new BitSet(new ulong[] { 0x0040000000000002UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_forIter_in_traditionalForClause2199 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInClauseDecl_in_forInClause2211 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000800000UL });
        public static readonly BitSet FOLLOW_IN_in_forInClause2213 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_forInClauseTail_in_forInClause2216 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_forInClauseDecl2237 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_forInClauseDecl2241 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forInClauseTail2263 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_forInit2287 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forInit2291 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forCond2329 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forIter2362 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_WHILE_in_whileStatement2385 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_condition_in_whileStatement2388 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_whileStatement2390 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DO_in_doWhileStatement2401 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_doWhileStatement2404 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000001000000UL });
        public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement2406 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_condition_in_doWhileStatement2409 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_doWhileStatement2411 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_WITH_in_withStatement2422 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_condition_in_withStatement2425 = new BitSet(new ulong[] { 0x0140000000000000UL, 0x8000009F8F33D2FFUL, 0x00026000FFF7EE18UL });
        public static readonly BitSet FOLLOW_statement_in_withStatement2427 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2438 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000008000000UL });
        public static readonly BitSet FOLLOW_XML_in_defaultXMLNamespaceStatement2440 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2442 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2444 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_defaultXMLNamespaceStatement2446 = new BitSet(new ulong[] { 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_defaultXMLNamespaceStatement2448 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COLON_in_typeExpression2471 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F9800003CUL, 0x0002000000000018UL });
        public static readonly BitSet FOLLOW_identifier_in_typeExpression2479 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_177_in_typeExpression2483 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_typeExpression2487 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2519 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifier2537 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2539 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020000000UL });
        public static readonly BitSet FOLLOW_namespaceName_in_qualifiedIdent2567 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
        public static readonly BitSet FOLLOW_DBL_COLON_in_qualifiedIdent2569 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_qualifiedIdent2573 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IDENT_in_namespaceName2585 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_reservedNamespace_in_namespaceName2589 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_reservedNamespace0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_identifierStar2626 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifierStar2643 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_identifierStar2645 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifierStar2657 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000010000000UL });
        public static readonly BitSet FOLLOW_STAR_in_identifierStar2659 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotation_in_annotations2691 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001000000000UL, 0x0000100000000000UL });
        public static readonly BitSet FOLLOW_includeDirective_in_annotations2697 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001000000000UL, 0x0000100000000000UL });
        public static readonly BitSet FOLLOW_LBRACK_in_annotation2724 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000808800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_ident_in_annotation2728 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000200UL });
        public static readonly BitSet FOLLOW_annotationParamList_in_annotation2732 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_annotation2737 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_annotationParamList2763 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x800000808800043DUL, 0x000000001FC00818UL });
        public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2769 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_COMMA_in_annotationParamList2775 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x800000808800003DUL, 0x000000001FC00818UL });
        public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2777 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_annotationParamList2788 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_annotationParam2815 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam2817 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x8000000000000001UL, 0x000000001FC00800UL });
        public static readonly BitSet FOLLOW_constant_in_annotationParam2819 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_constant_in_annotationParam2834 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_annotationParam2843 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_modifier_in_modifiers2858 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000CF80000000UL, 0x007C000000000000UL });
        public static readonly BitSet FOLLOW_namespaceName_in_modifier2881 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STATIC_in_modifier2886 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_178_in_modifier2891 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_179_in_modifier2896 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_180_in_modifier2901 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_181_in_modifier2906 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DYNAMIC_in_modifier2911 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_182_in_modifier2916 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_arguments2937 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expressionList_in_arguments2939 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_arguments2941 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_arguments2956 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_arguments2958 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_element2988 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral3010 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x800000BF8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_elementList_in_arrayLiteral3012 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral3015 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3037 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_elementList3040 = new BitSet(new ulong[] { 0x0040000000000002UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3043 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3068 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_nonemptyElementList3071 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3073 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral3088 = new BitSet(new ulong[] { 0x0080000000000000UL, 0x000000808800003CUL, 0x000000001E000018UL });
        public static readonly BitSet FOLLOW_fieldList_in_objectLiteral3090 = new BitSet(new ulong[] { 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral3093 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_literalField_in_fieldList3116 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_fieldList3119 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000808800003CUL, 0x000000001E000018UL });
        public static readonly BitSet FOLLOW_literalField_in_fieldList3122 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_fieldName_in_literalField3139 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_COLON_in_literalField3141 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_element_in_literalField3143 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_fieldName3167 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_number_in_fieldName3172 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expression3194 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3206 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_expressionList3209 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3211 = new BitSet(new ulong[] { 0x2000000000000002UL });
        public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression3240 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x001FFF0000000100UL });
        public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression3250 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression3254 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x001FFF0000000100UL });
        public static readonly BitSet FOLLOW_set_in_assignmentOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_logicalOrExpression_in_conditionalExpression3348 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0020000000000000UL });
        public static readonly BitSet FOLLOW_QUESTION_in_conditionalExpression3362 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_conditionalSubExpression_in_conditionalExpression3367 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3396 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_COLON_in_conditionalSubExpression3398 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3401 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3415 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0040000000000000UL, 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_logicalOrOperator_in_logicalOrExpression3420 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3423 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0040000000000000UL, 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_set_in_logicalOrOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3452 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0080000000000000UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_logicalAndOperator_in_logicalAndExpression3457 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3460 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0080000000000000UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_set_in_logicalAndOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3489 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_BOR_in_bitwiseOrExpression3494 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3497 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3511 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0200000000000000UL });
        public static readonly BitSet FOLLOW_BXOR_in_bitwiseXorExpression3516 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3519 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0200000000000000UL });
        public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3533 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0400000000000000UL });
        public static readonly BitSet FOLLOW_BAND_in_bitwiseAndExpression3538 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3541 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0400000000000000UL });
        public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3555 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x7800000000000000UL });
        public static readonly BitSet FOLLOW_equalityOperator_in_equalityExpression3560 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3565 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x7800000000000000UL });
        public static readonly BitSet FOLLOW_set_in_equalityOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3605 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x8000000000800000UL, 0x000000000000003FUL });
        public static readonly BitSet FOLLOW_relationalOperator_in_relationalExpression3615 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3618 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x8000000000800000UL, 0x000000000000003FUL });
        public static readonly BitSet FOLLOW_IN_in_relationalOperator3633 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LT_in_relationalOperator3638 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GT_in_relationalOperator3642 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LE_in_relationalOperator3646 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GE_in_relationalOperator3650 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IS_in_relationalOperator3654 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_AS_in_relationalOperator3658 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INSTANCEOF_in_relationalOperator3662 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3674 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x00000000000001C0UL });
        public static readonly BitSet FOLLOW_shiftOperator_in_shiftExpression3679 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3682 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x00000000000001C0UL });
        public static readonly BitSet FOLLOW_set_in_shiftOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3715 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000600UL });
        public static readonly BitSet FOLLOW_additiveOperator_in_additiveExpression3720 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3723 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000600UL });
        public static readonly BitSet FOLLOW_set_in_additiveOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3753 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000010000000UL, 0x0000000000001800UL });
        public static readonly BitSet FOLLOW_multiplicativeOperator_in_multiplicativeExpression3759 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3765 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000010000000UL, 0x0000000000001800UL });
        public static readonly BitSet FOLLOW_set_in_multiplicativeOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INC_in_unaryExpression3803 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3805 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEC_in_unaryExpression3821 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3823 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_MINUS_in_unaryExpression3837 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3839 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_PLUS_in_unaryExpression3852 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3854 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3867 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3878 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000000003FF00818UL });
        public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3880 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_177_in_unaryExpressionNotPlusMinus3893 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3895 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3908 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3910 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3923 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3925 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_BNOT_in_unaryExpressionNotPlusMinus3938 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3940 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3953 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_primaryExpression_in_postfixExpression3966 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_propOrIdent_in_postfixExpression3979 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_DOT_in_postfixExpression3991 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000010000200UL, 0x0000000000100000UL });
        public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression3993 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_LBRACK_in_postfixExpression3999 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_postfixExpression4001 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_postfixExpression4003 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_E4X_DESC_in_postfixExpression4020 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000010000200UL, 0x0000000000100000UL });
        public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression4022 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_arguments_in_postfixExpression4028 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000200UL, 0x0000000000086000UL });
        public static readonly BitSet FOLLOW_INC_in_postfixExpression4054 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEC_in_postfixExpression4073 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_e4xExpression4100 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_e4xExpression4106 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xFilterPredicate_in_e4xExpression4111 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4122 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000009F9800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4128 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_e4xAttributeIdentifier4134 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_e4xAttributeIdentifier4140 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_e4xAttributeIdentifier4142 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_e4xAttributeIdentifier4144 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_e4xFilterPredicate4159 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expression_in_e4xFilterPredicate4164 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_e4xFilterPredicate4168 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_UNDEFINED_in_primaryExpression4180 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_constant_in_primaryExpression4185 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpression4190 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpression4195 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_functionDefinition_in_primaryExpression4200 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newFullExpression_in_primaryExpression4205 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_primaryExpression4210 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_encapsulatedExpression_in_primaryExpression4215 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_primaryExpression4220 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_primaryExpression4225 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_propOrIdent4245 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_propOrIdent4249 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_xmlLiteral_in_constant4277 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_regexpLiteral_in_constant4282 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_number_in_constant4287 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_constant4292 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_TRUE_in_constant4297 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FALSE_in_constant4302 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NULL_in_constant4307 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_number0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LT_in_xmlLiteral4360 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DIV_in_regexpLiteral4390 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NEW_in_newFullExpression4411 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000000003FF00818UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_newFullExpression4414 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_arguments_in_newFullExpression4416 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_primaryExpression_in_fullNewSubexpression4429 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000000UL });
        public static readonly BitSet FOLLOW_DOT_in_fullNewSubexpression4443 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_fullNewSubexpression4445 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000000UL });
        public static readonly BitSet FOLLOW_brackets_in_fullNewSubexpression4462 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000001020000000UL });
        public static readonly BitSet FOLLOW_NEW_in_newShortExpression4490 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000000003FF00818UL });
        public static readonly BitSet FOLLOW_shortNewSubexpression_in_newShortExpression4493 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_shortNewSubexpression4506 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_shortNewSubexpression4511 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_propertyOperator4523 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_propertyOperator4526 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_brackets_in_propertyOperator4531 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SL_COMMENT_in_comment4542 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ML_COMMENT_in_comment4555 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_brackets4580 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_expressionList_in_brackets4582 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000002000000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_brackets4584 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_encapsulatedExpression4605 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_encapsulatedExpression4607 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000400UL });
        public static readonly BitSet FOLLOW_RPAREN_in_encapsulatedExpression4609 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FUNCTION_in_functionDefinition4633 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000200UL });
        public static readonly BitSet FOLLOW_parameterDeclarationList_in_functionDefinition4635 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x0000000000080000UL });
        public static readonly BitSet FOLLOW_typeExpression_in_functionDefinition4637 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_block_in_functionDefinition4640 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IDENT_in_ident4667 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_USE_in_ident4674 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_XML_in_ident4686 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DYNAMIC_in_ident4698 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_ident4710 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IS_in_ident4722 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_AS_in_ident4734 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GET_in_ident4746 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SET_in_ident4758 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as2CompilationUnit_in_synpred1337 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_synpred441554 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionStatement_in_synpred461568 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ELSE_in_synpred611767 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInClauseDecl_in_synpred692114 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000800000UL });
        public static readonly BitSet FOLLOW_IN_in_synpred692116 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_synpred1043071 = new BitSet(new ulong[] { 0x0040000000000000UL, 0x8000009F8800023FUL, 0x000200003FF7EE18UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_synpred1043073 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentOperator_in_synpred1103246 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_relationalOperator_in_synpred1363611 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newFullExpression_in_synpred1774205 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_synpred1784210 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_synpred1904443 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000008F8800003CUL, 0x0000000000000018UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_synpred1904445 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_brackets_in_synpred1914462 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_synpred1924506 = new BitSet(new ulong[] { 0x0000000000000002UL });

    }
}