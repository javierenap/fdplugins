// $ANTLR 3.0 C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g 2007-08-23 10:40:53
namespace 
CodeReformatter.Generators.Core

{

using System.IO;
using System.Diagnostics;


using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;

using IDictionary	= System.Collections.IDictionary;
using Hashtable 	= System.Collections.Hashtable;



using Antlr.Runtime.Tree;

public class ASParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"COMPILATION_UNIT", 
		"TYPE_BLOCK", 
		"METHOD_DEF", 
		"VAR_DEF", 
		"ANNOTATIONS", 
		"ANNOTATION", 
		"ANNOTATION_PARAMS", 
		"MODIFIERS", 
		"NAMESPACE_DEF", 
		"ACCESSOR_ROLE", 
		"CLASS_DEF", 
		"INTERFACE_DEF", 
		"PARAMS", 
		"PARAM", 
		"TYPE_SPEC", 
		"BLOCK", 
		"ELIST", 
		"CONDITION", 
		"ARGUMENTS", 
		"EXPR_STMNT", 
		"ENCPS_EXPR", 
		"VAR_INIT", 
		"METHOD_CALL", 
		"PROPERTY_OR_IDENTIFIER", 
		"PROPERTY_ACCESS", 
		"TYPE_NAME", 
		"ARRAY_ACC", 
		"UNARY_PLUS", 
		"UNARY_MINUS", 
		"POST_INC", 
		"POST_DEC", 
		"PRE_INC", 
		"PRE_DEC", 
		"ARRAY_LITERAL", 
		"ELEMENT", 
		"OBJECT_LITERAL", 
		"OBJECT_FIELD", 
		"FUNC_DEF", 
		"FOR_INIT", 
		"FOR_CONDITION", 
		"FOR_ITERATOR", 
		"FOR_EACH", 
		"FOR_IN", 
		"SWITCH_STATEMENT_LIST", 
		"IDENTIFIER", 
		"DEFAULT_XML_NAMESPACE", 
		"SINGLELINE_COMMENT", 
		"MULTILINE_COMMENT", 
		"COMMENT_LIST", 
		"COMMENT_ENTRY", 
		"VIRTUAL_PLACEHOLDER", 
		"ANNOTATION_ASSIGN", 
		"AS2_COMPILATION_UNIT", 
		"IMETHOD_DEF", 
		"PACKAGE", 
		"LCURLY", 
		"RCURLY", 
		"SEMI", 
		"IMPORT", 
		"CLASS", 
		"INTERFACE", 
		"EXTENDS", 
		"COMMA", 
		"IMPLEMENTS", 
		"INCLUDE_DIRECTIVE", 
		"STRING_LITERAL", 
		"FUNCTION", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"USE", 
		"VAR", 
		"CONST", 
		"ASSIGN", 
		"LPAREN", 
		"RPAREN", 
		"REST", 
		"IF", 
		"ELSE", 
		"RETURN", 
		"CONTINUE", 
		"BREAK", 
		"SWITCH", 
		"CASE", 
		"COLON", 
		"DEFAULT", 
		"FOR", 
		"EACH", 
		"IN", 
		"WHILE", 
		"DO", 
		"WITH", 
		"XML", 
		"STAR", 
		"DOT", 
		"DBL_COLON", 
		"IDENT", 
		"PUBLIC", 
		"PRIVATE", 
		"PROTECTED", 
		"INTERNAL", 
		"LBRACK", 
		"RBRACK", 
		"STATIC", 
		"DYNAMIC", 
		"STAR_ASSIGN", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"PLUS_ASSIGN", 
		"MINUS_ASSIGN", 
		"SL_ASSIGN", 
		"SR_ASSIGN", 
		"BSR_ASSIGN", 
		"BAND_ASSIGN", 
		"BXOR_ASSIGN", 
		"BOR_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"QUESTION", 
		"LOR", 
		"LAND", 
		"BOR", 
		"BXOR", 
		"BAND", 
		"STRICT_EQUAL", 
		"STRICT_NOT_EQUAL", 
		"NOT_EQUAL", 
		"EQUAL", 
		"LT", 
		"GT", 
		"LE", 
		"GE", 
		"IS", 
		"AS", 
		"INSTANCEOF", 
		"SL", 
		"SR", 
		"BSR", 
		"PLUS", 
		"MINUS", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"DELETE", 
		"TYPEOF", 
		"LNOT", 
		"BNOT", 
		"E4X_DESC", 
		"E4X_ATTRI", 
		"UNDEFINED", 
		"TRUE", 
		"FALSE", 
		"NULL", 
		"HEX_LITERAL", 
		"DECIMAL_LITERAL", 
		"OCTAL_LITERAL", 
		"FLOAT_LITERAL", 
		"NEW", 
		"SL_COMMENT", 
		"ML_COMMENT", 
		"ESC", 
		"HEX_DIGIT", 
		"EXPONENT", 
		"WS", 
		"NL", 
		"BOM", 
		"OCT_DIGIT", 
		"CTRLCHAR_ESC", 
		"UNICODE_ESC", 
		"OCTAL_ESC", 
		"'include'", 
		"'throw'", 
		"'try'", 
		"'catch'", 
		"'finally'", 
		"'void'", 
		"'final'", 
		"'enumerable'", 
		"'explicit'", 
		"'override'", 
		"'intrinsic'", 
		"'or'", 
		"'and'"
    };

    public const int INTERNAL = 104;
    public const int BLOCK = 19;
    public const int BOR_ASSIGN = 119;
    public const int STRING_LITERAL = 69;
    public const int GT = 133;
    public const int HEX_DIGIT = 166;
    public const int GET = 71;
    public const int UNDEFINED = 154;
    public const int SL_ASSIGN = 114;
    public const int PRE_DEC = 36;
    public const int SR = 140;
    public const int LOR_ASSIGN = 121;
    public const int IMPLEMENTS = 67;
    public const int GE = 135;
    public const int LBRACK = 105;
    public const int OCTAL_LITERAL = 160;
    public const int SL = 139;
    public const int PROPERTY_OR_IDENTIFIER = 27;
    public const int SINGLELINE_COMMENT = 50;
    public const int UNICODE_ESC = 173;
    public const int EXTENDS = 65;
    public const int NAMESPACE_DEF = 12;
    public const int FOR_IN = 46;
    public const int NOT_EQUAL = 130;
    public const int MOD_ASSIGN = 111;
    public const int LCURLY = 59;
    public const int UNARY_MINUS = 32;
    public const int LNOT = 150;
    public const int ANNOTATION_ASSIGN = 55;
    public const int ACCESSOR_ROLE = 13;
    public const int E4X_ATTRI = 153;
    public const int MULTILINE_COMMENT = 51;
    public const int DEFAULT = 89;
    public const int STATIC = 107;
    public const int ML_COMMENT = 164;
    public const int OCTAL_ESC = 174;
    public const int STRICT_NOT_EQUAL = 129;
    public const int OCT_DIGIT = 171;
    public const int ANNOTATIONS = 8;
    public const int E4X_DESC = 152;
    public const int POST_DEC = 34;
    public const int DECIMAL_LITERAL = 159;
    public const int MOD = 145;
    public const int INTERFACE_DEF = 15;
    public const int MODIFIERS = 11;
    public const int TYPE_SPEC = 18;
    public const int DIV = 144;
    public const int UNARY_PLUS = 31;
    public const int EACH = 91;
    public const int DEFAULT_XML_NAMESPACE = 49;
    public const int LAND_ASSIGN = 120;
    public const int CONDITION = 21;
    public const int ASSIGN = 77;
    public const int NULL = 157;
    public const int PRIVATE = 102;
    public const int DO = 94;
    public const int EOF = -1;
    public const int MINUS = 143;
    public const int SWITCH_STATEMENT_LIST = 47;
    public const int PARAM = 17;
    public const int TYPE_BLOCK = 5;
    public const int VIRTUAL_PLACEHOLDER = 54;
    public const int VAR_INIT = 25;
    public const int INSTANCEOF = 138;
    public const int FUNCTION = 70;
    public const int PROPERTY_ACCESS = 28;
    public const int TYPE_NAME = 29;
    public const int INC = 146;
    public const int RETURN = 83;
    public const int ELSE = 82;
    public const int EQUAL = 131;
    public const int BXOR_ASSIGN = 118;
    public const int CTRLCHAR_ESC = 172;
    public const int BSR_ASSIGN = 116;
    public const int TRUE = 155;
    public const int DBL_COLON = 99;
    public const int IDENTIFIER = 48;
    public const int COMMENT_ENTRY = 53;
    public const int COMMENT_LIST = 52;
    public const int SEMI = 61;
    public const int STRICT_EQUAL = 128;
    public const int PLUS_ASSIGN = 112;
    public const int BSR = 141;
    public const int OBJECT_FIELD = 40;
    public const int ELEMENT = 38;
    public const int NEW = 162;
    public const int DIV_ASSIGN = 110;
    public const int DELETE = 148;
    public const int NL = 169;
    public const int IDENT = 100;
    public const int BAND_ASSIGN = 117;
    public const int AS = 137;
    public const int AS2_COMPILATION_UNIT = 56;
    public const int CASE = 87;
    public const int OBJECT_LITERAL = 39;
    public const int RBRACK = 106;
    public const int LPAREN = 78;
    public const int PLUS = 142;
    public const int CLASS = 63;
    public const int FUNC_DEF = 41;
    public const int ARRAY_ACC = 30;
    public const int BREAK = 85;
    public const int WHILE = 93;
    public const int CONST = 76;
    public const int RCURLY = 60;
    public const int INTERFACE = 64;
    public const int PARAMS = 16;
    public const int FOR_INIT = 42;
    public const int DEC = 147;
    public const int COMMA = 66;
    public const int COMPILATION_UNIT = 4;
    public const int LT = 132;
    public const int FOR_ITERATOR = 44;
    public const int ARGUMENTS = 22;
    public const int LE = 134;
    public const int FOR_CONDITION = 43;
    public const int CLASS_DEF = 14;
    public const int MINUS_ASSIGN = 113;
    public const int ENCPS_EXPR = 24;
    public const int LOR = 123;
    public const int WITH = 95;
    public const int REST = 80;
    public const int INCLUDE_DIRECTIVE = 68;
    public const int BAND = 127;
    public const int STAR_ASSIGN = 109;
    public const int EXPONENT = 167;
    public const int SL_COMMENT = 163;
    public const int VAR = 75;
    public const int WS = 168;
    public const int PACKAGE = 58;
    public const int STAR = 97;
    public const int FOR = 90;
    public const int FALSE = 156;
    public const int IMPORT = 62;
    public const int DOT = 98;
    public const int XML = 96;
    public const int ANNOTATION = 9;
    public const int QUESTION = 122;
    public const int EXPR_STMNT = 23;
    public const int PRE_INC = 35;
    public const int BOR = 125;
    public const int NAMESPACE = 73;
    public const int BOM = 170;
    public const int SWITCH = 86;
    public const int CONTINUE = 84;
    public const int ARRAY_LITERAL = 37;
    public const int USE = 74;
    public const int SR_ASSIGN = 115;
    public const int IMETHOD_DEF = 57;
    public const int ANNOTATION_PARAMS = 10;
    public const int HEX_LITERAL = 158;
    public const int IS = 136;
    public const int METHOD_CALL = 26;
    public const int FOR_EACH = 45;
    public const int LAND = 124;
    public const int DYNAMIC = 108;
    public const int IN = 92;
    public const int BXOR = 126;
    public const int METHOD_DEF = 6;
    public const int VAR_DEF = 7;
    public const int IF = 81;
    public const int ELIST = 20;
    public const int TYPEOF = 149;
    public const int FLOAT_LITERAL = 161;
    public const int COLON = 88;
    public const int SET = 72;
    public const int PUBLIC = 101;
    public const int POST_INC = 33;
    public const int ESC = 165;
    public const int BNOT = 151;
    public const int RPAREN = 79;
    public const int PROTECTED = 103;
    protected class InOperator_scope 
    {
        protected internal Boolean allowed;
    }
    protected Stack InOperator_stack = new Stack();

    
    
        public ASParser(ITokenStream input) 
    		: base(input)
    	{
    		InitializeCyclicDFAs();
            ruleMemo = new IDictionary[370+1];
         }
        
    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();
    
    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set { this.adaptor = value; }
    }

    override public string[] TokenNames
	{
		get { return tokenNames; }
	}

    override public string GrammarFileName
	{
		get { return "C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g"; }
	}

    
    
    	#region Members
    	
    	private ASLexer lexer;
    	private ICharStream cs;
    	public static int CHANNEL_PLACEHOLDER = 999;
    
    	public void SetInput(ASLexer lexer, ICharStream cs) 
    	{
    		this.lexer = lexer;
    		this.cs = cs;
    	}
    
    	/*
    	protected void mismatch(IIntStream input, int ttype, BitSet follow)
    	{
    		MismatchedTokenException mte = new MismatchedTokenException(ttype, input);
    		RecoverFromMismatchedToken(input, mte, ttype, follow);
    	}
    	*/
    	
    	#endregion


    public class as2Program_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2Program
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:1: as2Program : as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) ;
    public as2Program_return as2Program() // throws RecognitionException [1]
    {   
        as2Program_return retval = new as2Program_return();
        retval.start = input.LT(1);
        int as2Program_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        as2CompilationUnit_return as2CompilationUnit1 = null;
        
        
        RewriteRuleSubtreeStream stream_as2CompilationUnit = new RewriteRuleSubtreeStream(adaptor,"rule as2CompilationUnit");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 1) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:4: ( as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:4: as2CompilationUnit
            {
            	PushFollow(FOLLOW_as2CompilationUnit_in_as2Program351);
            	as2CompilationUnit1 = as2CompilationUnit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);
            	
            	// AST REWRITE
            	// elements:          as2CompilationUnit
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 99:23: -> ^( COMPILATION_UNIT as2CompilationUnit )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:26: ^( COMPILATION_UNIT as2CompilationUnit )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_as2CompilationUnit.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 1, as2Program_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2Program

    public class as3Program_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as3Program
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:102:1: as3Program : as3CompilationUnit -> ^( COMPILATION_UNIT as3CompilationUnit ) ;
    public as3Program_return as3Program() // throws RecognitionException [1]
    {   
        as3Program_return retval = new as3Program_return();
        retval.start = input.LT(1);
        int as3Program_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        as3CompilationUnit_return as3CompilationUnit2 = null;
        
        
        RewriteRuleSubtreeStream stream_as3CompilationUnit = new RewriteRuleSubtreeStream(adaptor,"rule as3CompilationUnit");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 2) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:4: ( as3CompilationUnit -> ^( COMPILATION_UNIT as3CompilationUnit ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:4: as3CompilationUnit
            {
            	PushFollow(FOLLOW_as3CompilationUnit_in_as3Program371);
            	as3CompilationUnit2 = as3CompilationUnit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);
            	
            	// AST REWRITE
            	// elements:          as3CompilationUnit
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 103:23: -> ^( COMPILATION_UNIT as3CompilationUnit )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:26: ^( COMPILATION_UNIT as3CompilationUnit )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_as3CompilationUnit.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 2, as3Program_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as3Program

    public class as2CompilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2CompilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:107:1: as2CompilationUnit : ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type ( commentExpression )? ;
    public as2CompilationUnit_return as2CompilationUnit() // throws RecognitionException [1]
    {   
        as2CompilationUnit_return retval = new as2CompilationUnit_return();
        retval.start = input.LT(1);
        int as2CompilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        commentExpression_return commentExpression3 = null;

        importDefinition_return importDefinition4 = null;

        annotations_return annotations5 = null;

        commentExpression_return commentExpression6 = null;

        as2Type_return as2Type7 = null;

        commentExpression_return commentExpression8 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 3) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: ( ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type ( commentExpression )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type ( commentExpression )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: ( commentExpression )?
            	int alt1 = 2;
            	int LA1_0 = input.LA(1);
            	
            	if ( (LA1_0 == SL_COMMENT) )
            	{
            	    int LA1_1 = input.LA(2);
            	    
            	    if ( (synpred1()) )
            	    {
            	        alt1 = 1;
            	    }
            	}
            	else if ( (LA1_0 == ML_COMMENT) )
            	{
            	    int LA1_2 = input.LA(2);
            	    
            	    if ( (synpred1()) )
            	    {
            	        alt1 = 1;
            	    }
            	}
            	switch (alt1) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_as2CompilationUnit393);
            	        	commentExpression3 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression3.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:3: ( importDefinition )*
            	do 
            	{
            	    int alt2 = 2;
            	    int LA2_0 = input.LA(1);
            	    
            	    if ( (LA2_0 == IMPORT) )
            	    {
            	        alt2 = 1;
            	    }
            	    
            	
            	    switch (alt2) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: importDefinition
            			    {
            			    	PushFollow(FOLLOW_importDefinition_in_as2CompilationUnit399);
            			    	importDefinition4 = importDefinition();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition4.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop2;
            	    }
            	} while (true);
            	
            	loop2:
            		;	// Stops C# compiler whinging that label 'loop2' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:3: ( annotations | commentExpression )*
            	do 
            	{
            	    int alt3 = 3;
            	    int LA3_0 = input.LA(1);
            	    
            	    if ( (LA3_0 == LBRACK || LA3_0 == 175) )
            	    {
            	        alt3 = 1;
            	    }
            	    else if ( ((LA3_0 >= SL_COMMENT && LA3_0 <= ML_COMMENT)) )
            	    {
            	        alt3 = 2;
            	    }
            	    
            	
            	    switch (alt3) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:4: annotations
            			    {
            			    	PushFollow(FOLLOW_annotations_in_as2CompilationUnit405);
            			    	annotations5 = annotations();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations5.Tree);
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:18: commentExpression
            			    {
            			    	PushFollow(FOLLOW_commentExpression_in_as2CompilationUnit409);
            			    	commentExpression6 = commentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression6.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop3;
            	    }
            	} while (true);
            	
            	loop3:
            		;	// Stops C# compiler whinging that label 'loop3' has no statements

            	PushFollow(FOLLOW_as2Type_in_as2CompilationUnit415);
            	as2Type7 = as2Type();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, as2Type7.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:112:3: ( commentExpression )?
            	int alt4 = 2;
            	int LA4_0 = input.LA(1);
            	
            	if ( ((LA4_0 >= SL_COMMENT && LA4_0 <= ML_COMMENT)) )
            	{
            	    alt4 = 1;
            	}
            	switch (alt4) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_as2CompilationUnit419);
            	        	commentExpression8 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression8.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 3, as2CompilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2CompilationUnit

    public class as2Type_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2Type
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:115:1: as2Type : mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) ;
    public as2Type_return as2Type() // throws RecognitionException [1]
    {   
        as2Type_return retval = new as2Type_return();
        retval.start = input.LT(1);
        int as2Type_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return mods = null;

        as2ClassDefinition_return as2ClassDefinition9 = null;

        as2InterfaceDefinition_return as2InterfaceDefinition10 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 4) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:4: (mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:4: mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_modifiers_in_as2Type433);
            	mods = modifiers();
            	followingStackPointer_--;
            	if (failed) return retval;
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            	int alt5 = 2;
            	int LA5_0 = input.LA(1);
            	
            	if ( (LA5_0 == CLASS) )
            	{
            	    alt5 = 1;
            	}
            	else if ( (LA5_0 == INTERFACE) )
            	{
            	    alt5 = 2;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d5s0 =
            	        new NoViableAltException("117:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )", 5, 0, input);
            	
            	    throw nvae_d5s0;
            	}
            	switch (alt5) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:4: as2ClassDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2ClassDefinition_in_as2Type439);
            	        	as2ClassDefinition9 = as2ClassDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2ClassDefinition9.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:118:4: as2InterfaceDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2InterfaceDefinition_in_as2Type445);
            	        	as2InterfaceDefinition10 = as2InterfaceDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2InterfaceDefinition10.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 4, as2Type_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2Type

    public class as3CompilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as3CompilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:122:1: as3CompilationUnit : ( commentExpression )? packageDecl ( packageBlockEntry )* EOF ;
    public as3CompilationUnit_return as3CompilationUnit() // throws RecognitionException [1]
    {   
        as3CompilationUnit_return retval = new as3CompilationUnit_return();
        retval.start = input.LT(1);
        int as3CompilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EOF14 = null;
        commentExpression_return commentExpression11 = null;

        packageDecl_return packageDecl12 = null;

        packageBlockEntry_return packageBlockEntry13 = null;
        
        
        CommonTree EOF14_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 5) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( ( commentExpression )? packageDecl ( packageBlockEntry )* EOF )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( commentExpression )? packageDecl ( packageBlockEntry )* EOF
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( commentExpression )?
            	int alt6 = 2;
            	int LA6_0 = input.LA(1);
            	
            	if ( ((LA6_0 >= SL_COMMENT && LA6_0 <= ML_COMMENT)) )
            	{
            	    alt6 = 1;
            	}
            	switch (alt6) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_as3CompilationUnit463);
            	        	commentExpression11 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression11.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_packageDecl_in_as3CompilationUnit468);
            	packageDecl12 = packageDecl();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, packageDecl12.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:125:3: ( packageBlockEntry )*
            	do 
            	{
            	    int alt7 = 2;
            	    int LA7_0 = input.LA(1);
            	    
            	    if ( ((LA7_0 >= SEMI && LA7_0 <= INTERFACE) || LA7_0 == FUNCTION || (LA7_0 >= NAMESPACE && LA7_0 <= CONST) || (LA7_0 >= IDENT && LA7_0 <= LBRACK) || (LA7_0 >= STATIC && LA7_0 <= DYNAMIC) || (LA7_0 >= SL_COMMENT && LA7_0 <= ML_COMMENT) || LA7_0 == 175 || (LA7_0 >= 181 && LA7_0 <= 185)) )
            	    {
            	        alt7 = 1;
            	    }
            	    
            	
            	    switch (alt7) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
            			    {
            			    	PushFollow(FOLLOW_packageBlockEntry_in_as3CompilationUnit472);
            			    	packageBlockEntry13 = packageBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, packageBlockEntry13.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop7;
            	    }
            	} while (true);
            	
            	loop7:
            		;	// Stops C# compiler whinging that label 'loop7' has no statements

            	EOF14 = (IToken)input.LT(1);
            	Match(input,EOF,FOLLOW_EOF_in_as3CompilationUnit477); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 5, as3CompilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as3CompilationUnit

    public class packageDecl_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageDecl
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:129:1: packageDecl : PACKAGE ( identifier )? packageBlock ;
    public packageDecl_return packageDecl() // throws RecognitionException [1]
    {   
        packageDecl_return retval = new packageDecl_return();
        retval.start = input.LT(1);
        int packageDecl_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken PACKAGE15 = null;
        identifier_return identifier16 = null;

        packageBlock_return packageBlock17 = null;
        
        
        CommonTree PACKAGE15_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 6) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:4: ( PACKAGE ( identifier )? packageBlock )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:4: PACKAGE ( identifier )? packageBlock
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PACKAGE15 = (IToken)input.LT(1);
            	Match(input,PACKAGE,FOLLOW_PACKAGE_in_packageDecl489); if (failed) return retval;
            	if ( backtracking==0 ) {
            	PACKAGE15_tree = (CommonTree)adaptor.Create(PACKAGE15);
            	root_0 = (CommonTree)adaptor.BecomeRoot(PACKAGE15_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:13: ( identifier )?
            	int alt8 = 2;
            	int LA8_0 = input.LA(1);
            	
            	if ( ((LA8_0 >= GET && LA8_0 <= USE) || LA8_0 == XML || (LA8_0 >= IDENT && LA8_0 <= INTERNAL) || LA8_0 == DYNAMIC || (LA8_0 >= IS && LA8_0 <= AS)) )
            	{
            	    alt8 = 1;
            	}
            	switch (alt8) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: identifier
            	        {
            	        	PushFollow(FOLLOW_identifier_in_packageDecl492);
            	        	identifier16 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier16.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_packageBlock_in_packageDecl497);
            	packageBlock17 = packageBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, packageBlock17.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 6, packageDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageDecl

    public class packageBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:134:1: packageBlock : LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) ;
    public packageBlock_return packageBlock() // throws RecognitionException [1]
    {   
        packageBlock_return retval = new packageBlock_return();
        retval.start = input.LT(1);
        int packageBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY18 = null;
        IToken RCURLY20 = null;
        packageBlockEntry_return packageBlockEntry19 = null;
        
        
        CommonTree LCURLY18_tree=null;
        CommonTree RCURLY20_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_packageBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule packageBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 7) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: LCURLY ( packageBlockEntry )* RCURLY
            {
            	LCURLY18 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_packageBlock508); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY18);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:136:3: ( packageBlockEntry )*
            	do 
            	{
            	    int alt9 = 2;
            	    int LA9_0 = input.LA(1);
            	    
            	    if ( ((LA9_0 >= SEMI && LA9_0 <= INTERFACE) || LA9_0 == FUNCTION || (LA9_0 >= NAMESPACE && LA9_0 <= CONST) || (LA9_0 >= IDENT && LA9_0 <= LBRACK) || (LA9_0 >= STATIC && LA9_0 <= DYNAMIC) || (LA9_0 >= SL_COMMENT && LA9_0 <= ML_COMMENT) || LA9_0 == 175 || (LA9_0 >= 181 && LA9_0 <= 185)) )
            	    {
            	        alt9 = 1;
            	    }
            	    
            	
            	    switch (alt9) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
            			    {
            			    	PushFollow(FOLLOW_packageBlockEntry_in_packageBlock512);
            			    	packageBlockEntry19 = packageBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_packageBlockEntry.Add(packageBlockEntry19.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop9;
            	    }
            	} while (true);
            	
            	loop9:
            		;	// Stops C# compiler whinging that label 'loop9' has no statements

            	RCURLY20 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_packageBlock517); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY20);

            	
            	// AST REWRITE
            	// elements:          packageBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 138:3: -> ^( BLOCK ( packageBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:6: ^( BLOCK ( packageBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:14: ( packageBlockEntry )*
            	    while ( stream_packageBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_packageBlockEntry.Next());
            	    
            	    }
            	    stream_packageBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 7, packageBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageBlock

    public class packageBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:141:1: packageBlockEntry : ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression );
    public packageBlockEntry_return packageBlockEntry() // throws RecognitionException [1]
    {   
        packageBlockEntry_return retval = new packageBlockEntry_return();
        retval.start = input.LT(1);
        int packageBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI29 = null;
        modifiers_return mods = null;

        importDefinition_return importDefinition21 = null;

        annotations_return annotations22 = null;

        classDefinition_return classDefinition23 = null;

        interfaceDefinition_return interfaceDefinition24 = null;

        variableDefinition_return variableDefinition25 = null;

        methodDefinition_return methodDefinition26 = null;

        namespaceDefinition_return namespaceDefinition27 = null;

        useNamespaceDirective_return useNamespaceDirective28 = null;

        commentExpression_return commentExpression30 = null;
        
        
        CommonTree SEMI29_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 8) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression )
            int alt13 = 2;
            int LA13_0 = input.LA(1);
            
            if ( ((LA13_0 >= SEMI && LA13_0 <= INTERFACE) || LA13_0 == FUNCTION || (LA13_0 >= NAMESPACE && LA13_0 <= CONST) || (LA13_0 >= IDENT && LA13_0 <= LBRACK) || (LA13_0 >= STATIC && LA13_0 <= DYNAMIC) || LA13_0 == 175 || (LA13_0 >= 181 && LA13_0 <= 185)) )
            {
                alt13 = 1;
            }
            else if ( ((LA13_0 >= SL_COMMENT && LA13_0 <= ML_COMMENT)) )
            {
                alt13 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d13s0 =
                    new NoViableAltException("141:1: packageBlockEntry : ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression );", 13, 0, input);
            
                throw nvae_d13s0;
            }
            switch (alt13) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )
                    	int alt12 = 3;
                    	switch ( input.LA(1) ) 
                    	{
                    	case IMPORT:
                    		{
                    	    alt12 = 1;
                    	    }
                    	    break;
                    	case CLASS:
                    	case INTERFACE:
                    	case FUNCTION:
                    	case NAMESPACE:
                    	case USE:
                    	case VAR:
                    	case CONST:
                    	case IDENT:
                    	case PUBLIC:
                    	case PRIVATE:
                    	case PROTECTED:
                    	case INTERNAL:
                    	case LBRACK:
                    	case STATIC:
                    	case DYNAMIC:
                    	case 175:
                    	case 181:
                    	case 182:
                    	case 183:
                    	case 184:
                    	case 185:
                    		{
                    	    alt12 = 2;
                    	    }
                    	    break;
                    	case SEMI:
                    		{
                    	    alt12 = 3;
                    	    }
                    	    break;
                    		default:
                    		    if ( backtracking > 0 ) {failed = true; return retval;}
                    		    NoViableAltException nvae_d12s0 =
                    		        new NoViableAltException("142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )", 12, 0, input);
                    	
                    		    throw nvae_d12s0;
                    	}
                    	
                    	switch (alt12) 
                    	{
                    	    case 1 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:6: importDefinition
                    	        {
                    	        	PushFollow(FOLLOW_importDefinition_in_packageBlockEntry541);
                    	        	importDefinition21 = importDefinition();
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition21.Tree);
                    	        
                    	        }
                    	        break;
                    	    case 2 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:5: ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )
                    	        {
                    	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:5: ( annotations )?
                    	        	int alt10 = 2;
                    	        	int LA10_0 = input.LA(1);
                    	        	
                    	        	if ( (LA10_0 == LBRACK || LA10_0 == 175) )
                    	        	{
                    	        	    alt10 = 1;
                    	        	}
                    	        	switch (alt10) 
                    	        	{
                    	        	    case 1 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotations
                    	        	        {
                    	        	        	PushFollow(FOLLOW_annotations_in_packageBlockEntry547);
                    	        	        	annotations22 = annotations();
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations22.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	
                    	        	}

                    	        	PushFollow(FOLLOW_modifiers_in_packageBlockEntry555);
                    	        	mods = modifiers();
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:145:4: ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )
                    	        	int alt11 = 6;
                    	        	switch ( input.LA(1) ) 
                    	        	{
                    	        	case CLASS:
                    	        		{
                    	        	    alt11 = 1;
                    	        	    }
                    	        	    break;
                    	        	case INTERFACE:
                    	        		{
                    	        	    alt11 = 2;
                    	        	    }
                    	        	    break;
                    	        	case VAR:
                    	        	case CONST:
                    	        		{
                    	        	    alt11 = 3;
                    	        	    }
                    	        	    break;
                    	        	case FUNCTION:
                    	        		{
                    	        	    alt11 = 4;
                    	        	    }
                    	        	    break;
                    	        	case NAMESPACE:
                    	        		{
                    	        	    alt11 = 5;
                    	        	    }
                    	        	    break;
                    	        	case USE:
                    	        		{
                    	        	    alt11 = 6;
                    	        	    }
                    	        	    break;
                    	        		default:
                    	        		    if ( backtracking > 0 ) {failed = true; return retval;}
                    	        		    NoViableAltException nvae_d11s0 =
                    	        		        new NoViableAltException("145:4: ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )", 11, 0, input);
                    	        	
                    	        		    throw nvae_d11s0;
                    	        	}
                    	        	
                    	        	switch (alt11) 
                    	        	{
                    	        	    case 1 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:145:6: classDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_classDefinition_in_packageBlockEntry563);
                    	        	        	classDefinition23 = classDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, classDefinition23.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 2 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:146:6: interfaceDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_interfaceDefinition_in_packageBlockEntry571);
                    	        	        	interfaceDefinition24 = interfaceDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, interfaceDefinition24.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 3 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:147:6: variableDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_variableDefinition_in_packageBlockEntry579);
                    	        	        	variableDefinition25 = variableDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDefinition25.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 4 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:148:6: methodDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_methodDefinition_in_packageBlockEntry587);
                    	        	        	methodDefinition26 = methodDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, methodDefinition26.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 5 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:149:6: namespaceDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_namespaceDefinition_in_packageBlockEntry595);
                    	        	        	namespaceDefinition27 = namespaceDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceDefinition27.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 6 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:150:6: useNamespaceDirective
                    	        	        {
                    	        	        	PushFollow(FOLLOW_useNamespaceDirective_in_packageBlockEntry603);
                    	        	        	useNamespaceDirective28 = useNamespaceDirective();
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, useNamespaceDirective28.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	
                    	        	}

                    	        
                    	        }
                    	        break;
                    	    case 3 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:152:5: SEMI
                    	        {
                    	        	SEMI29 = (IToken)input.LT(1);
                    	        	Match(input,SEMI,FOLLOW_SEMI_in_packageBlockEntry614); if (failed) return retval;
                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:154:5: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_packageBlockEntry625);
                    	commentExpression30 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression30.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 8, packageBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageBlockEntry

    public class endOfFile_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start endOfFile
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:157:1: endOfFile : EOF ;
    public endOfFile_return endOfFile() // throws RecognitionException [1]
    {   
        endOfFile_return retval = new endOfFile_return();
        retval.start = input.LT(1);
        int endOfFile_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EOF31 = null;
        
        CommonTree EOF31_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 9) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:158:4: ( EOF )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:158:4: EOF
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	EOF31 = (IToken)input.LT(1);
            	Match(input,EOF,FOLLOW_EOF_in_endOfFile636); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 9, endOfFile_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end endOfFile

    public class importDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start importDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:161:1: importDefinition : IMPORT identifierStar semi ;
    public importDefinition_return importDefinition() // throws RecognitionException [1]
    {   
        importDefinition_return retval = new importDefinition_return();
        retval.start = input.LT(1);
        int importDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IMPORT32 = null;
        identifierStar_return identifierStar33 = null;

        semi_return semi34 = null;
        
        
        CommonTree IMPORT32_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 10) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:162:4: ( IMPORT identifierStar semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:162:4: IMPORT identifierStar semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IMPORT32 = (IToken)input.LT(1);
            	Match(input,IMPORT,FOLLOW_IMPORT_in_importDefinition648); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IMPORT32_tree = (CommonTree)adaptor.Create(IMPORT32);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IMPORT32_tree, root_0);
            	}
            	PushFollow(FOLLOW_identifierStar_in_importDefinition651);
            	identifierStar33 = identifierStar();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, identifierStar33.Tree);
            	PushFollow(FOLLOW_semi_in_importDefinition653);
            	semi34 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi34.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 10, importDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end importDefinition

    public class semi_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start semi
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:165:1: semi : ( SEMI | );
    public semi_return semi() // throws RecognitionException [1]
    {   
        semi_return retval = new semi_return();
        retval.start = input.LT(1);
        int semi_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI35 = null;
        
        CommonTree SEMI35_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 11) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: ( SEMI | )
            int alt14 = 2;
            int LA14_0 = input.LA(1);
            
            if ( (LA14_0 == SEMI) )
            {
                int LA14_1 = input.LA(2);
                
                if ( (synpred20()) )
                {
                    alt14 = 1;
                }
                else if ( (true) )
                {
                    alt14 = 2;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d14s1 =
                        new NoViableAltException("165:1: semi : ( SEMI | );", 14, 1, input);
                
                    throw nvae_d14s1;
                }
            }
            else if ( (LA14_0 == EOF || (LA14_0 >= LCURLY && LA14_0 <= RCURLY) || (LA14_0 >= IMPORT && LA14_0 <= INTERFACE) || (LA14_0 >= INCLUDE_DIRECTIVE && LA14_0 <= CONST) || LA14_0 == LPAREN || (LA14_0 >= IF && LA14_0 <= CASE) || (LA14_0 >= DEFAULT && LA14_0 <= FOR) || (LA14_0 >= WHILE && LA14_0 <= XML) || (LA14_0 >= IDENT && LA14_0 <= LBRACK) || (LA14_0 >= STATIC && LA14_0 <= DYNAMIC) || LA14_0 == LT || (LA14_0 >= IS && LA14_0 <= AS) || (LA14_0 >= PLUS && LA14_0 <= DIV) || (LA14_0 >= INC && LA14_0 <= BNOT) || (LA14_0 >= E4X_ATTRI && LA14_0 <= ML_COMMENT) || (LA14_0 >= 175 && LA14_0 <= 177) || (LA14_0 >= 180 && LA14_0 <= 185)) )
            {
                alt14 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d14s0 =
                    new NoViableAltException("165:1: semi : ( SEMI | );", 14, 0, input);
            
                throw nvae_d14s0;
            }
            switch (alt14) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI35 = (IToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_semi664); if (failed) return retval;
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:168:2: 
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 11, semi_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end semi

    public class classDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start classDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:170:1: classDefinition[CommonTree mods] : CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) ;
    public classDefinition_return classDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        classDefinition_return retval = new classDefinition_return();
        retval.start = input.LT(1);
        int classDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CLASS36 = null;
        ident_return ident37 = null;

        classExtendsClause_return classExtendsClause38 = null;

        implementsClause_return implementsClause39 = null;

        typeBlock_return typeBlock40 = null;
        
        
        CommonTree CLASS36_tree=null;
        RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor,"token CLASS");
        RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
        RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 12) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: ( CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: CLASS ident classExtendsClause implementsClause typeBlock
            {
            	CLASS36 = (IToken)input.LT(1);
            	Match(input,CLASS,FOLLOW_CLASS_in_classDefinition681); if (failed) return retval;
            	if ( backtracking==0 ) stream_CLASS.Add(CLASS36);

            	PushFollow(FOLLOW_ident_in_classDefinition683);
            	ident37 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident37.Tree);
            	PushFollow(FOLLOW_classExtendsClause_in_classDefinition687);
            	classExtendsClause38 = classExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_classExtendsClause.Add(classExtendsClause38.Tree);
            	PushFollow(FOLLOW_implementsClause_in_classDefinition691);
            	implementsClause39 = implementsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_implementsClause.Add(implementsClause39.Tree);
            	PushFollow(FOLLOW_typeBlock_in_classDefinition695);
            	typeBlock40 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock40.Tree);
            	
            	// AST REWRITE
            	// elements:          classExtendsClause, implementsClause, typeBlock, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 175:3: -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:175:6: ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_classExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_implementsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 12, classDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end classDefinition

    public class as2ClassDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2ClassDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:178:1: as2ClassDefinition[CommonTree mods] : CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) ;
    public as2ClassDefinition_return as2ClassDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2ClassDefinition_return retval = new as2ClassDefinition_return();
        retval.start = input.LT(1);
        int as2ClassDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CLASS41 = null;
        identifier_return identifier42 = null;

        classExtendsClause_return classExtendsClause43 = null;

        implementsClause_return implementsClause44 = null;

        typeBlock_return typeBlock45 = null;
        
        
        CommonTree CLASS41_tree=null;
        RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor,"token CLASS");
        RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
        RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 13) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: ( CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: CLASS identifier classExtendsClause implementsClause typeBlock
            {
            	CLASS41 = (IToken)input.LT(1);
            	Match(input,CLASS,FOLLOW_CLASS_in_as2ClassDefinition725); if (failed) return retval;
            	if ( backtracking==0 ) stream_CLASS.Add(CLASS41);

            	PushFollow(FOLLOW_identifier_in_as2ClassDefinition727);
            	identifier42 = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(identifier42.Tree);
            	PushFollow(FOLLOW_classExtendsClause_in_as2ClassDefinition731);
            	classExtendsClause43 = classExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_classExtendsClause.Add(classExtendsClause43.Tree);
            	PushFollow(FOLLOW_implementsClause_in_as2ClassDefinition735);
            	implementsClause44 = implementsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_implementsClause.Add(implementsClause44.Tree);
            	PushFollow(FOLLOW_typeBlock_in_as2ClassDefinition739);
            	typeBlock45 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock45.Tree);
            	
            	// AST REWRITE
            	// elements:          typeBlock, implementsClause, classExtendsClause, identifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 183:3: -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:183:6: ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_classExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_implementsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 13, as2ClassDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2ClassDefinition

    public class interfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:186:1: interfaceDefinition[CommonTree mods] : INTERFACE ident interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock ) ;
    public interfaceDefinition_return interfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        interfaceDefinition_return retval = new interfaceDefinition_return();
        retval.start = input.LT(1);
        int interfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INTERFACE46 = null;
        ident_return ident47 = null;

        interfaceExtendsClause_return interfaceExtendsClause48 = null;

        interfaceTypeBlock_return interfaceTypeBlock49 = null;
        
        
        CommonTree INTERFACE46_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_interfaceTypeBlock = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlock");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 14) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:188:4: ( INTERFACE ident interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:188:4: INTERFACE ident interfaceExtendsClause interfaceTypeBlock
            {
            	INTERFACE46 = (IToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_interfaceDefinition774); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(INTERFACE46);

            	PushFollow(FOLLOW_ident_in_interfaceDefinition776);
            	ident47 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident47.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_interfaceDefinition780);
            	interfaceExtendsClause48 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause48.Tree);
            	PushFollow(FOLLOW_interfaceTypeBlock_in_interfaceDefinition784);
            	interfaceTypeBlock49 = interfaceTypeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceTypeBlock.Add(interfaceTypeBlock49.Tree);
            	
            	// AST REWRITE
            	// elements:          interfaceTypeBlock, ident, interfaceExtendsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 191:3: -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:191:6: ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_interfaceTypeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 14, interfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceDefinition

    public class as2InterfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2InterfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:1: as2InterfaceDefinition[CommonTree mods] : INTERFACE identifier interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock ) ;
    public as2InterfaceDefinition_return as2InterfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2InterfaceDefinition_return retval = new as2InterfaceDefinition_return();
        retval.start = input.LT(1);
        int as2InterfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INTERFACE50 = null;
        identifier_return identifier51 = null;

        interfaceExtendsClause_return interfaceExtendsClause52 = null;

        interfaceTypeBlock_return interfaceTypeBlock53 = null;
        
        
        CommonTree INTERFACE50_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_interfaceTypeBlock = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlock");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 15) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: ( INTERFACE identifier interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: INTERFACE identifier interfaceExtendsClause interfaceTypeBlock
            {
            	INTERFACE50 = (IToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_as2InterfaceDefinition817); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(INTERFACE50);

            	PushFollow(FOLLOW_identifier_in_as2InterfaceDefinition819);
            	identifier51 = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(identifier51.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition823);
            	interfaceExtendsClause52 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause52.Tree);
            	PushFollow(FOLLOW_interfaceTypeBlock_in_as2InterfaceDefinition827);
            	interfaceTypeBlock53 = interfaceTypeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceTypeBlock.Add(interfaceTypeBlock53.Tree);
            	
            	// AST REWRITE
            	// elements:          identifier, interfaceTypeBlock, interfaceExtendsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 199:3: -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:6: ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_interfaceTypeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 15, as2InterfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2InterfaceDefinition

    public class classExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start classExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:202:1: classExtendsClause : ( EXTENDS identifier )? ;
    public classExtendsClause_return classExtendsClause() // throws RecognitionException [1]
    {   
        classExtendsClause_return retval = new classExtendsClause_return();
        retval.start = input.LT(1);
        int classExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EXTENDS54 = null;
        identifier_return identifier55 = null;
        
        
        CommonTree EXTENDS54_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 16) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( ( EXTENDS identifier )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( EXTENDS identifier )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( EXTENDS identifier )?
            	int alt15 = 2;
            	int LA15_0 = input.LA(1);
            	
            	if ( (LA15_0 == EXTENDS) )
            	{
            	    alt15 = 1;
            	}
            	switch (alt15) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:5: EXTENDS identifier
            	        {
            	        	EXTENDS54 = (IToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_classExtendsClause855); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	EXTENDS54_tree = (CommonTree)adaptor.Create(EXTENDS54);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS54_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_classExtendsClause858);
            	        	identifier55 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier55.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 16, classExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end classExtendsClause

    public class interfaceExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:205:1: interfaceExtendsClause : ( EXTENDS identifier ( COMMA identifier )* )? ;
    public interfaceExtendsClause_return interfaceExtendsClause() // throws RecognitionException [1]
    {   
        interfaceExtendsClause_return retval = new interfaceExtendsClause_return();
        retval.start = input.LT(1);
        int interfaceExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EXTENDS56 = null;
        IToken COMMA58 = null;
        identifier_return identifier57 = null;

        identifier_return identifier59 = null;
        
        
        CommonTree EXTENDS56_tree=null;
        CommonTree COMMA58_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 17) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( ( EXTENDS identifier ( COMMA identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( EXTENDS identifier ( COMMA identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( EXTENDS identifier ( COMMA identifier )* )?
            	int alt17 = 2;
            	int LA17_0 = input.LA(1);
            	
            	if ( (LA17_0 == EXTENDS) )
            	{
            	    alt17 = 1;
            	}
            	switch (alt17) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:5: EXTENDS identifier ( COMMA identifier )*
            	        {
            	        	EXTENDS56 = (IToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_interfaceExtendsClause871); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	EXTENDS56_tree = (CommonTree)adaptor.Create(EXTENDS56);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS56_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause874);
            	        	identifier57 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier57.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:25: ( COMMA identifier )*
            	        	do 
            	        	{
            	        	    int alt16 = 2;
            	        	    int LA16_0 = input.LA(1);
            	        	    
            	        	    if ( (LA16_0 == COMMA) )
            	        	    {
            	        	        alt16 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt16) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:27: COMMA identifier
            	        			    {
            	        			    	COMMA58 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_interfaceExtendsClause878); if (failed) return retval;
            	        			    	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause881);
            	        			    	identifier59 = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier59.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop16;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop16:
            	        		;	// Stops C# compiler whinging that label 'loop16' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 17, interfaceExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceExtendsClause

    public class implementsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start implementsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:208:1: implementsClause : ( IMPLEMENTS identifier ( COMMA identifier )* )? ;
    public implementsClause_return implementsClause() // throws RecognitionException [1]
    {   
        implementsClause_return retval = new implementsClause_return();
        retval.start = input.LT(1);
        int implementsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IMPLEMENTS60 = null;
        IToken COMMA62 = null;
        identifier_return identifier61 = null;

        identifier_return identifier63 = null;
        
        
        CommonTree IMPLEMENTS60_tree=null;
        CommonTree COMMA62_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 18) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( ( IMPLEMENTS identifier ( COMMA identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
            	int alt19 = 2;
            	int LA19_0 = input.LA(1);
            	
            	if ( (LA19_0 == IMPLEMENTS) )
            	{
            	    alt19 = 1;
            	}
            	switch (alt19) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:5: IMPLEMENTS identifier ( COMMA identifier )*
            	        {
            	        	IMPLEMENTS60 = (IToken)input.LT(1);
            	        	Match(input,IMPLEMENTS,FOLLOW_IMPLEMENTS_in_implementsClause896); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	IMPLEMENTS60_tree = (CommonTree)adaptor.Create(IMPLEMENTS60);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(IMPLEMENTS60_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_implementsClause899);
            	        	identifier61 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier61.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:28: ( COMMA identifier )*
            	        	do 
            	        	{
            	        	    int alt18 = 2;
            	        	    int LA18_0 = input.LA(1);
            	        	    
            	        	    if ( (LA18_0 == COMMA) )
            	        	    {
            	        	        alt18 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt18) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:30: COMMA identifier
            	        			    {
            	        			    	COMMA62 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_implementsClause903); if (failed) return retval;
            	        			    	PushFollow(FOLLOW_identifier_in_implementsClause906);
            	        			    	identifier63 = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier63.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop18;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop18:
            	        		;	// Stops C# compiler whinging that label 'loop18' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 18, implementsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end implementsClause

    public class interfaceTypeBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceTypeBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:212:1: interfaceTypeBlock : LCURLY ( interfaceTypeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* ) ;
    public interfaceTypeBlock_return interfaceTypeBlock() // throws RecognitionException [1]
    {   
        interfaceTypeBlock_return retval = new interfaceTypeBlock_return();
        retval.start = input.LT(1);
        int interfaceTypeBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY64 = null;
        IToken RCURLY66 = null;
        interfaceTypeBlockEntry_return interfaceTypeBlockEntry65 = null;
        
        
        CommonTree LCURLY64_tree=null;
        CommonTree RCURLY66_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_interfaceTypeBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 19) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:213:4: ( LCURLY ( interfaceTypeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:213:4: LCURLY ( interfaceTypeBlockEntry )* RCURLY
            {
            	LCURLY64 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_interfaceTypeBlock923); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY64);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:214:3: ( interfaceTypeBlockEntry )*
            	do 
            	{
            	    int alt20 = 2;
            	    int LA20_0 = input.LA(1);
            	    
            	    if ( (LA20_0 == IMPORT || LA20_0 == INCLUDE_DIRECTIVE || LA20_0 == FUNCTION || (LA20_0 >= IDENT && LA20_0 <= LBRACK) || (LA20_0 >= STATIC && LA20_0 <= DYNAMIC) || (LA20_0 >= SL_COMMENT && LA20_0 <= ML_COMMENT) || LA20_0 == 175 || (LA20_0 >= 181 && LA20_0 <= 185)) )
            	    {
            	        alt20 = 1;
            	    }
            	    
            	
            	    switch (alt20) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: interfaceTypeBlockEntry
            			    {
            			    	PushFollow(FOLLOW_interfaceTypeBlockEntry_in_interfaceTypeBlock927);
            			    	interfaceTypeBlockEntry65 = interfaceTypeBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_interfaceTypeBlockEntry.Add(interfaceTypeBlockEntry65.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop20;
            	    }
            	} while (true);
            	
            	loop20:
            		;	// Stops C# compiler whinging that label 'loop20' has no statements

            	RCURLY66 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_interfaceTypeBlock932); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY66);

            	
            	// AST REWRITE
            	// elements:          interfaceTypeBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 216:3: -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:216:6: ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:216:19: ( interfaceTypeBlockEntry )*
            	    while ( stream_interfaceTypeBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_interfaceTypeBlockEntry.Next());
            	    
            	    }
            	    stream_interfaceTypeBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 19, interfaceTypeBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceTypeBlock

    public class typeBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:219:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) ;
    public typeBlock_return typeBlock() // throws RecognitionException [1]
    {   
        typeBlock_return retval = new typeBlock_return();
        retval.start = input.LT(1);
        int typeBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY67 = null;
        IToken RCURLY69 = null;
        typeBlockEntry_return typeBlockEntry68 = null;
        
        
        CommonTree LCURLY67_tree=null;
        CommonTree RCURLY69_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_typeBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule typeBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 20) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:4: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:4: LCURLY ( typeBlockEntry )* RCURLY
            {
            	LCURLY67 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_typeBlock955); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY67);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:221:3: ( typeBlockEntry )*
            	do 
            	{
            	    int alt21 = 2;
            	    int LA21_0 = input.LA(1);
            	    
            	    if ( (LA21_0 == IMPORT || LA21_0 == INCLUDE_DIRECTIVE || LA21_0 == FUNCTION || (LA21_0 >= VAR && LA21_0 <= CONST) || (LA21_0 >= IDENT && LA21_0 <= LBRACK) || (LA21_0 >= STATIC && LA21_0 <= DYNAMIC) || (LA21_0 >= SL_COMMENT && LA21_0 <= ML_COMMENT) || LA21_0 == 175 || (LA21_0 >= 181 && LA21_0 <= 185)) )
            	    {
            	        alt21 = 1;
            	    }
            	    
            	
            	    switch (alt21) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeBlockEntry
            			    {
            			    	PushFollow(FOLLOW_typeBlockEntry_in_typeBlock959);
            			    	typeBlockEntry68 = typeBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_typeBlockEntry.Add(typeBlockEntry68.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop21;
            	    }
            	} while (true);
            	
            	loop21:
            		;	// Stops C# compiler whinging that label 'loop21' has no statements

            	RCURLY69 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_typeBlock964); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY69);

            	
            	// AST REWRITE
            	// elements:          typeBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 223:3: -> ^( TYPE_BLOCK ( typeBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:223:6: ^( TYPE_BLOCK ( typeBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:223:19: ( typeBlockEntry )*
            	    while ( stream_typeBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeBlockEntry.Next());
            	    
            	    }
            	    stream_typeBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 20, typeBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlock

    public class interfaceTypeBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceTypeBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:226:1: interfaceTypeBlockEntry : (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );
    public interfaceTypeBlockEntry_return interfaceTypeBlockEntry() // throws RecognitionException [1]
    {   
        interfaceTypeBlockEntry_return retval = new interfaceTypeBlockEntry_return();
        retval.start = input.LT(1);
        int interfaceTypeBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return m = null;

        interfaceMethodDefinition_return interfaceMethodDefinition70 = null;

        importDefinition_return importDefinition71 = null;

        as2IncludeDirective_return as2IncludeDirective72 = null;

        commentExpression_return commentExpression73 = null;

        annotations_return annotations74 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 21) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:227:4: (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations )
            int alt22 = 5;
            switch ( input.LA(1) ) 
            {
            case FUNCTION:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case STATIC:
            case DYNAMIC:
            case 181:
            case 182:
            case 183:
            case 184:
            case 185:
            	{
                alt22 = 1;
                }
                break;
            case IMPORT:
            	{
                alt22 = 2;
                }
                break;
            case INCLUDE_DIRECTIVE:
            	{
                alt22 = 3;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt22 = 4;
                }
                break;
            case LBRACK:
            case 175:
            	{
                alt22 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d22s0 =
            	        new NoViableAltException("226:1: interfaceTypeBlockEntry : (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );", 22, 0, input);
            
            	    throw nvae_d22s0;
            }
            
            switch (alt22) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:227:4: m= modifiers ( interfaceMethodDefinition[$m.tree] )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_modifiers_in_interfaceTypeBlockEntry988);
                    	m = modifiers();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:228:3: ( interfaceMethodDefinition[$m.tree] )
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:229:4: interfaceMethodDefinition[$m.tree]
                    	{
                    		PushFollow(FOLLOW_interfaceMethodDefinition_in_interfaceTypeBlockEntry999);
                    		interfaceMethodDefinition70 = interfaceMethodDefinition(((CommonTree)m.tree));
                    		followingStackPointer_--;
                    		if (failed) return retval;
                    		if ( backtracking==0 ) adaptor.AddChild(root_0, interfaceMethodDefinition70.Tree);
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:231:4: importDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_importDefinition_in_interfaceTypeBlockEntry1009);
                    	importDefinition71 = importDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition71.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:232:4: as2IncludeDirective
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_as2IncludeDirective_in_interfaceTypeBlockEntry1014);
                    	as2IncludeDirective72 = as2IncludeDirective();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, as2IncludeDirective72.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:233:4: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_interfaceTypeBlockEntry1019);
                    	commentExpression73 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression73.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:234:4: annotations
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_annotations_in_interfaceTypeBlockEntry1024);
                    	annotations74 = annotations();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations74.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 21, interfaceTypeBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceTypeBlockEntry

    public class typeBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:237:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );
    public typeBlockEntry_return typeBlockEntry() // throws RecognitionException [1]
    {   
        typeBlockEntry_return retval = new typeBlockEntry_return();
        retval.start = input.LT(1);
        int typeBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return m = null;

        variableDefinition_return variableDefinition75 = null;

        methodDefinition_return methodDefinition76 = null;

        importDefinition_return importDefinition77 = null;

        as2IncludeDirective_return as2IncludeDirective78 = null;

        commentExpression_return commentExpression79 = null;

        annotations_return annotations80 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 22) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:238:4: (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations )
            int alt24 = 5;
            switch ( input.LA(1) ) 
            {
            case FUNCTION:
            case VAR:
            case CONST:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case STATIC:
            case DYNAMIC:
            case 181:
            case 182:
            case 183:
            case 184:
            case 185:
            	{
                alt24 = 1;
                }
                break;
            case IMPORT:
            	{
                alt24 = 2;
                }
                break;
            case INCLUDE_DIRECTIVE:
            	{
                alt24 = 3;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt24 = 4;
                }
                break;
            case LBRACK:
            case 175:
            	{
                alt24 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d24s0 =
            	        new NoViableAltException("237:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );", 24, 0, input);
            
            	    throw nvae_d24s0;
            }
            
            switch (alt24) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:238:4: m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_modifiers_in_typeBlockEntry1037);
                    	m = modifiers();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:239:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    	int alt23 = 2;
                    	int LA23_0 = input.LA(1);
                    	
                    	if ( ((LA23_0 >= VAR && LA23_0 <= CONST)) )
                    	{
                    	    alt23 = 1;
                    	}
                    	else if ( (LA23_0 == FUNCTION) )
                    	{
                    	    alt23 = 2;
                    	}
                    	else 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    NoViableAltException nvae_d23s0 =
                    	        new NoViableAltException("239:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )", 23, 0, input);
                    	
                    	    throw nvae_d23s0;
                    	}
                    	switch (alt23) 
                    	{
                    	    case 1 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:239:5: variableDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_variableDefinition_in_typeBlockEntry1044);
                    	        	variableDefinition75 = variableDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDefinition75.Tree);
                    	        
                    	        }
                    	        break;
                    	    case 2 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:240:5: methodDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_methodDefinition_in_typeBlockEntry1051);
                    	        	methodDefinition76 = methodDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, methodDefinition76.Tree);
                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:242:4: importDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_importDefinition_in_typeBlockEntry1061);
                    	importDefinition77 = importDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition77.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:243:4: as2IncludeDirective
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_as2IncludeDirective_in_typeBlockEntry1066);
                    	as2IncludeDirective78 = as2IncludeDirective();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, as2IncludeDirective78.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:244:4: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_typeBlockEntry1071);
                    	commentExpression79 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression79.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:245:4: annotations
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_annotations_in_typeBlockEntry1076);
                    	annotations80 = annotations();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations80.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 22, typeBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlockEntry

    public class as2IncludeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2IncludeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:248:1: as2IncludeDirective : INCLUDE_DIRECTIVE STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) ;
    public as2IncludeDirective_return as2IncludeDirective() // throws RecognitionException [1]
    {   
        as2IncludeDirective_return retval = new as2IncludeDirective_return();
        retval.start = input.LT(1);
        int as2IncludeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INCLUDE_DIRECTIVE81 = null;
        IToken STRING_LITERAL82 = null;
        
        CommonTree INCLUDE_DIRECTIVE81_tree=null;
        CommonTree STRING_LITERAL82_tree=null;
        RewriteRuleTokenStream stream_INCLUDE_DIRECTIVE = new RewriteRuleTokenStream(adaptor,"token INCLUDE_DIRECTIVE");
        RewriteRuleTokenStream stream_STRING_LITERAL = new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 23) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:249:4: ( INCLUDE_DIRECTIVE STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:249:4: INCLUDE_DIRECTIVE STRING_LITERAL
            {
            	INCLUDE_DIRECTIVE81 = (IToken)input.LT(1);
            	Match(input,INCLUDE_DIRECTIVE,FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1087); if (failed) return retval;
            	if ( backtracking==0 ) stream_INCLUDE_DIRECTIVE.Add(INCLUDE_DIRECTIVE81);

            	STRING_LITERAL82 = (IToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_as2IncludeDirective1089); if (failed) return retval;
            	if ( backtracking==0 ) stream_STRING_LITERAL.Add(STRING_LITERAL82);

            	
            	// AST REWRITE
            	// elements:          INCLUDE_DIRECTIVE, STRING_LITERAL
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 249:37: -> ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:249:40: ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_INCLUDE_DIRECTIVE.Next(), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_STRING_LITERAL.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 23, as2IncludeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2IncludeDirective

    public class includeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start includeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:252:1: includeDirective : 'include' STRING_LITERAL semi ;
    public includeDirective_return includeDirective() // throws RecognitionException [1]
    {   
        includeDirective_return retval = new includeDirective_return();
        retval.start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal83 = null;
        IToken STRING_LITERAL84 = null;
        semi_return semi85 = null;
        
        
        CommonTree string_literal83_tree=null;
        CommonTree STRING_LITERAL84_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 24) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:253:4: ( 'include' STRING_LITERAL semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:253:4: 'include' STRING_LITERAL semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal83 = (IToken)input.LT(1);
            	Match(input,175,FOLLOW_175_in_includeDirective1108); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal83_tree = (CommonTree)adaptor.Create(string_literal83);
            	adaptor.AddChild(root_0, string_literal83_tree);
            	}
            	STRING_LITERAL84 = (IToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_includeDirective1112); if (failed) return retval;
            	if ( backtracking==0 ) {
            	STRING_LITERAL84_tree = (CommonTree)adaptor.Create(STRING_LITERAL84);
            	adaptor.AddChild(root_0, STRING_LITERAL84_tree);
            	}
            	PushFollow(FOLLOW_semi_in_includeDirective1116);
            	semi85 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi85.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 24, includeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end includeDirective

    public class interfaceMethodDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceMethodDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:258:1: interfaceMethodDefinition[CommonTree mods] : FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( semi ) -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ) ;
    public interfaceMethodDefinition_return interfaceMethodDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        interfaceMethodDefinition_return retval = new interfaceMethodDefinition_return();
        retval.start = input.LT(1);
        int interfaceMethodDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken FUNCTION86 = null;
        optionalAccessorRole_return r = null;

        ident_return ident87 = null;

        parameterDeclarationList_return parameterDeclarationList88 = null;

        typeExpression_return typeExpression89 = null;

        commentExpression_return commentExpression90 = null;

        semi_return semi91 = null;
        
        
        CommonTree FUNCTION86_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor,"rule optionalAccessorRole");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_commentExpression = new RewriteRuleSubtreeStream(adaptor,"rule commentExpression");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 25) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:259:4: ( FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( semi ) -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:259:4: FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( semi )
            {
            	FUNCTION86 = (IToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_interfaceMethodDefinition1128); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION86);

            	PushFollow(FOLLOW_optionalAccessorRole_in_interfaceMethodDefinition1134);
            	r = optionalAccessorRole();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_optionalAccessorRole.Add(r.Tree);
            	PushFollow(FOLLOW_ident_in_interfaceMethodDefinition1138);
            	ident87 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident87.Tree);
            	PushFollow(FOLLOW_parameterDeclarationList_in_interfaceMethodDefinition1142);
            	parameterDeclarationList88 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList88.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:263:3: ( typeExpression )?
            	int alt25 = 2;
            	int LA25_0 = input.LA(1);
            	
            	if ( (LA25_0 == COLON) )
            	{
            	    alt25 = 1;
            	}
            	switch (alt25) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_interfaceMethodDefinition1146);
            	        	typeExpression89 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression89.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:264:3: ( commentExpression )?
            	int alt26 = 2;
            	int LA26_0 = input.LA(1);
            	
            	if ( (LA26_0 == SL_COMMENT) )
            	{
            	    int LA26_1 = input.LA(2);
            	    
            	    if ( (synpred38()) )
            	    {
            	        alt26 = 1;
            	    }
            	}
            	else if ( (LA26_0 == ML_COMMENT) )
            	{
            	    int LA26_2 = input.LA(2);
            	    
            	    if ( (synpred38()) )
            	    {
            	        alt26 = 1;
            	    }
            	}
            	switch (alt26) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_interfaceMethodDefinition1151);
            	        	commentExpression90 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_commentExpression.Add(commentExpression90.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:265:3: ( semi )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:265:4: semi
            	{
            		PushFollow(FOLLOW_semi_in_interfaceMethodDefinition1157);
            		semi91 = semi();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_semi.Add(semi91.Tree);
            	
            	}

            	
            	// AST REWRITE
            	// elements:          commentExpression, typeExpression, ident, parameterDeclarationList, optionalAccessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 266:3: -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:266:6: ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IMETHOD_DEF, "IMETHOD_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:269:7: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:270:7: ( commentExpression )?
            	    if ( stream_commentExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_commentExpression.Next());
            	    
            	    }
            	    stream_commentExpression.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 25, interfaceMethodDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceMethodDefinition

    public class methodDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start methodDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:274:1: methodDefinition[CommonTree mods] : FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block )? ) ;
    public methodDefinition_return methodDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        methodDefinition_return retval = new methodDefinition_return();
        retval.start = input.LT(1);
        int methodDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken FUNCTION92 = null;
        optionalAccessorRole_return r = null;

        ident_return ident93 = null;

        parameterDeclarationList_return parameterDeclarationList94 = null;

        typeExpression_return typeExpression95 = null;

        commentExpression_return commentExpression96 = null;

        block_return block97 = null;

        semi_return semi98 = null;
        
        
        CommonTree FUNCTION92_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor,"rule optionalAccessorRole");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_commentExpression = new RewriteRuleSubtreeStream(adaptor,"rule commentExpression");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 26) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:275:4: ( FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:275:4: FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block | semi )
            {
            	FUNCTION92 = (IToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_methodDefinition1232); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION92);

            	PushFollow(FOLLOW_optionalAccessorRole_in_methodDefinition1238);
            	r = optionalAccessorRole();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_optionalAccessorRole.Add(r.Tree);
            	PushFollow(FOLLOW_ident_in_methodDefinition1242);
            	ident93 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident93.Tree);
            	PushFollow(FOLLOW_parameterDeclarationList_in_methodDefinition1246);
            	parameterDeclarationList94 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList94.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:279:3: ( typeExpression )?
            	int alt27 = 2;
            	int LA27_0 = input.LA(1);
            	
            	if ( (LA27_0 == COLON) )
            	{
            	    alt27 = 1;
            	}
            	switch (alt27) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_methodDefinition1250);
            	        	typeExpression95 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression95.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:280:3: ( commentExpression )?
            	int alt28 = 2;
            	int LA28_0 = input.LA(1);
            	
            	if ( (LA28_0 == SL_COMMENT) )
            	{
            	    int LA28_1 = input.LA(2);
            	    
            	    if ( (synpred40()) )
            	    {
            	        alt28 = 1;
            	    }
            	}
            	else if ( (LA28_0 == ML_COMMENT) )
            	{
            	    int LA28_2 = input.LA(2);
            	    
            	    if ( (synpred40()) )
            	    {
            	        alt28 = 1;
            	    }
            	}
            	switch (alt28) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_methodDefinition1255);
            	        	commentExpression96 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_commentExpression.Add(commentExpression96.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:3: ( block | semi )
            	int alt29 = 2;
            	int LA29_0 = input.LA(1);
            	
            	if ( (LA29_0 == LCURLY) )
            	{
            	    alt29 = 1;
            	}
            	else if ( (LA29_0 == EOF || (LA29_0 >= RCURLY && LA29_0 <= INTERFACE) || LA29_0 == INCLUDE_DIRECTIVE || LA29_0 == FUNCTION || (LA29_0 >= NAMESPACE && LA29_0 <= CONST) || (LA29_0 >= IDENT && LA29_0 <= LBRACK) || (LA29_0 >= STATIC && LA29_0 <= DYNAMIC) || (LA29_0 >= SL_COMMENT && LA29_0 <= ML_COMMENT) || LA29_0 == 175 || (LA29_0 >= 181 && LA29_0 <= 185)) )
            	{
            	    alt29 = 2;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d29s0 =
            	        new NoViableAltException("281:3: ( block | semi )", 29, 0, input);
            	
            	    throw nvae_d29s0;
            	}
            	switch (alt29) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:4: block
            	        {
            	        	PushFollow(FOLLOW_block_in_methodDefinition1261);
            	        	block97 = block();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_block.Add(block97.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:10: semi
            	        {
            	        	PushFollow(FOLLOW_semi_in_methodDefinition1263);
            	        	semi98 = semi();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_semi.Add(semi98.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          typeExpression, block, commentExpression, parameterDeclarationList, ident, optionalAccessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 282:3: -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:282:6: ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( commentExpression )? ( block )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:285:7: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:286:7: ( commentExpression )?
            	    if ( stream_commentExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_commentExpression.Next());
            	    
            	    }
            	    stream_commentExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:287:7: ( block )?
            	    if ( stream_block.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    }
            	    stream_block.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 26, methodDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end methodDefinition

    public class optionalAccessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start optionalAccessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:1: optionalAccessorRole : ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) ;
    public optionalAccessorRole_return optionalAccessorRole() // throws RecognitionException [1]
    {   
        optionalAccessorRole_return retval = new optionalAccessorRole_return();
        retval.start = input.LT(1);
        int optionalAccessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        accessorRole_return accessorRole99 = null;
        
        
        RewriteRuleSubtreeStream stream_accessorRole = new RewriteRuleSubtreeStream(adaptor,"rule accessorRole");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 27) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:292:4: ( ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:292:4: ( accessorRole )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:292:4: ( accessorRole )?
            	int alt30 = 2;
            	int LA30_0 = input.LA(1);
            	
            	if ( (LA30_0 == GET) )
            	{
            	    int LA30_1 = input.LA(2);
            	    
            	    if ( ((LA30_1 >= GET && LA30_1 <= USE) || LA30_1 == XML || LA30_1 == IDENT || LA30_1 == DYNAMIC || (LA30_1 >= IS && LA30_1 <= AS)) )
            	    {
            	        alt30 = 1;
            	    }
            	}
            	else if ( (LA30_0 == SET) )
            	{
            	    int LA30_9 = input.LA(2);
            	    
            	    if ( ((LA30_9 >= GET && LA30_9 <= USE) || LA30_9 == XML || LA30_9 == IDENT || LA30_9 == DYNAMIC || (LA30_9 >= IS && LA30_9 <= AS)) )
            	    {
            	        alt30 = 1;
            	    }
            	}
            	switch (alt30) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: accessorRole
            	        {
            	        	PushFollow(FOLLOW_accessorRole_in_optionalAccessorRole1346);
            	        	accessorRole99 = accessorRole();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_accessorRole.Add(accessorRole99.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          accessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 293:3: -> ^( ACCESSOR_ROLE ( accessorRole )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:6: ^( ACCESSOR_ROLE ( accessorRole )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ACCESSOR_ROLE, "ACCESSOR_ROLE"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:22: ( accessorRole )?
            	    if ( stream_accessorRole.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_accessorRole.Next());
            	    
            	    }
            	    stream_accessorRole.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 27, optionalAccessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end optionalAccessorRole

    public class accessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start accessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:296:1: accessorRole : ( GET | SET );
    public accessorRole_return accessorRole() // throws RecognitionException [1]
    {   
        accessorRole_return retval = new accessorRole_return();
        retval.start = input.LT(1);
        int accessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set100 = null;
        
        CommonTree set100_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 28) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:297:4: ( GET | SET )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set100 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= GET && input.LA(1) <= SET) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set100));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_accessorRole0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 28, accessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end accessorRole

    public class namespaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start namespaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:1: namespaceDefinition[CommonTree mods] : NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) ;
    public namespaceDefinition_return namespaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        namespaceDefinition_return retval = new namespaceDefinition_return();
        retval.start = input.LT(1);
        int namespaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NAMESPACE101 = null;
        ident_return ident102 = null;
        
        
        CommonTree NAMESPACE101_tree=null;
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 29) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:301:4: ( NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:301:4: NAMESPACE ident
            {
            	NAMESPACE101 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespaceDefinition1385); if (failed) return retval;
            	if ( backtracking==0 ) stream_NAMESPACE.Add(NAMESPACE101);

            	PushFollow(FOLLOW_ident_in_namespaceDefinition1387);
            	ident102 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident102.Tree);
            	
            	// AST REWRITE
            	// elements:          NAMESPACE, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 302:3: -> ^( NAMESPACE_DEF NAMESPACE ident )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:302:6: ^( NAMESPACE_DEF NAMESPACE ident )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_NAMESPACE.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 29, namespaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end namespaceDefinition

    public class useNamespaceDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start useNamespaceDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:305:1: useNamespaceDirective : USE NAMESPACE ident semi ;
    public useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
    {   
        useNamespaceDirective_return retval = new useNamespaceDirective_return();
        retval.start = input.LT(1);
        int useNamespaceDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken USE103 = null;
        IToken NAMESPACE104 = null;
        ident_return ident105 = null;

        semi_return semi106 = null;
        
        
        CommonTree USE103_tree=null;
        CommonTree NAMESPACE104_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 30) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:306:4: ( USE NAMESPACE ident semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:306:4: USE NAMESPACE ident semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	USE103 = (IToken)input.LT(1);
            	Match(input,USE,FOLLOW_USE_in_useNamespaceDirective1412); if (failed) return retval;
            	if ( backtracking==0 ) {
            	USE103_tree = (CommonTree)adaptor.Create(USE103);
            	adaptor.AddChild(root_0, USE103_tree);
            	}
            	NAMESPACE104 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_useNamespaceDirective1414); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NAMESPACE104_tree = (CommonTree)adaptor.Create(NAMESPACE104);
            	adaptor.AddChild(root_0, NAMESPACE104_tree);
            	}
            	PushFollow(FOLLOW_ident_in_useNamespaceDirective1416);
            	ident105 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident105.Tree);
            	PushFollow(FOLLOW_semi_in_useNamespaceDirective1418);
            	semi106 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi106.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 30, useNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end useNamespaceDirective

    public class variableDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:309:1: variableDefinition[CommonTree mods] : decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) ;
    public variableDefinition_return variableDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        variableDefinition_return retval = new variableDefinition_return();
        retval.start = input.LT(1);
        int variableDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA108 = null;
        varOrConst_return decl = null;

        variableDeclarator_return variableDeclarator107 = null;

        variableDeclarator_return variableDeclarator109 = null;

        semi_return semi110 = null;
        
        
        CommonTree COMMA108_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_varOrConst = new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
        RewriteRuleSubtreeStream stream_variableDeclarator = new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 31) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:314:4: (decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:314:4: decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi
            {
            	PushFollow(FOLLOW_varOrConst_in_variableDefinition1442);
            	decl = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_varOrConst.Add(decl.Tree);
            	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1444);
            	variableDeclarator107 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator107.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:3: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt31 = 2;
            	    int LA31_0 = input.LA(1);
            	    
            	    if ( (LA31_0 == COMMA) )
            	    {
            	        alt31 = 1;
            	    }
            	    
            	
            	    switch (alt31) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:4: COMMA variableDeclarator
            			    {
            			    	COMMA108 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_variableDefinition1449); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA108);

            			    	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1451);
            			    	variableDeclarator109 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator109.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop31;
            	    }
            	} while (true);
            	
            	loop31:
            		;	// Stops C# compiler whinging that label 'loop31' has no statements

            	PushFollow(FOLLOW_semi_in_variableDefinition1457);
            	semi110 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi110.Tree);
            	
            	// AST REWRITE
            	// elements:          decl, variableDeclarator
            	// token labels:      
            	// rule labels:       decl, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_decl = new RewriteRuleSubtreeStream(adaptor, "token decl", (decl!=null ? decl.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 317:3: -> ^( VAR_DEF $decl ( variableDeclarator )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:6: ^( VAR_DEF $decl ( variableDeclarator )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_decl.Next());
            	    if ( !(stream_variableDeclarator.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_variableDeclarator.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_variableDeclarator.Next());
            	    
            	    }
            	    stream_variableDeclarator.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 31, variableDefinition_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end variableDefinition

    public class varOrConst_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start varOrConst
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:320:1: varOrConst : ( VAR | CONST );
    public varOrConst_return varOrConst() // throws RecognitionException [1]
    {   
        varOrConst_return retval = new varOrConst_return();
        retval.start = input.LT(1);
        int varOrConst_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set111 = null;
        
        CommonTree set111_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 32) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:321:4: ( VAR | CONST )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set111 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= VAR && input.LA(1) <= CONST) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set111));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_varOrConst0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 32, varOrConst_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end varOrConst

    public class variableDeclarator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDeclarator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? ;
    public variableDeclarator_return variableDeclarator() // throws RecognitionException [1]
    {   
        variableDeclarator_return retval = new variableDeclarator_return();
        retval.start = input.LT(1);
        int variableDeclarator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ident112 = null;

        typeExpression_return typeExpression113 = null;

        variableInitializer_return variableInitializer114 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 33) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:4: ( ident ( typeExpression )? ( variableInitializer )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:4: ident ( typeExpression )? ( variableInitializer )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_ident_in_variableDeclarator1499);
            	ident112 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(ident112.Tree, root_0);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:11: ( typeExpression )?
            	int alt32 = 2;
            	int LA32_0 = input.LA(1);
            	
            	if ( (LA32_0 == COLON) )
            	{
            	    alt32 = 1;
            	}
            	switch (alt32) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_variableDeclarator1502);
            	        	typeExpression113 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, typeExpression113.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:27: ( variableInitializer )?
            	int alt33 = 2;
            	int LA33_0 = input.LA(1);
            	
            	if ( (LA33_0 == ASSIGN) )
            	{
            	    alt33 = 1;
            	}
            	switch (alt33) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: variableInitializer
            	        {
            	        	PushFollow(FOLLOW_variableInitializer_in_variableDeclarator1505);
            	        	variableInitializer114 = variableInitializer();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableInitializer114.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 33, variableDeclarator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableDeclarator

    public class declaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:327:1: declaration : varOrConst variableDeclarator declarationTail ;
    public declaration_return declaration() // throws RecognitionException [1]
    {   
        declaration_return retval = new declaration_return();
        retval.start = input.LT(1);
        int declaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        varOrConst_return varOrConst115 = null;

        variableDeclarator_return variableDeclarator116 = null;

        declarationTail_return declarationTail117 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 34) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:328:4: ( varOrConst variableDeclarator declarationTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:328:4: varOrConst variableDeclarator declarationTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_varOrConst_in_declaration1516);
            	varOrConst115 = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(varOrConst115.Tree, root_0);
            	PushFollow(FOLLOW_variableDeclarator_in_declaration1519);
            	variableDeclarator116 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator116.Tree);
            	PushFollow(FOLLOW_declarationTail_in_declaration1523);
            	declarationTail117 = declarationTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationTail117.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 34, declaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end declaration

    public class declarationTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:332:1: declarationTail : ( COMMA variableDeclarator )* ;
    public declarationTail_return declarationTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationTail_return retval = new declarationTail_return();
        retval.start = input.LT(1);
        int declarationTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA118 = null;
        variableDeclarator_return variableDeclarator119 = null;
        
        
        CommonTree COMMA118_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 35) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:4: ( ( COMMA variableDeclarator )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:4: ( COMMA variableDeclarator )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:4: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt34 = 2;
            	    int LA34_0 = input.LA(1);
            	    
            	    if ( (LA34_0 == COMMA) )
            	    {
            	        alt34 = 1;
            	    }
            	    
            	
            	    switch (alt34) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:5: COMMA variableDeclarator
            			    {
            			    	COMMA118 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_declarationTail1545); if (failed) return retval;
            			    	PushFollow(FOLLOW_variableDeclarator_in_declarationTail1548);
            			    	variableDeclarator119 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator119.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop34;
            	    }
            	} while (true);
            	
            	loop34:
            		;	// Stops C# compiler whinging that label 'loop34' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 35, declarationTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationTail

    public class variableInitializer_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableInitializer
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:340:1: variableInitializer : ASSIGN assignmentExpression ;
    public variableInitializer_return variableInitializer() // throws RecognitionException [1]
    {   
        variableInitializer_return retval = new variableInitializer_return();
        retval.start = input.LT(1);
        int variableInitializer_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN120 = null;
        assignmentExpression_return assignmentExpression121 = null;
        
        
        CommonTree ASSIGN120_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 36) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:341:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:341:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN120 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableInitializer1561); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN120_tree = (CommonTree)adaptor.Create(ASSIGN120);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN120_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_variableInitializer1564);
            	assignmentExpression121 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression121.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 36, variableInitializer_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableInitializer

    public class parameterDeclarationList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclarationList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:346:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) ;
    public parameterDeclarationList_return parameterDeclarationList() // throws RecognitionException [1]
    {   
        parameterDeclarationList_return retval = new parameterDeclarationList_return();
        retval.start = input.LT(1);
        int parameterDeclarationList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN122 = null;
        IToken COMMA124 = null;
        IToken RPAREN126 = null;
        parameterDeclaration_return parameterDeclaration123 = null;

        parameterDeclaration_return parameterDeclaration125 = null;
        
        
        CommonTree LPAREN122_tree=null;
        CommonTree COMMA124_tree=null;
        CommonTree RPAREN126_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_parameterDeclaration = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclaration");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 37) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
            {
            	LPAREN122 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_parameterDeclarationList1577); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN122);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:348:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
            	int alt36 = 2;
            	int LA36_0 = input.LA(1);
            	
            	if ( ((LA36_0 >= GET && LA36_0 <= USE) || LA36_0 == CONST || LA36_0 == REST || LA36_0 == XML || LA36_0 == IDENT || LA36_0 == DYNAMIC || (LA36_0 >= IS && LA36_0 <= AS)) )
            	{
            	    alt36 = 1;
            	}
            	switch (alt36) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:348:5: parameterDeclaration ( COMMA parameterDeclaration )*
            	        {
            	        	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1583);
            	        	parameterDeclaration123 = parameterDeclaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration123.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:349:4: ( COMMA parameterDeclaration )*
            	        	do 
            	        	{
            	        	    int alt35 = 2;
            	        	    int LA35_0 = input.LA(1);
            	        	    
            	        	    if ( (LA35_0 == COMMA) )
            	        	    {
            	        	        alt35 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt35) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:349:5: COMMA parameterDeclaration
            	        			    {
            	        			    	COMMA124 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_parameterDeclarationList1589); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA124);

            	        			    	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1591);
            	        			    	parameterDeclaration125 = parameterDeclaration();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration125.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop35;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop35:
            	        		;	// Stops C# compiler whinging that label 'loop35' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN126 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_parameterDeclarationList1602); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN126);

            	
            	// AST REWRITE
            	// elements:          parameterDeclaration
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 352:3: -> ^( PARAMS ( parameterDeclaration )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:352:6: ^( PARAMS ( parameterDeclaration )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAMS, "PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:352:15: ( parameterDeclaration )*
            	    while ( stream_parameterDeclaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDeclaration.Next());
            	    
            	    }
            	    stream_parameterDeclaration.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 37, parameterDeclarationList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclarationList

    public class parameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
    public parameterDeclaration_return parameterDeclaration() // throws RecognitionException [1]
    {   
        parameterDeclaration_return retval = new parameterDeclaration_return();
        retval.start = input.LT(1);
        int parameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        basicParameterDeclaration_return basicParameterDeclaration127 = null;

        parameterRestDeclaration_return parameterRestDeclaration128 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 38) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:357:4: ( basicParameterDeclaration | parameterRestDeclaration )
            int alt37 = 2;
            int LA37_0 = input.LA(1);
            
            if ( ((LA37_0 >= GET && LA37_0 <= USE) || LA37_0 == CONST || LA37_0 == XML || LA37_0 == IDENT || LA37_0 == DYNAMIC || (LA37_0 >= IS && LA37_0 <= AS)) )
            {
                alt37 = 1;
            }
            else if ( (LA37_0 == REST) )
            {
                alt37 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d37s0 =
                    new NoViableAltException("356:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );", 37, 0, input);
            
                throw nvae_d37s0;
            }
            switch (alt37) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:357:4: basicParameterDeclaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_basicParameterDeclaration_in_parameterDeclaration1625);
                    	basicParameterDeclaration127 = basicParameterDeclaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, basicParameterDeclaration127.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:357:32: parameterRestDeclaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_parameterRestDeclaration_in_parameterDeclaration1629);
                    	parameterRestDeclaration128 = parameterRestDeclaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, parameterRestDeclaration128.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 38, parameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclaration

    public class basicParameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start basicParameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:360:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
    public basicParameterDeclaration_return basicParameterDeclaration() // throws RecognitionException [1]
    {   
        basicParameterDeclaration_return retval = new basicParameterDeclaration_return();
        retval.start = input.LT(1);
        int basicParameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CONST129 = null;
        ident_return ident130 = null;

        typeExpression_return typeExpression131 = null;

        parameterDefault_return parameterDefault132 = null;
        
        
        CommonTree CONST129_tree=null;
        RewriteRuleTokenStream stream_CONST = new RewriteRuleTokenStream(adaptor,"token CONST");
        RewriteRuleSubtreeStream stream_parameterDefault = new RewriteRuleSubtreeStream(adaptor,"rule parameterDefault");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 39) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:4: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:4: ( CONST )?
            	int alt38 = 2;
            	int LA38_0 = input.LA(1);
            	
            	if ( (LA38_0 == CONST) )
            	{
            	    alt38 = 1;
            	}
            	switch (alt38) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: CONST
            	        {
            	        	CONST129 = (IToken)input.LT(1);
            	        	Match(input,CONST,FOLLOW_CONST_in_basicParameterDeclaration1640); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_CONST.Add(CONST129);

            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_ident_in_basicParameterDeclaration1643);
            	ident130 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident130.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:17: ( typeExpression )?
            	int alt39 = 2;
            	int LA39_0 = input.LA(1);
            	
            	if ( (LA39_0 == COLON) )
            	{
            	    alt39 = 1;
            	}
            	switch (alt39) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_basicParameterDeclaration1645);
            	        	typeExpression131 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression131.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:33: ( parameterDefault )?
            	int alt40 = 2;
            	int LA40_0 = input.LA(1);
            	
            	if ( (LA40_0 == ASSIGN) )
            	{
            	    alt40 = 1;
            	}
            	switch (alt40) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: parameterDefault
            	        {
            	        	PushFollow(FOLLOW_parameterDefault_in_basicParameterDeclaration1648);
            	        	parameterDefault132 = parameterDefault();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDefault.Add(parameterDefault132.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, parameterDefault, CONST, typeExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 362:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:14: ( CONST )?
            	    if ( stream_CONST.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_CONST.Next());
            	    
            	    }
            	    stream_CONST.Reset();
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:27: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:43: ( parameterDefault )?
            	    if ( stream_parameterDefault.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDefault.Next());
            	    
            	    }
            	    stream_parameterDefault.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 39, basicParameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end basicParameterDeclaration

    public class parameterDefault_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDefault
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:365:1: parameterDefault : ASSIGN assignmentExpression ;
    public parameterDefault_return parameterDefault() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        parameterDefault_return retval = new parameterDefault_return();
        retval.start = input.LT(1);
        int parameterDefault_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN133 = null;
        assignmentExpression_return assignmentExpression134 = null;
        
        
        CommonTree ASSIGN133_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 40) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:371:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:371:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN133 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_parameterDefault1692); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN133_tree = (CommonTree)adaptor.Create(ASSIGN133);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN133_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_parameterDefault1695);
            	assignmentExpression134 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression134.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 40, parameterDefault_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end parameterDefault

    public class parameterRestDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterRestDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:374:1: parameterRestDeclaration : REST ( ident )? -> ^( PARAM REST ( ident )? ) ;
    public parameterRestDeclaration_return parameterRestDeclaration() // throws RecognitionException [1]
    {   
        parameterRestDeclaration_return retval = new parameterRestDeclaration_return();
        retval.start = input.LT(1);
        int parameterRestDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken REST135 = null;
        ident_return ident136 = null;
        
        
        CommonTree REST135_tree=null;
        RewriteRuleTokenStream stream_REST = new RewriteRuleTokenStream(adaptor,"token REST");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 41) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:375:4: ( REST ( ident )? -> ^( PARAM REST ( ident )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:375:4: REST ( ident )?
            {
            	REST135 = (IToken)input.LT(1);
            	Match(input,REST,FOLLOW_REST_in_parameterRestDeclaration1706); if (failed) return retval;
            	if ( backtracking==0 ) stream_REST.Add(REST135);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:375:9: ( ident )?
            	int alt41 = 2;
            	int LA41_0 = input.LA(1);
            	
            	if ( ((LA41_0 >= GET && LA41_0 <= USE) || LA41_0 == XML || LA41_0 == IDENT || LA41_0 == DYNAMIC || (LA41_0 >= IS && LA41_0 <= AS)) )
            	{
            	    alt41 = 1;
            	}
            	switch (alt41) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: ident
            	        {
            	        	PushFollow(FOLLOW_ident_in_parameterRestDeclaration1708);
            	        	ident136 = ident();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_ident.Add(ident136.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, REST
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 376:3: -> ^( PARAM REST ( ident )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:376:6: ^( PARAM REST ( ident )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_REST.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:376:19: ( ident )?
            	    if ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 41, parameterRestDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterRestDeclaration

    public class block_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start block
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:378:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) ;
    public block_return block() // throws RecognitionException [1]
    {   
        block_return retval = new block_return();
        retval.start = input.LT(1);
        int block_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY137 = null;
        IToken RCURLY139 = null;
        blockEntry_return blockEntry138 = null;
        
        
        CommonTree LCURLY137_tree=null;
        CommonTree RCURLY139_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_blockEntry = new RewriteRuleSubtreeStream(adaptor,"rule blockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 42) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:379:4: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:379:4: LCURLY ( blockEntry )* RCURLY
            {
            	LCURLY137 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_block1732); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY137);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:379:11: ( blockEntry )*
            	do 
            	{
            	    int alt42 = 2;
            	    int LA42_0 = input.LA(1);
            	    
            	    if ( (LA42_0 == LCURLY || LA42_0 == SEMI || (LA42_0 >= STRING_LITERAL && LA42_0 <= CONST) || LA42_0 == LPAREN || LA42_0 == IF || (LA42_0 >= RETURN && LA42_0 <= SWITCH) || (LA42_0 >= DEFAULT && LA42_0 <= FOR) || (LA42_0 >= WHILE && LA42_0 <= XML) || (LA42_0 >= IDENT && LA42_0 <= LBRACK) || LA42_0 == DYNAMIC || LA42_0 == LT || (LA42_0 >= IS && LA42_0 <= AS) || (LA42_0 >= PLUS && LA42_0 <= DIV) || (LA42_0 >= INC && LA42_0 <= BNOT) || (LA42_0 >= E4X_ATTRI && LA42_0 <= ML_COMMENT) || (LA42_0 >= 176 && LA42_0 <= 177) || LA42_0 == 180) )
            	    {
            	        alt42 = 1;
            	    }
            	    
            	
            	    switch (alt42) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: blockEntry
            			    {
            			    	PushFollow(FOLLOW_blockEntry_in_block1734);
            			    	blockEntry138 = blockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_blockEntry.Add(blockEntry138.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop42;
            	    }
            	} while (true);
            	
            	loop42:
            		;	// Stops C# compiler whinging that label 'loop42' has no statements

            	RCURLY139 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_block1737); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY139);

            	
            	// AST REWRITE
            	// elements:          blockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 380:3: -> ^( BLOCK ( blockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:380:6: ^( BLOCK ( blockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:380:14: ( blockEntry )*
            	    while ( stream_blockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_blockEntry.Next());
            	    
            	    }
            	    stream_blockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 42, block_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end block

    public class blockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start blockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:383:1: blockEntry : statement ;
    public blockEntry_return blockEntry() // throws RecognitionException [1]
    {   
        blockEntry_return retval = new blockEntry_return();
        retval.start = input.LT(1);
        int blockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement140 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 43) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:384:4: ( statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:384:4: statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_statement_in_blockEntry1759);
            	statement140 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement140.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 43, blockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end blockEntry

    public class condition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start condition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:387:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
    public condition_return condition() // throws RecognitionException [1]
    {   
        condition_return retval = new condition_return();
        retval.start = input.LT(1);
        int condition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN141 = null;
        IToken RPAREN143 = null;
        expression_return expression142 = null;
        
        
        CommonTree LPAREN141_tree=null;
        CommonTree RPAREN143_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 44) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:388:4: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:388:4: LPAREN expression RPAREN
            {
            	LPAREN141 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_condition1770); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN141);

            	PushFollow(FOLLOW_expression_in_condition1772);
            	expression142 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expression.Add(expression142.Tree);
            	RPAREN143 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_condition1774); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN143);

            	
            	// AST REWRITE
            	// elements:          expression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 389:3: -> ^( CONDITION expression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:389:6: ^( CONDITION expression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CONDITION, "CONDITION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 44, condition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end condition

    public class statement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start statement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );
    public statement_return statement() // throws RecognitionException [1]
    {   
        statement_return retval = new statement_return();
        retval.start = input.LT(1);
        int statement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI161 = null;
        block_return block144 = null;

        declarationStatement_return declarationStatement145 = null;

        expressionStatement_return expressionStatement146 = null;

        ifStatement_return ifStatement147 = null;

        forEachStatement_return forEachStatement148 = null;

        forStatement_return forStatement149 = null;

        whileStatement_return whileStatement150 = null;

        doWhileStatement_return doWhileStatement151 = null;

        withStatement_return withStatement152 = null;

        switchStatement_return switchStatement153 = null;

        breakStatement_return breakStatement154 = null;

        continueStatement_return continueStatement155 = null;

        returnStatement_return returnStatement156 = null;

        throwStatement_return throwStatement157 = null;

        tryStatement_return tryStatement158 = null;

        defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement159 = null;

        commentExpression_return commentExpression160 = null;
        
        
        CommonTree SEMI161_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 45) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:393:4: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI )
            int alt43 = 18;
            switch ( input.LA(1) ) 
            {
            case LCURLY:
            	{
                int LA43_1 = input.LA(2);
                
                if ( (LA43_1 == LCURLY) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( ((LA43_1 >= VAR && LA43_1 <= CONST)) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == INC) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == DEC) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == MINUS) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == PLUS) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == DELETE) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == 180) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == TYPEOF) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == LNOT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == BNOT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == UNDEFINED) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == LT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == DIV) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( ((LA43_1 >= HEX_LITERAL && LA43_1 <= FLOAT_LITERAL)) )
                {
                    int LA43_64 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s64 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 64, input);
                    
                        throw nvae_d43s64;
                    }
                }
                else if ( (LA43_1 == STRING_LITERAL) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == TRUE) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == FALSE) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == NULL) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == LBRACK) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == FUNCTION) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == NEW) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == LPAREN) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == E4X_ATTRI) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == IDENT) )
                {
                    int LA43_74 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s74 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 74, input);
                    
                        throw nvae_d43s74;
                    }
                }
                else if ( ((LA43_1 >= PUBLIC && LA43_1 <= INTERNAL)) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == USE) )
                {
                    int LA43_76 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s76 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 76, input);
                    
                        throw nvae_d43s76;
                    }
                }
                else if ( (LA43_1 == XML) )
                {
                    int LA43_77 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s77 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 77, input);
                    
                        throw nvae_d43s77;
                    }
                }
                else if ( (LA43_1 == DYNAMIC) )
                {
                    int LA43_78 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s78 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 78, input);
                    
                        throw nvae_d43s78;
                    }
                }
                else if ( (LA43_1 == NAMESPACE) )
                {
                    int LA43_79 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s79 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 79, input);
                    
                        throw nvae_d43s79;
                    }
                }
                else if ( (LA43_1 == IS) )
                {
                    int LA43_80 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s80 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 80, input);
                    
                        throw nvae_d43s80;
                    }
                }
                else if ( (LA43_1 == AS) )
                {
                    int LA43_81 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s81 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 81, input);
                    
                        throw nvae_d43s81;
                    }
                }
                else if ( (LA43_1 == GET) )
                {
                    int LA43_82 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s82 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 82, input);
                    
                        throw nvae_d43s82;
                    }
                }
                else if ( (LA43_1 == SET) )
                {
                    int LA43_83 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s83 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 83, input);
                    
                        throw nvae_d43s83;
                    }
                }
                else if ( (LA43_1 == IF) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == FOR) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == WHILE) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == DO) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == WITH) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == SWITCH) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == BREAK) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == CONTINUE) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == RETURN) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == 176) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == 177) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == DEFAULT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == SL_COMMENT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == ML_COMMENT) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == SEMI) && (synpred57()) )
                {
                    alt43 = 1;
                }
                else if ( (LA43_1 == RCURLY) )
                {
                    int LA43_99 = input.LA(3);
                    
                    if ( (synpred57()) )
                    {
                        alt43 = 1;
                    }
                    else if ( (synpred59()) )
                    {
                        alt43 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d43s99 =
                            new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 99, input);
                    
                        throw nvae_d43s99;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d43s1 =
                        new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 1, input);
                
                    throw nvae_d43s1;
                }
                }
                break;
            case VAR:
            case CONST:
            	{
                alt43 = 2;
                }
                break;
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case PLUS:
            case MINUS:
            case DIV:
            case INC:
            case DEC:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case 180:
            	{
                alt43 = 3;
                }
                break;
            case IF:
            	{
                alt43 = 4;
                }
                break;
            case FOR:
            	{
                int LA43_36 = input.LA(2);
                
                if ( (LA43_36 == LPAREN) )
                {
                    alt43 = 6;
                }
                else if ( (LA43_36 == EACH) )
                {
                    alt43 = 5;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d43s36 =
                        new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 36, input);
                
                    throw nvae_d43s36;
                }
                }
                break;
            case WHILE:
            	{
                alt43 = 7;
                }
                break;
            case DO:
            	{
                alt43 = 8;
                }
                break;
            case WITH:
            	{
                alt43 = 9;
                }
                break;
            case SWITCH:
            	{
                alt43 = 10;
                }
                break;
            case BREAK:
            	{
                alt43 = 11;
                }
                break;
            case CONTINUE:
            	{
                alt43 = 12;
                }
                break;
            case RETURN:
            	{
                alt43 = 13;
                }
                break;
            case 176:
            	{
                alt43 = 14;
                }
                break;
            case 177:
            	{
                alt43 = 15;
                }
                break;
            case DEFAULT:
            	{
                alt43 = 16;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt43 = 17;
                }
                break;
            case SEMI:
            	{
                alt43 = 18;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d43s0 =
            	        new NoViableAltException("392:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 43, 0, input);
            
            	    throw nvae_d43s0;
            }
            
            switch (alt43) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:393:4: ( LCURLY )=> block
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_block_in_statement1800);
                    	block144 = block();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, block144.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:394:4: declarationStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declarationStatement_in_statement1805);
                    	declarationStatement145 = declarationStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationStatement145.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:395:4: expressionStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_expressionStatement_in_statement1810);
                    	expressionStatement146 = expressionStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionStatement146.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:396:4: ifStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ifStatement_in_statement1815);
                    	ifStatement147 = ifStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ifStatement147.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:398:4: forEachStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_forEachStatement_in_statement1822);
                    	forEachStatement148 = forEachStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, forEachStatement148.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:399:4: forStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_forStatement_in_statement1827);
                    	forStatement149 = forStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, forStatement149.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:402:4: whileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_whileStatement_in_statement1835);
                    	whileStatement150 = whileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, whileStatement150.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:405:4: doWhileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_doWhileStatement_in_statement1843);
                    	doWhileStatement151 = doWhileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, doWhileStatement151.Tree);
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:408:4: withStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_withStatement_in_statement1852);
                    	withStatement152 = withStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, withStatement152.Tree);
                    
                    }
                    break;
                case 10 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:4: switchStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_switchStatement_in_statement1861);
                    	switchStatement153 = switchStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, switchStatement153.Tree);
                    
                    }
                    break;
                case 11 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:414:4: breakStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_breakStatement_in_statement1870);
                    	breakStatement154 = breakStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, breakStatement154.Tree);
                    
                    }
                    break;
                case 12 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:417:4: continueStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_continueStatement_in_statement1878);
                    	continueStatement155 = continueStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, continueStatement155.Tree);
                    
                    }
                    break;
                case 13 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:4: returnStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_returnStatement_in_statement1886);
                    	returnStatement156 = returnStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, returnStatement156.Tree);
                    
                    }
                    break;
                case 14 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:423:4: throwStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_throwStatement_in_statement1894);
                    	throwStatement157 = throwStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, throwStatement157.Tree);
                    
                    }
                    break;
                case 15 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:426:4: tryStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_tryStatement_in_statement1903);
                    	tryStatement158 = tryStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, tryStatement158.Tree);
                    
                    }
                    break;
                case 16 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:429:4: defaultXMLNamespaceStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_defaultXMLNamespaceStatement_in_statement1912);
                    	defaultXMLNamespaceStatement159 = defaultXMLNamespaceStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, defaultXMLNamespaceStatement159.Tree);
                    
                    }
                    break;
                case 17 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:432:4: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_statement1921);
                    	commentExpression160 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression160.Tree);
                    
                    }
                    break;
                case 18 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:435:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI161 = (IToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_statement1929); if (failed) return retval;
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 45, statement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end statement

    public class declarationStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:438:1: declarationStatement : declaration semi ;
    public declarationStatement_return declarationStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationStatement_return retval = new declarationStatement_return();
        retval.start = input.LT(1);
        int declarationStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration162 = null;

        semi_return semi163 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 46) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:443:4: ( declaration semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:443:4: declaration semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_declaration_in_declarationStatement1951);
            	declaration162 = declaration();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration162.Tree);
            	PushFollow(FOLLOW_semi_in_declarationStatement1953);
            	semi163 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi163.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 46, declarationStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationStatement

    public class expressionStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:446:1: expressionStatement : expressionList semi -> ^( EXPR_STMNT expressionList ) ;
    public expressionStatement_return expressionStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expressionStatement_return retval = new expressionStatement_return();
        retval.start = input.LT(1);
        int expressionStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList164 = null;

        semi_return semi165 = null;
        
        
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 47) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:451:4: ( expressionList semi -> ^( EXPR_STMNT expressionList ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:451:4: expressionList semi
            {
            	PushFollow(FOLLOW_expressionList_in_expressionStatement1974);
            	expressionList164 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expressionList.Add(expressionList164.Tree);
            	PushFollow(FOLLOW_semi_in_expressionStatement1976);
            	semi165 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi165.Tree);
            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 452:3: -> ^( EXPR_STMNT expressionList )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:452:6: ^( EXPR_STMNT expressionList )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 47, expressionStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expressionStatement

    public class ifStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ifStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:455:1: ifStatement : IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )? ;
    public ifStatement_return ifStatement() // throws RecognitionException [1]
    {   
        ifStatement_return retval = new ifStatement_return();
        retval.start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IF166 = null;
        condition_return condition167 = null;

        commentExpression_return commentExpression168 = null;

        statement_return statement169 = null;

        commentExpression_return commentExpression170 = null;

        elseClause_return elseClause171 = null;
        
        
        CommonTree IF166_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 48) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: ( IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IF166 = (IToken)input.LT(1);
            	Match(input,IF,FOLLOW_IF_in_ifStatement1998); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IF166_tree = (CommonTree)adaptor.Create(IF166);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IF166_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_ifStatement2001);
            	condition167 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition167.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:18: ( commentExpression )?
            	int alt44 = 2;
            	int LA44_0 = input.LA(1);
            	
            	if ( (LA44_0 == SL_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA44_50 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA44_51 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA44_54 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA44_55 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA44_56 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA44_57 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA44_58 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA44_59 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA44_60 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA44_61 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA44_62 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA44_63 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA44_64 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA44_65 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA44_66 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA44_67 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA44_68 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA44_69 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA44_70 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA44_71 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA44_72 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA44_73 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA44_74 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA44_75 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA44_76 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA44_77 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA44_78 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA44_79 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA44_80 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA44_81 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA44_82 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA44_83 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA44_84 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA44_85 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA44_86 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA44_87 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA44_88 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA44_89 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA44_90 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA44_91 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA44_92 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA44_93 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA44_94 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA44_95 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA44_96 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 176:
            	        	{
            	            int LA44_97 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA44_98 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA44_99 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA44_100 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA44_0 == ML_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA44_103 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA44_104 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA44_105 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA44_106 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA44_107 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA44_108 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA44_109 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA44_110 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA44_111 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA44_112 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA44_113 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA44_114 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA44_115 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA44_116 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA44_117 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA44_118 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA44_119 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA44_120 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA44_121 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA44_122 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA44_123 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA44_124 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA44_125 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA44_126 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA44_127 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA44_128 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA44_129 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA44_130 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA44_131 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA44_132 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA44_133 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA44_134 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA44_135 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA44_136 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA44_137 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA44_138 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA44_139 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA44_140 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA44_141 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA44_142 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA44_143 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA44_144 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA44_145 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA44_146 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA44_147 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 176:
            	        	{
            	            int LA44_148 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA44_149 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA44_150 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA44_151 = input.LA(3);
            	            
            	            if ( (synpred74()) )
            	            {
            	                alt44 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt44) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_ifStatement2003);
            	        	commentExpression168 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression168.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_statement_in_ifStatement2006);
            	statement169 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement169.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:47: ( commentExpression )?
            	int alt45 = 2;
            	int LA45_0 = input.LA(1);
            	
            	if ( (LA45_0 == SL_COMMENT) )
            	{
            	    int LA45_1 = input.LA(2);
            	    
            	    if ( (synpred75()) )
            	    {
            	        alt45 = 1;
            	    }
            	}
            	else if ( (LA45_0 == ML_COMMENT) )
            	{
            	    int LA45_2 = input.LA(2);
            	    
            	    if ( (synpred75()) )
            	    {
            	        alt45 = 1;
            	    }
            	}
            	switch (alt45) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_ifStatement2008);
            	        	commentExpression170 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression170.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:3: ( ( ELSE )=> elseClause )?
            	int alt46 = 2;
            	int LA46_0 = input.LA(1);
            	
            	if ( (LA46_0 == ELSE) )
            	{
            	    int LA46_1 = input.LA(2);
            	    
            	    if ( (synpred76()) )
            	    {
            	        alt46 = 1;
            	    }
            	}
            	switch (alt46) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:4: ( ELSE )=> elseClause
            	        {
            	        	PushFollow(FOLLOW_elseClause_in_ifStatement2018);
            	        	elseClause171 = elseClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, elseClause171.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 48, ifStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ifStatement

    public class elseClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elseClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:1: elseClause : ELSE ( commentExpression )? statement ;
    public elseClause_return elseClause() // throws RecognitionException [1]
    {   
        elseClause_return retval = new elseClause_return();
        retval.start = input.LT(1);
        int elseClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ELSE172 = null;
        commentExpression_return commentExpression173 = null;

        statement_return statement174 = null;
        
        
        CommonTree ELSE172_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 49) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:4: ( ELSE ( commentExpression )? statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:4: ELSE ( commentExpression )? statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ELSE172 = (IToken)input.LT(1);
            	Match(input,ELSE,FOLLOW_ELSE_in_elseClause2031); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ELSE172_tree = (CommonTree)adaptor.Create(ELSE172);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ELSE172_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:10: ( commentExpression )?
            	int alt47 = 2;
            	int LA47_0 = input.LA(1);
            	
            	if ( (LA47_0 == SL_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA47_50 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA47_51 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA47_52 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA47_53 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA47_54 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA47_55 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA47_56 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA47_57 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA47_58 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA47_59 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA47_60 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA47_61 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA47_62 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA47_63 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA47_64 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA47_65 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA47_66 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA47_67 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA47_68 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA47_69 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA47_70 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA47_71 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA47_72 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA47_73 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA47_74 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA47_75 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA47_76 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA47_77 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA47_78 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA47_79 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA47_80 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA47_81 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA47_82 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA47_83 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA47_84 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA47_85 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA47_86 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA47_87 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA47_88 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA47_89 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA47_90 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA47_91 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA47_92 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA47_93 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA47_94 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 176:
            	        	{
            	            int LA47_95 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA47_96 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA47_97 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA47_98 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA47_0 == ML_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA47_103 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA47_104 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA47_106 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA47_107 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA47_108 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA47_109 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA47_110 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA47_111 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA47_112 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA47_113 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA47_114 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA47_115 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA47_116 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA47_117 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA47_118 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA47_119 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA47_120 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA47_121 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA47_122 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA47_123 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA47_124 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA47_125 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA47_126 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA47_127 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA47_128 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA47_129 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA47_130 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA47_131 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA47_132 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA47_133 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA47_134 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA47_135 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA47_136 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA47_137 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA47_138 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA47_139 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA47_140 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA47_141 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA47_142 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA47_143 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA47_144 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA47_145 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA47_146 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA47_147 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA47_148 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 176:
            	        	{
            	            int LA47_149 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA47_150 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA47_151 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA47_152 = input.LA(3);
            	            
            	            if ( (synpred77()) )
            	            {
            	                alt47 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt47) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_elseClause2034);
            	        	commentExpression173 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression173.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_statement_in_elseClause2037);
            	statement174 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement174.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 49, elseClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elseClause

    public class throwStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start throwStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:1: throwStatement : 'throw' expression semi ;
    public throwStatement_return throwStatement() // throws RecognitionException [1]
    {   
        throwStatement_return retval = new throwStatement_return();
        retval.start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal175 = null;
        expression_return expression176 = null;

        semi_return semi177 = null;
        
        
        CommonTree string_literal175_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 50) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:465:4: ( 'throw' expression semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:465:4: 'throw' expression semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal175 = (IToken)input.LT(1);
            	Match(input,176,FOLLOW_176_in_throwStatement2048); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal175_tree = (CommonTree)adaptor.Create(string_literal175);
            	root_0 = (CommonTree)adaptor.BecomeRoot(string_literal175_tree, root_0);
            	}
            	PushFollow(FOLLOW_expression_in_throwStatement2051);
            	expression176 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression176.Tree);
            	PushFollow(FOLLOW_semi_in_throwStatement2053);
            	semi177 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi177.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 50, throwStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end throwStatement

    public class tryStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start tryStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:468:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? ;
    public tryStatement_return tryStatement() // throws RecognitionException [1]
    {   
        tryStatement_return retval = new tryStatement_return();
        retval.start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal178 = null;
        block_return block179 = null;

        catchBlock_return catchBlock180 = null;

        finallyBlock_return finallyBlock181 = null;
        
        
        CommonTree string_literal178_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 51) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:4: ( 'try' block ( catchBlock )* ( finallyBlock )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:4: 'try' block ( catchBlock )* ( finallyBlock )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal178 = (IToken)input.LT(1);
            	Match(input,177,FOLLOW_177_in_tryStatement2064); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal178_tree = (CommonTree)adaptor.Create(string_literal178);
            	adaptor.AddChild(root_0, string_literal178_tree);
            	}
            	PushFollow(FOLLOW_block_in_tryStatement2068);
            	block179 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block179.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:471:3: ( catchBlock )*
            	do 
            	{
            	    int alt48 = 2;
            	    int LA48_0 = input.LA(1);
            	    
            	    if ( (LA48_0 == 178) )
            	    {
            	        alt48 = 1;
            	    }
            	    
            	
            	    switch (alt48) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: catchBlock
            			    {
            			    	PushFollow(FOLLOW_catchBlock_in_tryStatement2072);
            			    	catchBlock180 = catchBlock();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, catchBlock180.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop48;
            	    }
            	} while (true);
            	
            	loop48:
            		;	// Stops C# compiler whinging that label 'loop48' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:3: ( finallyBlock )?
            	int alt49 = 2;
            	int LA49_0 = input.LA(1);
            	
            	if ( (LA49_0 == 179) )
            	{
            	    alt49 = 1;
            	}
            	switch (alt49) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: finallyBlock
            	        {
            	        	PushFollow(FOLLOW_finallyBlock_in_tryStatement2077);
            	        	finallyBlock181 = finallyBlock();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, finallyBlock181.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 51, tryStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end tryStatement

    public class catchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start catchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:475:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
    public catchBlock_return catchBlock() // throws RecognitionException [1]
    {   
        catchBlock_return retval = new catchBlock_return();
        retval.start = input.LT(1);
        int catchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal182 = null;
        IToken LPAREN183 = null;
        IToken RPAREN186 = null;
        ident_return ident184 = null;

        typeExpression_return typeExpression185 = null;

        block_return block187 = null;
        
        
        CommonTree string_literal182_tree=null;
        CommonTree LPAREN183_tree=null;
        CommonTree RPAREN186_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 52) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:4: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal182 = (IToken)input.LT(1);
            	Match(input,178,FOLLOW_178_in_catchBlock2089); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal182_tree = (CommonTree)adaptor.Create(string_literal182);
            	adaptor.AddChild(root_0, string_literal182_tree);
            	}
            	LPAREN183 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_catchBlock2091); if (failed) return retval;
            	PushFollow(FOLLOW_ident_in_catchBlock2094);
            	ident184 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident184.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:26: ( typeExpression )?
            	int alt50 = 2;
            	int LA50_0 = input.LA(1);
            	
            	if ( (LA50_0 == COLON) )
            	{
            	    alt50 = 1;
            	}
            	switch (alt50) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_catchBlock2096);
            	        	typeExpression185 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, typeExpression185.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RPAREN186 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_catchBlock2099); if (failed) return retval;
            	PushFollow(FOLLOW_block_in_catchBlock2104);
            	block187 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block187.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 52, catchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end catchBlock

    public class finallyBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start finallyBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:480:1: finallyBlock : 'finally' block ;
    public finallyBlock_return finallyBlock() // throws RecognitionException [1]
    {   
        finallyBlock_return retval = new finallyBlock_return();
        retval.start = input.LT(1);
        int finallyBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal188 = null;
        block_return block189 = null;
        
        
        CommonTree string_literal188_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 53) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:4: ( 'finally' block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:4: 'finally' block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal188 = (IToken)input.LT(1);
            	Match(input,179,FOLLOW_179_in_finallyBlock2115); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal188_tree = (CommonTree)adaptor.Create(string_literal188);
            	adaptor.AddChild(root_0, string_literal188_tree);
            	}
            	PushFollow(FOLLOW_block_in_finallyBlock2117);
            	block189 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block189.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 53, finallyBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end finallyBlock

    public class returnStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start returnStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:484:1: returnStatement : RETURN ( expression )? semi ;
    public returnStatement_return returnStatement() // throws RecognitionException [1]
    {   
        returnStatement_return retval = new returnStatement_return();
        retval.start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken RETURN190 = null;
        expression_return expression191 = null;

        semi_return semi192 = null;
        
        
        CommonTree RETURN190_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 54) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:4: ( RETURN ( expression )? semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:4: RETURN ( expression )? semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	RETURN190 = (IToken)input.LT(1);
            	Match(input,RETURN,FOLLOW_RETURN_in_returnStatement2128); if (failed) return retval;
            	if ( backtracking==0 ) {
            	RETURN190_tree = (CommonTree)adaptor.Create(RETURN190);
            	root_0 = (CommonTree)adaptor.BecomeRoot(RETURN190_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:12: ( expression )?
            	int alt51 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case INC:
            	    	{
            	        int LA51_1 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case DEC:
            	    	{
            	        int LA51_2 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case MINUS:
            	    	{
            	        int LA51_3 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case PLUS:
            	    	{
            	        int LA51_4 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case DELETE:
            	    	{
            	        int LA51_5 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case 180:
            	    	{
            	        int LA51_6 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case TYPEOF:
            	    	{
            	        int LA51_7 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case LNOT:
            	    	{
            	        int LA51_8 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case BNOT:
            	    	{
            	        int LA51_9 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case UNDEFINED:
            	    	{
            	        int LA51_10 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case LT:
            	    	{
            	        int LA51_11 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case DIV:
            	    	{
            	        int LA51_12 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case HEX_LITERAL:
            	    case DECIMAL_LITERAL:
            	    case OCTAL_LITERAL:
            	    case FLOAT_LITERAL:
            	    	{
            	        int LA51_13 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case STRING_LITERAL:
            	    	{
            	        int LA51_14 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case TRUE:
            	    	{
            	        int LA51_15 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case FALSE:
            	    	{
            	        int LA51_16 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case NULL:
            	    	{
            	        int LA51_17 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case LBRACK:
            	    	{
            	        int LA51_18 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case LCURLY:
            	    	{
            	        int LA51_19 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case FUNCTION:
            	    	{
            	        int LA51_20 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case NEW:
            	    	{
            	        int LA51_21 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case LPAREN:
            	    	{
            	        int LA51_22 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case E4X_ATTRI:
            	    	{
            	        int LA51_23 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case IDENT:
            	    	{
            	        int LA51_24 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case PUBLIC:
            	    case PRIVATE:
            	    case PROTECTED:
            	    case INTERNAL:
            	    	{
            	        int LA51_25 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case USE:
            	    	{
            	        int LA51_26 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case XML:
            	    	{
            	        int LA51_27 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case DYNAMIC:
            	    	{
            	        int LA51_28 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case NAMESPACE:
            	    	{
            	        int LA51_29 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case IS:
            	    	{
            	        int LA51_30 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case AS:
            	    	{
            	        int LA51_31 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case GET:
            	    	{
            	        int LA51_32 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	    case SET:
            	    	{
            	        int LA51_33 = input.LA(2);
            	        
            	        if ( (synpred81()) )
            	        {
            	            alt51 = 1;
            	        }
            	        }
            	        break;
            	}
            	
            	switch (alt51) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expression
            	        {
            	        	PushFollow(FOLLOW_expression_in_returnStatement2131);
            	        	expression191 = expression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, expression191.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_semi_in_returnStatement2134);
            	semi192 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi192.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 54, returnStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end returnStatement

    public class continueStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start continueStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:488:1: continueStatement : CONTINUE semi ;
    public continueStatement_return continueStatement() // throws RecognitionException [1]
    {   
        continueStatement_return retval = new continueStatement_return();
        retval.start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CONTINUE193 = null;
        semi_return semi194 = null;
        
        
        CommonTree CONTINUE193_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 55) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:489:4: ( CONTINUE semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:489:4: CONTINUE semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CONTINUE193 = (IToken)input.LT(1);
            	Match(input,CONTINUE,FOLLOW_CONTINUE_in_continueStatement2147); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CONTINUE193_tree = (CommonTree)adaptor.Create(CONTINUE193);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CONTINUE193_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_continueStatement2150);
            	semi194 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi194.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 55, continueStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end continueStatement

    public class breakStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start breakStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:492:1: breakStatement : BREAK semi ;
    public breakStatement_return breakStatement() // throws RecognitionException [1]
    {   
        breakStatement_return retval = new breakStatement_return();
        retval.start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BREAK195 = null;
        semi_return semi196 = null;
        
        
        CommonTree BREAK195_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 56) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:493:4: ( BREAK semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:493:4: BREAK semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	BREAK195 = (IToken)input.LT(1);
            	Match(input,BREAK,FOLLOW_BREAK_in_breakStatement2161); if (failed) return retval;
            	if ( backtracking==0 ) {
            	BREAK195_tree = (CommonTree)adaptor.Create(BREAK195);
            	root_0 = (CommonTree)adaptor.BecomeRoot(BREAK195_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_breakStatement2164);
            	semi196 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi196.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 56, breakStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end breakStatement

    public class switchStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:496:1: switchStatement : SWITCH ( condition ( commentExpression )* ) switchBlock ;
    public switchStatement_return switchStatement() // throws RecognitionException [1]
    {   
        switchStatement_return retval = new switchStatement_return();
        retval.start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SWITCH197 = null;
        condition_return condition198 = null;

        commentExpression_return commentExpression199 = null;

        switchBlock_return switchBlock200 = null;
        
        
        CommonTree SWITCH197_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 57) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:4: ( SWITCH ( condition ( commentExpression )* ) switchBlock )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:4: SWITCH ( condition ( commentExpression )* ) switchBlock
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	SWITCH197 = (IToken)input.LT(1);
            	Match(input,SWITCH,FOLLOW_SWITCH_in_switchStatement2175); if (failed) return retval;
            	if ( backtracking==0 ) {
            	SWITCH197_tree = (CommonTree)adaptor.Create(SWITCH197);
            	root_0 = (CommonTree)adaptor.BecomeRoot(SWITCH197_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:12: ( condition ( commentExpression )* )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:13: condition ( commentExpression )*
            	{
            		PushFollow(FOLLOW_condition_in_switchStatement2179);
            		condition198 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition198.Tree);
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:23: ( commentExpression )*
            		do 
            		{
            		    int alt52 = 2;
            		    int LA52_0 = input.LA(1);
            		    
            		    if ( ((LA52_0 >= SL_COMMENT && LA52_0 <= ML_COMMENT)) )
            		    {
            		        alt52 = 1;
            		    }
            		    
            		
            		    switch (alt52) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_switchStatement2181);
            				    	commentExpression199 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression199.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop52;
            		    }
            		} while (true);
            		
            		loop52:
            			;	// Stops C# compiler whinging that label 'loop52' has no statements

            	
            	}

            	PushFollow(FOLLOW_switchBlock_in_switchStatement2187);
            	switchBlock200 = switchBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, switchBlock200.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 57, switchStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatement

    public class switchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:501:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
    public switchBlock_return switchBlock() // throws RecognitionException [1]
    {   
        switchBlock_return retval = new switchBlock_return();
        retval.start = input.LT(1);
        int switchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY201 = null;
        IToken RCURLY204 = null;
        caseStatement_return caseStatement202 = null;

        defaultStatement_return defaultStatement203 = null;
        
        
        CommonTree LCURLY201_tree=null;
        CommonTree RCURLY204_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_caseStatement = new RewriteRuleSubtreeStream(adaptor,"rule caseStatement");
        RewriteRuleSubtreeStream stream_defaultStatement = new RewriteRuleSubtreeStream(adaptor,"rule defaultStatement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 58) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:502:4: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:502:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
            {
            	LCURLY201 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_switchBlock2198); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY201);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:503:3: ( caseStatement )*
            	do 
            	{
            	    int alt53 = 2;
            	    int LA53_0 = input.LA(1);
            	    
            	    if ( (LA53_0 == CASE) )
            	    {
            	        alt53 = 1;
            	    }
            	    
            	
            	    switch (alt53) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:503:4: caseStatement
            			    {
            			    	PushFollow(FOLLOW_caseStatement_in_switchBlock2203);
            			    	caseStatement202 = caseStatement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_caseStatement.Add(caseStatement202.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop53;
            	    }
            	} while (true);
            	
            	loop53:
            		;	// Stops C# compiler whinging that label 'loop53' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:504:3: ( defaultStatement )?
            	int alt54 = 2;
            	int LA54_0 = input.LA(1);
            	
            	if ( (LA54_0 == DEFAULT) )
            	{
            	    alt54 = 1;
            	}
            	switch (alt54) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:504:4: defaultStatement
            	        {
            	        	PushFollow(FOLLOW_defaultStatement_in_switchBlock2210);
            	        	defaultStatement203 = defaultStatement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_defaultStatement.Add(defaultStatement203.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY204 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_switchBlock2216); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY204);

            	
            	// AST REWRITE
            	// elements:          defaultStatement, caseStatement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 506:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:14: ( caseStatement )*
            	    while ( stream_caseStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_caseStatement.Next());
            	    
            	    }
            	    stream_caseStatement.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:29: ( defaultStatement )?
            	    if ( stream_defaultStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_defaultStatement.Next());
            	    
            	    }
            	    stream_defaultStatement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 58, switchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchBlock

    public class caseStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start caseStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:509:1: caseStatement : CASE expression COLON l= switchStatementList ;
    public caseStatement_return caseStatement() // throws RecognitionException [1]
    {   
        caseStatement_return retval = new caseStatement_return();
        retval.start = input.LT(1);
        int caseStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CASE205 = null;
        IToken COLON207 = null;
        switchStatementList_return l = null;

        expression_return expression206 = null;
        
        
        CommonTree CASE205_tree=null;
        CommonTree COLON207_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 59) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:510:4: ( CASE expression COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:510:4: CASE expression COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CASE205 = (IToken)input.LT(1);
            	Match(input,CASE,FOLLOW_CASE_in_caseStatement2241); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CASE205_tree = (CommonTree)adaptor.Create(CASE205);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CASE205_tree, root_0);
            	}
            	PushFollow(FOLLOW_expression_in_caseStatement2244);
            	expression206 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression206.Tree);
            	COLON207 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_caseStatement2246); if (failed) return retval;
            	PushFollow(FOLLOW_switchStatementList_in_caseStatement2251);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 59, caseStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end caseStatement

    public class defaultStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start defaultStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:513:1: defaultStatement : DEFAULT COLON l= switchStatementList ;
    public defaultStatement_return defaultStatement() // throws RecognitionException [1]
    {   
        defaultStatement_return retval = new defaultStatement_return();
        retval.start = input.LT(1);
        int defaultStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DEFAULT208 = null;
        IToken COLON209 = null;
        switchStatementList_return l = null;
        
        
        CommonTree DEFAULT208_tree=null;
        CommonTree COLON209_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 60) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:4: ( DEFAULT COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:4: DEFAULT COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DEFAULT208 = (IToken)input.LT(1);
            	Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultStatement2263); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DEFAULT208_tree = (CommonTree)adaptor.Create(DEFAULT208);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DEFAULT208_tree, root_0);
            	}
            	COLON209 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_defaultStatement2266); if (failed) return retval;
            	PushFollow(FOLLOW_switchStatementList_in_defaultStatement2271);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 60, defaultStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end defaultStatement

    public class switchStatementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:517:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
    public switchStatementList_return switchStatementList() // throws RecognitionException [1]
    {   
        switchStatementList_return retval = new switchStatementList_return();
        retval.start = input.LT(1);
        int switchStatementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement210 = null;
        
        
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 61) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:4: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:4: ( statement )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:4: ( statement )*
            	do 
            	{
            	    int alt55 = 2;
            	    int LA55_0 = input.LA(1);
            	    
            	    if ( (LA55_0 == DEFAULT) )
            	    {
            	        int LA55_1 = input.LA(2);
            	        
            	        if ( (LA55_1 == XML) )
            	        {
            	            alt55 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA55_0 == LCURLY || LA55_0 == SEMI || (LA55_0 >= STRING_LITERAL && LA55_0 <= CONST) || LA55_0 == LPAREN || LA55_0 == IF || (LA55_0 >= RETURN && LA55_0 <= SWITCH) || LA55_0 == FOR || (LA55_0 >= WHILE && LA55_0 <= XML) || (LA55_0 >= IDENT && LA55_0 <= LBRACK) || LA55_0 == DYNAMIC || LA55_0 == LT || (LA55_0 >= IS && LA55_0 <= AS) || (LA55_0 >= PLUS && LA55_0 <= DIV) || (LA55_0 >= INC && LA55_0 <= BNOT) || (LA55_0 >= E4X_ATTRI && LA55_0 <= ML_COMMENT) || (LA55_0 >= 176 && LA55_0 <= 177) || LA55_0 == 180) )
            	    {
            	        alt55 = 1;
            	    }
            	    
            	
            	    switch (alt55) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: statement
            			    {
            			    	PushFollow(FOLLOW_statement_in_switchStatementList2282);
            			    	statement210 = statement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_statement.Add(statement210.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop55;
            	    }
            	} while (true);
            	
            	loop55:
            		;	// Stops C# compiler whinging that label 'loop55' has no statements

            	
            	// AST REWRITE
            	// elements:          statement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 518:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:42: ( statement )*
            	    while ( stream_statement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_statement.Next());
            	    
            	    }
            	    stream_statement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 61, switchStatementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatementList

    public class forEachStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forEachStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:521:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) ;
    public forEachStatement_return forEachStatement() // throws RecognitionException [1]
    {   
        forEachStatement_return retval = new forEachStatement_return();
        retval.start = input.LT(1);
        int forEachStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken f = null;
        IToken EACH211 = null;
        IToken LPAREN212 = null;
        IToken RPAREN214 = null;
        forInClause_return forInClause213 = null;

        statement_return statement215 = null;
        
        
        CommonTree f_tree=null;
        CommonTree EACH211_tree=null;
        CommonTree LPAREN212_tree=null;
        CommonTree RPAREN214_tree=null;
        RewriteRuleTokenStream stream_EACH = new RewriteRuleTokenStream(adaptor,"token EACH");
        RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 62) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:522:4: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:522:4: f= FOR EACH LPAREN forInClause RPAREN statement
            {
            	f = (IToken)input.LT(1);
            	Match(input,FOR,FOLLOW_FOR_in_forEachStatement2305); if (failed) return retval;
            	if ( backtracking==0 ) stream_FOR.Add(f);

            	EACH211 = (IToken)input.LT(1);
            	Match(input,EACH,FOLLOW_EACH_in_forEachStatement2307); if (failed) return retval;
            	if ( backtracking==0 ) stream_EACH.Add(EACH211);

            	LPAREN212 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_forEachStatement2311); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN212);

            	PushFollow(FOLLOW_forInClause_in_forEachStatement2315);
            	forInClause213 = forInClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_forInClause.Add(forInClause213.Tree);
            	RPAREN214 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_forEachStatement2319); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN214);

            	PushFollow(FOLLOW_statement_in_forEachStatement2323);
            	statement215 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_statement.Add(statement215.Tree);
            	
            	// AST REWRITE
            	// elements:          forInClause, statement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 527:3: -> ^( FOR_EACH[$f] forInClause statement )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:527:6: ^( FOR_EACH[$f] forInClause statement )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_EACH, f), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_forInClause.Next());
            	    adaptor.AddChild(root_1, stream_statement.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 62, forEachStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end forEachStatement

    public class forStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:530:1: forStatement : f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) ;
    public forStatement_return forStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forStatement_return retval = new forStatement_return();
        retval.start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken f = null;
        IToken LPAREN216 = null;
        IToken RPAREN218 = null;
        IToken RPAREN221 = null;
        forInClause_return forInClause217 = null;

        statement_return statement219 = null;

        traditionalForClause_return traditionalForClause220 = null;

        statement_return statement222 = null;
        
        
        CommonTree f_tree=null;
        CommonTree LPAREN216_tree=null;
        CommonTree RPAREN218_tree=null;
        CommonTree RPAREN221_tree=null;
        RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        RewriteRuleSubtreeStream stream_traditionalForClause = new RewriteRuleSubtreeStream(adaptor,"rule traditionalForClause");
        RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 63) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:535:4: (f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:535:4: f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            {
            	f = (IToken)input.LT(1);
            	Match(input,FOR,FOLLOW_FOR_in_forStatement2359); if (failed) return retval;
            	if ( backtracking==0 ) stream_FOR.Add(f);

            	LPAREN216 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_forStatement2363); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN216);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            	int alt56 = 2;
            	switch ( input.LA(1) ) 
            	{
            	case VAR:
            	case CONST:
            		{
            	    switch ( input.LA(2) ) 
            	    {
            	    case IDENT:
            	    	{
            	        int LA56_36 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s36 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 36, input);
            	        
            	            throw nvae_d56s36;
            	        }
            	        }
            	        break;
            	    case USE:
            	    	{
            	        int LA56_37 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s37 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 37, input);
            	        
            	            throw nvae_d56s37;
            	        }
            	        }
            	        break;
            	    case XML:
            	    	{
            	        int LA56_38 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s38 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 38, input);
            	        
            	            throw nvae_d56s38;
            	        }
            	        }
            	        break;
            	    case DYNAMIC:
            	    	{
            	        int LA56_39 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s39 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 39, input);
            	        
            	            throw nvae_d56s39;
            	        }
            	        }
            	        break;
            	    case NAMESPACE:
            	    	{
            	        int LA56_40 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s40 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 40, input);
            	        
            	            throw nvae_d56s40;
            	        }
            	        }
            	        break;
            	    case IS:
            	    	{
            	        int LA56_41 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s41 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 41, input);
            	        
            	            throw nvae_d56s41;
            	        }
            	        }
            	        break;
            	    case AS:
            	    	{
            	        int LA56_42 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s42 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 42, input);
            	        
            	            throw nvae_d56s42;
            	        }
            	        }
            	        break;
            	    case GET:
            	    	{
            	        int LA56_43 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s43 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 43, input);
            	        
            	            throw nvae_d56s43;
            	        }
            	        }
            	        break;
            	    case SET:
            	    	{
            	        int LA56_44 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s44 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 44, input);
            	        
            	            throw nvae_d56s44;
            	        }
            	        }
            	        break;
            	    	default:
            	    	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    	    NoViableAltException nvae_d56s1 =
            	    	        new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 1, input);
            	    
            	    	    throw nvae_d56s1;
            	    }
            	
            	    }
            	    break;
            	case IDENT:
            		{
            	    int LA56_2 = input.LA(2);
            	    
            	    if ( (LA56_2 == IN) )
            	    {
            	        int LA56_45 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s45 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 45, input);
            	        
            	            throw nvae_d56s45;
            	        }
            	    }
            	    else if ( (LA56_2 == SEMI || LA56_2 == COMMA || (LA56_2 >= ASSIGN && LA56_2 <= LPAREN) || (LA56_2 >= STAR && LA56_2 <= DBL_COLON) || LA56_2 == LBRACK || (LA56_2 >= STAR_ASSIGN && LA56_2 <= DEC) || LA56_2 == E4X_DESC || (LA56_2 >= 186 && LA56_2 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s2 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 2, input);
            	    
            	        throw nvae_d56s2;
            	    }
            	    }
            	    break;
            	case USE:
            		{
            	    int LA56_3 = input.LA(2);
            	    
            	    if ( (LA56_3 == SEMI || LA56_3 == COMMA || (LA56_3 >= ASSIGN && LA56_3 <= LPAREN) || (LA56_3 >= STAR && LA56_3 <= DOT) || LA56_3 == LBRACK || (LA56_3 >= STAR_ASSIGN && LA56_3 <= DEC) || LA56_3 == E4X_DESC || (LA56_3 >= 186 && LA56_3 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else if ( (LA56_3 == IN) )
            	    {
            	        int LA56_82 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s82 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 82, input);
            	        
            	            throw nvae_d56s82;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s3 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 3, input);
            	    
            	        throw nvae_d56s3;
            	    }
            	    }
            	    break;
            	case XML:
            		{
            	    int LA56_4 = input.LA(2);
            	    
            	    if ( (LA56_4 == IN) )
            	    {
            	        int LA56_100 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s100 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 100, input);
            	        
            	            throw nvae_d56s100;
            	        }
            	    }
            	    else if ( (LA56_4 == SEMI || LA56_4 == COMMA || (LA56_4 >= ASSIGN && LA56_4 <= LPAREN) || (LA56_4 >= STAR && LA56_4 <= DOT) || LA56_4 == LBRACK || (LA56_4 >= STAR_ASSIGN && LA56_4 <= DEC) || LA56_4 == E4X_DESC || (LA56_4 >= 186 && LA56_4 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s4 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 4, input);
            	    
            	        throw nvae_d56s4;
            	    }
            	    }
            	    break;
            	case DYNAMIC:
            		{
            	    int LA56_5 = input.LA(2);
            	    
            	    if ( (LA56_5 == IN) )
            	    {
            	        int LA56_127 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s127 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 127, input);
            	        
            	            throw nvae_d56s127;
            	        }
            	    }
            	    else if ( (LA56_5 == SEMI || LA56_5 == COMMA || (LA56_5 >= ASSIGN && LA56_5 <= LPAREN) || (LA56_5 >= STAR && LA56_5 <= DOT) || LA56_5 == LBRACK || (LA56_5 >= STAR_ASSIGN && LA56_5 <= DEC) || LA56_5 == E4X_DESC || (LA56_5 >= 186 && LA56_5 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s5 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 5, input);
            	    
            	        throw nvae_d56s5;
            	    }
            	    }
            	    break;
            	case NAMESPACE:
            		{
            	    int LA56_6 = input.LA(2);
            	    
            	    if ( (LA56_6 == SEMI || LA56_6 == COMMA || (LA56_6 >= ASSIGN && LA56_6 <= LPAREN) || (LA56_6 >= STAR && LA56_6 <= DOT) || LA56_6 == LBRACK || (LA56_6 >= STAR_ASSIGN && LA56_6 <= DEC) || LA56_6 == E4X_DESC || (LA56_6 >= 186 && LA56_6 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else if ( (LA56_6 == IN) )
            	    {
            	        int LA56_163 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s163 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 163, input);
            	        
            	            throw nvae_d56s163;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s6 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 6, input);
            	    
            	        throw nvae_d56s6;
            	    }
            	    }
            	    break;
            	case IS:
            		{
            	    int LA56_7 = input.LA(2);
            	    
            	    if ( (LA56_7 == IN) )
            	    {
            	        int LA56_181 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s181 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 181, input);
            	        
            	            throw nvae_d56s181;
            	        }
            	    }
            	    else if ( (LA56_7 == SEMI || LA56_7 == COMMA || (LA56_7 >= ASSIGN && LA56_7 <= LPAREN) || (LA56_7 >= STAR && LA56_7 <= DOT) || LA56_7 == LBRACK || (LA56_7 >= STAR_ASSIGN && LA56_7 <= DEC) || LA56_7 == E4X_DESC || (LA56_7 >= 186 && LA56_7 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s7 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 7, input);
            	    
            	        throw nvae_d56s7;
            	    }
            	    }
            	    break;
            	case AS:
            		{
            	    int LA56_8 = input.LA(2);
            	    
            	    if ( (LA56_8 == IN) )
            	    {
            	        int LA56_208 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s208 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 208, input);
            	        
            	            throw nvae_d56s208;
            	        }
            	    }
            	    else if ( (LA56_8 == SEMI || LA56_8 == COMMA || (LA56_8 >= ASSIGN && LA56_8 <= LPAREN) || (LA56_8 >= STAR && LA56_8 <= DOT) || LA56_8 == LBRACK || (LA56_8 >= STAR_ASSIGN && LA56_8 <= DEC) || LA56_8 == E4X_DESC || (LA56_8 >= 186 && LA56_8 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s8 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 8, input);
            	    
            	        throw nvae_d56s8;
            	    }
            	    }
            	    break;
            	case GET:
            		{
            	    int LA56_9 = input.LA(2);
            	    
            	    if ( (LA56_9 == IN) )
            	    {
            	        int LA56_235 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s235 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 235, input);
            	        
            	            throw nvae_d56s235;
            	        }
            	    }
            	    else if ( (LA56_9 == SEMI || LA56_9 == COMMA || (LA56_9 >= ASSIGN && LA56_9 <= LPAREN) || (LA56_9 >= STAR && LA56_9 <= DOT) || LA56_9 == LBRACK || (LA56_9 >= STAR_ASSIGN && LA56_9 <= DEC) || LA56_9 == E4X_DESC || (LA56_9 >= 186 && LA56_9 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s9 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 9, input);
            	    
            	        throw nvae_d56s9;
            	    }
            	    }
            	    break;
            	case SET:
            		{
            	    int LA56_10 = input.LA(2);
            	    
            	    if ( (LA56_10 == IN) )
            	    {
            	        int LA56_262 = input.LA(3);
            	        
            	        if ( (synpred86()) )
            	        {
            	            alt56 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt56 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d56s262 =
            	                new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 262, input);
            	        
            	            throw nvae_d56s262;
            	        }
            	    }
            	    else if ( (LA56_10 == SEMI || LA56_10 == COMMA || (LA56_10 >= ASSIGN && LA56_10 <= LPAREN) || (LA56_10 >= STAR && LA56_10 <= DOT) || LA56_10 == LBRACK || (LA56_10 >= STAR_ASSIGN && LA56_10 <= DEC) || LA56_10 == E4X_DESC || (LA56_10 >= 186 && LA56_10 <= 187)) )
            	    {
            	        alt56 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d56s10 =
            	            new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 10, input);
            	    
            	        throw nvae_d56s10;
            	    }
            	    }
            	    break;
            	case LCURLY:
            	case SEMI:
            	case STRING_LITERAL:
            	case FUNCTION:
            	case LPAREN:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case LBRACK:
            	case LT:
            	case PLUS:
            	case MINUS:
            	case DIV:
            	case INC:
            	case DEC:
            	case DELETE:
            	case TYPEOF:
            	case LNOT:
            	case BNOT:
            	case E4X_ATTRI:
            	case UNDEFINED:
            	case TRUE:
            	case FALSE:
            	case NULL:
            	case HEX_LITERAL:
            	case DECIMAL_LITERAL:
            	case OCTAL_LITERAL:
            	case FLOAT_LITERAL:
            	case NEW:
            	case 180:
            		{
            	    alt56 = 2;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d56s0 =
            		        new NoViableAltException("537:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 56, 0, input);
            	
            		    throw nvae_d56s0;
            	}
            	
            	switch (alt56) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:537:5: ( forInClauseDecl IN )=> forInClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_forInClause_in_forStatement2375);
            	        	forInClause217 = forInClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_forInClause.Add(forInClause217.Tree);
            	        	RPAREN218 = (IToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2377); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN218);

            	        	PushFollow(FOLLOW_statement_in_forStatement2379);
            	        	statement219 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement219.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          statement, forInClause
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 538:4: -> ^( FOR_IN[$f] forInClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:7: ^( FOR_IN[$f] forInClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_IN, f), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_forInClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:540:5: traditionalForClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_traditionalForClause_in_forStatement2400);
            	        	traditionalForClause220 = traditionalForClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_traditionalForClause.Add(traditionalForClause220.Tree);
            	        	RPAREN221 = (IToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2402); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN221);

            	        	PushFollow(FOLLOW_statement_in_forStatement2404);
            	        	statement222 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement222.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          statement, f, traditionalForClause
            	        	// token labels:      f
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleTokenStream stream_f = new RewriteRuleTokenStream(adaptor, "token f", f);
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 541:4: -> ^( $f traditionalForClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:7: ^( $f traditionalForClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_f.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_traditionalForClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 63, forStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forStatement

    public class traditionalForClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start traditionalForClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:545:1: traditionalForClause : a= forInit SEMI b= forCond SEMI c= forIter ;
    public traditionalForClause_return traditionalForClause() // throws RecognitionException [1]
    {   
        traditionalForClause_return retval = new traditionalForClause_return();
        retval.start = input.LT(1);
        int traditionalForClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI223 = null;
        IToken SEMI224 = null;
        forInit_return a = null;

        forCond_return b = null;

        forIter_return c = null;
        
        
        CommonTree SEMI223_tree=null;
        CommonTree SEMI224_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 64) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:546:4: (a= forInit SEMI b= forCond SEMI c= forIter )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:546:4: a= forInit SEMI b= forCond SEMI c= forIter
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInit_in_traditionalForClause2435);
            	a = forInit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, a.Tree);
            	SEMI223 = (IToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2437); if (failed) return retval;
            	PushFollow(FOLLOW_forCond_in_traditionalForClause2445);
            	b = forCond();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, b.Tree);
            	SEMI224 = (IToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2447); if (failed) return retval;
            	PushFollow(FOLLOW_forIter_in_traditionalForClause2455);
            	c = forIter();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 64, traditionalForClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end traditionalForClause

    public class forInClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:1: forInClause : forInClauseDecl IN forInClauseTail ;
    public forInClause_return forInClause() // throws RecognitionException [1]
    {   
        forInClause_return retval = new forInClause_return();
        retval.start = input.LT(1);
        int forInClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IN226 = null;
        forInClauseDecl_return forInClauseDecl225 = null;

        forInClauseTail_return forInClauseTail227 = null;
        
        
        CommonTree IN226_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 65) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:552:4: ( forInClauseDecl IN forInClauseTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:552:4: forInClauseDecl IN forInClauseTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInClauseDecl_in_forInClause2467);
            	forInClauseDecl225 = forInClauseDecl();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseDecl225.Tree);
            	IN226 = (IToken)input.LT(1);
            	Match(input,IN,FOLLOW_IN_in_forInClause2469); if (failed) return retval;
            	PushFollow(FOLLOW_forInClauseTail_in_forInClause2472);
            	forInClauseTail227 = forInClauseTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseTail227.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 65, forInClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end forInClause

    public class forInClauseDecl_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseDecl
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:555:1: forInClauseDecl : ( declaration | ident );
    public forInClauseDecl_return forInClauseDecl() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseDecl_return retval = new forInClauseDecl_return();
        retval.start = input.LT(1);
        int forInClauseDecl_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration228 = null;

        ident_return ident229 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 66) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:4: ( declaration | ident )
            int alt57 = 2;
            int LA57_0 = input.LA(1);
            
            if ( ((LA57_0 >= VAR && LA57_0 <= CONST)) )
            {
                alt57 = 1;
            }
            else if ( ((LA57_0 >= GET && LA57_0 <= USE) || LA57_0 == XML || LA57_0 == IDENT || LA57_0 == DYNAMIC || (LA57_0 >= IS && LA57_0 <= AS)) )
            {
                alt57 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d57s0 =
                    new NoViableAltException("555:1: forInClauseDecl : ( declaration | ident );", 57, 0, input);
            
                throw nvae_d57s0;
            }
            switch (alt57) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:4: declaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declaration_in_forInClauseDecl2493);
                    	declaration228 = declaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration228.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:18: ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_forInClauseDecl2497);
                    	ident229 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ident229.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 66, forInClauseDecl_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseDecl

    public class forInClauseTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:1: forInClauseTail : expressionList ;
    public forInClauseTail_return forInClauseTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseTail_return retval = new forInClauseTail_return();
        retval.start = input.LT(1);
        int forInClauseTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList230 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 67) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:569:4: ( expressionList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:569:4: expressionList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_expressionList_in_forInClauseTail2519);
            	expressionList230 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList230.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 67, forInClauseTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseTail

    public class forInit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:573:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
    public forInit_return forInit() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInit_return retval = new forInit_return();
        retval.start = input.LT(1);
        int forInit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration231 = null;

        expressionList_return expressionList232 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        RewriteRuleSubtreeStream stream_declaration = new RewriteRuleSubtreeStream(adaptor,"rule declaration");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 68) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:4: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:4: ( declaration | expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:4: ( declaration | expressionList )?
            	int alt58 = 3;
            	int LA58_0 = input.LA(1);
            	
            	if ( ((LA58_0 >= VAR && LA58_0 <= CONST)) )
            	{
            	    alt58 = 1;
            	}
            	else if ( (LA58_0 == LCURLY || (LA58_0 >= STRING_LITERAL && LA58_0 <= USE) || LA58_0 == LPAREN || LA58_0 == XML || (LA58_0 >= IDENT && LA58_0 <= LBRACK) || LA58_0 == DYNAMIC || LA58_0 == LT || (LA58_0 >= IS && LA58_0 <= AS) || (LA58_0 >= PLUS && LA58_0 <= DIV) || (LA58_0 >= INC && LA58_0 <= BNOT) || (LA58_0 >= E4X_ATTRI && LA58_0 <= NEW) || LA58_0 == 180) )
            	{
            	    alt58 = 2;
            	}
            	switch (alt58) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:5: declaration
            	        {
            	        	PushFollow(FOLLOW_declaration_in_forInit2543);
            	        	declaration231 = declaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_declaration.Add(declaration231.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:19: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forInit2547);
            	        	expressionList232 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList232.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList, declaration
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 579:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:579:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:579:17: ( declaration )?
            	    if ( stream_declaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_declaration.Next());
            	    
            	    }
            	    stream_declaration.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:579:30: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 68, forInit_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInit

    public class forCond_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forCond
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:582:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
    public forCond_return forCond() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forCond_return retval = new forCond_return();
        retval.start = input.LT(1);
        int forCond_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList233 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 69) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:4: ( expressionList )?
            	int alt59 = 2;
            	int LA59_0 = input.LA(1);
            	
            	if ( (LA59_0 == LCURLY || (LA59_0 >= STRING_LITERAL && LA59_0 <= USE) || LA59_0 == LPAREN || LA59_0 == XML || (LA59_0 >= IDENT && LA59_0 <= LBRACK) || LA59_0 == DYNAMIC || LA59_0 == LT || (LA59_0 >= IS && LA59_0 <= AS) || (LA59_0 >= PLUS && LA59_0 <= DIV) || (LA59_0 >= INC && LA59_0 <= BNOT) || (LA59_0 >= E4X_ATTRI && LA59_0 <= NEW) || LA59_0 == 180) )
            	{
            	    alt59 = 1;
            	}
            	switch (alt59) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forCond2585);
            	        	expressionList233 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList233.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 588:3: -> ^( FOR_CONDITION ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:588:6: ^( FOR_CONDITION ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:588:22: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 69, forCond_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forCond

    public class forIter_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forIter
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:591:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
    public forIter_return forIter() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forIter_return retval = new forIter_return();
        retval.start = input.LT(1);
        int forIter_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList234 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 70) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( expressionList )?
            	int alt60 = 2;
            	int LA60_0 = input.LA(1);
            	
            	if ( (LA60_0 == LCURLY || (LA60_0 >= STRING_LITERAL && LA60_0 <= USE) || LA60_0 == LPAREN || LA60_0 == XML || (LA60_0 >= IDENT && LA60_0 <= LBRACK) || LA60_0 == DYNAMIC || LA60_0 == LT || (LA60_0 >= IS && LA60_0 <= AS) || (LA60_0 >= PLUS && LA60_0 <= DIV) || (LA60_0 >= INC && LA60_0 <= BNOT) || (LA60_0 >= E4X_ATTRI && LA60_0 <= NEW) || LA60_0 == 180) )
            	{
            	    alt60 = 1;
            	}
            	switch (alt60) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forIter2618);
            	        	expressionList234 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList234.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 597:3: -> ^( FOR_ITERATOR ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:597:6: ^( FOR_ITERATOR ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:597:21: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 70, forIter_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forIter

    public class whileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start whileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:600:1: whileStatement : WHILE condition ( ( commentExpression )* statement ) ;
    public whileStatement_return whileStatement() // throws RecognitionException [1]
    {   
        whileStatement_return retval = new whileStatement_return();
        retval.start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken WHILE235 = null;
        condition_return condition236 = null;

        commentExpression_return commentExpression237 = null;

        statement_return statement238 = null;
        
        
        CommonTree WHILE235_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 71) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:4: ( WHILE condition ( ( commentExpression )* statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:4: WHILE condition ( ( commentExpression )* statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WHILE235 = (IToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_whileStatement2641); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WHILE235_tree = (CommonTree)adaptor.Create(WHILE235);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WHILE235_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_whileStatement2644);
            	condition236 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition236.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:21: ( ( commentExpression )* statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:22: ( commentExpression )* statement
            	{
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:22: ( commentExpression )*
            		do 
            		{
            		    int alt61 = 2;
            		    int LA61_0 = input.LA(1);
            		    
            		    if ( (LA61_0 == SL_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA61_50 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA61_51 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA61_52 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA61_53 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA61_54 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA61_55 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA61_56 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA61_57 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA61_58 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 180:
            		        	{
            		            int LA61_59 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA61_60 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA61_61 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA61_62 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA61_63 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA61_64 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA61_65 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA61_66 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA61_67 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA61_68 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA61_69 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA61_70 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA61_71 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA61_72 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA61_73 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA61_74 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA61_75 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA61_76 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA61_77 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA61_78 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA61_79 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA61_80 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA61_81 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA61_82 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA61_83 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA61_84 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA61_85 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA61_86 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA61_87 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA61_88 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA61_89 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA61_90 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA61_91 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA61_92 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA61_93 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA61_94 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 176:
            		        	{
            		            int LA61_95 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA61_96 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA61_97 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA61_98 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    else if ( (LA61_0 == ML_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA61_103 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA61_104 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA61_105 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA61_106 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA61_107 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA61_108 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA61_109 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA61_110 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA61_111 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 180:
            		        	{
            		            int LA61_112 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA61_113 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA61_114 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA61_115 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA61_116 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA61_117 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA61_118 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA61_119 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA61_120 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA61_121 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA61_122 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA61_123 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA61_124 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA61_125 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA61_126 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA61_127 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA61_128 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA61_129 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA61_130 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA61_131 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA61_132 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA61_133 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA61_134 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA61_135 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA61_136 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA61_137 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA61_138 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA61_139 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA61_140 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA61_141 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA61_142 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA61_143 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA61_144 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA61_145 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA61_146 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA61_147 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 176:
            		        	{
            		            int LA61_148 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA61_149 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA61_150 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA61_151 = input.LA(3);
            		            
            		            if ( (synpred92()) )
            		            {
            		                alt61 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    
            		
            		    switch (alt61) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_whileStatement2647);
            				    	commentExpression237 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression237.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop61;
            		    }
            		} while (true);
            		
            		loop61:
            			;	// Stops C# compiler whinging that label 'loop61' has no statements

            		PushFollow(FOLLOW_statement_in_whileStatement2650);
            		statement238 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement238.Tree);
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 71, whileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end whileStatement

    public class doWhileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start doWhileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:604:1: doWhileStatement : DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi ;
    public doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {   
        doWhileStatement_return retval = new doWhileStatement_return();
        retval.start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DO239 = null;
        IToken WHILE242 = null;
        commentExpression_return commentExpression240 = null;

        statement_return statement241 = null;

        condition_return condition243 = null;

        commentExpression_return commentExpression244 = null;

        semi_return semi245 = null;
        
        
        CommonTree DO239_tree=null;
        CommonTree WHILE242_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 72) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:4: ( DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:4: DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DO239 = (IToken)input.LT(1);
            	Match(input,DO,FOLLOW_DO_in_doWhileStatement2662); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DO239_tree = (CommonTree)adaptor.Create(DO239);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DO239_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:8: ( commentExpression )*
            	do 
            	{
            	    int alt62 = 2;
            	    int LA62_0 = input.LA(1);
            	    
            	    if ( (LA62_0 == SL_COMMENT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case SL_COMMENT:
            	        	{
            	            int LA62_50 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA62_51 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        case SEMI:
            	        case STRING_LITERAL:
            	        case FUNCTION:
            	        case GET:
            	        case SET:
            	        case NAMESPACE:
            	        case USE:
            	        case VAR:
            	        case CONST:
            	        case LPAREN:
            	        case IF:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case DEFAULT:
            	        case FOR:
            	        case DO:
            	        case WITH:
            	        case XML:
            	        case IDENT:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case LBRACK:
            	        case DYNAMIC:
            	        case LT:
            	        case IS:
            	        case AS:
            	        case PLUS:
            	        case MINUS:
            	        case DIV:
            	        case INC:
            	        case DEC:
            	        case DELETE:
            	        case TYPEOF:
            	        case LNOT:
            	        case BNOT:
            	        case E4X_ATTRI:
            	        case UNDEFINED:
            	        case TRUE:
            	        case FALSE:
            	        case NULL:
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        case NEW:
            	        case 176:
            	        case 177:
            	        case 180:
            	        	{
            	            alt62 = 1;
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA62_88 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA62_0 == ML_COMMENT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case SL_COMMENT:
            	        	{
            	            int LA62_99 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA62_100 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        case SEMI:
            	        case STRING_LITERAL:
            	        case FUNCTION:
            	        case GET:
            	        case SET:
            	        case NAMESPACE:
            	        case USE:
            	        case VAR:
            	        case CONST:
            	        case LPAREN:
            	        case IF:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case DEFAULT:
            	        case FOR:
            	        case DO:
            	        case WITH:
            	        case XML:
            	        case IDENT:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case LBRACK:
            	        case DYNAMIC:
            	        case LT:
            	        case IS:
            	        case AS:
            	        case PLUS:
            	        case MINUS:
            	        case DIV:
            	        case INC:
            	        case DEC:
            	        case DELETE:
            	        case TYPEOF:
            	        case LNOT:
            	        case BNOT:
            	        case E4X_ATTRI:
            	        case UNDEFINED:
            	        case TRUE:
            	        case FALSE:
            	        case NULL:
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        case NEW:
            	        case 176:
            	        case 177:
            	        case 180:
            	        	{
            	            alt62 = 1;
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA62_137 = input.LA(3);
            	            
            	            if ( (synpred93()) )
            	            {
            	                alt62 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt62) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            			    {
            			    	PushFollow(FOLLOW_commentExpression_in_doWhileStatement2665);
            			    	commentExpression240 = commentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression240.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop62;
            	    }
            	} while (true);
            	
            	loop62:
            		;	// Stops C# compiler whinging that label 'loop62' has no statements

            	PushFollow(FOLLOW_statement_in_doWhileStatement2668);
            	statement241 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement241.Tree);
            	WHILE242 = (IToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_doWhileStatement2670); if (failed) return retval;
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:44: ( condition ( commentExpression )* )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:45: condition ( commentExpression )*
            	{
            		PushFollow(FOLLOW_condition_in_doWhileStatement2674);
            		condition243 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition243.Tree);
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:55: ( commentExpression )*
            		do 
            		{
            		    int alt63 = 2;
            		    int LA63_0 = input.LA(1);
            		    
            		    if ( (LA63_0 == SL_COMMENT) )
            		    {
            		        int LA63_49 = input.LA(2);
            		        
            		        if ( (synpred94()) )
            		        {
            		            alt63 = 1;
            		        }
            		        
            		    
            		    }
            		    else if ( (LA63_0 == ML_COMMENT) )
            		    {
            		        int LA63_50 = input.LA(2);
            		        
            		        if ( (synpred94()) )
            		        {
            		            alt63 = 1;
            		        }
            		        
            		    
            		    }
            		    
            		
            		    switch (alt63) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_doWhileStatement2676);
            				    	commentExpression244 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression244.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop63;
            		    }
            		} while (true);
            		
            		loop63:
            			;	// Stops C# compiler whinging that label 'loop63' has no statements

            	
            	}

            	PushFollow(FOLLOW_semi_in_doWhileStatement2680);
            	semi245 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi245.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 72, doWhileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end doWhileStatement

    public class withStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start withStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:608:1: withStatement : WITH condition ( ( commentExpression )* statement ) ;
    public withStatement_return withStatement() // throws RecognitionException [1]
    {   
        withStatement_return retval = new withStatement_return();
        retval.start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken WITH246 = null;
        condition_return condition247 = null;

        commentExpression_return commentExpression248 = null;

        statement_return statement249 = null;
        
        
        CommonTree WITH246_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 73) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:4: ( WITH condition ( ( commentExpression )* statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:4: WITH condition ( ( commentExpression )* statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WITH246 = (IToken)input.LT(1);
            	Match(input,WITH,FOLLOW_WITH_in_withStatement2691); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WITH246_tree = (CommonTree)adaptor.Create(WITH246);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WITH246_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_withStatement2694);
            	condition247 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition247.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:20: ( ( commentExpression )* statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:21: ( commentExpression )* statement
            	{
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:21: ( commentExpression )*
            		do 
            		{
            		    int alt64 = 2;
            		    int LA64_0 = input.LA(1);
            		    
            		    if ( (LA64_0 == SL_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA64_50 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA64_51 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA64_53 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA64_54 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA64_55 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA64_56 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA64_57 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA64_58 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA64_59 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 180:
            		        	{
            		            int LA64_60 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA64_61 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA64_62 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA64_63 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA64_64 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA64_65 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA64_66 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA64_67 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA64_68 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA64_69 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA64_70 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA64_71 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA64_72 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA64_73 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA64_74 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA64_75 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA64_76 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA64_77 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA64_78 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA64_79 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA64_80 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA64_81 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA64_82 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA64_83 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA64_84 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA64_85 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA64_86 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA64_87 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA64_88 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA64_89 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA64_90 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA64_91 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA64_92 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA64_93 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA64_94 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA64_95 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 176:
            		        	{
            		            int LA64_96 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA64_97 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA64_98 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA64_99 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    else if ( (LA64_0 == ML_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA64_103 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA64_104 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA64_105 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA64_106 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA64_107 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA64_108 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA64_109 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA64_110 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA64_111 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 180:
            		        	{
            		            int LA64_112 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA64_113 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA64_114 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA64_115 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA64_116 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA64_117 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA64_118 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA64_119 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA64_120 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA64_121 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA64_122 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA64_123 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA64_124 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA64_125 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA64_126 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA64_127 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA64_128 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA64_129 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA64_130 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA64_131 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA64_132 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA64_133 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA64_134 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA64_135 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA64_136 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA64_137 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA64_138 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA64_139 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA64_140 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA64_141 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA64_142 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA64_143 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA64_144 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA64_145 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA64_146 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA64_147 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 176:
            		        	{
            		            int LA64_148 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA64_149 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA64_150 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA64_151 = input.LA(3);
            		            
            		            if ( (synpred95()) )
            		            {
            		                alt64 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    
            		
            		    switch (alt64) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_withStatement2697);
            				    	commentExpression248 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression248.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop64;
            		    }
            		} while (true);
            		
            		loop64:
            			;	// Stops C# compiler whinging that label 'loop64' has no statements

            		PushFollow(FOLLOW_statement_in_withStatement2700);
            		statement249 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement249.Tree);
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 73, withStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end withStatement

    public class defaultXMLNamespaceStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start defaultXMLNamespaceStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
    public defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement() // throws RecognitionException [1]
    {   
        defaultXMLNamespaceStatement_return retval = new defaultXMLNamespaceStatement_return();
        retval.start = input.LT(1);
        int defaultXMLNamespaceStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DEFAULT250 = null;
        IToken XML251 = null;
        IToken NAMESPACE252 = null;
        IToken ASSIGN253 = null;
        expression_return expression254 = null;

        semi_return semi255 = null;
        
        
        CommonTree DEFAULT250_tree=null;
        CommonTree XML251_tree=null;
        CommonTree NAMESPACE252_tree=null;
        CommonTree ASSIGN253_tree=null;
        RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor,"token XML");
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleTokenStream stream_DEFAULT = new RewriteRuleTokenStream(adaptor,"token DEFAULT");
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 74) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:613:4: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:613:4: DEFAULT XML NAMESPACE ASSIGN expression semi
            {
            	DEFAULT250 = (IToken)input.LT(1);
            	Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2712); if (failed) return retval;
            	if ( backtracking==0 ) stream_DEFAULT.Add(DEFAULT250);

            	XML251 = (IToken)input.LT(1);
            	Match(input,XML,FOLLOW_XML_in_defaultXMLNamespaceStatement2714); if (failed) return retval;
            	if ( backtracking==0 ) stream_XML.Add(XML251);

            	NAMESPACE252 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2716); if (failed) return retval;
            	if ( backtracking==0 ) stream_NAMESPACE.Add(NAMESPACE252);

            	ASSIGN253 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2718); if (failed) return retval;
            	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN253);

            	PushFollow(FOLLOW_expression_in_defaultXMLNamespaceStatement2720);
            	expression254 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expression.Add(expression254.Tree);
            	PushFollow(FOLLOW_semi_in_defaultXMLNamespaceStatement2722);
            	semi255 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi255.Tree);
            	
            	// AST REWRITE
            	// elements:          expression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 614:3: -> ^( DEFAULT_XML_NAMESPACE expression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:614:6: ^( DEFAULT_XML_NAMESPACE expression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 74, defaultXMLNamespaceStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end defaultXMLNamespaceStatement

    public class typeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:617:1: typeExpression : c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) ;
    public typeExpression_return typeExpression() // throws RecognitionException [1]
    {   
        typeExpression_return retval = new typeExpression_return();
        retval.start = input.LT(1);
        int typeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken c = null;
        IToken string_literal257 = null;
        IToken STAR258 = null;
        identifier_return identifier256 = null;
        
        
        CommonTree c_tree=null;
        CommonTree string_literal257_tree=null;
        CommonTree STAR258_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_180 = new RewriteRuleTokenStream(adaptor,"token 180");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 75) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:4: (c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:4: c= COLON ( identifier | 'void' | STAR )
            {
            	c = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_typeExpression2745); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(c);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:620:3: ( identifier | 'void' | STAR )
            	int alt65 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case USE:
            	case XML:
            	case IDENT:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case DYNAMIC:
            	case IS:
            	case AS:
            		{
            	    alt65 = 1;
            	    }
            	    break;
            	case 180:
            		{
            	    alt65 = 2;
            	    }
            	    break;
            	case STAR:
            		{
            	    alt65 = 3;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d65s0 =
            		        new NoViableAltException("620:3: ( identifier | 'void' | STAR )", 65, 0, input);
            	
            		    throw nvae_d65s0;
            	}
            	
            	switch (alt65) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:620:4: identifier
            	        {
            	        	PushFollow(FOLLOW_identifier_in_typeExpression2753);
            	        	identifier256 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_identifier.Add(identifier256.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:620:17: 'void'
            	        {
            	        	string_literal257 = (IToken)input.LT(1);
            	        	Match(input,180,FOLLOW_180_in_typeExpression2757); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_180.Add(string_literal257);

            	        
            	        }
            	        break;
            	    case 3 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:620:26: STAR
            	        {
            	        	STAR258 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_typeExpression2761); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR258);

            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          180, identifier, STAR
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 621:3: -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:6: ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_SPEC, c), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:22: ( identifier )?
            	    if ( stream_identifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_identifier.Next());
            	    
            	    }
            	    stream_identifier.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:34: ( 'void' )?
            	    if ( stream_180.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_180.Next());
            	    
            	    }
            	    stream_180.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:42: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 75, typeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeExpression

    public class identifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:624:1: identifier : qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) ;
    public identifier_return identifier() // throws RecognitionException [1]
    {   
        identifier_return retval = new identifier_return();
        retval.start = input.LT(1);
        int identifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT260 = null;
        qualifiedIdent_return qualifiedIdent259 = null;

        qualifiedIdent_return qualifiedIdent261 = null;
        
        
        CommonTree DOT260_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 76) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:625:4: ( qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:625:4: qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )*
            {
            	PushFollow(FOLLOW_qualifiedIdent_in_identifier2793);
            	qualifiedIdent259 = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent259.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:626:3: ( options {greedy=true; } : DOT qualifiedIdent )*
            	do 
            	{
            	    int alt66 = 2;
            	    int LA66_0 = input.LA(1);
            	    
            	    if ( (LA66_0 == DOT) )
            	    {
            	        alt66 = 1;
            	    }
            	    
            	
            	    switch (alt66) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:627:6: DOT qualifiedIdent
            			    {
            			    	DOT260 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifier2811); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT260);

            			    	PushFollow(FOLLOW_qualifiedIdent_in_identifier2813);
            			    	qualifiedIdent261 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent261.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop66;
            	    }
            	} while (true);
            	
            	loop66:
            		;	// Stops C# compiler whinging that label 'loop66' has no statements

            	
            	// AST REWRITE
            	// elements:          qualifiedIdent
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 629:3: -> ^( IDENTIFIER ( qualifiedIdent )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:629:6: ^( IDENTIFIER ( qualifiedIdent )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_qualifiedIdent.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_qualifiedIdent.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            	    
            	    }
            	    stream_qualifiedIdent.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 76, identifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifier

    public class qualifiedIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start qualifiedIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:632:1: qualifiedIdent : ( namespaceName DBL_COLON )? ident ;
    public qualifiedIdent_return qualifiedIdent() // throws RecognitionException [1]
    {   
        qualifiedIdent_return retval = new qualifiedIdent_return();
        retval.start = input.LT(1);
        int qualifiedIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DBL_COLON263 = null;
        namespaceName_return namespaceName262 = null;

        ident_return ident264 = null;
        
        
        CommonTree DBL_COLON263_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 77) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:4: ( ( namespaceName DBL_COLON )? ident )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:4: ( namespaceName DBL_COLON )? ident
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:4: ( namespaceName DBL_COLON )?
            	int alt67 = 2;
            	int LA67_0 = input.LA(1);
            	
            	if ( (LA67_0 == IDENT) )
            	{
            	    int LA67_1 = input.LA(2);
            	    
            	    if ( (LA67_1 == DBL_COLON) )
            	    {
            	        alt67 = 1;
            	    }
            	}
            	else if ( ((LA67_0 >= PUBLIC && LA67_0 <= INTERNAL)) )
            	{
            	    alt67 = 1;
            	}
            	switch (alt67) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:633:5: namespaceName DBL_COLON
            	        {
            	        	PushFollow(FOLLOW_namespaceName_in_qualifiedIdent2841);
            	        	namespaceName262 = namespaceName();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceName262.Tree);
            	        	DBL_COLON263 = (IToken)input.LT(1);
            	        	Match(input,DBL_COLON,FOLLOW_DBL_COLON_in_qualifiedIdent2843); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	DBL_COLON263_tree = (CommonTree)adaptor.Create(DBL_COLON263);
            	        	adaptor.AddChild(root_0, DBL_COLON263_tree);
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_ident_in_qualifiedIdent2847);
            	ident264 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident264.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 77, qualifiedIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end qualifiedIdent

    public class namespaceName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start namespaceName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:636:1: namespaceName : ( IDENT | reservedNamespace );
    public namespaceName_return namespaceName() // throws RecognitionException [1]
    {   
        namespaceName_return retval = new namespaceName_return();
        retval.start = input.LT(1);
        int namespaceName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IDENT265 = null;
        reservedNamespace_return reservedNamespace266 = null;
        
        
        CommonTree IDENT265_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 78) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:637:4: ( IDENT | reservedNamespace )
            int alt68 = 2;
            int LA68_0 = input.LA(1);
            
            if ( (LA68_0 == IDENT) )
            {
                alt68 = 1;
            }
            else if ( ((LA68_0 >= PUBLIC && LA68_0 <= INTERNAL)) )
            {
                alt68 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d68s0 =
                    new NoViableAltException("636:1: namespaceName : ( IDENT | reservedNamespace );", 68, 0, input);
            
                throw nvae_d68s0;
            }
            switch (alt68) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:637:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT265 = (IToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_namespaceName2859); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT265_tree = (CommonTree)adaptor.Create(IDENT265);
                    	adaptor.AddChild(root_0, IDENT265_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:637:12: reservedNamespace
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_reservedNamespace_in_namespaceName2863);
                    	reservedNamespace266 = reservedNamespace();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, reservedNamespace266.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 78, namespaceName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end namespaceName

    public class reservedNamespace_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start reservedNamespace
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:640:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
    public reservedNamespace_return reservedNamespace() // throws RecognitionException [1]
    {   
        reservedNamespace_return retval = new reservedNamespace_return();
        retval.start = input.LT(1);
        int reservedNamespace_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set267 = null;
        
        CommonTree set267_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 79) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:641:4: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set267 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= PUBLIC && input.LA(1) <= INTERNAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set267));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_reservedNamespace0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 79, reservedNamespace_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end reservedNamespace

    public class identifierStar_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifierStar
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:647:1: identifierStar : ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) ;
    public identifierStar_return identifierStar() // throws RecognitionException [1]
    {   
        identifierStar_return retval = new identifierStar_return();
        retval.start = input.LT(1);
        int identifierStar_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT269 = null;
        IToken DOT271 = null;
        IToken STAR272 = null;
        ident_return ident268 = null;

        ident_return ident270 = null;
        
        
        CommonTree DOT269_tree=null;
        CommonTree DOT271_tree=null;
        CommonTree STAR272_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 80) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:648:4: ( ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:648:4: ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )?
            {
            	PushFollow(FOLLOW_ident_in_identifierStar2900);
            	ident268 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident268.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:649:3: ( options {greedy=true; } : DOT ident )*
            	do 
            	{
            	    int alt69 = 2;
            	    int LA69_0 = input.LA(1);
            	    
            	    if ( (LA69_0 == DOT) )
            	    {
            	        int LA69_1 = input.LA(2);
            	        
            	        if ( ((LA69_1 >= GET && LA69_1 <= USE) || LA69_1 == XML || LA69_1 == IDENT || LA69_1 == DYNAMIC || (LA69_1 >= IS && LA69_1 <= AS)) )
            	        {
            	            alt69 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt69) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:650:5: DOT ident
            			    {
            			    	DOT269 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifierStar2917); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT269);

            			    	PushFollow(FOLLOW_ident_in_identifierStar2919);
            			    	ident270 = ident();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_ident.Add(ident270.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop69;
            	    }
            	} while (true);
            	
            	loop69:
            		;	// Stops C# compiler whinging that label 'loop69' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:652:3: ( DOT STAR )?
            	int alt70 = 2;
            	int LA70_0 = input.LA(1);
            	
            	if ( (LA70_0 == DOT) )
            	{
            	    alt70 = 1;
            	}
            	switch (alt70) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:652:5: DOT STAR
            	        {
            	        	DOT271 = (IToken)input.LT(1);
            	        	Match(input,DOT,FOLLOW_DOT_in_identifierStar2931); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DOT.Add(DOT271);

            	        	STAR272 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_identifierStar2933); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR272);

            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, STAR
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 654:3: -> ^( IDENTIFIER ( ident )+ ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:654:6: ^( IDENTIFIER ( ident )+ ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_ident.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:654:26: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 80, identifierStar_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifierStar

    public class annotations_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotations
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:657:1: annotations : ( annotation | includeDirective )+ -> ^( ANNOTATIONS ( annotation )+ ) ;
    public annotations_return annotations() // throws RecognitionException [1]
    {   
        annotations_return retval = new annotations_return();
        retval.start = input.LT(1);
        int annotations_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        annotation_return annotation273 = null;

        includeDirective_return includeDirective274 = null;
        
        
        RewriteRuleSubtreeStream stream_includeDirective = new RewriteRuleSubtreeStream(adaptor,"rule includeDirective");
        RewriteRuleSubtreeStream stream_annotation = new RewriteRuleSubtreeStream(adaptor,"rule annotation");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 81) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:4: ( ( annotation | includeDirective )+ -> ^( ANNOTATIONS ( annotation )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:4: ( annotation | includeDirective )+
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:4: ( annotation | includeDirective )+
            	int cnt71 = 0;
            	do 
            	{
            	    int alt71 = 3;
            	    int LA71_0 = input.LA(1);
            	    
            	    if ( (LA71_0 == LBRACK) )
            	    {
            	        int LA71_12 = input.LA(2);
            	        
            	        if ( (synpred106()) )
            	        {
            	            alt71 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA71_0 == 175) )
            	    {
            	        int LA71_13 = input.LA(2);
            	        
            	        if ( (synpred107()) )
            	        {
            	            alt71 = 2;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt71) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:6: annotation
            			    {
            			    	PushFollow(FOLLOW_annotation_in_annotations2966);
            			    	annotation273 = annotation();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_annotation.Add(annotation273.Tree);
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:659:5: includeDirective
            			    {
            			    	PushFollow(FOLLOW_includeDirective_in_annotations2972);
            			    	includeDirective274 = includeDirective();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_includeDirective.Add(includeDirective274.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt71 >= 1 ) goto loop71;
            			    if ( backtracking > 0 ) {failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(71, input);
            		            throw eee;
            	    }
            	    cnt71++;
            	} while (true);
            	
            	loop71:
            		;	// Stops C# compiler whinging that label 'loop71' has no statements

            	
            	// AST REWRITE
            	// elements:          annotation
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 661:3: -> ^( ANNOTATIONS ( annotation )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:661:6: ^( ANNOTATIONS ( annotation )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATIONS, "ANNOTATIONS"), root_1);
            	    
            	    if ( !(stream_annotation.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_annotation.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotation.Next());
            	    
            	    }
            	    stream_annotation.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 81, annotations_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotations

    public class annotation_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotation
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:664:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
    public annotation_return annotation() // throws RecognitionException [1]
    {   
        annotation_return retval = new annotation_return();
        retval.start = input.LT(1);
        int annotation_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK275 = null;
        IToken RBRACK278 = null;
        ident_return ident276 = null;

        annotationParamList_return annotationParamList277 = null;
        
        
        CommonTree LBRACK275_tree=null;
        CommonTree RBRACK278_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_annotationParamList = new RewriteRuleSubtreeStream(adaptor,"rule annotationParamList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 82) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:4: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:4: LBRACK ident ( annotationParamList )? RBRACK
            {
            	LBRACK275 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_annotation2999); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK275);

            	PushFollow(FOLLOW_ident_in_annotation3003);
            	ident276 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident276.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:667:3: ( annotationParamList )?
            	int alt72 = 2;
            	int LA72_0 = input.LA(1);
            	
            	if ( (LA72_0 == LPAREN) )
            	{
            	    alt72 = 1;
            	}
            	switch (alt72) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotationParamList
            	        {
            	        	PushFollow(FOLLOW_annotationParamList_in_annotation3007);
            	        	annotationParamList277 = annotationParamList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParamList.Add(annotationParamList277.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK278 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_annotation3012); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK278);

            	
            	// AST REWRITE
            	// elements:          annotationParamList, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 669:3: -> ^( ANNOTATION ident ( annotationParamList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:669:6: ^( ANNOTATION ident ( annotationParamList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:669:25: ( annotationParamList )?
            	    if ( stream_annotationParamList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParamList.Next());
            	    
            	    }
            	    stream_annotationParamList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 82, annotation_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotation

    public class annotationParamList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParamList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:672:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
    public annotationParamList_return annotationParamList() // throws RecognitionException [1]
    {   
        annotationParamList_return retval = new annotationParamList_return();
        retval.start = input.LT(1);
        int annotationParamList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN279 = null;
        IToken COMMA281 = null;
        IToken RPAREN283 = null;
        annotationParam_return annotationParam280 = null;

        annotationParam_return annotationParam282 = null;
        
        
        CommonTree LPAREN279_tree=null;
        CommonTree COMMA281_tree=null;
        CommonTree RPAREN283_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_annotationParam = new RewriteRuleSubtreeStream(adaptor,"rule annotationParam");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 83) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:674:3: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:674:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
            {
            	LPAREN279 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_annotationParamList3038); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN279);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:675:3: ( annotationParam ( COMMA annotationParam )* )?
            	int alt74 = 2;
            	int LA74_0 = input.LA(1);
            	
            	if ( (LA74_0 == STRING_LITERAL || (LA74_0 >= GET && LA74_0 <= USE) || LA74_0 == XML || LA74_0 == IDENT || LA74_0 == DYNAMIC || LA74_0 == LT || (LA74_0 >= IS && LA74_0 <= AS) || LA74_0 == DIV || (LA74_0 >= TRUE && LA74_0 <= FLOAT_LITERAL)) )
            	{
            	    alt74 = 1;
            	}
            	switch (alt74) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:675:5: annotationParam ( COMMA annotationParam )*
            	        {
            	        	PushFollow(FOLLOW_annotationParam_in_annotationParamList3044);
            	        	annotationParam280 = annotationParam();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam280.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:676:4: ( COMMA annotationParam )*
            	        	do 
            	        	{
            	        	    int alt73 = 2;
            	        	    int LA73_0 = input.LA(1);
            	        	    
            	        	    if ( (LA73_0 == COMMA) )
            	        	    {
            	        	        alt73 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt73) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:676:5: COMMA annotationParam
            	        			    {
            	        			    	COMMA281 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_annotationParamList3050); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA281);

            	        			    	PushFollow(FOLLOW_annotationParam_in_annotationParamList3052);
            	        			    	annotationParam282 = annotationParam();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam282.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop73;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop73:
            	        		;	// Stops C# compiler whinging that label 'loop73' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN283 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_annotationParamList3063); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN283);

            	
            	// AST REWRITE
            	// elements:          annotationParam
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 679:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:679:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:679:26: ( annotationParam )*
            	    while ( stream_annotationParam.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParam.Next());
            	    
            	    }
            	    stream_annotationParam.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 83, annotationParamList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParamList

    public class annotationParam_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParam
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );
    public annotationParam_return annotationParam() // throws RecognitionException [1]
    {   
        annotationParam_return retval = new annotationParam_return();
        retval.start = input.LT(1);
        int annotationParam_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN285 = null;
        ident_return ident284 = null;

        constant_return constant286 = null;

        constant_return constant287 = null;

        ident_return ident288 = null;
        
        
        CommonTree ASSIGN285_tree=null;
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleSubtreeStream stream_constant = new RewriteRuleSubtreeStream(adaptor,"rule constant");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 84) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:695:3: ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident )
            int alt75 = 3;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                int LA75_1 = input.LA(2);
                
                if ( (LA75_1 == EOF || LA75_1 == COMMA || LA75_1 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_1 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s1 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 1, input);
                
                    throw nvae_d75s1;
                }
                }
                break;
            case USE:
            	{
                int LA75_2 = input.LA(2);
                
                if ( (LA75_2 == EOF || LA75_2 == COMMA || LA75_2 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_2 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s2 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 2, input);
                
                    throw nvae_d75s2;
                }
                }
                break;
            case XML:
            	{
                int LA75_3 = input.LA(2);
                
                if ( (LA75_3 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else if ( (LA75_3 == EOF || LA75_3 == COMMA || LA75_3 == RPAREN) )
                {
                    alt75 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s3 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 3, input);
                
                    throw nvae_d75s3;
                }
                }
                break;
            case DYNAMIC:
            	{
                int LA75_4 = input.LA(2);
                
                if ( (LA75_4 == EOF || LA75_4 == COMMA || LA75_4 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_4 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s4 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 4, input);
                
                    throw nvae_d75s4;
                }
                }
                break;
            case NAMESPACE:
            	{
                int LA75_5 = input.LA(2);
                
                if ( (LA75_5 == EOF || LA75_5 == COMMA || LA75_5 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_5 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s5 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 5, input);
                
                    throw nvae_d75s5;
                }
                }
                break;
            case IS:
            	{
                int LA75_6 = input.LA(2);
                
                if ( (LA75_6 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else if ( (LA75_6 == EOF || LA75_6 == COMMA || LA75_6 == RPAREN) )
                {
                    alt75 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s6 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 6, input);
                
                    throw nvae_d75s6;
                }
                }
                break;
            case AS:
            	{
                int LA75_7 = input.LA(2);
                
                if ( (LA75_7 == EOF || LA75_7 == COMMA || LA75_7 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_7 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s7 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 7, input);
                
                    throw nvae_d75s7;
                }
                }
                break;
            case GET:
            	{
                int LA75_8 = input.LA(2);
                
                if ( (LA75_8 == EOF || LA75_8 == COMMA || LA75_8 == RPAREN) )
                {
                    alt75 = 3;
                }
                else if ( (LA75_8 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s8 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 8, input);
                
                    throw nvae_d75s8;
                }
                }
                break;
            case SET:
            	{
                int LA75_9 = input.LA(2);
                
                if ( (LA75_9 == ASSIGN) )
                {
                    alt75 = 1;
                }
                else if ( (LA75_9 == EOF || LA75_9 == COMMA || LA75_9 == RPAREN) )
                {
                    alt75 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d75s9 =
                        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 9, input);
                
                    throw nvae_d75s9;
                }
                }
                break;
            case STRING_LITERAL:
            case LT:
            case DIV:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt75 = 2;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d75s0 =
            	        new NoViableAltException("693:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 75, 0, input);
            
            	    throw nvae_d75s0;
            }
            
            switch (alt75) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:695:3: ident ASSIGN constant
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam3090);
                    	ident284 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ident284.Tree);
                    	ASSIGN285 = (IToken)input.LT(1);
                    	Match(input,ASSIGN,FOLLOW_ASSIGN_in_annotationParam3092); if (failed) return retval;
                    	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN285);

                    	PushFollow(FOLLOW_constant_in_annotationParam3094);
                    	constant286 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(constant286.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          constant, ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 695:25: -> ^( ANNOTATION_ASSIGN ident constant )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:695:28: ^( ANNOTATION_ASSIGN ident constant )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_ASSIGN, "ANNOTATION_ASSIGN"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_ident.Next());
                    	    adaptor.AddChild(root_1, stream_constant.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:696:4: constant
                    {
                    	PushFollow(FOLLOW_constant_in_annotationParam3109);
                    	constant287 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(constant287.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          constant
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 696:13: -> constant
                    	{
                    	    adaptor.AddChild(root_0, stream_constant.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:697:4: ident
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam3118);
                    	ident288 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ident288.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 697:10: -> ident
                    	{
                    	    adaptor.AddChild(root_0, stream_ident.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 84, annotationParam_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParam

    public class modifiers_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifiers
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:700:1: modifiers : ( modifier )* -> ^( MODIFIERS ( modifier )* ) ;
    public modifiers_return modifiers() // throws RecognitionException [1]
    {   
        modifiers_return retval = new modifiers_return();
        retval.start = input.LT(1);
        int modifiers_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifier_return modifier289 = null;
        
        
        RewriteRuleSubtreeStream stream_modifier = new RewriteRuleSubtreeStream(adaptor,"rule modifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 85) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:701:4: ( ( modifier )* -> ^( MODIFIERS ( modifier )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:701:4: ( modifier )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:701:4: ( modifier )*
            	do 
            	{
            	    int alt76 = 2;
            	    int LA76_0 = input.LA(1);
            	    
            	    if ( ((LA76_0 >= IDENT && LA76_0 <= INTERNAL) || (LA76_0 >= STATIC && LA76_0 <= DYNAMIC) || (LA76_0 >= 181 && LA76_0 <= 185)) )
            	    {
            	        alt76 = 1;
            	    }
            	    
            	
            	    switch (alt76) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: modifier
            			    {
            			    	PushFollow(FOLLOW_modifier_in_modifiers3133);
            			    	modifier289 = modifier();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_modifier.Add(modifier289.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop76;
            	    }
            	} while (true);
            	
            	loop76:
            		;	// Stops C# compiler whinging that label 'loop76' has no statements

            	
            	// AST REWRITE
            	// elements:          modifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 702:3: -> ^( MODIFIERS ( modifier )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:702:6: ^( MODIFIERS ( modifier )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MODIFIERS, "MODIFIERS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:702:18: ( modifier )*
            	    while ( stream_modifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_modifier.Next());
            	    
            	    }
            	    stream_modifier.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 85, modifiers_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifiers

    public class modifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:705:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
    public modifier_return modifier() // throws RecognitionException [1]
    {   
        modifier_return retval = new modifier_return();
        retval.start = input.LT(1);
        int modifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STATIC291 = null;
        IToken string_literal292 = null;
        IToken string_literal293 = null;
        IToken string_literal294 = null;
        IToken string_literal295 = null;
        IToken DYNAMIC296 = null;
        IToken string_literal297 = null;
        namespaceName_return namespaceName290 = null;
        
        
        CommonTree STATIC291_tree=null;
        CommonTree string_literal292_tree=null;
        CommonTree string_literal293_tree=null;
        CommonTree string_literal294_tree=null;
        CommonTree string_literal295_tree=null;
        CommonTree DYNAMIC296_tree=null;
        CommonTree string_literal297_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 86) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:4: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
            int alt77 = 8;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            	{
                alt77 = 1;
                }
                break;
            case STATIC:
            	{
                alt77 = 2;
                }
                break;
            case 181:
            	{
                alt77 = 3;
                }
                break;
            case 182:
            	{
                alt77 = 4;
                }
                break;
            case 183:
            	{
                alt77 = 5;
                }
                break;
            case 184:
            	{
                alt77 = 6;
                }
                break;
            case DYNAMIC:
            	{
                alt77 = 7;
                }
                break;
            case 185:
            	{
                alt77 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d77s0 =
            	        new NoViableAltException("705:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );", 77, 0, input);
            
            	    throw nvae_d77s0;
            }
            
            switch (alt77) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:4: namespaceName
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_namespaceName_in_modifier3156);
                    	namespaceName290 = namespaceName();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceName290.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:4: STATIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STATIC291 = (IToken)input.LT(1);
                    	Match(input,STATIC,FOLLOW_STATIC_in_modifier3161); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STATIC291_tree = (CommonTree)adaptor.Create(STATIC291);
                    	adaptor.AddChild(root_0, STATIC291_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:708:4: 'final'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal292 = (IToken)input.LT(1);
                    	Match(input,181,FOLLOW_181_in_modifier3166); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal292_tree = (CommonTree)adaptor.Create(string_literal292);
                    	adaptor.AddChild(root_0, string_literal292_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:709:4: 'enumerable'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal293 = (IToken)input.LT(1);
                    	Match(input,182,FOLLOW_182_in_modifier3171); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal293_tree = (CommonTree)adaptor.Create(string_literal293);
                    	adaptor.AddChild(root_0, string_literal293_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:710:4: 'explicit'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal294 = (IToken)input.LT(1);
                    	Match(input,183,FOLLOW_183_in_modifier3176); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal294_tree = (CommonTree)adaptor.Create(string_literal294);
                    	adaptor.AddChild(root_0, string_literal294_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:711:4: 'override'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal295 = (IToken)input.LT(1);
                    	Match(input,184,FOLLOW_184_in_modifier3181); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal295_tree = (CommonTree)adaptor.Create(string_literal295);
                    	adaptor.AddChild(root_0, string_literal295_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:4: DYNAMIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	DYNAMIC296 = (IToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_modifier3186); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	DYNAMIC296_tree = (CommonTree)adaptor.Create(DYNAMIC296);
                    	adaptor.AddChild(root_0, DYNAMIC296_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:713:4: 'intrinsic'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal297 = (IToken)input.LT(1);
                    	Match(input,185,FOLLOW_185_in_modifier3191); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal297_tree = (CommonTree)adaptor.Create(string_literal297);
                    	adaptor.AddChild(root_0, string_literal297_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 86, modifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifier

    public class arguments_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arguments
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );
    public arguments_return arguments() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        arguments_return retval = new arguments_return();
        retval.start = input.LT(1);
        int arguments_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN298 = null;
        IToken RPAREN300 = null;
        IToken LPAREN301 = null;
        IToken RPAREN302 = null;
        expressionList_return expressionList299 = null;
        
        
        CommonTree LPAREN298_tree=null;
        CommonTree RPAREN300_tree=null;
        CommonTree LPAREN301_tree=null;
        CommonTree RPAREN302_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 87) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:4: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS )
            int alt78 = 2;
            int LA78_0 = input.LA(1);
            
            if ( (LA78_0 == LPAREN) )
            {
                int LA78_1 = input.LA(2);
                
                if ( (LA78_1 == RPAREN) )
                {
                    alt78 = 2;
                }
                else if ( (LA78_1 == LCURLY || (LA78_1 >= STRING_LITERAL && LA78_1 <= USE) || LA78_1 == LPAREN || LA78_1 == XML || (LA78_1 >= IDENT && LA78_1 <= LBRACK) || LA78_1 == DYNAMIC || LA78_1 == LT || (LA78_1 >= IS && LA78_1 <= AS) || (LA78_1 >= PLUS && LA78_1 <= DIV) || (LA78_1 >= INC && LA78_1 <= BNOT) || (LA78_1 >= E4X_ATTRI && LA78_1 <= NEW) || LA78_1 == 180) )
                {
                    alt78 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d78s1 =
                        new NoViableAltException("716:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 78, 1, input);
                
                    throw nvae_d78s1;
                }
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d78s0 =
                    new NoViableAltException("716:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 78, 0, input);
            
                throw nvae_d78s0;
            }
            switch (alt78) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:4: LPAREN expressionList RPAREN
                    {
                    	LPAREN298 = (IToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3212); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN298);

                    	PushFollow(FOLLOW_expressionList_in_arguments3214);
                    	expressionList299 = expressionList();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_expressionList.Add(expressionList299.Tree);
                    	RPAREN300 = (IToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3216); if (failed) return retval;
                    	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN300);

                    	
                    	// AST REWRITE
                    	// elements:          expressionList
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 722:3: -> ^( ARGUMENTS expressionList )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:6: ^( ARGUMENTS expressionList )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_expressionList.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:723:4: LPAREN RPAREN
                    {
                    	LPAREN301 = (IToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3231); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN301);

                    	RPAREN302 = (IToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3233); if (failed) return retval;
                    	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN302);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 724:3: -> ARGUMENTS
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(ARGUMENTS, "ARGUMENTS"));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 87, arguments_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end arguments

    public class element_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start element
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:728:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
    public element_return element() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        element_return retval = new element_return();
        retval.start = input.LT(1);
        int element_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression303 = null;
        
        
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 88) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:733:4: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:733:4: assignmentExpression
            {
            	PushFollow(FOLLOW_assignmentExpression_in_element3263);
            	assignmentExpression303 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression303.Tree);
            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 734:3: -> ^( ELEMENT assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:734:6: ^( ELEMENT assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELEMENT, "ELEMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 88, element_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end element

    public class arrayLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arrayLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:738:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) ;
    public arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {   
        arrayLiteral_return retval = new arrayLiteral_return();
        retval.start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK304 = null;
        IToken RBRACK306 = null;
        elementList_return elementList305 = null;
        
        
        CommonTree LBRACK304_tree=null;
        CommonTree RBRACK306_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_elementList = new RewriteRuleSubtreeStream(adaptor,"rule elementList");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 89) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:739:4: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:739:4: LBRACK ( elementList )? RBRACK
            {
            	LBRACK304 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_arrayLiteral3285); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK304);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:739:11: ( elementList )?
            	int alt79 = 2;
            	int LA79_0 = input.LA(1);
            	
            	if ( (LA79_0 == LCURLY || (LA79_0 >= STRING_LITERAL && LA79_0 <= USE) || LA79_0 == LPAREN || LA79_0 == XML || (LA79_0 >= IDENT && LA79_0 <= LBRACK) || LA79_0 == DYNAMIC || LA79_0 == LT || (LA79_0 >= IS && LA79_0 <= AS) || (LA79_0 >= PLUS && LA79_0 <= DIV) || (LA79_0 >= INC && LA79_0 <= BNOT) || (LA79_0 >= E4X_ATTRI && LA79_0 <= NEW) || LA79_0 == 180) )
            	{
            	    alt79 = 1;
            	}
            	switch (alt79) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: elementList
            	        {
            	        	PushFollow(FOLLOW_elementList_in_arrayLiteral3287);
            	        	elementList305 = elementList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_elementList.Add(elementList305.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK306 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_arrayLiteral3290); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK306);

            	
            	// AST REWRITE
            	// elements:          elementList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 740:3: -> ^( ARRAY_LITERAL ( elementList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:6: ^( ARRAY_LITERAL ( elementList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:740:22: ( elementList )?
            	    if ( stream_elementList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_elementList.Next());
            	    
            	    }
            	    stream_elementList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 89, arrayLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end arrayLiteral

    public class elementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:743:1: elementList : nonemptyElementList ( COMMA ( nonemptyElementList )? )* ;
    public elementList_return elementList() // throws RecognitionException [1]
    {   
        elementList_return retval = new elementList_return();
        retval.start = input.LT(1);
        int elementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA308 = null;
        nonemptyElementList_return nonemptyElementList307 = null;

        nonemptyElementList_return nonemptyElementList309 = null;
        
        
        CommonTree COMMA308_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 90) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:4: ( nonemptyElementList ( COMMA ( nonemptyElementList )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:4: nonemptyElementList ( COMMA ( nonemptyElementList )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_nonemptyElementList_in_elementList3312);
            	nonemptyElementList307 = nonemptyElementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList307.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:24: ( COMMA ( nonemptyElementList )? )*
            	do 
            	{
            	    int alt81 = 2;
            	    int LA81_0 = input.LA(1);
            	    
            	    if ( (LA81_0 == COMMA) )
            	    {
            	        alt81 = 1;
            	    }
            	    
            	
            	    switch (alt81) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:25: COMMA ( nonemptyElementList )?
            			    {
            			    	COMMA308 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_elementList3315); if (failed) return retval;
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:32: ( nonemptyElementList )?
            			    	int alt80 = 2;
            			    	int LA80_0 = input.LA(1);
            			    	
            			    	if ( (LA80_0 == LCURLY || (LA80_0 >= STRING_LITERAL && LA80_0 <= USE) || LA80_0 == LPAREN || LA80_0 == XML || (LA80_0 >= IDENT && LA80_0 <= LBRACK) || LA80_0 == DYNAMIC || LA80_0 == LT || (LA80_0 >= IS && LA80_0 <= AS) || (LA80_0 >= PLUS && LA80_0 <= DIV) || (LA80_0 >= INC && LA80_0 <= BNOT) || (LA80_0 >= E4X_ATTRI && LA80_0 <= NEW) || LA80_0 == 180) )
            			    	{
            			    	    alt80 = 1;
            			    	}
            			    	switch (alt80) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: nonemptyElementList
            			    	        {
            			    	        	PushFollow(FOLLOW_nonemptyElementList_in_elementList3318);
            			    	        	nonemptyElementList309 = nonemptyElementList();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList309.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop81;
            	    }
            	} while (true);
            	
            	loop81:
            		;	// Stops C# compiler whinging that label 'loop81' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 90, elementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elementList

    public class nonemptyElementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start nonemptyElementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:747:1: nonemptyElementList : assignmentExpression ( COMMA assignmentExpression )* ;
    public nonemptyElementList_return nonemptyElementList() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        nonemptyElementList_return retval = new nonemptyElementList_return();
        retval.start = input.LT(1);
        int nonemptyElementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA311 = null;
        assignmentExpression_return assignmentExpression310 = null;

        assignmentExpression_return assignmentExpression312 = null;
        
        
        CommonTree COMMA311_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 91) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:4: ( assignmentExpression ( COMMA assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3343);
            	assignmentExpression310 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression310.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:25: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt82 = 2;
            	    int LA82_0 = input.LA(1);
            	    
            	    if ( (LA82_0 == COMMA) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA82_4 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA82_5 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA82_6 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA82_7 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA82_8 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA82_9 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA82_10 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA82_11 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA82_12 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA82_13 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA82_14 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA82_15 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA82_16 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA82_17 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA82_18 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA82_19 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA82_20 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA82_21 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA82_22 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA82_23 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA82_24 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA82_25 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA82_26 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA82_27 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA82_28 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA82_29 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA82_30 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA82_31 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA82_32 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA82_33 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA82_34 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA82_35 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA82_36 = input.LA(3);
            	            
            	            if ( (synpred125()) )
            	            {
            	                alt82 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt82) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:26: COMMA assignmentExpression
            			    {
            			    	COMMA311 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_nonemptyElementList3346); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	COMMA311_tree = (CommonTree)adaptor.Create(COMMA311);
            			    	adaptor.AddChild(root_0, COMMA311_tree);
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3348);
            			    	assignmentExpression312 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression312.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop82;
            	    }
            	} while (true);
            	
            	loop82:
            		;	// Stops C# compiler whinging that label 'loop82' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 91, nonemptyElementList_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end nonemptyElementList

    public class objectLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start objectLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:756:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
    public objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {   
        objectLiteral_return retval = new objectLiteral_return();
        retval.start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY313 = null;
        IToken RCURLY315 = null;
        fieldList_return fieldList314 = null;
        
        
        CommonTree LCURLY313_tree=null;
        CommonTree RCURLY315_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_fieldList = new RewriteRuleSubtreeStream(adaptor,"rule fieldList");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 92) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:757:4: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:757:4: LCURLY ( fieldList )? RCURLY
            {
            	LCURLY313 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_objectLiteral3363); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY313);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:757:11: ( fieldList )?
            	int alt83 = 2;
            	int LA83_0 = input.LA(1);
            	
            	if ( ((LA83_0 >= GET && LA83_0 <= USE) || LA83_0 == XML || LA83_0 == IDENT || LA83_0 == DYNAMIC || (LA83_0 >= IS && LA83_0 <= AS) || (LA83_0 >= HEX_LITERAL && LA83_0 <= FLOAT_LITERAL)) )
            	{
            	    alt83 = 1;
            	}
            	switch (alt83) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: fieldList
            	        {
            	        	PushFollow(FOLLOW_fieldList_in_objectLiteral3365);
            	        	fieldList314 = fieldList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_fieldList.Add(fieldList314.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY315 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_objectLiteral3368); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY315);

            	
            	// AST REWRITE
            	// elements:          fieldList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 758:3: -> ^( OBJECT_LITERAL ( fieldList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:758:6: ^( OBJECT_LITERAL ( fieldList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:758:23: ( fieldList )?
            	    if ( stream_fieldList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_fieldList.Next());
            	    
            	    }
            	    stream_fieldList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 92, objectLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end objectLiteral

    public class fieldList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:761:1: fieldList : literalField ( COMMA ( literalField )? )* ;
    public fieldList_return fieldList() // throws RecognitionException [1]
    {   
        fieldList_return retval = new fieldList_return();
        retval.start = input.LT(1);
        int fieldList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA317 = null;
        literalField_return literalField316 = null;

        literalField_return literalField318 = null;
        
        
        CommonTree COMMA317_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 93) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:762:4: ( literalField ( COMMA ( literalField )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:762:4: literalField ( COMMA ( literalField )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_literalField_in_fieldList3391);
            	literalField316 = literalField();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField316.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:762:17: ( COMMA ( literalField )? )*
            	do 
            	{
            	    int alt85 = 2;
            	    int LA85_0 = input.LA(1);
            	    
            	    if ( (LA85_0 == COMMA) )
            	    {
            	        alt85 = 1;
            	    }
            	    
            	
            	    switch (alt85) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:762:18: COMMA ( literalField )?
            			    {
            			    	COMMA317 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_fieldList3394); if (failed) return retval;
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:762:25: ( literalField )?
            			    	int alt84 = 2;
            			    	int LA84_0 = input.LA(1);
            			    	
            			    	if ( ((LA84_0 >= GET && LA84_0 <= USE) || LA84_0 == XML || LA84_0 == IDENT || LA84_0 == DYNAMIC || (LA84_0 >= IS && LA84_0 <= AS) || (LA84_0 >= HEX_LITERAL && LA84_0 <= FLOAT_LITERAL)) )
            			    	{
            			    	    alt84 = 1;
            			    	}
            			    	switch (alt84) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: literalField
            			    	        {
            			    	        	PushFollow(FOLLOW_literalField_in_fieldList3397);
            			    	        	literalField318 = literalField();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField318.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop85;
            	    }
            	} while (true);
            	
            	loop85:
            		;	// Stops C# compiler whinging that label 'loop85' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 93, fieldList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldList

    public class literalField_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start literalField
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:765:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
    public literalField_return literalField() // throws RecognitionException [1]
    {   
        literalField_return retval = new literalField_return();
        retval.start = input.LT(1);
        int literalField_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COLON320 = null;
        fieldName_return fieldName319 = null;

        element_return element321 = null;
        
        
        CommonTree COLON320_tree=null;
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_element = new RewriteRuleSubtreeStream(adaptor,"rule element");
        RewriteRuleSubtreeStream stream_fieldName = new RewriteRuleSubtreeStream(adaptor,"rule fieldName");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 94) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:766:5: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:766:5: fieldName COLON element
            {
            	PushFollow(FOLLOW_fieldName_in_literalField3414);
            	fieldName319 = fieldName();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_fieldName.Add(fieldName319.Tree);
            	COLON320 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_literalField3416); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(COLON320);

            	PushFollow(FOLLOW_element_in_literalField3418);
            	element321 = element();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_element.Add(element321.Tree);
            	
            	// AST REWRITE
            	// elements:          fieldName, element
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 767:3: -> ^( OBJECT_FIELD fieldName element )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:767:6: ^( OBJECT_FIELD fieldName element )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_fieldName.Next());
            	    adaptor.AddChild(root_1, stream_element.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 94, literalField_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end literalField

    public class fieldName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:770:1: fieldName : ( ident | number );
    public fieldName_return fieldName() // throws RecognitionException [1]
    {   
        fieldName_return retval = new fieldName_return();
        retval.start = input.LT(1);
        int fieldName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ident322 = null;

        number_return number323 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 95) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:771:4: ( ident | number )
            int alt86 = 2;
            int LA86_0 = input.LA(1);
            
            if ( ((LA86_0 >= GET && LA86_0 <= USE) || LA86_0 == XML || LA86_0 == IDENT || LA86_0 == DYNAMIC || (LA86_0 >= IS && LA86_0 <= AS)) )
            {
                alt86 = 1;
            }
            else if ( ((LA86_0 >= HEX_LITERAL && LA86_0 <= FLOAT_LITERAL)) )
            {
                alt86 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d86s0 =
                    new NoViableAltException("770:1: fieldName : ( ident | number );", 86, 0, input);
            
                throw nvae_d86s0;
            }
            switch (alt86) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:771:4: ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_fieldName3442);
                    	ident322 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ident322.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:772:4: number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_fieldName3447);
                    	number323 = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, number323.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 95, fieldName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldName

    public class expression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:776:1: expression : assignmentExpression ;
    public expression_return expression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expression_return retval = new expression_return();
        retval.start = input.LT(1);
        int expression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression324 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 96) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:781:4: ( assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:781:4: assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_expression3469);
            	assignmentExpression324 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression324.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 96, expression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expression

    public class expressionList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:785:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) ;
    public expressionList_return expressionList() // throws RecognitionException [1]
    {   
        expressionList_return retval = new expressionList_return();
        retval.start = input.LT(1);
        int expressionList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA326 = null;
        assignmentExpression_return assignmentExpression325 = null;

        assignmentExpression_return assignmentExpression327 = null;
        
        
        CommonTree COMMA326_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 97) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:4: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	PushFollow(FOLLOW_assignmentExpression_in_expressionList3481);
            	assignmentExpression325 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression325.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:25: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt87 = 2;
            	    int LA87_0 = input.LA(1);
            	    
            	    if ( (LA87_0 == COMMA) )
            	    {
            	        alt87 = 1;
            	    }
            	    
            	
            	    switch (alt87) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:26: COMMA assignmentExpression
            			    {
            			    	COMMA326 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_expressionList3484); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA326);

            			    	PushFollow(FOLLOW_assignmentExpression_in_expressionList3486);
            			    	assignmentExpression327 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression327.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop87;
            	    }
            	} while (true);
            	
            	loop87:
            		;	// Stops C# compiler whinging that label 'loop87' has no statements

            	
            	// AST REWRITE
            	// elements:          assignmentExpression, COMMA, assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 786:55: -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:58: ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELIST, "ELIST"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:87: ( COMMA assignmentExpression )*
            	    while ( stream_COMMA.HasNext() || stream_assignmentExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_COMMA.Next());
            	        adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    }
            	    stream_COMMA.Reset();
            	    stream_assignmentExpression.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 97, expressionList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end expressionList

    public class assignmentExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:790:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
    public assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {   
        assignmentExpression_return retval = new assignmentExpression_return();
        retval.start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        conditionalExpression_return conditionalExpression328 = null;

        assignmentOperator_return assignmentOperator329 = null;

        assignmentExpression_return assignmentExpression330 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 98) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:791:4: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:791:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression3515);
            	conditionalExpression328 = conditionalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, conditionalExpression328.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:2: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
            	do 
            	{
            	    int alt88 = 2;
            	    int LA88_0 = input.LA(1);
            	    
            	    if ( (LA88_0 == ASSIGN || (LA88_0 >= STAR_ASSIGN && LA88_0 <= LOR_ASSIGN)) )
            	    {
            	        int LA88_70 = input.LA(2);
            	        
            	        if ( (synpred131()) )
            	        {
            	            alt88 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt88) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:4: ( assignmentOperator )=> assignmentOperator assignmentExpression
            			    {
            			    	PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression3525);
            			    	assignmentOperator329 = assignmentOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentOperator329.Tree);
            			    	PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression3529);
            			    	assignmentExpression330 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression330.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop88;
            	    }
            	} while (true);
            	
            	loop88:
            		;	// Stops C# compiler whinging that label 'loop88' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 98, assignmentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentExpression

    public class assignmentOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:797:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
    public assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {   
        assignmentOperator_return retval = new assignmentOperator_return();
        retval.start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set331 = null;
        
        CommonTree set331_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 99) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:798:4: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set331 = (IToken)input.LT(1);
            	if ( input.LA(1) == ASSIGN || (input.LA(1) >= STAR_ASSIGN && input.LA(1) <= LOR_ASSIGN) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set331));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_assignmentOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 99, assignmentOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentOperator

    public class conditionalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:815:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
    public conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {   
        conditionalExpression_return retval = new conditionalExpression_return();
        retval.start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken QUESTION333 = null;
        logicalOrExpression_return logicalOrExpression332 = null;

        conditionalSubExpression_return conditionalSubExpression334 = null;
        
        
        CommonTree QUESTION333_tree=null;
        RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream(adaptor,"token QUESTION");
        RewriteRuleSubtreeStream stream_logicalOrExpression = new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
        RewriteRuleSubtreeStream stream_conditionalSubExpression = new RewriteRuleSubtreeStream(adaptor,"rule conditionalSubExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 100) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:4: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:4: ( logicalOrExpression -> logicalOrExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:5: logicalOrExpression
            	{
            		PushFollow(FOLLOW_logicalOrExpression_in_conditionalExpression3623);
            		logicalOrExpression332 = logicalOrExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_logicalOrExpression.Add(logicalOrExpression332.Tree);
            		
            		// AST REWRITE
            		// elements:          logicalOrExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 816:25: -> logicalOrExpression
            		{
            		    adaptor.AddChild(root_0, stream_logicalOrExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:817:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            	int alt89 = 2;
            	int LA89_0 = input.LA(1);
            	
            	if ( (LA89_0 == QUESTION) )
            	{
            	    alt89 = 1;
            	}
            	switch (alt89) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:818:4: QUESTION conditionalSubExpression
            	        {
            	        	QUESTION333 = (IToken)input.LT(1);
            	        	Match(input,QUESTION,FOLLOW_QUESTION_in_conditionalExpression3637); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_QUESTION.Add(QUESTION333);

            	        	PushFollow(FOLLOW_conditionalSubExpression_in_conditionalExpression3642);
            	        	conditionalSubExpression334 = conditionalSubExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_conditionalSubExpression.Add(conditionalSubExpression334.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          QUESTION, conditionalSubExpression, conditionalExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 820:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:820:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    adaptor.AddChild(root_1, stream_conditionalSubExpression.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 100, conditionalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalExpression

    public class conditionalSubExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalSubExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:823:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
    public conditionalSubExpression_return conditionalSubExpression() // throws RecognitionException [1]
    {   
        conditionalSubExpression_return retval = new conditionalSubExpression_return();
        retval.start = input.LT(1);
        int conditionalSubExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COLON336 = null;
        assignmentExpression_return assignmentExpression335 = null;

        assignmentExpression_return assignmentExpression337 = null;
        
        
        CommonTree COLON336_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 101) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:4: ( assignmentExpression COLON assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:4: assignmentExpression COLON assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3671);
            	assignmentExpression335 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression335.Tree);
            	COLON336 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_conditionalSubExpression3673); if (failed) return retval;
            	if ( backtracking==0 ) {
            	COLON336_tree = (CommonTree)adaptor.Create(COLON336);
            	root_0 = (CommonTree)adaptor.BecomeRoot(COLON336_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3676);
            	assignmentExpression337 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression337.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 101, conditionalSubExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalSubExpression

    public class logicalOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:830:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
    public logicalOrExpression_return logicalOrExpression() // throws RecognitionException [1]
    {   
        logicalOrExpression_return retval = new logicalOrExpression_return();
        retval.start = input.LT(1);
        int logicalOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        logicalAndExpression_return logicalAndExpression338 = null;

        logicalOrOperator_return logicalOrOperator339 = null;

        logicalAndExpression_return logicalAndExpression340 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 102) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:831:4: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:831:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3690);
            	logicalAndExpression338 = logicalAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression338.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:832:3: ( logicalOrOperator logicalAndExpression )*
            	do 
            	{
            	    int alt90 = 2;
            	    int LA90_0 = input.LA(1);
            	    
            	    if ( (LA90_0 == LOR || LA90_0 == 186) )
            	    {
            	        alt90 = 1;
            	    }
            	    
            	
            	    switch (alt90) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:832:4: logicalOrOperator logicalAndExpression
            			    {
            			    	PushFollow(FOLLOW_logicalOrOperator_in_logicalOrExpression3695);
            			    	logicalOrOperator339 = logicalOrOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(logicalOrOperator339.Tree, root_0);
            			    	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3698);
            			    	logicalAndExpression340 = logicalAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression340.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop90;
            	    }
            	} while (true);
            	
            	loop90:
            		;	// Stops C# compiler whinging that label 'loop90' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 102, logicalOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrExpression

    public class logicalOrOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:835:1: logicalOrOperator : ( LOR | 'or' );
    public logicalOrOperator_return logicalOrOperator() // throws RecognitionException [1]
    {   
        logicalOrOperator_return retval = new logicalOrOperator_return();
        retval.start = input.LT(1);
        int logicalOrOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set341 = null;
        
        CommonTree set341_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 103) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:4: ( LOR | 'or' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set341 = (IToken)input.LT(1);
            	if ( input.LA(1) == LOR || input.LA(1) == 186 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set341));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalOrOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 103, logicalOrOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrOperator

    public class logicalAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:840:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
    public logicalAndExpression_return logicalAndExpression() // throws RecognitionException [1]
    {   
        logicalAndExpression_return retval = new logicalAndExpression_return();
        retval.start = input.LT(1);
        int logicalAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        bitwiseOrExpression_return bitwiseOrExpression342 = null;

        logicalAndOperator_return logicalAndOperator343 = null;

        bitwiseOrExpression_return bitwiseOrExpression344 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 104) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:4: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3727);
            	bitwiseOrExpression342 = bitwiseOrExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression342.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:3: ( logicalAndOperator bitwiseOrExpression )*
            	do 
            	{
            	    int alt91 = 2;
            	    int LA91_0 = input.LA(1);
            	    
            	    if ( (LA91_0 == LAND || LA91_0 == 187) )
            	    {
            	        alt91 = 1;
            	    }
            	    
            	
            	    switch (alt91) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:4: logicalAndOperator bitwiseOrExpression
            			    {
            			    	PushFollow(FOLLOW_logicalAndOperator_in_logicalAndExpression3732);
            			    	logicalAndOperator343 = logicalAndOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(logicalAndOperator343.Tree, root_0);
            			    	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3735);
            			    	bitwiseOrExpression344 = bitwiseOrExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression344.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop91;
            	    }
            	} while (true);
            	
            	loop91:
            		;	// Stops C# compiler whinging that label 'loop91' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 104, logicalAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndExpression

    public class logicalAndOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:1: logicalAndOperator : ( LAND | 'and' );
    public logicalAndOperator_return logicalAndOperator() // throws RecognitionException [1]
    {   
        logicalAndOperator_return retval = new logicalAndOperator_return();
        retval.start = input.LT(1);
        int logicalAndOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set345 = null;
        
        CommonTree set345_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 105) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:846:4: ( LAND | 'and' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set345 = (IToken)input.LT(1);
            	if ( input.LA(1) == LAND || input.LA(1) == 187 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set345));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalAndOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 105, logicalAndOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndOperator

    public class bitwiseOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
    public bitwiseOrExpression_return bitwiseOrExpression() // throws RecognitionException [1]
    {   
        bitwiseOrExpression_return retval = new bitwiseOrExpression_return();
        retval.start = input.LT(1);
        int bitwiseOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BOR347 = null;
        bitwiseXorExpression_return bitwiseXorExpression346 = null;

        bitwiseXorExpression_return bitwiseXorExpression348 = null;
        
        
        CommonTree BOR347_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 106) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:851:4: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:851:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3764);
            	bitwiseXorExpression346 = bitwiseXorExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression346.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:852:3: ( BOR bitwiseXorExpression )*
            	do 
            	{
            	    int alt92 = 2;
            	    int LA92_0 = input.LA(1);
            	    
            	    if ( (LA92_0 == BOR) )
            	    {
            	        alt92 = 1;
            	    }
            	    
            	
            	    switch (alt92) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:852:4: BOR bitwiseXorExpression
            			    {
            			    	BOR347 = (IToken)input.LT(1);
            			    	Match(input,BOR,FOLLOW_BOR_in_bitwiseOrExpression3769); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BOR347_tree = (CommonTree)adaptor.Create(BOR347);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BOR347_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3772);
            			    	bitwiseXorExpression348 = bitwiseXorExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression348.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop92;
            	    }
            	} while (true);
            	
            	loop92:
            		;	// Stops C# compiler whinging that label 'loop92' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 106, bitwiseOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseOrExpression

    public class bitwiseXorExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseXorExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
    public bitwiseXorExpression_return bitwiseXorExpression() // throws RecognitionException [1]
    {   
        bitwiseXorExpression_return retval = new bitwiseXorExpression_return();
        retval.start = input.LT(1);
        int bitwiseXorExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BXOR350 = null;
        bitwiseAndExpression_return bitwiseAndExpression349 = null;

        bitwiseAndExpression_return bitwiseAndExpression351 = null;
        
        
        CommonTree BXOR350_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 107) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:857:4: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:857:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3786);
            	bitwiseAndExpression349 = bitwiseAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression349.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:858:3: ( BXOR bitwiseAndExpression )*
            	do 
            	{
            	    int alt93 = 2;
            	    int LA93_0 = input.LA(1);
            	    
            	    if ( (LA93_0 == BXOR) )
            	    {
            	        alt93 = 1;
            	    }
            	    
            	
            	    switch (alt93) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:858:4: BXOR bitwiseAndExpression
            			    {
            			    	BXOR350 = (IToken)input.LT(1);
            			    	Match(input,BXOR,FOLLOW_BXOR_in_bitwiseXorExpression3791); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BXOR350_tree = (CommonTree)adaptor.Create(BXOR350);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BXOR350_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3794);
            			    	bitwiseAndExpression351 = bitwiseAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression351.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop93;
            	    }
            	} while (true);
            	
            	loop93:
            		;	// Stops C# compiler whinging that label 'loop93' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 107, bitwiseXorExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseXorExpression

    public class bitwiseAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:862:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
    public bitwiseAndExpression_return bitwiseAndExpression() // throws RecognitionException [1]
    {   
        bitwiseAndExpression_return retval = new bitwiseAndExpression_return();
        retval.start = input.LT(1);
        int bitwiseAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BAND353 = null;
        equalityExpression_return equalityExpression352 = null;

        equalityExpression_return equalityExpression354 = null;
        
        
        CommonTree BAND353_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 108) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:863:4: ( equalityExpression ( BAND equalityExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:863:4: equalityExpression ( BAND equalityExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3808);
            	equalityExpression352 = equalityExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression352.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:864:3: ( BAND equalityExpression )*
            	do 
            	{
            	    int alt94 = 2;
            	    int LA94_0 = input.LA(1);
            	    
            	    if ( (LA94_0 == BAND) )
            	    {
            	        alt94 = 1;
            	    }
            	    
            	
            	    switch (alt94) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:864:4: BAND equalityExpression
            			    {
            			    	BAND353 = (IToken)input.LT(1);
            			    	Match(input,BAND,FOLLOW_BAND_in_bitwiseAndExpression3813); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BAND353_tree = (CommonTree)adaptor.Create(BAND353);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BAND353_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3816);
            			    	equalityExpression354 = equalityExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression354.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop94;
            	    }
            	} while (true);
            	
            	loop94:
            		;	// Stops C# compiler whinging that label 'loop94' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 108, bitwiseAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseAndExpression

    public class equalityExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:868:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
    public equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {   
        equalityExpression_return retval = new equalityExpression_return();
        retval.start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        relationalExpression_return relationalExpression355 = null;

        equalityOperator_return equalityOperator356 = null;

        relationalExpression_return relationalExpression357 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 109) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:869:4: ( relationalExpression ( equalityOperator relationalExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:869:4: relationalExpression ( equalityOperator relationalExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_relationalExpression_in_equalityExpression3830);
            	relationalExpression355 = relationalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression355.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:870:2: ( equalityOperator relationalExpression )*
            	do 
            	{
            	    int alt95 = 2;
            	    int LA95_0 = input.LA(1);
            	    
            	    if ( ((LA95_0 >= STRICT_EQUAL && LA95_0 <= EQUAL)) )
            	    {
            	        alt95 = 1;
            	    }
            	    
            	
            	    switch (alt95) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:870:4: equalityOperator relationalExpression
            			    {
            			    	PushFollow(FOLLOW_equalityOperator_in_equalityExpression3835);
            			    	equalityOperator356 = equalityOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(equalityOperator356.Tree, root_0);
            			    	PushFollow(FOLLOW_relationalExpression_in_equalityExpression3840);
            			    	relationalExpression357 = relationalExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression357.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop95;
            	    }
            	} while (true);
            	
            	loop95:
            		;	// Stops C# compiler whinging that label 'loop95' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 109, equalityExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityExpression

    public class equalityOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:875:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
    public equalityOperator_return equalityOperator() // throws RecognitionException [1]
    {   
        equalityOperator_return retval = new equalityOperator_return();
        retval.start = input.LT(1);
        int equalityOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set358 = null;
        
        CommonTree set358_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 110) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:876:4: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set358 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= STRICT_EQUAL && input.LA(1) <= EQUAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set358));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_equalityOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 110, equalityOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityOperator

    public class relationalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:880:1: relationalExpression : shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* ;
    public relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {   
        relationalExpression_return retval = new relationalExpression_return();
        retval.start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        shiftExpression_return shiftExpression359 = null;

        relationalOperator_return relationalOperator360 = null;

        shiftExpression_return shiftExpression361 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 111) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:881:4: ( shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:881:4: shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_shiftExpression_in_relationalExpression3880);
            	shiftExpression359 = shiftExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression359.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:3: ( ( relationalOperator )=> relationalOperator shiftExpression )*
            	do 
            	{
            	    int alt96 = 2;
            	    int LA96_0 = input.LA(1);
            	    
            	    if ( (LA96_0 == LT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA96_83 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA96_85 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA96_86 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA96_87 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA96_88 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA96_89 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA96_92 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA96_96 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA96_97 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA96_110 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA96_112 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA96_113 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA96_114 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA96_115 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA96_116 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA96_117 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA96_118 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA96_120 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA96_121 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA96_122 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA96_123 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA96_124 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA96_125 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA96_126 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA96_127 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA96_128 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA96_129 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA96_130 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA96_131 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA96_132 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA96_133 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA96_134 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA96_135 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA96_0 == IS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA96_152 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA96_153 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA96_154 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA96_155 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA96_156 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA96_157 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA96_158 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA96_159 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA96_160 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA96_161 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA96_162 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA96_163 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA96_164 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA96_165 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA96_166 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA96_167 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA96_168 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA96_169 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA96_170 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA96_171 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA96_172 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA96_173 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA96_174 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA96_175 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA96_176 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA96_177 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA96_178 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA96_179 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA96_180 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA96_181 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA96_182 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA96_183 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA96_184 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA96_0 == AS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA96_222 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA96_223 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA96_224 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA96_225 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA96_226 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA96_227 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA96_228 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA96_229 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA96_230 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA96_231 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA96_232 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA96_233 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA96_234 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA96_235 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA96_236 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA96_237 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA96_238 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA96_239 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA96_240 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA96_241 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA96_242 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA96_243 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA96_244 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA96_245 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA96_246 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA96_247 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA96_248 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA96_249 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA96_250 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA96_251 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA96_252 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA96_253 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA96_254 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA96_0 == IN) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA96_292 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA96_293 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA96_294 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA96_295 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA96_296 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA96_297 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA96_298 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA96_299 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA96_300 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA96_301 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA96_302 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA96_303 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA96_304 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA96_305 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA96_306 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA96_307 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA96_308 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA96_309 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA96_310 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA96_311 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA96_312 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA96_313 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA96_314 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA96_315 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA96_316 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA96_317 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA96_318 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA96_319 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA96_320 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA96_321 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA96_322 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA96_323 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA96_324 = input.LA(3);
            	            
            	            if ( ((synpred157() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt96 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA96_0 == GT) && (synpred157()) )
            	    {
            	        alt96 = 1;
            	    }
            	    else if ( (LA96_0 == LE) && (synpred157()) )
            	    {
            	        alt96 = 1;
            	    }
            	    else if ( (LA96_0 == GE) && (synpred157()) )
            	    {
            	        alt96 = 1;
            	    }
            	    else if ( (LA96_0 == INSTANCEOF) && (synpred157()) )
            	    {
            	        alt96 = 1;
            	    }
            	    
            	
            	    switch (alt96) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:4: ( relationalOperator )=> relationalOperator shiftExpression
            			    {
            			    	PushFollow(FOLLOW_relationalOperator_in_relationalExpression3890);
            			    	relationalOperator360 = relationalOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(relationalOperator360.Tree, root_0);
            			    	PushFollow(FOLLOW_shiftExpression_in_relationalExpression3893);
            			    	shiftExpression361 = shiftExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression361.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop96;
            	    }
            	} while (true);
            	
            	loop96:
            		;	// Stops C# compiler whinging that label 'loop96' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 111, relationalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalExpression

    public class relationalOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:885:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );
    public relationalOperator_return relationalOperator() // throws RecognitionException [1]
    {   
        relationalOperator_return retval = new relationalOperator_return();
        retval.start = input.LT(1);
        int relationalOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IN362 = null;
        IToken LT363 = null;
        IToken GT364 = null;
        IToken LE365 = null;
        IToken GE366 = null;
        IToken IS367 = null;
        IToken AS368 = null;
        IToken INSTANCEOF369 = null;
        
        CommonTree IN362_tree=null;
        CommonTree LT363_tree=null;
        CommonTree GT364_tree=null;
        CommonTree LE365_tree=null;
        CommonTree GE366_tree=null;
        CommonTree IS367_tree=null;
        CommonTree AS368_tree=null;
        CommonTree INSTANCEOF369_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 112) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:4: ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF )
            int alt97 = 8;
            switch ( input.LA(1) ) 
            {
            case IN:
            	{
                alt97 = 1;
                }
                break;
            case LT:
            	{
                alt97 = 2;
                }
                break;
            case GT:
            	{
                alt97 = 3;
                }
                break;
            case LE:
            	{
                alt97 = 4;
                }
                break;
            case GE:
            	{
                alt97 = 5;
                }
                break;
            case IS:
            	{
                alt97 = 6;
                }
                break;
            case AS:
            	{
                alt97 = 7;
                }
                break;
            case INSTANCEOF:
            	{
                alt97 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d97s0 =
            	        new NoViableAltException("885:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );", 97, 0, input);
            
            	    throw nvae_d97s0;
            }
            
            switch (alt97) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:4: {...}? IN
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( !(((InOperator_scope)InOperator_stack.Peek()).allowed) ) 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    throw new FailedPredicateException(input, "relationalOperator", "$InOperator::allowed");
                    	}
                    	IN362 = (IToken)input.LT(1);
                    	Match(input,IN,FOLLOW_IN_in_relationalOperator3908); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IN362_tree = (CommonTree)adaptor.Create(IN362);
                    	adaptor.AddChild(root_0, IN362_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:4: LT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LT363 = (IToken)input.LT(1);
                    	Match(input,LT,FOLLOW_LT_in_relationalOperator3913); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LT363_tree = (CommonTree)adaptor.Create(LT363);
                    	adaptor.AddChild(root_0, LT363_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:9: GT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GT364 = (IToken)input.LT(1);
                    	Match(input,GT,FOLLOW_GT_in_relationalOperator3917); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GT364_tree = (CommonTree)adaptor.Create(GT364);
                    	adaptor.AddChild(root_0, GT364_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:14: LE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LE365 = (IToken)input.LT(1);
                    	Match(input,LE,FOLLOW_LE_in_relationalOperator3921); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LE365_tree = (CommonTree)adaptor.Create(LE365);
                    	adaptor.AddChild(root_0, LE365_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:19: GE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GE366 = (IToken)input.LT(1);
                    	Match(input,GE,FOLLOW_GE_in_relationalOperator3925); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GE366_tree = (CommonTree)adaptor.Create(GE366);
                    	adaptor.AddChild(root_0, GE366_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:24: IS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IS367 = (IToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_relationalOperator3929); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IS367_tree = (CommonTree)adaptor.Create(IS367);
                    	adaptor.AddChild(root_0, IS367_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:29: AS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	AS368 = (IToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_relationalOperator3933); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	AS368_tree = (CommonTree)adaptor.Create(AS368);
                    	adaptor.AddChild(root_0, AS368_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:34: INSTANCEOF
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	INSTANCEOF369 = (IToken)input.LT(1);
                    	Match(input,INSTANCEOF,FOLLOW_INSTANCEOF_in_relationalOperator3937); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	INSTANCEOF369_tree = (CommonTree)adaptor.Create(INSTANCEOF369);
                    	adaptor.AddChild(root_0, INSTANCEOF369_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 112, relationalOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalOperator

    public class shiftExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:891:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
    public shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {   
        shiftExpression_return retval = new shiftExpression_return();
        retval.start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        additiveExpression_return additiveExpression370 = null;

        shiftOperator_return shiftOperator371 = null;

        additiveExpression_return additiveExpression372 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 113) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:892:4: ( additiveExpression ( shiftOperator additiveExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:892:4: additiveExpression ( shiftOperator additiveExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_additiveExpression_in_shiftExpression3949);
            	additiveExpression370 = additiveExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression370.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:893:3: ( shiftOperator additiveExpression )*
            	do 
            	{
            	    int alt98 = 2;
            	    int LA98_0 = input.LA(1);
            	    
            	    if ( ((LA98_0 >= SL && LA98_0 <= BSR)) )
            	    {
            	        alt98 = 1;
            	    }
            	    
            	
            	    switch (alt98) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:893:4: shiftOperator additiveExpression
            			    {
            			    	PushFollow(FOLLOW_shiftOperator_in_shiftExpression3954);
            			    	shiftOperator371 = shiftOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(shiftOperator371.Tree, root_0);
            			    	PushFollow(FOLLOW_additiveExpression_in_shiftExpression3957);
            			    	additiveExpression372 = additiveExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression372.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop98;
            	    }
            	} while (true);
            	
            	loop98:
            		;	// Stops C# compiler whinging that label 'loop98' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 113, shiftExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftExpression

    public class shiftOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:1: shiftOperator : ( SL | SR | BSR );
    public shiftOperator_return shiftOperator() // throws RecognitionException [1]
    {   
        shiftOperator_return retval = new shiftOperator_return();
        retval.start = input.LT(1);
        int shiftOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set373 = null;
        
        CommonTree set373_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 114) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:4: ( SL | SR | BSR )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set373 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= SL && input.LA(1) <= BSR) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set373));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_shiftOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 114, shiftOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftOperator

    public class additiveExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:901:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
    public additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {   
        additiveExpression_return retval = new additiveExpression_return();
        retval.start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        multiplicativeExpression_return multiplicativeExpression374 = null;

        additiveOperator_return additiveOperator375 = null;

        multiplicativeExpression_return multiplicativeExpression376 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 115) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:4: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3990);
            	multiplicativeExpression374 = multiplicativeExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression374.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:3: ( additiveOperator multiplicativeExpression )*
            	do 
            	{
            	    int alt99 = 2;
            	    int LA99_0 = input.LA(1);
            	    
            	    if ( (LA99_0 == MINUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA99_83 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA99_84 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA99_85 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA99_86 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA99_87 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA99_88 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA99_89 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA99_90 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA99_91 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA99_92 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA99_93 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA99_94 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA99_95 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA99_96 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA99_97 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA99_98 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA99_99 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA99_100 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA99_101 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA99_102 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA99_103 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA99_104 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA99_105 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA99_106 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA99_107 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA99_108 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA99_109 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA99_110 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA99_111 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA99_112 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA99_113 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA99_114 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA99_115 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA99_0 == PLUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA99_116 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA99_117 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA99_118 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA99_119 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA99_120 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA99_121 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA99_122 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA99_123 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA99_124 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA99_125 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA99_126 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA99_127 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA99_128 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA99_129 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA99_130 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA99_131 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA99_132 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA99_133 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA99_134 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA99_135 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA99_136 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA99_137 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA99_138 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA99_139 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA99_140 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA99_141 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA99_142 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA99_143 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA99_144 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA99_145 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA99_146 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA99_147 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA99_148 = input.LA(3);
            	            
            	            if ( (synpred168()) )
            	            {
            	                alt99 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt99) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:4: additiveOperator multiplicativeExpression
            			    {
            			    	PushFollow(FOLLOW_additiveOperator_in_additiveExpression3995);
            			    	additiveOperator375 = additiveOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(additiveOperator375.Tree, root_0);
            			    	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3998);
            			    	multiplicativeExpression376 = multiplicativeExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression376.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop99;
            	    }
            	} while (true);
            	
            	loop99:
            		;	// Stops C# compiler whinging that label 'loop99' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 115, additiveExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveExpression

    public class additiveOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:906:1: additiveOperator : ( PLUS | MINUS );
    public additiveOperator_return additiveOperator() // throws RecognitionException [1]
    {   
        additiveOperator_return retval = new additiveOperator_return();
        retval.start = input.LT(1);
        int additiveOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set377 = null;
        
        CommonTree set377_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 116) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:907:4: ( PLUS | MINUS )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set377 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= PLUS && input.LA(1) <= MINUS) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set377));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_additiveOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 116, additiveOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveOperator

    public class multiplicativeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:911:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
    public multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {   
        multiplicativeExpression_return retval = new multiplicativeExpression_return();
        retval.start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        unaryExpression_return unaryExpression378 = null;

        multiplicativeOperator_return multiplicativeOperator379 = null;

        unaryExpression_return unaryExpression380 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 117) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:912:4: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:912:4: unaryExpression ( multiplicativeOperator unaryExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression4028);
            	unaryExpression378 = unaryExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression378.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:3: ( multiplicativeOperator unaryExpression )*
            	do 
            	{
            	    int alt100 = 2;
            	    int LA100_0 = input.LA(1);
            	    
            	    if ( (LA100_0 == DIV) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA100_85 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA100_87 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA100_88 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA100_89 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA100_90 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA100_91 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA100_94 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA100_98 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA100_99 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA100_112 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA100_114 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA100_115 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA100_116 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA100_117 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA100_118 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA100_119 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA100_120 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA100_122 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA100_123 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA100_124 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA100_125 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA100_126 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA100_127 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA100_128 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA100_129 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA100_130 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA100_131 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA100_132 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA100_133 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA100_134 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA100_135 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA100_136 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA100_137 = input.LA(3);
            	            
            	            if ( (synpred170()) )
            	            {
            	                alt100 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA100_0 == STAR || LA100_0 == MOD) )
            	    {
            	        alt100 = 1;
            	    }
            	    
            	
            	    switch (alt100) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:5: multiplicativeOperator unaryExpression
            			    {
            			    	PushFollow(FOLLOW_multiplicativeOperator_in_multiplicativeExpression4034);
            			    	multiplicativeOperator379 = multiplicativeOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(multiplicativeOperator379.Tree, root_0);
            			    	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression4040);
            			    	unaryExpression380 = unaryExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression380.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop100;
            	    }
            	} while (true);
            	
            	loop100:
            		;	// Stops C# compiler whinging that label 'loop100' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 117, multiplicativeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeExpression

    public class multiplicativeOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:918:1: multiplicativeOperator : ( STAR | DIV | MOD );
    public multiplicativeOperator_return multiplicativeOperator() // throws RecognitionException [1]
    {   
        multiplicativeOperator_return retval = new multiplicativeOperator_return();
        retval.start = input.LT(1);
        int multiplicativeOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set381 = null;
        
        CommonTree set381_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 118) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:919:4: ( STAR | DIV | MOD )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set381 = (IToken)input.LT(1);
            	if ( input.LA(1) == STAR || (input.LA(1) >= DIV && input.LA(1) <= MOD) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set381));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_multiplicativeOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 118, multiplicativeOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeOperator

    public class unaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:923:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );
    public unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {   
        unaryExpression_return retval = new unaryExpression_return();
        retval.start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken iin = null;
        IToken dde = null;
        IToken MINUS384 = null;
        IToken PLUS386 = null;
        unaryExpression_return unaryExpression382 = null;

        unaryExpression_return unaryExpression383 = null;

        unaryExpression_return unaryExpression385 = null;

        unaryExpression_return unaryExpression387 = null;

        unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus388 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree MINUS384_tree=null;
        CommonTree PLUS386_tree=null;
        RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream(adaptor,"token PLUS");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_MINUS = new RewriteRuleTokenStream(adaptor,"token MINUS");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 119) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:4: (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus )
            int alt101 = 5;
            switch ( input.LA(1) ) 
            {
            case INC:
            	{
                alt101 = 1;
                }
                break;
            case DEC:
            	{
                alt101 = 2;
                }
                break;
            case MINUS:
            	{
                alt101 = 3;
                }
                break;
            case PLUS:
            	{
                alt101 = 4;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case DIV:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case 180:
            	{
                alt101 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d101s0 =
            	        new NoViableAltException("923:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );", 101, 0, input);
            
            	    throw nvae_d101s0;
            }
            
            switch (alt101) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:4: iin= INC unaryExpression
                    {
                    	iin = (IToken)input.LT(1);
                    	Match(input,INC,FOLLOW_INC_in_unaryExpression4078); if (failed) return retval;
                    	if ( backtracking==0 ) stream_INC.Add(iin);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4080);
                    	unaryExpression382 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression382.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 924:28: -> ^( PRE_INC[$iin] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:31: ^( PRE_INC[$iin] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_INC, iin), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:925:4: dde= DEC unaryExpression
                    {
                    	dde = (IToken)input.LT(1);
                    	Match(input,DEC,FOLLOW_DEC_in_unaryExpression4096); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DEC.Add(dde);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4098);
                    	unaryExpression383 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression383.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 925:28: -> ^( PRE_DEC[$dde] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:925:31: ^( PRE_DEC[$dde] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_DEC, dde), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:926:4: MINUS unaryExpression
                    {
                    	MINUS384 = (IToken)input.LT(1);
                    	Match(input,MINUS,FOLLOW_MINUS_in_unaryExpression4112); if (failed) return retval;
                    	if ( backtracking==0 ) stream_MINUS.Add(MINUS384);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4114);
                    	unaryExpression385 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression385.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 926:26: -> ^( UNARY_MINUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:926:29: ^( UNARY_MINUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:927:4: PLUS unaryExpression
                    {
                    	PLUS386 = (IToken)input.LT(1);
                    	Match(input,PLUS,FOLLOW_PLUS_in_unaryExpression4127); if (failed) return retval;
                    	if ( backtracking==0 ) stream_PLUS.Add(PLUS386);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4129);
                    	unaryExpression387 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression387.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 927:25: -> ^( UNARY_PLUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:927:28: ^( UNARY_PLUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_PLUS, "UNARY_PLUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:928:4: unaryExpressionNotPlusMinus
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression4142);
                    	unaryExpressionNotPlusMinus388 = unaryExpressionNotPlusMinus();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus388.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 119, unaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpression

    public class unaryExpressionNotPlusMinus_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpressionNotPlusMinus
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:931:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
    public unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus() // throws RecognitionException [1]
    {   
        unaryExpressionNotPlusMinus_return retval = new unaryExpressionNotPlusMinus_return();
        retval.start = input.LT(1);
        int unaryExpressionNotPlusMinus_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DELETE389 = null;
        IToken string_literal391 = null;
        IToken TYPEOF393 = null;
        IToken LNOT395 = null;
        IToken BNOT397 = null;
        postfixExpression_return postfixExpression390 = null;

        unaryExpression_return unaryExpression392 = null;

        unaryExpression_return unaryExpression394 = null;

        unaryExpression_return unaryExpression396 = null;

        unaryExpression_return unaryExpression398 = null;

        postfixExpression_return postfixExpression399 = null;
        
        
        CommonTree DELETE389_tree=null;
        CommonTree string_literal391_tree=null;
        CommonTree TYPEOF393_tree=null;
        CommonTree LNOT395_tree=null;
        CommonTree BNOT397_tree=null;
        RewriteRuleTokenStream stream_BNOT = new RewriteRuleTokenStream(adaptor,"token BNOT");
        RewriteRuleTokenStream stream_LNOT = new RewriteRuleTokenStream(adaptor,"token LNOT");
        RewriteRuleTokenStream stream_TYPEOF = new RewriteRuleTokenStream(adaptor,"token TYPEOF");
        RewriteRuleTokenStream stream_DELETE = new RewriteRuleTokenStream(adaptor,"token DELETE");
        RewriteRuleTokenStream stream_180 = new RewriteRuleTokenStream(adaptor,"token 180");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        RewriteRuleSubtreeStream stream_postfixExpression = new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 120) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:932:4: ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
            int alt102 = 6;
            switch ( input.LA(1) ) 
            {
            case DELETE:
            	{
                alt102 = 1;
                }
                break;
            case 180:
            	{
                alt102 = 2;
                }
                break;
            case TYPEOF:
            	{
                alt102 = 3;
                }
                break;
            case LNOT:
            	{
                alt102 = 4;
                }
                break;
            case BNOT:
            	{
                alt102 = 5;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case DIV:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            	{
                alt102 = 6;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d102s0 =
            	        new NoViableAltException("931:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );", 102, 0, input);
            
            	    throw nvae_d102s0;
            }
            
            switch (alt102) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:932:4: DELETE postfixExpression
                    {
                    	DELETE389 = (IToken)input.LT(1);
                    	Match(input,DELETE,FOLLOW_DELETE_in_unaryExpressionNotPlusMinus4153); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DELETE.Add(DELETE389);

                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4155);
                    	postfixExpression390 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_postfixExpression.Add(postfixExpression390.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          postfixExpression, DELETE
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 932:29: -> ^( DELETE postfixExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:932:32: ^( DELETE postfixExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DELETE.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_postfixExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:933:4: 'void' unaryExpression
                    {
                    	string_literal391 = (IToken)input.LT(1);
                    	Match(input,180,FOLLOW_180_in_unaryExpressionNotPlusMinus4168); if (failed) return retval;
                    	if ( backtracking==0 ) stream_180.Add(string_literal391);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4170);
                    	unaryExpression392 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression392.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, 180
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 933:27: -> ^( 'void' unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:933:30: ^( 'void' unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_180.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:934:4: TYPEOF unaryExpression
                    {
                    	TYPEOF393 = (IToken)input.LT(1);
                    	Match(input,TYPEOF,FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus4183); if (failed) return retval;
                    	if ( backtracking==0 ) stream_TYPEOF.Add(TYPEOF393);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4185);
                    	unaryExpression394 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression394.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          TYPEOF, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 934:27: -> ^( TYPEOF unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:934:30: ^( TYPEOF unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_TYPEOF.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:4: LNOT unaryExpression
                    {
                    	LNOT395 = (IToken)input.LT(1);
                    	Match(input,LNOT,FOLLOW_LNOT_in_unaryExpressionNotPlusMinus4198); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LNOT.Add(LNOT395);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4200);
                    	unaryExpression396 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression396.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          LNOT, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 935:25: -> ^( LNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:28: ^( LNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: BNOT unaryExpression
                    {
                    	BNOT397 = (IToken)input.LT(1);
                    	Match(input,BNOT,FOLLOW_BNOT_in_unaryExpressionNotPlusMinus4213); if (failed) return retval;
                    	if ( backtracking==0 ) stream_BNOT.Add(BNOT397);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4215);
                    	unaryExpression398 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression398.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, BNOT
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 936:25: -> ^( BNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:28: ^( BNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:937:4: postfixExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4228);
                    	postfixExpression399 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, postfixExpression399.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 120, unaryExpressionNotPlusMinus_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpressionNotPlusMinus

    public class postfixExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start postfixExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:941:1: postfixExpression : ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? ;
    public postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {   
        postfixExpression_return retval = new postfixExpression_return();
        retval.start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken iin = null;
        IToken dde = null;
        IToken DOT401 = null;
        IToken LBRACK403 = null;
        IToken RBRACK405 = null;
        IToken E4X_DESC406 = null;
        propOrIdent_return poi = null;

        primaryExpression_return primaryExpression400 = null;

        e4xExpression_return e4xExpression402 = null;

        expression_return expression404 = null;

        e4xExpression_return e4xExpression407 = null;

        arguments_return arguments408 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree DOT401_tree=null;
        CommonTree LBRACK403_tree=null;
        CommonTree RBRACK405_tree=null;
        CommonTree E4X_DESC406_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_E4X_DESC = new RewriteRuleTokenStream(adaptor,"token E4X_DESC");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_arguments = new RewriteRuleSubtreeStream(adaptor,"rule arguments");
        RewriteRuleSubtreeStream stream_e4xExpression = new RewriteRuleSubtreeStream(adaptor,"rule e4xExpression");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_propOrIdent = new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 121) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: ( ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:5: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_postfixExpression4241);
            		primaryExpression400 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression400.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 942:23: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:943:3: (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )*
            	do 
            	{
            	    int alt103 = 6;
            	    switch ( input.LA(1) ) 
            	    {
            	    case LBRACK:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA103_86 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA103_87 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA103_88 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA103_89 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA103_90 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA103_91 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA103_92 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA103_93 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA103_94 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA103_95 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA103_96 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA103_97 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA103_98 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA103_99 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA103_100 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA103_101 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA103_102 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA103_103 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA103_104 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA103_105 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA103_106 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA103_107 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA103_108 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA103_109 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA103_110 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA103_111 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA103_112 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA103_113 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA103_114 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA103_115 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA103_116 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA103_117 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA103_118 = input.LA(3);
            	            
            	            if ( (synpred184()) )
            	            {
            	                alt103 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case LPAREN:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case RPAREN:
            	        	{
            	            alt103 = 5;
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA103_121 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA103_122 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA103_123 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA103_124 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA103_125 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA103_126 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA103_127 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA103_128 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA103_129 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA103_130 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA103_131 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA103_132 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA103_133 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA103_134 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA103_135 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA103_136 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA103_137 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA103_138 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA103_139 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA103_140 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA103_141 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA103_142 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA103_143 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA103_144 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA103_145 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA103_146 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA103_147 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA103_148 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA103_149 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA103_150 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA103_151 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA103_152 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA103_153 = input.LA(3);
            	            
            	            if ( (synpred186()) )
            	            {
            	                alt103 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case DOT:
            	    	{
            	        int LA103_84 = input.LA(2);
            	        
            	        if ( ((LA103_84 >= GET && LA103_84 <= USE) || LA103_84 == XML || (LA103_84 >= IDENT && LA103_84 <= INTERNAL) || LA103_84 == DYNAMIC || (LA103_84 >= IS && LA103_84 <= AS)) )
            	        {
            	            alt103 = 1;
            	        }
            	        else if ( (LA103_84 == LPAREN || LA103_84 == STAR || LA103_84 == E4X_ATTRI) )
            	        {
            	            alt103 = 2;
            	        }
            	        
            	    
            	        }
            	        break;
            	    case E4X_DESC:
            	    	{
            	        alt103 = 4;
            	        }
            	        break;
            	    
            	    }
            	
            	    switch (alt103) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:943:5: poi= propOrIdent[root_0, retval.start]
            			    {
            			    	PushFollow(FOLLOW_propOrIdent_in_postfixExpression4254);
            			    	poi = propOrIdent(root_0,  retval.start);
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_propOrIdent.Add(poi.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          poi
            			    	// token labels:      
            			    	// rule labels:       retval, poi
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	RewriteRuleSubtreeStream stream_poi = new RewriteRuleSubtreeStream(adaptor, "token poi", (poi!=null ? poi.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 943:43: -> $poi
            			    	{
            			    	    adaptor.AddChild(root_0, stream_poi.Next());
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:944:5: DOT e4xExpression
            			    {
            			    	DOT401 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_postfixExpression4266); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT401);

            			    	PushFollow(FOLLOW_e4xExpression_in_postfixExpression4268);
            			    	e4xExpression402 = e4xExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_e4xExpression.Add(e4xExpression402.Tree);
            			    
            			    }
            			    break;
            			case 3 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:5: LBRACK expression RBRACK
            			    {
            			    	LBRACK403 = (IToken)input.LT(1);
            			    	Match(input,LBRACK,FOLLOW_LBRACK_in_postfixExpression4274); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK403);

            			    	PushFollow(FOLLOW_expression_in_postfixExpression4276);
            			    	expression404 = expression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_expression.Add(expression404.Tree);
            			    	RBRACK405 = (IToken)input.LT(1);
            			    	Match(input,RBRACK,FOLLOW_RBRACK_in_postfixExpression4278); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK405);

            			    	
            			    	// AST REWRITE
            			    	// elements:          postfixExpression, expression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 945:30: -> ^( ARRAY_ACC $postfixExpression expression )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:33: ^( ARRAY_ACC $postfixExpression expression )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_expression.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 4 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:946:5: E4X_DESC e4xExpression
            			    {
            			    	E4X_DESC406 = (IToken)input.LT(1);
            			    	Match(input,E4X_DESC,FOLLOW_E4X_DESC_in_postfixExpression4295); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_E4X_DESC.Add(E4X_DESC406);

            			    	PushFollow(FOLLOW_e4xExpression_in_postfixExpression4297);
            			    	e4xExpression407 = e4xExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_e4xExpression.Add(e4xExpression407.Tree);
            			    
            			    }
            			    break;
            			case 5 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:947:5: arguments
            			    {
            			    	PushFollow(FOLLOW_arguments_in_postfixExpression4303);
            			    	arguments408 = arguments();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_arguments.Add(arguments408.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          postfixExpression, arguments
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 947:15: -> ^( METHOD_CALL $postfixExpression arguments )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:947:18: ^( METHOD_CALL $postfixExpression arguments )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_CALL, "METHOD_CALL"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_arguments.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop103;
            	    }
            	} while (true);
            	
            	loop103:
            		;	// Stops C# compiler whinging that label 'loop103' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:950:3: (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            	int alt104 = 3;
            	int LA104_0 = input.LA(1);
            	
            	if ( (LA104_0 == INC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA104_84 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA104_85 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA104_86 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA104_87 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA104_88 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA104_89 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA104_90 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA104_91 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA104_92 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA104_93 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA104_94 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA104_95 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA104_96 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA104_97 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA104_98 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA104_99 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA104_100 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA104_101 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA104_102 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA104_103 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA104_104 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA104_105 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA104_106 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA104_107 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA104_108 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA104_109 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA104_110 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA104_111 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA104_112 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA104_113 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA104_114 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA104_115 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA104_116 = input.LA(3);
            	            
            	            if ( (synpred187()) )
            	            {
            	                alt104 = 1;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case RCURLY:
            	        case SEMI:
            	        case IMPORT:
            	        case CLASS:
            	        case INTERFACE:
            	        case COMMA:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 175:
            	        case 176:
            	        case 177:
            	        case 181:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        case 187:
            	        	{
            	            alt104 = 1;
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA104_0 == DEC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA104_167 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA104_168 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA104_169 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA104_170 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA104_171 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case 180:
            	        	{
            	            int LA104_172 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA104_173 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA104_174 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA104_175 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA104_176 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA104_177 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA104_178 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA104_179 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA104_180 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA104_181 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA104_182 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA104_183 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA104_184 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA104_185 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA104_186 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA104_187 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA104_188 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA104_189 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA104_190 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA104_191 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA104_192 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA104_193 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA104_194 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA104_195 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA104_196 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA104_197 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA104_198 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA104_199 = input.LA(3);
            	            
            	            if ( (synpred188()) )
            	            {
            	                alt104 = 2;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case RCURLY:
            	        case SEMI:
            	        case IMPORT:
            	        case CLASS:
            	        case INTERFACE:
            	        case COMMA:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 175:
            	        case 176:
            	        case 177:
            	        case 181:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        case 187:
            	        	{
            	            alt104 = 2;
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt104) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:950:6: iin= INC
            	        {
            	        	iin = (IToken)input.LT(1);
            	        	Match(input,INC,FOLLOW_INC_in_postfixExpression4329); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_INC.Add(iin);

            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 950:14: -> ^( POST_INC[$iin] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:950:17: ^( POST_INC[$iin] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_INC, iin), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:6: dde= DEC
            	        {
            	        	dde = (IToken)input.LT(1);
            	        	Match(input,DEC,FOLLOW_DEC_in_postfixExpression4348); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DEC.Add(dde);

            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 951:14: -> ^( POST_DEC[$dde] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:17: ^( POST_DEC[$dde] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_DEC, dde), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 121, postfixExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end postfixExpression

    public class e4xExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:955:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
    public e4xExpression_return e4xExpression() // throws RecognitionException [1]
    {   
        e4xExpression_return retval = new e4xExpression_return();
        retval.start = input.LT(1);
        int e4xExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STAR409 = null;
        e4xAttributeIdentifier_return e4xAttributeIdentifier410 = null;

        e4xFilterPredicate_return e4xFilterPredicate411 = null;
        
        
        CommonTree STAR409_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 122) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:956:4: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
            int alt105 = 3;
            switch ( input.LA(1) ) 
            {
            case STAR:
            	{
                alt105 = 1;
                }
                break;
            case E4X_ATTRI:
            	{
                alt105 = 2;
                }
                break;
            case LPAREN:
            	{
                alt105 = 3;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d105s0 =
            	        new NoViableAltException("955:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );", 105, 0, input);
            
            	    throw nvae_d105s0;
            }
            
            switch (alt105) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:956:4: STAR
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STAR409 = (IToken)input.LT(1);
                    	Match(input,STAR,FOLLOW_STAR_in_e4xExpression4375); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STAR409_tree = (CommonTree)adaptor.Create(STAR409);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(STAR409_tree, root_0);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:957:4: e4xAttributeIdentifier
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xAttributeIdentifier_in_e4xExpression4381);
                    	e4xAttributeIdentifier410 = e4xAttributeIdentifier();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xAttributeIdentifier410.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:958:4: e4xFilterPredicate
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xFilterPredicate_in_e4xExpression4386);
                    	e4xFilterPredicate411 = e4xFilterPredicate();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xFilterPredicate411.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 122, e4xExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xExpression

    public class e4xAttributeIdentifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xAttributeIdentifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:961:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
    public e4xAttributeIdentifier_return e4xAttributeIdentifier() // throws RecognitionException [1]
    {   
        e4xAttributeIdentifier_return retval = new e4xAttributeIdentifier_return();
        retval.start = input.LT(1);
        int e4xAttributeIdentifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken E4X_ATTRI412 = null;
        IToken STAR414 = null;
        IToken LBRACK415 = null;
        IToken RBRACK417 = null;
        qualifiedIdent_return qualifiedIdent413 = null;

        expression_return expression416 = null;
        
        
        CommonTree E4X_ATTRI412_tree=null;
        CommonTree STAR414_tree=null;
        CommonTree LBRACK415_tree=null;
        CommonTree RBRACK417_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 123) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:962:4: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:962:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	E4X_ATTRI412 = (IToken)input.LT(1);
            	Match(input,E4X_ATTRI,FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4397); if (failed) return retval;
            	if ( backtracking==0 ) {
            	E4X_ATTRI412_tree = (CommonTree)adaptor.Create(E4X_ATTRI412);
            	adaptor.AddChild(root_0, E4X_ATTRI412_tree);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:963:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
            	int alt106 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case USE:
            	case XML:
            	case IDENT:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case DYNAMIC:
            	case IS:
            	case AS:
            		{
            	    alt106 = 1;
            	    }
            	    break;
            	case STAR:
            		{
            	    alt106 = 2;
            	    }
            	    break;
            	case LBRACK:
            		{
            	    alt106 = 3;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d106s0 =
            		        new NoViableAltException("963:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )", 106, 0, input);
            	
            		    throw nvae_d106s0;
            	}
            	
            	switch (alt106) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:963:5: qualifiedIdent
            	        {
            	        	PushFollow(FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4403);
            	        	qualifiedIdent413 = qualifiedIdent();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent413.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:964:5: STAR
            	        {
            	        	STAR414 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_e4xAttributeIdentifier4409); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	STAR414_tree = (CommonTree)adaptor.Create(STAR414);
            	        	adaptor.AddChild(root_0, STAR414_tree);
            	        	}
            	        
            	        }
            	        break;
            	    case 3 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:5: LBRACK expression RBRACK
            	        {
            	        	LBRACK415 = (IToken)input.LT(1);
            	        	Match(input,LBRACK,FOLLOW_LBRACK_in_e4xAttributeIdentifier4415); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	LBRACK415_tree = (CommonTree)adaptor.Create(LBRACK415);
            	        	adaptor.AddChild(root_0, LBRACK415_tree);
            	        	}
            	        	PushFollow(FOLLOW_expression_in_e4xAttributeIdentifier4417);
            	        	expression416 = expression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, expression416.Tree);
            	        	RBRACK417 = (IToken)input.LT(1);
            	        	Match(input,RBRACK,FOLLOW_RBRACK_in_e4xAttributeIdentifier4419); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	RBRACK417_tree = (CommonTree)adaptor.Create(RBRACK417);
            	        	adaptor.AddChild(root_0, RBRACK417_tree);
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 123, e4xAttributeIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xAttributeIdentifier

    public class e4xFilterPredicate_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xFilterPredicate
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:969:1: e4xFilterPredicate : LPAREN expression RPAREN ;
    public e4xFilterPredicate_return e4xFilterPredicate() // throws RecognitionException [1]
    {   
        e4xFilterPredicate_return retval = new e4xFilterPredicate_return();
        retval.start = input.LT(1);
        int e4xFilterPredicate_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN418 = null;
        IToken RPAREN420 = null;
        expression_return expression419 = null;
        
        
        CommonTree LPAREN418_tree=null;
        CommonTree RPAREN420_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 124) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:970:4: ( LPAREN expression RPAREN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:970:4: LPAREN expression RPAREN
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	LPAREN418 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_e4xFilterPredicate4434); if (failed) return retval;
            	PushFollow(FOLLOW_expression_in_e4xFilterPredicate4439);
            	expression419 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression419.Tree);
            	RPAREN420 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_e4xFilterPredicate4443); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 124, e4xFilterPredicate_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xFilterPredicate

    public class primaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start primaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
    public primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {   
        primaryExpression_return retval = new primaryExpression_return();
        retval.start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken UNDEFINED421 = null;
        constant_return constant422 = null;

        arrayLiteral_return arrayLiteral423 = null;

        objectLiteral_return objectLiteral424 = null;

        functionDefinition_return functionDefinition425 = null;

        newFullExpression_return newFullExpression426 = null;

        newShortExpression_return newShortExpression427 = null;

        encapsulatedExpression_return encapsulatedExpression428 = null;

        e4xAttributeIdentifier_return e4xAttributeIdentifier429 = null;

        qualifiedIdent_return qualifiedIdent430 = null;
        
        
        CommonTree UNDEFINED421_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 125) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:976:4: ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
            int alt107 = 10;
            switch ( input.LA(1) ) 
            {
            case UNDEFINED:
            	{
                alt107 = 1;
                }
                break;
            case STRING_LITERAL:
            case LT:
            case DIV:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt107 = 2;
                }
                break;
            case LBRACK:
            	{
                alt107 = 3;
                }
                break;
            case LCURLY:
            	{
                alt107 = 4;
                }
                break;
            case FUNCTION:
            	{
                alt107 = 5;
                }
                break;
            case NEW:
            	{
                switch ( input.LA(2) ) 
                {
                case UNDEFINED:
                	{
                    int LA107_25 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s25 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 25, input);
                    
                        throw nvae_d107s25;
                    }
                    }
                    break;
                case LT:
                	{
                    int LA107_26 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s26 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 26, input);
                    
                        throw nvae_d107s26;
                    }
                    }
                    break;
                case DIV:
                	{
                    int LA107_27 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s27 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 27, input);
                    
                        throw nvae_d107s27;
                    }
                    }
                    break;
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOAT_LITERAL:
                	{
                    int LA107_28 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s28 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 28, input);
                    
                        throw nvae_d107s28;
                    }
                    }
                    break;
                case STRING_LITERAL:
                	{
                    int LA107_29 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s29 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 29, input);
                    
                        throw nvae_d107s29;
                    }
                    }
                    break;
                case TRUE:
                	{
                    int LA107_30 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s30 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 30, input);
                    
                        throw nvae_d107s30;
                    }
                    }
                    break;
                case FALSE:
                	{
                    int LA107_31 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s31 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 31, input);
                    
                        throw nvae_d107s31;
                    }
                    }
                    break;
                case NULL:
                	{
                    int LA107_32 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s32 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 32, input);
                    
                        throw nvae_d107s32;
                    }
                    }
                    break;
                case LBRACK:
                	{
                    int LA107_33 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s33 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 33, input);
                    
                        throw nvae_d107s33;
                    }
                    }
                    break;
                case LCURLY:
                	{
                    int LA107_34 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s34 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 34, input);
                    
                        throw nvae_d107s34;
                    }
                    }
                    break;
                case FUNCTION:
                	{
                    int LA107_35 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s35 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 35, input);
                    
                        throw nvae_d107s35;
                    }
                    }
                    break;
                case NEW:
                	{
                    int LA107_36 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s36 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 36, input);
                    
                        throw nvae_d107s36;
                    }
                    }
                    break;
                case LPAREN:
                	{
                    int LA107_37 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s37 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 37, input);
                    
                        throw nvae_d107s37;
                    }
                    }
                    break;
                case E4X_ATTRI:
                	{
                    int LA107_38 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s38 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 38, input);
                    
                        throw nvae_d107s38;
                    }
                    }
                    break;
                case IDENT:
                	{
                    int LA107_39 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s39 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 39, input);
                    
                        throw nvae_d107s39;
                    }
                    }
                    break;
                case PUBLIC:
                case PRIVATE:
                case PROTECTED:
                case INTERNAL:
                	{
                    int LA107_40 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s40 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 40, input);
                    
                        throw nvae_d107s40;
                    }
                    }
                    break;
                case USE:
                	{
                    int LA107_41 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s41 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 41, input);
                    
                        throw nvae_d107s41;
                    }
                    }
                    break;
                case XML:
                	{
                    int LA107_42 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s42 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 42, input);
                    
                        throw nvae_d107s42;
                    }
                    }
                    break;
                case DYNAMIC:
                	{
                    int LA107_43 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s43 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 43, input);
                    
                        throw nvae_d107s43;
                    }
                    }
                    break;
                case NAMESPACE:
                	{
                    int LA107_44 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s44 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 44, input);
                    
                        throw nvae_d107s44;
                    }
                    }
                    break;
                case IS:
                	{
                    int LA107_45 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s45 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 45, input);
                    
                        throw nvae_d107s45;
                    }
                    }
                    break;
                case AS:
                	{
                    int LA107_46 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s46 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 46, input);
                    
                        throw nvae_d107s46;
                    }
                    }
                    break;
                case GET:
                	{
                    int LA107_47 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s47 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 47, input);
                    
                        throw nvae_d107s47;
                    }
                    }
                    break;
                case SET:
                	{
                    int LA107_48 = input.LA(3);
                    
                    if ( (synpred198()) )
                    {
                        alt107 = 6;
                    }
                    else if ( (synpred199()) )
                    {
                        alt107 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d107s48 =
                            new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 48, input);
                    
                        throw nvae_d107s48;
                    }
                    }
                    break;
                	default:
                	    if ( backtracking > 0 ) {failed = true; return retval;}
                	    NoViableAltException nvae_d107s12 =
                	        new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 12, input);
                
                	    throw nvae_d107s12;
                }
            
                }
                break;
            case LPAREN:
            	{
                alt107 = 8;
                }
                break;
            case E4X_ATTRI:
            	{
                alt107 = 9;
                }
                break;
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case DYNAMIC:
            case IS:
            case AS:
            	{
                alt107 = 10;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d107s0 =
            	        new NoViableAltException("975:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 107, 0, input);
            
            	    throw nvae_d107s0;
            }
            
            switch (alt107) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:976:4: UNDEFINED
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	UNDEFINED421 = (IToken)input.LT(1);
                    	Match(input,UNDEFINED,FOLLOW_UNDEFINED_in_primaryExpression4455); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	UNDEFINED421_tree = (CommonTree)adaptor.Create(UNDEFINED421);
                    	adaptor.AddChild(root_0, UNDEFINED421_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:977:4: constant
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_constant_in_primaryExpression4460);
                    	constant422 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, constant422.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:978:4: arrayLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_arrayLiteral_in_primaryExpression4465);
                    	arrayLiteral423 = arrayLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, arrayLiteral423.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:979:4: objectLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_objectLiteral_in_primaryExpression4470);
                    	objectLiteral424 = objectLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, objectLiteral424.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:980:4: functionDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_functionDefinition_in_primaryExpression4475);
                    	functionDefinition425 = functionDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, functionDefinition425.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:981:4: newFullExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newFullExpression_in_primaryExpression4480);
                    	newFullExpression426 = newFullExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newFullExpression426.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:982:4: newShortExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newShortExpression_in_primaryExpression4485);
                    	newShortExpression427 = newShortExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newShortExpression427.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:983:4: encapsulatedExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_encapsulatedExpression_in_primaryExpression4490);
                    	encapsulatedExpression428 = encapsulatedExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, encapsulatedExpression428.Tree);
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:984:4: e4xAttributeIdentifier
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xAttributeIdentifier_in_primaryExpression4495);
                    	e4xAttributeIdentifier429 = e4xAttributeIdentifier();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xAttributeIdentifier429.Tree);
                    
                    }
                    break;
                case 10 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:985:4: qualifiedIdent
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_qualifiedIdent_in_primaryExpression4500);
                    	qualifiedIdent430 = qualifiedIdent();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent430.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 125, primaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end primaryExpression

    public class propOrIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start propOrIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:989:1: propOrIdent[CommonTree identPrimary, IToken startToken] : DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) ;
    public propOrIdent_return propOrIdent(CommonTree identPrimary, IToken startToken) // throws RecognitionException [1]
    {   
        propOrIdent_return retval = new propOrIdent_return();
        retval.start = input.LT(1);
        int propOrIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT431 = null;
        qualifiedIdent_return propId = null;
        
        
        CommonTree DOT431_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 126) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:991:3: ( DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:991:3: DOT propId= qualifiedIdent
            {
            	if ( backtracking == 0 ) 
            	{
            	   retval.start = startToken; 
            	}
            	DOT431 = (IToken)input.LT(1);
            	Match(input,DOT,FOLLOW_DOT_in_propOrIdent4520); if (failed) return retval;
            	if ( backtracking==0 ) stream_DOT.Add(DOT431);

            	PushFollow(FOLLOW_qualifiedIdent_in_propOrIdent4524);
            	propId = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(propId.Tree);
            	
            	// AST REWRITE
            	// elements:          propId
            	// token labels:      
            	// rule labels:       propId, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_propId = new RewriteRuleSubtreeStream(adaptor, "token propId", (propId!=null ? propId.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 998:3: -> ^( PROPERTY_OR_IDENTIFIER $propId)
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:6: ^( PROPERTY_OR_IDENTIFIER $propId)
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PROPERTY_OR_IDENTIFIER, "PROPERTY_OR_IDENTIFIER"), root_1);
            	    
            	    adaptor.AddChild(root_1, identPrimary);
            	    adaptor.AddChild(root_1, stream_propId.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 126, propOrIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end propOrIdent

    public class constant_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start constant
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1001:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );
    public constant_return constant() // throws RecognitionException [1]
    {   
        constant_return retval = new constant_return();
        retval.start = input.LT(1);
        int constant_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STRING_LITERAL435 = null;
        IToken TRUE436 = null;
        IToken FALSE437 = null;
        IToken NULL438 = null;
        xmlLiteral_return xmlLiteral432 = null;

        regexpLiteral_return regexpLiteral433 = null;

        number_return number434 = null;
        
        
        CommonTree STRING_LITERAL435_tree=null;
        CommonTree TRUE436_tree=null;
        CommonTree FALSE437_tree=null;
        CommonTree NULL438_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 127) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1002:4: ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL )
            int alt108 = 7;
            switch ( input.LA(1) ) 
            {
            case LT:
            	{
                alt108 = 1;
                }
                break;
            case DIV:
            	{
                alt108 = 2;
                }
                break;
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt108 = 3;
                }
                break;
            case STRING_LITERAL:
            	{
                alt108 = 4;
                }
                break;
            case TRUE:
            	{
                alt108 = 5;
                }
                break;
            case FALSE:
            	{
                alt108 = 6;
                }
                break;
            case NULL:
            	{
                alt108 = 7;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d108s0 =
            	        new NoViableAltException("1001:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );", 108, 0, input);
            
            	    throw nvae_d108s0;
            }
            
            switch (alt108) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1002:4: xmlLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_xmlLiteral_in_constant4552);
                    	xmlLiteral432 = xmlLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, xmlLiteral432.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1003:4: regexpLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_regexpLiteral_in_constant4557);
                    	regexpLiteral433 = regexpLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, regexpLiteral433.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1004:4: number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_constant4562);
                    	number434 = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, number434.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1005:4: STRING_LITERAL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STRING_LITERAL435 = (IToken)input.LT(1);
                    	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_constant4567); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STRING_LITERAL435_tree = (CommonTree)adaptor.Create(STRING_LITERAL435);
                    	adaptor.AddChild(root_0, STRING_LITERAL435_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:4: TRUE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	TRUE436 = (IToken)input.LT(1);
                    	Match(input,TRUE,FOLLOW_TRUE_in_constant4572); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	TRUE436_tree = (CommonTree)adaptor.Create(TRUE436);
                    	adaptor.AddChild(root_0, TRUE436_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:4: FALSE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	FALSE437 = (IToken)input.LT(1);
                    	Match(input,FALSE,FOLLOW_FALSE_in_constant4577); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	FALSE437_tree = (CommonTree)adaptor.Create(FALSE437);
                    	adaptor.AddChild(root_0, FALSE437_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1008:4: NULL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	NULL438 = (IToken)input.LT(1);
                    	Match(input,NULL,FOLLOW_NULL_in_constant4582); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	NULL438_tree = (CommonTree)adaptor.Create(NULL438);
                    	adaptor.AddChild(root_0, NULL438_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 127, constant_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end constant

    public class number_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start number
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1011:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
    public number_return number() // throws RecognitionException [1]
    {   
        number_return retval = new number_return();
        retval.start = input.LT(1);
        int number_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set439 = null;
        
        CommonTree set439_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 128) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1011:10: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set439 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= HEX_LITERAL && input.LA(1) <= FLOAT_LITERAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set439));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_number0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 128, number_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end number

    public class xmlLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start xmlLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1018:1: xmlLiteral : LT ->;
    public xmlLiteral_return xmlLiteral() // throws RecognitionException [1]
    {   
        xmlLiteral_return retval = new xmlLiteral_return();
        retval.start = input.LT(1);
        int xmlLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LT440 = null;
        
        CommonTree LT440_tree=null;
        RewriteRuleTokenStream stream_LT = new RewriteRuleTokenStream(adaptor,"token LT");
    
        
        		CommonTree xml = null;
        	
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 129) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1025:3: ( LT ->)
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1025:3: LT
            {
            	LT440 = (IToken)input.LT(1);
            	Match(input,LT,FOLLOW_LT_in_xmlLiteral4635); if (failed) return retval;
            	if ( backtracking==0 ) stream_LT.Add(LT440);

            	if ( backtracking == 0 ) 
            	{
            	   /*xml=parseXMLLiteral();*/ 
            	}
            	
            	// AST REWRITE
            	// elements:          
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1027:3: ->
            	{
            	    adaptor.AddChild(root_0, xml);
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 129, xmlLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end xmlLiteral

    public class regexpLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start regexpLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1031:1: regexpLiteral : s= DIV -> ^() ;
    public regexpLiteral_return regexpLiteral() // throws RecognitionException [1]
    {   
        regexpLiteral_return retval = new regexpLiteral_return();
        retval.start = input.LT(1);
        int regexpLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken s = null;
        
        CommonTree s_tree=null;
        RewriteRuleTokenStream stream_DIV = new RewriteRuleTokenStream(adaptor,"token DIV");
    
        
        		CommonTree regexp = null;
        	
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 130) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:4: (s= DIV -> ^() )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:4: s= DIV
            {
            	s = (IToken)input.LT(1);
            	Match(input,DIV,FOLLOW_DIV_in_regexpLiteral4665); if (failed) return retval;
            	if ( backtracking==0 ) stream_DIV.Add(s);

            	if ( backtracking == 0 ) 
            	{
            	   /*regexp=parseRegexpLiteral((LinkedListToken)s);*/ 
            	}
            	
            	// AST REWRITE
            	// elements:          
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1036:3: -> ^()
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1036:6: ^()
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(regexp, root_1);
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 130, regexpLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end regexpLiteral

    public class newFullExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start newFullExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1039:1: newFullExpression : NEW fullNewSubexpression arguments ;
    public newFullExpression_return newFullExpression() // throws RecognitionException [1]
    {   
        newFullExpression_return retval = new newFullExpression_return();
        retval.start = input.LT(1);
        int newFullExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NEW441 = null;
        fullNewSubexpression_return fullNewSubexpression442 = null;

        arguments_return arguments443 = null;
        
        
        CommonTree NEW441_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 131) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1040:4: ( NEW fullNewSubexpression arguments )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1040:4: NEW fullNewSubexpression arguments
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	NEW441 = (IToken)input.LT(1);
            	Match(input,NEW,FOLLOW_NEW_in_newFullExpression4686); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NEW441_tree = (CommonTree)adaptor.Create(NEW441);
            	root_0 = (CommonTree)adaptor.BecomeRoot(NEW441_tree, root_0);
            	}
            	PushFollow(FOLLOW_fullNewSubexpression_in_newFullExpression4689);
            	fullNewSubexpression442 = fullNewSubexpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, fullNewSubexpression442.Tree);
            	PushFollow(FOLLOW_arguments_in_newFullExpression4691);
            	arguments443 = arguments();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, arguments443.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 131, newFullExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end newFullExpression

    public class fullNewSubexpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fullNewSubexpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1043:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
    public fullNewSubexpression_return fullNewSubexpression() // throws RecognitionException [1]
    {   
        fullNewSubexpression_return retval = new fullNewSubexpression_return();
        retval.start = input.LT(1);
        int fullNewSubexpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT445 = null;
        primaryExpression_return primaryExpression444 = null;

        qualifiedIdent_return qualifiedIdent446 = null;

        brackets_return brackets447 = null;
        
        
        CommonTree DOT445_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_brackets = new RewriteRuleSubtreeStream(adaptor,"rule brackets");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 132) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:4: ( ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:4: ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:6: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_fullNewSubexpression4704);
            		primaryExpression444 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression444.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 1044:24: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:3: ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            	do 
            	{
            	    int alt109 = 3;
            	    int LA109_0 = input.LA(1);
            	    
            	    if ( (LA109_0 == DOT) )
            	    {
            	        int LA109_2 = input.LA(2);
            	        
            	        if ( (synpred211()) )
            	        {
            	            alt109 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA109_0 == LBRACK) )
            	    {
            	        int LA109_3 = input.LA(2);
            	        
            	        if ( (synpred212()) )
            	        {
            	            alt109 = 2;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt109) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:5: DOT qualifiedIdent
            			    {
            			    	DOT445 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_fullNewSubexpression4718); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT445);

            			    	PushFollow(FOLLOW_qualifiedIdent_in_fullNewSubexpression4720);
            			    	qualifiedIdent446 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent446.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          DOT, qualifiedIdent, fullNewSubexpression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1046:24: -> ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:27: ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DOT.Next(), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1047:5: brackets
            			    {
            			    	PushFollow(FOLLOW_brackets_in_fullNewSubexpression4737);
            			    	brackets447 = brackets();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_brackets.Add(brackets447.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          fullNewSubexpression, brackets
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1047:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1047:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_brackets.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop109;
            	    }
            	} while (true);
            	
            	loop109:
            		;	// Stops C# compiler whinging that label 'loop109' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 132, fullNewSubexpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fullNewSubexpression

    public class newShortExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start newShortExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:1: newShortExpression : NEW shortNewSubexpression ;
    public newShortExpression_return newShortExpression() // throws RecognitionException [1]
    {   
        newShortExpression_return retval = new newShortExpression_return();
        retval.start = input.LT(1);
        int newShortExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NEW448 = null;
        shortNewSubexpression_return shortNewSubexpression449 = null;
        
        
        CommonTree NEW448_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 133) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1052:4: ( NEW shortNewSubexpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1052:4: NEW shortNewSubexpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	NEW448 = (IToken)input.LT(1);
            	Match(input,NEW,FOLLOW_NEW_in_newShortExpression4765); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NEW448_tree = (CommonTree)adaptor.Create(NEW448);
            	root_0 = (CommonTree)adaptor.BecomeRoot(NEW448_tree, root_0);
            	}
            	PushFollow(FOLLOW_shortNewSubexpression_in_newShortExpression4768);
            	shortNewSubexpression449 = shortNewSubexpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, shortNewSubexpression449.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 133, newShortExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end newShortExpression

    public class shortNewSubexpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shortNewSubexpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );
    public shortNewSubexpression_return shortNewSubexpression() // throws RecognitionException [1]
    {   
        shortNewSubexpression_return retval = new shortNewSubexpression_return();
        retval.start = input.LT(1);
        int shortNewSubexpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        fullNewSubexpression_return fullNewSubexpression450 = null;

        newShortExpression_return newShortExpression451 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 134) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: ( fullNewSubexpression | newShortExpression )
            int alt110 = 2;
            int LA110_0 = input.LA(1);
            
            if ( (LA110_0 == LCURLY || (LA110_0 >= STRING_LITERAL && LA110_0 <= USE) || LA110_0 == LPAREN || LA110_0 == XML || (LA110_0 >= IDENT && LA110_0 <= LBRACK) || LA110_0 == DYNAMIC || LA110_0 == LT || (LA110_0 >= IS && LA110_0 <= AS) || LA110_0 == DIV || (LA110_0 >= E4X_ATTRI && LA110_0 <= FLOAT_LITERAL)) )
            {
                alt110 = 1;
            }
            else if ( (LA110_0 == NEW) )
            {
                switch ( input.LA(2) ) 
                {
                case UNDEFINED:
                	{
                    int LA110_25 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s25 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 25, input);
                    
                        throw nvae_d110s25;
                    }
                    }
                    break;
                case LT:
                	{
                    int LA110_26 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s26 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 26, input);
                    
                        throw nvae_d110s26;
                    }
                    }
                    break;
                case DIV:
                	{
                    int LA110_27 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s27 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 27, input);
                    
                        throw nvae_d110s27;
                    }
                    }
                    break;
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOAT_LITERAL:
                	{
                    int LA110_28 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s28 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 28, input);
                    
                        throw nvae_d110s28;
                    }
                    }
                    break;
                case STRING_LITERAL:
                	{
                    int LA110_29 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s29 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 29, input);
                    
                        throw nvae_d110s29;
                    }
                    }
                    break;
                case TRUE:
                	{
                    int LA110_30 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s30 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 30, input);
                    
                        throw nvae_d110s30;
                    }
                    }
                    break;
                case FALSE:
                	{
                    int LA110_31 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s31 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 31, input);
                    
                        throw nvae_d110s31;
                    }
                    }
                    break;
                case NULL:
                	{
                    int LA110_32 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s32 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 32, input);
                    
                        throw nvae_d110s32;
                    }
                    }
                    break;
                case LBRACK:
                	{
                    int LA110_33 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s33 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 33, input);
                    
                        throw nvae_d110s33;
                    }
                    }
                    break;
                case LCURLY:
                	{
                    int LA110_34 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s34 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 34, input);
                    
                        throw nvae_d110s34;
                    }
                    }
                    break;
                case FUNCTION:
                	{
                    int LA110_35 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s35 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 35, input);
                    
                        throw nvae_d110s35;
                    }
                    }
                    break;
                case NEW:
                	{
                    int LA110_36 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s36 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 36, input);
                    
                        throw nvae_d110s36;
                    }
                    }
                    break;
                case LPAREN:
                	{
                    int LA110_37 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s37 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 37, input);
                    
                        throw nvae_d110s37;
                    }
                    }
                    break;
                case E4X_ATTRI:
                	{
                    int LA110_38 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s38 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 38, input);
                    
                        throw nvae_d110s38;
                    }
                    }
                    break;
                case IDENT:
                	{
                    int LA110_39 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s39 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 39, input);
                    
                        throw nvae_d110s39;
                    }
                    }
                    break;
                case PUBLIC:
                case PRIVATE:
                case PROTECTED:
                case INTERNAL:
                	{
                    int LA110_40 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s40 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 40, input);
                    
                        throw nvae_d110s40;
                    }
                    }
                    break;
                case USE:
                	{
                    int LA110_41 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s41 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 41, input);
                    
                        throw nvae_d110s41;
                    }
                    }
                    break;
                case XML:
                	{
                    int LA110_42 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s42 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 42, input);
                    
                        throw nvae_d110s42;
                    }
                    }
                    break;
                case DYNAMIC:
                	{
                    int LA110_43 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s43 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 43, input);
                    
                        throw nvae_d110s43;
                    }
                    }
                    break;
                case NAMESPACE:
                	{
                    int LA110_44 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s44 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 44, input);
                    
                        throw nvae_d110s44;
                    }
                    }
                    break;
                case IS:
                	{
                    int LA110_45 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s45 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 45, input);
                    
                        throw nvae_d110s45;
                    }
                    }
                    break;
                case AS:
                	{
                    int LA110_46 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s46 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 46, input);
                    
                        throw nvae_d110s46;
                    }
                    }
                    break;
                case GET:
                	{
                    int LA110_47 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s47 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 47, input);
                    
                        throw nvae_d110s47;
                    }
                    }
                    break;
                case SET:
                	{
                    int LA110_48 = input.LA(3);
                    
                    if ( (synpred213()) )
                    {
                        alt110 = 1;
                    }
                    else if ( (true) )
                    {
                        alt110 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d110s48 =
                            new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 48, input);
                    
                        throw nvae_d110s48;
                    }
                    }
                    break;
                	default:
                	    if ( backtracking > 0 ) {failed = true; return retval;}
                	    NoViableAltException nvae_d110s12 =
                	        new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 12, input);
                
                	    throw nvae_d110s12;
                }
            
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d110s0 =
                    new NoViableAltException("1055:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 110, 0, input);
            
                throw nvae_d110s0;
            }
            switch (alt110) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: fullNewSubexpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_fullNewSubexpression_in_shortNewSubexpression4781);
                    	fullNewSubexpression450 = fullNewSubexpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, fullNewSubexpression450.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1057:4: newShortExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newShortExpression_in_shortNewSubexpression4786);
                    	newShortExpression451 = newShortExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newShortExpression451.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 134, shortNewSubexpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shortNewSubexpression

    public class propertyOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start propertyOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1060:1: propertyOperator : ( DOT qualifiedIdent | brackets );
    public propertyOperator_return propertyOperator() // throws RecognitionException [1]
    {   
        propertyOperator_return retval = new propertyOperator_return();
        retval.start = input.LT(1);
        int propertyOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT452 = null;
        qualifiedIdent_return qualifiedIdent453 = null;

        brackets_return brackets454 = null;
        
        
        CommonTree DOT452_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 135) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1061:4: ( DOT qualifiedIdent | brackets )
            int alt111 = 2;
            int LA111_0 = input.LA(1);
            
            if ( (LA111_0 == DOT) )
            {
                alt111 = 1;
            }
            else if ( (LA111_0 == LBRACK) )
            {
                alt111 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d111s0 =
                    new NoViableAltException("1060:1: propertyOperator : ( DOT qualifiedIdent | brackets );", 111, 0, input);
            
                throw nvae_d111s0;
            }
            switch (alt111) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1061:4: DOT qualifiedIdent
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	DOT452 = (IToken)input.LT(1);
                    	Match(input,DOT,FOLLOW_DOT_in_propertyOperator4798); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	DOT452_tree = (CommonTree)adaptor.Create(DOT452);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(DOT452_tree, root_0);
                    	}
                    	PushFollow(FOLLOW_qualifiedIdent_in_propertyOperator4801);
                    	qualifiedIdent453 = qualifiedIdent();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent453.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1062:4: brackets
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_brackets_in_propertyOperator4806);
                    	brackets454 = brackets();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, brackets454.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 135, propertyOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end propertyOperator

    public class commentExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start commentExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1066:1: commentExpression : comment -> ^( COMMENT_LIST comment ) ;
    public commentExpression_return commentExpression() // throws RecognitionException [1]
    {   
        commentExpression_return retval = new commentExpression_return();
        retval.start = input.LT(1);
        int commentExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        comment_return comment455 = null;
        
        
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 136) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:4: ( comment -> ^( COMMENT_LIST comment ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:4: comment
            {
            	PushFollow(FOLLOW_comment_in_commentExpression4818);
            	comment455 = comment();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_comment.Add(comment455.Tree);
            	
            	// AST REWRITE
            	// elements:          comment
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1067:12: -> ^( COMMENT_LIST comment )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:15: ^( COMMENT_LIST comment )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_LIST, "COMMENT_LIST"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_comment.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 136, commentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end commentExpression

    public class comment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start comment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1070:1: comment : ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) );
    public comment_return comment() // throws RecognitionException [1]
    {   
        comment_return retval = new comment_return();
        retval.start = input.LT(1);
        int comment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        singleLineComment_return singleLineComment456 = null;

        comment_return comment457 = null;

        multilineComment_return multilineComment458 = null;

        comment_return comment459 = null;
        
        
        RewriteRuleSubtreeStream stream_multilineComment = new RewriteRuleSubtreeStream(adaptor,"rule multilineComment");
        RewriteRuleSubtreeStream stream_singleLineComment = new RewriteRuleSubtreeStream(adaptor,"rule singleLineComment");
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 137) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:4: ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) )
            int alt114 = 2;
            int LA114_0 = input.LA(1);
            
            if ( (LA114_0 == SL_COMMENT) )
            {
                alt114 = 1;
            }
            else if ( (LA114_0 == ML_COMMENT) )
            {
                alt114 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d114s0 =
                    new NoViableAltException("1070:1: comment : ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) );", 114, 0, input);
            
                throw nvae_d114s0;
            }
            switch (alt114) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:4: singleLineComment ( comment )*
                    {
                    	PushFollow(FOLLOW_singleLineComment_in_comment4837);
                    	singleLineComment456 = singleLineComment();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_singleLineComment.Add(singleLineComment456.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:22: ( comment )*
                    	do 
                    	{
                    	    int alt112 = 2;
                    	    int LA112_0 = input.LA(1);
                    	    
                    	    if ( (LA112_0 == SL_COMMENT) )
                    	    {
                    	        int LA112_4 = input.LA(2);
                    	        
                    	        if ( (synpred215()) )
                    	        {
                    	            alt112 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA112_0 == ML_COMMENT) )
                    	    {
                    	        int LA112_5 = input.LA(2);
                    	        
                    	        if ( (synpred215()) )
                    	        {
                    	            alt112 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt112) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment4839);
                    			    	comment457 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment457.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop112;
                    	    }
                    	} while (true);
                    	
                    	loop112:
                    		;	// Stops C# compiler whinging that label 'loop112' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          comment, singleLineComment
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1071:31: -> ^( COMMENT_ENTRY singleLineComment ( comment )* )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:34: ^( COMMENT_ENTRY singleLineComment ( comment )* )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_singleLineComment.Next());
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:68: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_1, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:4: multilineComment ( comment )*
                    {
                    	PushFollow(FOLLOW_multilineComment_in_comment4856);
                    	multilineComment458 = multilineComment();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_multilineComment.Add(multilineComment458.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:21: ( comment )*
                    	do 
                    	{
                    	    int alt113 = 2;
                    	    int LA113_0 = input.LA(1);
                    	    
                    	    if ( (LA113_0 == SL_COMMENT) )
                    	    {
                    	        int LA113_4 = input.LA(2);
                    	        
                    	        if ( (synpred217()) )
                    	        {
                    	            alt113 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA113_0 == ML_COMMENT) )
                    	    {
                    	        int LA113_5 = input.LA(2);
                    	        
                    	        if ( (synpred217()) )
                    	        {
                    	            alt113 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt113) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment4858);
                    			    	comment459 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment459.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop113;
                    	    }
                    	} while (true);
                    	
                    	loop113:
                    		;	// Stops C# compiler whinging that label 'loop113' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          comment, multilineComment
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1072:30: -> ^( COMMENT_ENTRY multilineComment ( comment )* )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:33: ^( COMMENT_ENTRY multilineComment ( comment )* )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_multilineComment.Next());
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:66: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_1, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 137, comment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end comment

    public class singleLineComment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start singleLineComment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1075:1: singleLineComment : SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) ;
    public singleLineComment_return singleLineComment() // throws RecognitionException [1]
    {   
        singleLineComment_return retval = new singleLineComment_return();
        retval.start = input.LT(1);
        int singleLineComment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SL_COMMENT460 = null;
        
        CommonTree SL_COMMENT460_tree=null;
        RewriteRuleTokenStream stream_SL_COMMENT = new RewriteRuleTokenStream(adaptor,"token SL_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 138) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1076:4: ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1076:4: SL_COMMENT
            {
            	SL_COMMENT460 = (IToken)input.LT(1);
            	Match(input,SL_COMMENT,FOLLOW_SL_COMMENT_in_singleLineComment4881); if (failed) return retval;
            	if ( backtracking==0 ) stream_SL_COMMENT.Add(SL_COMMENT460);

            	
            	// AST REWRITE
            	// elements:          SL_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1076:15: -> ^( SINGLELINE_COMMENT SL_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1076:18: ^( SINGLELINE_COMMENT SL_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SINGLELINE_COMMENT, "SINGLELINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_SL_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 138, singleLineComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end singleLineComment

    public class multilineComment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multilineComment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1079:1: multilineComment : ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) ;
    public multilineComment_return multilineComment() // throws RecognitionException [1]
    {   
        multilineComment_return retval = new multilineComment_return();
        retval.start = input.LT(1);
        int multilineComment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ML_COMMENT461 = null;
        
        CommonTree ML_COMMENT461_tree=null;
        RewriteRuleTokenStream stream_ML_COMMENT = new RewriteRuleTokenStream(adaptor,"token ML_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 139) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1080:4: ( ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1080:4: ML_COMMENT
            {
            	ML_COMMENT461 = (IToken)input.LT(1);
            	Match(input,ML_COMMENT,FOLLOW_ML_COMMENT_in_multilineComment4901); if (failed) return retval;
            	if ( backtracking==0 ) stream_ML_COMMENT.Add(ML_COMMENT461);

            	
            	// AST REWRITE
            	// elements:          ML_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1080:15: -> ^( MULTILINE_COMMENT ML_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1080:18: ^( MULTILINE_COMMENT ML_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MULTILINE_COMMENT, "MULTILINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ML_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 139, multilineComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multilineComment

    public class brackets_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start brackets
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1084:1: brackets : LBRACK expressionList RBRACK ;
    public brackets_return brackets() // throws RecognitionException [1]
    {   
        brackets_return retval = new brackets_return();
        retval.start = input.LT(1);
        int brackets_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK462 = null;
        IToken RBRACK464 = null;
        expressionList_return expressionList463 = null;
        
        
        CommonTree LBRACK462_tree=null;
        CommonTree RBRACK464_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 140) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1088:4: ( LBRACK expressionList RBRACK )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1088:4: LBRACK expressionList RBRACK
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	LBRACK462 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_brackets4926); if (failed) return retval;
            	if ( backtracking==0 ) {
            	LBRACK462_tree = (CommonTree)adaptor.Create(LBRACK462);
            	adaptor.AddChild(root_0, LBRACK462_tree);
            	}
            	PushFollow(FOLLOW_expressionList_in_brackets4928);
            	expressionList463 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList463.Tree);
            	RBRACK464 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_brackets4930); if (failed) return retval;
            	if ( backtracking==0 ) {
            	RBRACK464_tree = (CommonTree)adaptor.Create(RBRACK464);
            	adaptor.AddChild(root_0, RBRACK464_tree);
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 140, brackets_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end brackets

    public class encapsulatedExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start encapsulatedExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1091:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
    public encapsulatedExpression_return encapsulatedExpression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        encapsulatedExpression_return retval = new encapsulatedExpression_return();
        retval.start = input.LT(1);
        int encapsulatedExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN465 = null;
        IToken RPAREN467 = null;
        assignmentExpression_return assignmentExpression466 = null;
        
        
        CommonTree LPAREN465_tree=null;
        CommonTree RPAREN467_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 141) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1096:4: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1096:4: LPAREN assignmentExpression RPAREN
            {
            	LPAREN465 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_encapsulatedExpression4951); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN465);

            	PushFollow(FOLLOW_assignmentExpression_in_encapsulatedExpression4953);
            	assignmentExpression466 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression466.Tree);
            	RPAREN467 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_encapsulatedExpression4955); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN467);

            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1097:3: -> ^( ENCPS_EXPR assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1097:6: ^( ENCPS_EXPR assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 141, encapsulatedExpression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end encapsulatedExpression

    public class functionDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start functionDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1103:1: functionDefinition : FUNCTION ( ident )? parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF ( ident )? parameterDeclarationList ( typeExpression )? block ) ;
    public functionDefinition_return functionDefinition() // throws RecognitionException [1]
    {   
        functionDefinition_return retval = new functionDefinition_return();
        retval.start = input.LT(1);
        int functionDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken FUNCTION468 = null;
        ident_return ident469 = null;

        parameterDeclarationList_return parameterDeclarationList470 = null;

        typeExpression_return typeExpression471 = null;

        block_return block472 = null;
        
        
        CommonTree FUNCTION468_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 142) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1104:4: ( FUNCTION ( ident )? parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF ( ident )? parameterDeclarationList ( typeExpression )? block ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1104:4: FUNCTION ( ident )? parameterDeclarationList ( typeExpression )? block
            {
            	FUNCTION468 = (IToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionDefinition4979); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION468);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1104:13: ( ident )?
            	int alt115 = 2;
            	int LA115_0 = input.LA(1);
            	
            	if ( ((LA115_0 >= GET && LA115_0 <= USE) || LA115_0 == XML || LA115_0 == IDENT || LA115_0 == DYNAMIC || (LA115_0 >= IS && LA115_0 <= AS)) )
            	{
            	    alt115 = 1;
            	}
            	switch (alt115) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: ident
            	        {
            	        	PushFollow(FOLLOW_ident_in_functionDefinition4981);
            	        	ident469 = ident();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_ident.Add(ident469.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_parameterDeclarationList_in_functionDefinition4984);
            	parameterDeclarationList470 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList470.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1104:45: ( typeExpression )?
            	int alt116 = 2;
            	int LA116_0 = input.LA(1);
            	
            	if ( (LA116_0 == COLON) )
            	{
            	    alt116 = 1;
            	}
            	switch (alt116) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_functionDefinition4986);
            	        	typeExpression471 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression471.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_block_in_functionDefinition4989);
            	block472 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_block.Add(block472.Tree);
            	
            	// AST REWRITE
            	// elements:          parameterDeclarationList, block, typeExpression, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1105:3: -> ^( FUNC_DEF ( ident )? parameterDeclarationList ( typeExpression )? block )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1105:6: ^( FUNC_DEF ( ident )? parameterDeclarationList ( typeExpression )? block )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1105:17: ( ident )?
            	    if ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1105:49: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 142, functionDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end functionDefinition

    public class ident_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ident
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1109:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );
    public ident_return ident() // throws RecognitionException [1]
    {   
        ident_return retval = new ident_return();
        retval.start = input.LT(1);
        int ident_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken i = null;
        IToken IDENT473 = null;
        
        CommonTree i_tree=null;
        CommonTree IDENT473_tree=null;
        RewriteRuleTokenStream stream_GET = new RewriteRuleTokenStream(adaptor,"token GET");
        RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor,"token XML");
        RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor,"token AS");
        RewriteRuleTokenStream stream_DYNAMIC = new RewriteRuleTokenStream(adaptor,"token DYNAMIC");
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor,"token SET");
        RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor,"token IS");
        RewriteRuleTokenStream stream_USE = new RewriteRuleTokenStream(adaptor,"token USE");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 143) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1110:4: ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] )
            int alt117 = 9;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                alt117 = 1;
                }
                break;
            case USE:
            	{
                alt117 = 2;
                }
                break;
            case XML:
            	{
                alt117 = 3;
                }
                break;
            case DYNAMIC:
            	{
                alt117 = 4;
                }
                break;
            case NAMESPACE:
            	{
                alt117 = 5;
                }
                break;
            case IS:
            	{
                alt117 = 6;
                }
                break;
            case AS:
            	{
                alt117 = 7;
                }
                break;
            case GET:
            	{
                alt117 = 8;
                }
                break;
            case SET:
            	{
                alt117 = 9;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d117s0 =
            	        new NoViableAltException("1109:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );", 117, 0, input);
            
            	    throw nvae_d117s0;
            }
            
            switch (alt117) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1110:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT473 = (IToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_ident5019); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT473_tree = (CommonTree)adaptor.Create(IDENT473);
                    	adaptor.AddChild(root_0, IDENT473_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1111:4: i= USE
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,USE,FOLLOW_USE_in_ident5026); if (failed) return retval;
                    	if ( backtracking==0 ) stream_USE.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1111:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1112:4: i= XML
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,XML,FOLLOW_XML_in_ident5038); if (failed) return retval;
                    	if ( backtracking==0 ) stream_XML.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1112:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1113:4: i= DYNAMIC
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_ident5050); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DYNAMIC.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1113:14: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1114:4: i= NAMESPACE
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_ident5062); if (failed) return retval;
                    	if ( backtracking==0 ) stream_NAMESPACE.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1114:16: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1115:4: i= IS
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_ident5074); if (failed) return retval;
                    	if ( backtracking==0 ) stream_IS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1115:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1116:4: i= AS
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_ident5086); if (failed) return retval;
                    	if ( backtracking==0 ) stream_AS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1116:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1117:4: i= GET
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,GET,FOLLOW_GET_in_ident5098); if (failed) return retval;
                    	if ( backtracking==0 ) stream_GET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1117:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1118:4: i= SET
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,SET,FOLLOW_SET_in_ident5110); if (failed) return retval;
                    	if ( backtracking==0 ) stream_SET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1118:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 143, ident_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ident

    // $ANTLR start synpred1
    public void synpred1_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:4: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred1393);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred1

    // $ANTLR start synpred20
    public void synpred20_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: ( SEMI )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: SEMI
        {
        	Match(input,SEMI,FOLLOW_SEMI_in_synpred20664); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred20

    // $ANTLR start synpred38
    public void synpred38_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:264:3: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:264:3: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred381151);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred38

    // $ANTLR start synpred40
    public void synpred40_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:280:3: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:280:3: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred401255);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred40

    // $ANTLR start synpred57
    public void synpred57_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:393:4: ( LCURLY )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:393:5: LCURLY
        {
        	Match(input,LCURLY,FOLLOW_LCURLY_in_synpred571796); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred57

    // $ANTLR start synpred59
    public void synpred59_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:395:4: ( expressionStatement )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:395:4: expressionStatement
        {
        	PushFollow(FOLLOW_expressionStatement_in_synpred591810);
        	expressionStatement();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred59

    // $ANTLR start synpred74
    public void synpred74_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:18: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:18: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred742003);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred74

    // $ANTLR start synpred75
    public void synpred75_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:47: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:47: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred752008);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred75

    // $ANTLR start synpred76
    public void synpred76_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:4: ( ELSE )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:5: ELSE
        {
        	Match(input,ELSE,FOLLOW_ELSE_in_synpred762015); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred76

    // $ANTLR start synpred77
    public void synpred77_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:10: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:10: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred772034);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred77

    // $ANTLR start synpred81
    public void synpred81_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:12: ( expression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:12: expression
        {
        	PushFollow(FOLLOW_expression_in_synpred812131);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred81

    // $ANTLR start synpred86
    public void synpred86_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:537:5: ( forInClauseDecl IN )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:537:6: forInClauseDecl IN
        {
        	PushFollow(FOLLOW_forInClauseDecl_in_synpred862370);
        	forInClauseDecl();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,IN,FOLLOW_IN_in_synpred862372); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred86

    // $ANTLR start synpred92
    public void synpred92_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:22: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:22: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred922647);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred92

    // $ANTLR start synpred93
    public void synpred93_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:8: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:8: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred932665);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred93

    // $ANTLR start synpred94
    public void synpred94_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:55: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:605:55: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred942676);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred94

    // $ANTLR start synpred95
    public void synpred95_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:21: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:21: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred952697);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred95

    // $ANTLR start synpred106
    public void synpred106_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:6: ( annotation )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:6: annotation
        {
        	PushFollow(FOLLOW_annotation_in_synpred1062966);
        	annotation();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred106

    // $ANTLR start synpred107
    public void synpred107_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:659:5: ( includeDirective )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:659:5: includeDirective
        {
        	PushFollow(FOLLOW_includeDirective_in_synpred1072972);
        	includeDirective();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred107

    // $ANTLR start synpred125
    public void synpred125_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:26: ( COMMA assignmentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:26: COMMA assignmentExpression
        {
        	Match(input,COMMA,FOLLOW_COMMA_in_synpred1253346); if (failed) return ;
        	PushFollow(FOLLOW_assignmentExpression_in_synpred1253348);
        	assignmentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred125

    // $ANTLR start synpred131
    public void synpred131_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:4: ( assignmentOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:5: assignmentOperator
        {
        	PushFollow(FOLLOW_assignmentOperator_in_synpred1313521);
        	assignmentOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred131

    // $ANTLR start synpred157
    public void synpred157_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:4: ( relationalOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:5: relationalOperator
        {
        	PushFollow(FOLLOW_relationalOperator_in_synpred1573886);
        	relationalOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred157

    // $ANTLR start synpred168
    public void synpred168_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:4: ( additiveOperator multiplicativeExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:4: additiveOperator multiplicativeExpression
        {
        	PushFollow(FOLLOW_additiveOperator_in_synpred1683995);
        	additiveOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_multiplicativeExpression_in_synpred1683998);
        	multiplicativeExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred168

    // $ANTLR start synpred170
    public void synpred170_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:5: ( multiplicativeOperator unaryExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:5: multiplicativeOperator unaryExpression
        {
        	PushFollow(FOLLOW_multiplicativeOperator_in_synpred1704034);
        	multiplicativeOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_unaryExpression_in_synpred1704040);
        	unaryExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred170

    // $ANTLR start synpred184
    public void synpred184_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:5: ( LBRACK expression RBRACK )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:5: LBRACK expression RBRACK
        {
        	Match(input,LBRACK,FOLLOW_LBRACK_in_synpred1844274); if (failed) return ;
        	PushFollow(FOLLOW_expression_in_synpred1844276);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,RBRACK,FOLLOW_RBRACK_in_synpred1844278); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred184

    // $ANTLR start synpred186
    public void synpred186_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:947:5: ( arguments )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:947:5: arguments
        {
        	PushFollow(FOLLOW_arguments_in_synpred1864303);
        	arguments();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred186

    // $ANTLR start synpred187
    public void synpred187_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:950:6: ( INC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:950:6: INC
        {
        	Match(input,INC,FOLLOW_INC_in_synpred1874329); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred187

    // $ANTLR start synpred188
    public void synpred188_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:6: ( DEC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:6: DEC
        {
        	Match(input,DEC,FOLLOW_DEC_in_synpred1884348); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred188

    // $ANTLR start synpred198
    public void synpred198_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:981:4: ( newFullExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:981:4: newFullExpression
        {
        	PushFollow(FOLLOW_newFullExpression_in_synpred1984480);
        	newFullExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred198

    // $ANTLR start synpred199
    public void synpred199_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:982:4: ( newShortExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:982:4: newShortExpression
        {
        	PushFollow(FOLLOW_newShortExpression_in_synpred1994485);
        	newShortExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred199

    // $ANTLR start synpred211
    public void synpred211_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:5: ( DOT qualifiedIdent )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:5: DOT qualifiedIdent
        {
        	Match(input,DOT,FOLLOW_DOT_in_synpred2114718); if (failed) return ;
        	PushFollow(FOLLOW_qualifiedIdent_in_synpred2114720);
        	qualifiedIdent();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred211

    // $ANTLR start synpred212
    public void synpred212_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1047:5: ( brackets )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1047:5: brackets
        {
        	PushFollow(FOLLOW_brackets_in_synpred2124737);
        	brackets();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred212

    // $ANTLR start synpred213
    public void synpred213_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: ( fullNewSubexpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: fullNewSubexpression
        {
        	PushFollow(FOLLOW_fullNewSubexpression_in_synpred2134781);
        	fullNewSubexpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred213

    // $ANTLR start synpred215
    public void synpred215_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:22: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1071:22: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred2154839);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred215

    // $ANTLR start synpred217
    public void synpred217_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:21: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:21: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred2174858);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred217

   	public bool synpred1() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred1_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred77() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred77_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred188() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred188_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred157() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred157_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred76() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred76_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred187() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred187_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred125() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred125_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred75() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred75_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred186() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred186_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred74() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred74_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred184() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred184_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred40() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred40_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred217() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred217_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred215() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred215_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred59() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred59_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred213() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred213_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred212() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred212_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred107() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred107_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred57() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred57_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred211() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred211_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred199() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred199_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred168() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred168_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred106() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred106_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred198() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred198_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred86() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred86_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred20() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred20_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred131() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred131_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred81() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred81_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred38() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred38_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred95() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred95_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred94() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred94_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred93() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred93_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred92() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred92_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred170() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred170_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}


	private void InitializeCyclicDFAs()
	{
	}

 

    public static readonly BitSet FOLLOW_as2CompilationUnit_in_as2Program351 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as3CompilationUnit_in_as3Program371 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as2CompilationUnit393 = new BitSet(new ulong[]{0xC000000000000000UL,0x00001BF000000001UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_importDefinition_in_as2CompilationUnit399 = new BitSet(new ulong[]{0xC000000000000000UL,0x00001BF000000001UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_annotations_in_as2CompilationUnit405 = new BitSet(new ulong[]{0x8000000000000000UL,0x00001BF000000001UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as2CompilationUnit409 = new BitSet(new ulong[]{0x8000000000000000UL,0x00001BF000000001UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_as2Type_in_as2CompilationUnit415 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as2CompilationUnit419 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_as2Type433 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_as2ClassDefinition_in_as2Type439 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2InterfaceDefinition_in_as2Type445 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as3CompilationUnit463 = new BitSet(new ulong[]{0x0400000000000000UL});
    public static readonly BitSet FOLLOW_packageDecl_in_as3CompilationUnit468 = new BitSet(new ulong[]{0xE000000000000000UL,0x00001BF000001E41UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_packageBlockEntry_in_as3CompilationUnit472 = new BitSet(new ulong[]{0xE000000000000000UL,0x00001BF000001E41UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_EOF_in_as3CompilationUnit477 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PACKAGE_in_packageDecl489 = new BitSet(new ulong[]{0x0800000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_packageDecl492 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_packageBlock_in_packageDecl497 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_packageBlock508 = new BitSet(new ulong[]{0xF000000000000000UL,0x00001BF000001E41UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_packageBlockEntry_in_packageBlock512 = new BitSet(new ulong[]{0xF000000000000000UL,0x00001BF000001E41UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_packageBlock517 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_packageBlockEntry541 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_packageBlockEntry547 = new BitSet(new ulong[]{0x8000000000000000UL,0x000019F000001E41UL,0x03E0000000000000UL});
    public static readonly BitSet FOLLOW_modifiers_in_packageBlockEntry555 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000001E41UL});
    public static readonly BitSet FOLLOW_classDefinition_in_packageBlockEntry563 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceDefinition_in_packageBlockEntry571 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDefinition_in_packageBlockEntry579 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_methodDefinition_in_packageBlockEntry587 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDefinition_in_packageBlockEntry595 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_useNamespaceDirective_in_packageBlockEntry603 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_packageBlockEntry614 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_packageBlockEntry625 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EOF_in_endOfFile636 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IMPORT_in_importDefinition648 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifierStar_in_importDefinition651 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_importDefinition653 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_semi664 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_classDefinition681 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_classDefinition683 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000000000000AUL});
    public static readonly BitSet FOLLOW_classExtendsClause_in_classDefinition687 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_implementsClause_in_classDefinition691 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_classDefinition695 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_as2ClassDefinition725 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_as2ClassDefinition727 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000000000000AUL});
    public static readonly BitSet FOLLOW_classExtendsClause_in_as2ClassDefinition731 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_implementsClause_in_as2ClassDefinition735 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_as2ClassDefinition739 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDefinition774 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_interfaceDefinition776 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_interfaceDefinition780 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlock_in_interfaceDefinition784 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_as2InterfaceDefinition817 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_as2InterfaceDefinition819 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition823 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlock_in_as2InterfaceDefinition827 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_classExtendsClause855 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_classExtendsClause858 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceExtendsClause871 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause874 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_interfaceExtendsClause878 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause881 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_implementsClause896 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause899 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_implementsClause903 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause906 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceTypeBlock923 = new BitSet(new ulong[]{0x5000000000000000UL,0x00001BF000000050UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlockEntry_in_interfaceTypeBlock927 = new BitSet(new ulong[]{0x5000000000000000UL,0x00001BF000000050UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceTypeBlock932 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_typeBlock955 = new BitSet(new ulong[]{0x5000000000000000UL,0x00001BF000001850UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_typeBlockEntry_in_typeBlock959 = new BitSet(new ulong[]{0x5000000000000000UL,0x00001BF000001850UL,0x03E0801800000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_typeBlock964 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_interfaceTypeBlockEntry988 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000040UL});
    public static readonly BitSet FOLLOW_interfaceMethodDefinition_in_interfaceTypeBlockEntry999 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_interfaceTypeBlockEntry1009 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2IncludeDirective_in_interfaceTypeBlockEntry1014 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_interfaceTypeBlockEntry1019 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_interfaceTypeBlockEntry1024 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_typeBlockEntry1037 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001840UL});
    public static readonly BitSet FOLLOW_variableDefinition_in_typeBlockEntry1044 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_methodDefinition_in_typeBlockEntry1051 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_typeBlockEntry1061 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2IncludeDirective_in_typeBlockEntry1066 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_typeBlockEntry1071 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_typeBlockEntry1076 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1087 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000020UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_as2IncludeDirective1089 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_175_in_includeDirective1108 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000020UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_includeDirective1112 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_includeDirective1116 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_interfaceMethodDefinition1128 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_optionalAccessorRole_in_interfaceMethodDefinition1134 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_interfaceMethodDefinition1138 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_interfaceMethodDefinition1142 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000001000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_interfaceMethodDefinition1146 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_interfaceMethodDefinition1151 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_interfaceMethodDefinition1157 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_methodDefinition1232 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_optionalAccessorRole_in_methodDefinition1238 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_methodDefinition1242 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_methodDefinition1246 = new BitSet(new ulong[]{0x2800000000000002UL,0x0000000001000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_methodDefinition1250 = new BitSet(new ulong[]{0x2800000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_methodDefinition1255 = new BitSet(new ulong[]{0x2800000000000002UL});
    public static readonly BitSet FOLLOW_block_in_methodDefinition1261 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_methodDefinition1263 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_accessorRole_in_optionalAccessorRole1346 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_accessorRole0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDefinition1385 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_namespaceDefinition1387 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective1412 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000200UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective1414 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_useNamespaceDirective1416 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_useNamespaceDirective1418 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_variableDefinition1442 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1444 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDefinition1449 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1451 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_semi_in_variableDefinition1457 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_varOrConst0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_variableDeclarator1499 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000001002000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_variableDeclarator1502 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_variableInitializer_in_variableDeclarator1505 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_declaration1516 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declaration1519 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_declarationTail_in_declaration1523 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_declarationTail1545 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declarationTail1548 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableInitializer1561 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableInitializer1564 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_parameterDeclarationList1577 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100019780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1583 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008004UL});
    public static readonly BitSet FOLLOW_COMMA_in_parameterDeclarationList1589 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100011780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1591 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_parameterDeclarationList1602 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_basicParameterDeclaration_in_parameterDeclaration1625 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_parameterRestDeclaration_in_parameterDeclaration1629 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONST_in_basicParameterDeclaration1640 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_basicParameterDeclaration1643 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000001002000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_basicParameterDeclaration1645 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_parameterDefault_in_basicParameterDeclaration1648 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_parameterDefault1692 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_parameterDefault1695 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_REST_in_parameterRestDeclaration1706 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_parameterRestDeclaration1708 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_block1732 = new BitSet(new ulong[]{0x3800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_blockEntry_in_block1734 = new BitSet(new ulong[]{0x3800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_RCURLY_in_block1737 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_blockEntry1759 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_condition1770 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_condition1772 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_condition1774 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_statement1800 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declarationStatement_in_statement1805 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_statement1810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_statement1815 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachStatement_in_statement1822 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_statement1827 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_statement1835 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement1843 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_statement1852 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_statement1861 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_statement1870 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_statement1878 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_statement1886 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_statement1894 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_statement1903 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_defaultXMLNamespaceStatement_in_statement1912 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_statement1921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_statement1929 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_declarationStatement1951 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_declarationStatement1953 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_expressionStatement1974 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_expressionStatement1976 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IF_in_ifStatement1998 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_condition_in_ifStatement2001 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_commentExpression_in_ifStatement2003 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement2006 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_ifStatement2008 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000040000UL});
    public static readonly BitSet FOLLOW_elseClause_in_ifStatement2018 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_elseClause2031 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_commentExpression_in_elseClause2034 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_elseClause2037 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_176_in_throwStatement2048 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_throwStatement2051 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_throwStatement2053 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_177_in_tryStatement2064 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_block_in_tryStatement2068 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000C000000000000UL});
    public static readonly BitSet FOLLOW_catchBlock_in_tryStatement2072 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000C000000000000UL});
    public static readonly BitSet FOLLOW_finallyBlock_in_tryStatement2077 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_178_in_catchBlock2089 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_catchBlock2091 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_catchBlock2094 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001008000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_catchBlock2096 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_catchBlock2099 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_block_in_catchBlock2104 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_179_in_finallyBlock2115 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_block_in_finallyBlock2117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement2128 = new BitSet(new ulong[]{0x2800000000000002UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_returnStatement2131 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_returnStatement2134 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement2147 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_continueStatement2150 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement2161 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_breakStatement2164 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement2175 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_condition_in_switchStatement2179 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_switchStatement2181 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_switchBlock_in_switchStatement2187 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_switchBlock2198 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000002800000UL});
    public static readonly BitSet FOLLOW_caseStatement_in_switchBlock2203 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000002800000UL});
    public static readonly BitSet FOLLOW_defaultStatement_in_switchBlock2210 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_switchBlock2216 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CASE_in_caseStatement2241 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_caseStatement2244 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_COLON_in_caseStatement2246 = new BitSet(new ulong[]{0x2800000000000002UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_switchStatementList_in_caseStatement2251 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultStatement2263 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_COLON_in_defaultStatement2266 = new BitSet(new ulong[]{0x2800000000000002UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_switchStatementList_in_defaultStatement2271 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_switchStatementList2282 = new BitSet(new ulong[]{0x2800000000000002UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_FOR_in_forEachStatement2305 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000008000000UL});
    public static readonly BitSet FOLLOW_EACH_in_forEachStatement2307 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forEachStatement2311 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100001F80UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_forInClause_in_forEachStatement2315 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forEachStatement2319 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_forEachStatement2323 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forStatement2359 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement2363 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F100005FE0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_forInClause_in_forStatement2375 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2377 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2379 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_traditionalForClause_in_forStatement2400 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2402 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2404 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInit_in_traditionalForClause2435 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2437 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_forCond_in_traditionalForClause2445 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2447 = new BitSet(new ulong[]{0x0800000000000002UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_forIter_in_traditionalForClause2455 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_forInClause2467 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_IN_in_forInClause2469 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_forInClauseTail_in_forInClause2472 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInClauseDecl2493 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_forInClauseDecl2497 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInClauseTail2519 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInit2543 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInit2547 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forCond2585 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forIter2618 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement2641 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_condition_in_whileStatement2644 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_commentExpression_in_whileStatement2647 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_whileStatement2650 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement2662 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_commentExpression_in_doWhileStatement2665 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement2668 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement2670 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_condition_in_doWhileStatement2674 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_doWhileStatement2676 = new BitSet(new ulong[]{0x2000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_semi_in_doWhileStatement2680 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WITH_in_withStatement2691 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_condition_in_withStatement2694 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_commentExpression_in_withStatement2697 = new BitSet(new ulong[]{0x2800000000000000UL,0x000013F1E67A5FE0UL,0x0013001FFEFDC310UL});
    public static readonly BitSet FOLLOW_statement_in_withStatement2700 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2712 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000100000000UL});
    public static readonly BitSet FOLLOW_XML_in_defaultXMLNamespaceStatement2714 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000200UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2716 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2718 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_defaultXMLNamespaceStatement2720 = new BitSet(new ulong[]{0x2000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_defaultXMLNamespaceStatement2722 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COLON_in_typeExpression2745 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F300000780UL,0x0010000000000300UL});
    public static readonly BitSet FOLLOW_identifier_in_typeExpression2753 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_180_in_typeExpression2757 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_typeExpression2761 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2793 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifier2811 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2813 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL});
    public static readonly BitSet FOLLOW_namespaceName_in_qualifiedIdent2841 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000800000000UL});
    public static readonly BitSet FOLLOW_DBL_COLON_in_qualifiedIdent2843 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_qualifiedIdent2847 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_namespaceName2859 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_reservedNamespace_in_namespaceName2863 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_reservedNamespace0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar2900 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar2917 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar2919 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar2931 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000200000000UL});
    public static readonly BitSet FOLLOW_STAR_in_identifierStar2933 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_annotations2966 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_includeDirective_in_annotations2972 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020000000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_annotation2999 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_annotation3003 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000004000UL});
    public static readonly BitSet FOLLOW_annotationParamList_in_annotation3007 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_annotation3012 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_annotationParamList3038 = new BitSet(new ulong[]{0x0000000000000000UL,0x00001011000087A0UL,0x00000003F8010310UL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList3044 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008004UL});
    public static readonly BitSet FOLLOW_COMMA_in_annotationParamList3050 = new BitSet(new ulong[]{0x0000000000000000UL,0x00001011000007A0UL,0x00000003F8010310UL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList3052 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008004UL});
    public static readonly BitSet FOLLOW_RPAREN_in_annotationParamList3063 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3090 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000002000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam3092 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000020UL,0x00000003F8010010UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam3094 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam3109 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3118 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifier_in_modifiers3133 = new BitSet(new ulong[]{0x0000000000000002UL,0x000019F000000000UL,0x03E0000000000000UL});
    public static readonly BitSet FOLLOW_namespaceName_in_modifier3156 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STATIC_in_modifier3161 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_181_in_modifier3166 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_182_in_modifier3171 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_183_in_modifier3176 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_184_in_modifier3181 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_modifier3186 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_185_in_modifier3191 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3212 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expressionList_in_arguments3214 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3216 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3231 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3233 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_element3263 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral3285 = new BitSet(new ulong[]{0x0800000000000000UL,0x000017F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral3287 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral3290 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3312 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList3315 = new BitSet(new ulong[]{0x0800000000000002UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3318 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3343 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_nonemptyElementList3346 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3348 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral3363 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000101100000780UL,0x00000003C0000300UL});
    public static readonly BitSet FOLLOW_fieldList_in_objectLiteral3365 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral3368 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList3391 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_fieldList3394 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000101100000780UL,0x00000003C0000300UL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList3397 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_fieldName_in_literalField3414 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_COLON_in_literalField3416 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_element_in_literalField3418 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_fieldName3442 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_fieldName3447 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression3469 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3481 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_COMMA_in_expressionList3484 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3486 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression3515 = new BitSet(new ulong[]{0x0000000000000002UL,0x03FFE00000002000UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression3525 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression3529 = new BitSet(new ulong[]{0x0000000000000002UL,0x03FFE00000002000UL});
    public static readonly BitSet FOLLOW_set_in_assignmentOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalOrExpression_in_conditionalExpression3623 = new BitSet(new ulong[]{0x0000000000000002UL,0x0400000000000000UL});
    public static readonly BitSet FOLLOW_QUESTION_in_conditionalExpression3637 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_conditionalSubExpression_in_conditionalExpression3642 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3671 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalSubExpression3673 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3676 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3690 = new BitSet(new ulong[]{0x0000000000000002UL,0x0800000000000000UL,0x0400000000000000UL});
    public static readonly BitSet FOLLOW_logicalOrOperator_in_logicalOrExpression3695 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3698 = new BitSet(new ulong[]{0x0000000000000002UL,0x0800000000000000UL,0x0400000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalOrOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3727 = new BitSet(new ulong[]{0x0000000000000002UL,0x1000000000000000UL,0x0800000000000000UL});
    public static readonly BitSet FOLLOW_logicalAndOperator_in_logicalAndExpression3732 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3735 = new BitSet(new ulong[]{0x0000000000000002UL,0x1000000000000000UL,0x0800000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalAndOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3764 = new BitSet(new ulong[]{0x0000000000000002UL,0x2000000000000000UL});
    public static readonly BitSet FOLLOW_BOR_in_bitwiseOrExpression3769 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3772 = new BitSet(new ulong[]{0x0000000000000002UL,0x2000000000000000UL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3786 = new BitSet(new ulong[]{0x0000000000000002UL,0x4000000000000000UL});
    public static readonly BitSet FOLLOW_BXOR_in_bitwiseXorExpression3791 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3794 = new BitSet(new ulong[]{0x0000000000000002UL,0x4000000000000000UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3808 = new BitSet(new ulong[]{0x0000000000000002UL,0x8000000000000000UL});
    public static readonly BitSet FOLLOW_BAND_in_bitwiseAndExpression3813 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3816 = new BitSet(new ulong[]{0x0000000000000002UL,0x8000000000000000UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3830 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000000FUL});
    public static readonly BitSet FOLLOW_equalityOperator_in_equalityExpression3835 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3840 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000000FUL});
    public static readonly BitSet FOLLOW_set_in_equalityOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3880 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL,0x00000000000007F0UL});
    public static readonly BitSet FOLLOW_relationalOperator_in_relationalExpression3890 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3893 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL,0x00000000000007F0UL});
    public static readonly BitSet FOLLOW_IN_in_relationalOperator3908 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_relationalOperator3913 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_relationalOperator3917 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LE_in_relationalOperator3921 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GE_in_relationalOperator3925 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_relationalOperator3929 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_relationalOperator3933 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INSTANCEOF_in_relationalOperator3937 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3949 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000003800UL});
    public static readonly BitSet FOLLOW_shiftOperator_in_shiftExpression3954 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3957 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000003800UL});
    public static readonly BitSet FOLLOW_set_in_shiftOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3990 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000C000UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_additiveExpression3995 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3998 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000C000UL});
    public static readonly BitSet FOLLOW_set_in_additiveOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression4028 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000200000000UL,0x0000000000030000UL});
    public static readonly BitSet FOLLOW_multiplicativeOperator_in_multiplicativeExpression4034 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression4040 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000200000000UL,0x0000000000030000UL});
    public static readonly BitSet FOLLOW_set_in_multiplicativeOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_unaryExpression4078 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4080 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_unaryExpression4096 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_MINUS_in_unaryExpression4112 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4114 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PLUS_in_unaryExpression4127 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4129 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression4142 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DELETE_in_unaryExpressionNotPlusMinus4153 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00000007FE010310UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4155 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_180_in_unaryExpressionNotPlusMinus4168 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4170 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus4183 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4185 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LNOT_in_unaryExpressionNotPlusMinus4198 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4200 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BNOT_in_unaryExpressionNotPlusMinus4213 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4215 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4228 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_postfixExpression4241 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_propOrIdent_in_postfixExpression4254 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_DOT_in_postfixExpression4266 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000200004000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression4268 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_postfixExpression4274 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_postfixExpression4276 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_postfixExpression4278 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_E4X_DESC_in_postfixExpression4295 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000200004000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression4297 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_arguments_in_postfixExpression4303 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400004000UL,0x00000000010C0000UL});
    public static readonly BitSet FOLLOW_INC_in_postfixExpression4329 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_postfixExpression4348 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_e4xExpression4375 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_e4xExpression4381 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xFilterPredicate_in_e4xExpression4386 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4397 = new BitSet(new ulong[]{0x0000000000000000UL,0x000013F300000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4403 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_e4xAttributeIdentifier4409 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_e4xAttributeIdentifier4415 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_e4xAttributeIdentifier4417 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_e4xAttributeIdentifier4419 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_e4xFilterPredicate4434 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_e4xFilterPredicate4439 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_e4xFilterPredicate4443 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_UNDEFINED_in_primaryExpression4455 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_primaryExpression4460 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpression4465 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpression4470 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDefinition_in_primaryExpression4475 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newFullExpression_in_primaryExpression4480 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_primaryExpression4485 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_encapsulatedExpression_in_primaryExpression4490 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_primaryExpression4495 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_primaryExpression4500 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propOrIdent4520 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_propOrIdent4524 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlLiteral_in_constant4552 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_regexpLiteral_in_constant4557 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_constant4562 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_constant4567 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TRUE_in_constant4572 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FALSE_in_constant4577 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NULL_in_constant4582 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_number0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_xmlLiteral4635 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DIV_in_regexpLiteral4665 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NEW_in_newFullExpression4686 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00000007FE010310UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_newFullExpression4689 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_arguments_in_newFullExpression4691 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_fullNewSubexpression4704 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400000000UL});
    public static readonly BitSet FOLLOW_DOT_in_fullNewSubexpression4718 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_fullNewSubexpression4720 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400000000UL});
    public static readonly BitSet FOLLOW_brackets_in_fullNewSubexpression4737 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000020400000000UL});
    public static readonly BitSet FOLLOW_NEW_in_newShortExpression4765 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00000007FE010310UL});
    public static readonly BitSet FOLLOW_shortNewSubexpression_in_newShortExpression4768 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_shortNewSubexpression4781 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_shortNewSubexpression4786 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyOperator4798 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_propertyOperator4801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_brackets_in_propertyOperator4806 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_commentExpression4818 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_singleLineComment_in_comment4837 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment4839 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_multilineComment_in_comment4856 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment4858 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000001800000000UL});
    public static readonly BitSet FOLLOW_SL_COMMENT_in_singleLineComment4881 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ML_COMMENT_in_multilineComment4901 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_brackets4926 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expressionList_in_brackets4928 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_brackets4930 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_encapsulatedExpression4951 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_encapsulatedExpression4953 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_encapsulatedExpression4955 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDefinition4979 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000101100004780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_ident_in_functionDefinition4981 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_functionDefinition4984 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_functionDefinition4986 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_block_in_functionDefinition4989 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_ident5019 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_ident5026 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_in_ident5038 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_ident5050 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_ident5062 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_ident5074 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_ident5086 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GET_in_ident5098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SET_in_ident5110 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred1393 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred20664 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred381151 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred401255 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred571796 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_synpred591810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred742003 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred752008 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_synpred762015 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred772034 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_synpred812131 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_synpred862370 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_IN_in_synpred862372 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred922647 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred932665 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred942676 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred952697 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_synpred1062966 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_includeDirective_in_synpred1072972 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_synpred1253346 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred1253348 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred1313521 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_relationalOperator_in_synpred1573886 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_synpred1683995 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred1683998 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_multiplicativeOperator_in_synpred1704034 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred1704040 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_synpred1844274 = new BitSet(new ulong[]{0x0800000000000000UL,0x000013F1000047E0UL,0x00100007FEFDC310UL});
    public static readonly BitSet FOLLOW_expression_in_synpred1844276 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000040000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_synpred1844278 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_synpred1864303 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_synpred1874329 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_synpred1884348 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newFullExpression_in_synpred1984480 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_synpred1994485 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred2114718 = new BitSet(new ulong[]{0x0000000000000000UL,0x000011F100000780UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_synpred2114720 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_brackets_in_synpred2124737 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_synpred2134781 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred2154839 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred2174858 = new BitSet(new ulong[]{0x0000000000000002UL});

}
}