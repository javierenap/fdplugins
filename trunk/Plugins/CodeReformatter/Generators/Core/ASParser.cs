// $ANTLR 3.0 C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g 2007-08-21 15:30:09
namespace
CodeReformatter.Generators.Core
{

    using System.IO;
    using System.Diagnostics;


    using System;
    using Antlr.Runtime;
    using IList = System.Collections.IList;
    using ArrayList = System.Collections.ArrayList;
    using Stack = Antlr.Runtime.Collections.StackList;

    using IDictionary = System.Collections.IDictionary;
    using Hashtable = System.Collections.Hashtable;



    using Antlr.Runtime.Tree;

    public class ASParser : Parser
    {
        public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"COMPILATION_UNIT", 
		"TYPE_BLOCK", 
		"METHOD_DEF", 
		"VAR_DEF", 
		"ANNOTATIONS", 
		"ANNOTATION", 
		"ANNOTATION_PARAMS", 
		"MODIFIERS", 
		"NAMESPACE_DEF", 
		"ACCESSOR_ROLE", 
		"CLASS_DEF", 
		"INTERFACE_DEF", 
		"PARAMS", 
		"PARAM", 
		"TYPE_SPEC", 
		"BLOCK", 
		"ELIST", 
		"CONDITION", 
		"ARGUMENTS", 
		"EXPR_STMNT", 
		"ENCPS_EXPR", 
		"VAR_INIT", 
		"METHOD_CALL", 
		"PROPERTY_OR_IDENTIFIER", 
		"PROPERTY_ACCESS", 
		"TYPE_NAME", 
		"ARRAY_ACC", 
		"UNARY_PLUS", 
		"UNARY_MINUS", 
		"POST_INC", 
		"POST_DEC", 
		"PRE_INC", 
		"PRE_DEC", 
		"ARRAY_LITERAL", 
		"ELEMENT", 
		"OBJECT_LITERAL", 
		"OBJECT_FIELD", 
		"FUNC_DEF", 
		"FOR_INIT", 
		"FOR_CONDITION", 
		"FOR_ITERATOR", 
		"FOR_EACH", 
		"FOR_IN", 
		"SWITCH_STATEMENT_LIST", 
		"IDENTIFIER", 
		"DEFAULT_XML_NAMESPACE", 
		"VIRTUAL_PLACEHOLDER", 
		"PACKAGE", 
		"LCURLY", 
		"RCURLY", 
		"SEMI", 
		"IMPORT", 
		"CLASS", 
		"INTERFACE", 
		"EXTENDS", 
		"COMMA", 
		"IMPLEMENTS", 
		"INCLUDE_DIRECTIVE", 
		"STRING_LITERAL", 
		"FUNCTION", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"USE", 
		"VAR", 
		"CONST", 
		"ASSIGN", 
		"LPAREN", 
		"RPAREN", 
		"REST", 
		"IF", 
		"ELSE", 
		"RETURN", 
		"CONTINUE", 
		"BREAK", 
		"SWITCH", 
		"CASE", 
		"COLON", 
		"DEFAULT", 
		"FOR", 
		"EACH", 
		"IN", 
		"WHILE", 
		"DO", 
		"WITH", 
		"XML", 
		"STAR", 
		"DOT", 
		"DBL_COLON", 
		"IDENT", 
		"PUBLIC", 
		"PRIVATE", 
		"PROTECTED", 
		"INTERNAL", 
		"LBRACK", 
		"RBRACK", 
		"STATIC", 
		"DYNAMIC", 
		"STAR_ASSIGN", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"PLUS_ASSIGN", 
		"MINUS_ASSIGN", 
		"SL_ASSIGN", 
		"SR_ASSIGN", 
		"BSR_ASSIGN", 
		"BAND_ASSIGN", 
		"BXOR_ASSIGN", 
		"BOR_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"QUESTION", 
		"LOR", 
		"LAND", 
		"BOR", 
		"BXOR", 
		"BAND", 
		"STRICT_EQUAL", 
		"STRICT_NOT_EQUAL", 
		"NOT_EQUAL", 
		"EQUAL", 
		"LT", 
		"GT", 
		"LE", 
		"GE", 
		"IS", 
		"AS", 
		"INSTANCEOF", 
		"SL", 
		"SR", 
		"BSR", 
		"PLUS", 
		"MINUS", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"DELETE", 
		"TYPEOF", 
		"LNOT", 
		"BNOT", 
		"E4X_DESC", 
		"E4X_ATTRI", 
		"UNDEFINED", 
		"TRUE", 
		"FALSE", 
		"NULL", 
		"HEX_LITERAL", 
		"DECIMAL_LITERAL", 
		"OCTAL_LITERAL", 
		"FLOAT_LITERAL", 
		"NEW", 
		"UNICODE_IDENTIFIER_START", 
		"UNICODE_IDENTIFIER_PART", 
		"ESC", 
		"HEX_DIGIT", 
		"EXPONENT", 
		"WS", 
		"NL", 
		"BOM", 
		"SL_COMMENT", 
		"ML_COMMENT", 
		"OCT_DIGIT", 
		"CTRLCHAR_ESC", 
		"UNICODE_ESC", 
		"OCTAL_ESC", 
		"'include'", 
		"'throw'", 
		"'try'", 
		"'catch'", 
		"'finally'", 
		"'void'", 
		"'final'", 
		"'enumerable'", 
		"'explicit'", 
		"'override'", 
		"'intrinsic'", 
		"'or'", 
		"'and'"
    };

        public const int INTERNAL = 97;
        public const int BLOCK = 19;
        public const int BOR_ASSIGN = 112;
        public const int STRING_LITERAL = 62;
        public const int GT = 126;
        public const int HEX_DIGIT = 159;
        public const int GET = 64;
        public const int UNDEFINED = 147;
        public const int SL_ASSIGN = 107;
        public const int PRE_DEC = 36;
        public const int LOR_ASSIGN = 114;
        public const int SR = 133;
        public const int IMPLEMENTS = 60;
        public const int GE = 128;
        public const int LBRACK = 98;
        public const int OCTAL_LITERAL = 153;
        public const int SL = 132;
        public const int PROPERTY_OR_IDENTIFIER = 27;
        public const int UNICODE_ESC = 168;
        public const int EXTENDS = 58;
        public const int NAMESPACE_DEF = 12;
        public const int FOR_IN = 46;
        public const int NOT_EQUAL = 123;
        public const int MOD_ASSIGN = 104;
        public const int LCURLY = 52;
        public const int UNARY_MINUS = 32;
        public const int LNOT = 143;
        public const int ACCESSOR_ROLE = 13;
        public const int E4X_ATTRI = 146;
        public const int DEFAULT = 82;
        public const int STATIC = 100;
        public const int ML_COMMENT = 165;
        public const int OCTAL_ESC = 169;
        public const int STRICT_NOT_EQUAL = 122;
        public const int OCT_DIGIT = 166;
        public const int ANNOTATIONS = 8;
        public const int E4X_DESC = 145;
        public const int POST_DEC = 34;
        public const int DECIMAL_LITERAL = 152;
        public const int MOD = 138;
        public const int INTERFACE_DEF = 15;
        public const int MODIFIERS = 11;
        public const int TYPE_SPEC = 18;
        public const int DIV = 137;
        public const int UNARY_PLUS = 31;
        public const int EACH = 84;
        public const int DEFAULT_XML_NAMESPACE = 49;
        public const int LAND_ASSIGN = 113;
        public const int CONDITION = 21;
        public const int ASSIGN = 70;
        public const int NULL = 150;
        public const int PRIVATE = 95;
        public const int DO = 87;
        public const int EOF = -1;
        public const int MINUS = 136;
        public const int SWITCH_STATEMENT_LIST = 47;
        public const int PARAM = 17;
        public const int TYPE_BLOCK = 5;
        public const int VIRTUAL_PLACEHOLDER = 50;
        public const int VAR_INIT = 25;
        public const int INSTANCEOF = 131;
        public const int FUNCTION = 63;
        public const int PROPERTY_ACCESS = 28;
        public const int TYPE_NAME = 29;
        public const int INC = 139;
        public const int RETURN = 76;
        public const int ELSE = 75;
        public const int EQUAL = 124;
        public const int BXOR_ASSIGN = 111;
        public const int CTRLCHAR_ESC = 167;
        public const int BSR_ASSIGN = 109;
        public const int TRUE = 148;
        public const int DBL_COLON = 92;
        public const int IDENTIFIER = 48;
        public const int SEMI = 54;
        public const int STRICT_EQUAL = 121;
        public const int PLUS_ASSIGN = 105;
        public const int BSR = 134;
        public const int OBJECT_FIELD = 40;
        public const int ELEMENT = 38;
        public const int NEW = 155;
        public const int DIV_ASSIGN = 103;
        public const int DELETE = 141;
        public const int NL = 162;
        public const int IDENT = 93;
        public const int BAND_ASSIGN = 110;
        public const int AS = 130;
        public const int CASE = 80;
        public const int OBJECT_LITERAL = 39;
        public const int RBRACK = 99;
        public const int LPAREN = 71;
        public const int PLUS = 135;
        public const int CLASS = 56;
        public const int FUNC_DEF = 41;
        public const int ARRAY_ACC = 30;
        public const int BREAK = 78;
        public const int WHILE = 86;
        public const int CONST = 69;
        public const int RCURLY = 53;
        public const int INTERFACE = 57;
        public const int PARAMS = 16;
        public const int FOR_INIT = 42;
        public const int DEC = 140;
        public const int COMMA = 59;
        public const int COMPILATION_UNIT = 4;
        public const int LT = 125;
        public const int FOR_ITERATOR = 44;
        public const int ARGUMENTS = 22;
        public const int LE = 127;
        public const int FOR_CONDITION = 43;
        public const int CLASS_DEF = 14;
        public const int MINUS_ASSIGN = 106;
        public const int ENCPS_EXPR = 24;
        public const int LOR = 116;
        public const int WITH = 88;
        public const int REST = 73;
        public const int INCLUDE_DIRECTIVE = 61;
        public const int BAND = 120;
        public const int STAR_ASSIGN = 102;
        public const int EXPONENT = 160;
        public const int SL_COMMENT = 164;
        public const int VAR = 68;
        public const int WS = 161;
        public const int PACKAGE = 51;
        public const int STAR = 90;
        public const int FOR = 83;
        public const int FALSE = 149;
        public const int UNICODE_IDENTIFIER_PART = 157;
        public const int IMPORT = 55;
        public const int DOT = 91;
        public const int XML = 89;
        public const int ANNOTATION = 9;
        public const int QUESTION = 115;
        public const int EXPR_STMNT = 23;
        public const int PRE_INC = 35;
        public const int BOR = 118;
        public const int NAMESPACE = 66;
        public const int BOM = 163;
        public const int SWITCH = 79;
        public const int CONTINUE = 77;
        public const int ARRAY_LITERAL = 37;
        public const int USE = 67;
        public const int SR_ASSIGN = 108;
        public const int ANNOTATION_PARAMS = 10;
        public const int HEX_LITERAL = 151;
        public const int IS = 129;
        public const int METHOD_CALL = 26;
        public const int FOR_EACH = 45;
        public const int LAND = 117;
        public const int DYNAMIC = 101;
        public const int IN = 85;
        public const int BXOR = 119;
        public const int METHOD_DEF = 6;
        public const int VAR_DEF = 7;
        public const int IF = 74;
        public const int ELIST = 20;
        public const int TYPEOF = 142;
        public const int FLOAT_LITERAL = 154;
        public const int COLON = 81;
        public const int SET = 65;
        public const int PUBLIC = 94;
        public const int UNICODE_IDENTIFIER_START = 156;
        public const int POST_INC = 33;
        public const int ESC = 158;
        public const int BNOT = 144;
        public const int RPAREN = 72;
        public const int PROTECTED = 96;
        protected class InOperator_scope
        {
            protected internal Boolean allowed;
        }
        protected Stack InOperator_stack = new Stack();



        public ASParser(ITokenStream input)
            : base(input)
        {
            InitializeCyclicDFAs();
            ruleMemo = new IDictionary[332 + 1];
        }

        protected ITreeAdaptor adaptor = new CommonTreeAdaptor();

        public ITreeAdaptor TreeAdaptor
        {
            get { return this.adaptor; }
            set { this.adaptor = value; }
        }

        override public string[] TokenNames
        {
            get { return tokenNames; }
        }

        override public string GrammarFileName
        {
            get { return "C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g"; }
        }



        #region Members

        private ASLexer lexer;
        private ICharStream cs;
        public static int CHANNEL_PLACEHOLDER = 999;

        public void SetInput(ASLexer lexer, ICharStream cs)
        {
            this.lexer = lexer;
            this.cs = cs;
        }

        /*
        private CommonTree parseXMLLiteral()
        {
            return E4XHelper.parseXMLLiteral(lexer, cs, input);
        }	
        */

        #endregion


        public class compilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start compilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:94:1: compilationUnit : ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) ;
        public compilationUnit_return compilationUnit() // throws RecognitionException [1]
        {
            compilationUnit_return retval = new compilationUnit_return();
            retval.start = input.LT(1);
            int compilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            as2CompilationUnit_return as2CompilationUnit1 = null;

            as3CompilationUnit_return as3CompilationUnit2 = null;


            RewriteRuleSubtreeStream stream_as2CompilationUnit = new RewriteRuleSubtreeStream(adaptor, "rule as2CompilationUnit");
            RewriteRuleSubtreeStream stream_as3CompilationUnit = new RewriteRuleSubtreeStream(adaptor, "rule as3CompilationUnit");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 1))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:4: ( ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:4: ( as2CompilationUnit | as3CompilationUnit )
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:4: ( as2CompilationUnit | as3CompilationUnit )
                    int alt1 = 2;
                    int LA1_0 = input.LA(1);

                    if (((LA1_0 >= IMPORT && LA1_0 <= INTERFACE) || (LA1_0 >= IDENT && LA1_0 <= LBRACK) || (LA1_0 >= STATIC && LA1_0 <= DYNAMIC) || LA1_0 == 170 || (LA1_0 >= 176 && LA1_0 <= 180)))
                    {
                        alt1 = 1;
                    }
                    else if ((LA1_0 == PACKAGE))
                    {
                        alt1 = 2;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d1s0 =
                            new NoViableAltException("98:4: ( as2CompilationUnit | as3CompilationUnit )", 1, 0, input);

                        throw nvae_d1s0;
                    }
                    switch (alt1)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:98:6: as2CompilationUnit
                            {
                                PushFollow(FOLLOW_as2CompilationUnit_in_compilationUnit331);
                                as2CompilationUnit1 = as2CompilationUnit();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:5: as3CompilationUnit
                            {
                                PushFollow(FOLLOW_as3CompilationUnit_in_compilationUnit337);
                                as3CompilationUnit2 = as3CompilationUnit();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          as2CompilationUnit, as3CompilationUnit
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 100:5: -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:8: ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:27: ( as2CompilationUnit )?
                                if (stream_as2CompilationUnit.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_as2CompilationUnit.Next());

                                }
                                stream_as2CompilationUnit.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:47: ( as3CompilationUnit )?
                                if (stream_as3CompilationUnit.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_as3CompilationUnit.Next());

                                }
                                stream_as3CompilationUnit.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 1, compilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end compilationUnit

        public class as2CompilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2CompilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:1: as2CompilationUnit : ( importDefinition )* as2Type ;
        public as2CompilationUnit_return as2CompilationUnit() // throws RecognitionException [1]
        {
            as2CompilationUnit_return retval = new as2CompilationUnit_return();
            retval.start = input.LT(1);
            int as2CompilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            importDefinition_return importDefinition3 = null;

            as2Type_return as2Type4 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 2))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:4: ( ( importDefinition )* as2Type )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:4: ( importDefinition )* as2Type
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:4: ( importDefinition )*
                    do
                    {
                        int alt2 = 2;
                        int LA2_0 = input.LA(1);

                        if ((LA2_0 == IMPORT))
                        {
                            alt2 = 1;
                        }


                        switch (alt2)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: importDefinition
                                {
                                    PushFollow(FOLLOW_importDefinition_in_as2CompilationUnit365);
                                    importDefinition3 = importDefinition();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, importDefinition3.Tree);

                                }
                                break;

                            default:
                                goto loop2;
                        }
                    } while (true);

                loop2:
                    ;	// Stops C# compiler whinging that label 'loop2' has no statements

                    PushFollow(FOLLOW_as2Type_in_as2CompilationUnit370);
                    as2Type4 = as2Type();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, as2Type4.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 2, as2CompilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2CompilationUnit

        public class as2Type_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2Type
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:1: as2Type : annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] ) ;
        public as2Type_return as2Type() // throws RecognitionException [1]
        {
            as2Type_return retval = new as2Type_return();
            retval.start = input.LT(1);
            int as2Type_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotations_return annos = null;

            modifiers_return mods = null;

            as2ClassDefinition_return as2ClassDefinition5 = null;

            as2InterfaceDefinition_return as2InterfaceDefinition6 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 3))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: (annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: annos= annotations mods= modifiers ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_annotations_in_as2Type383);
                    annos = annotations();
                    followingStackPointer_--;
                    if (failed) return retval;
                    PushFollow(FOLLOW_modifiers_in_as2Type390);
                    mods = modifiers();
                    followingStackPointer_--;
                    if (failed) return retval;
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:2: ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )
                    int alt3 = 2;
                    int LA3_0 = input.LA(1);

                    if ((LA3_0 == CLASS))
                    {
                        alt3 = 1;
                    }
                    else if ((LA3_0 == INTERFACE))
                    {
                        alt3 = 2;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d3s0 =
                            new NoViableAltException("111:2: ( as2ClassDefinition[$annos.tree,$mods.tree] | as2InterfaceDefinition[$annos.tree,$mods.tree] )", 3, 0, input);

                        throw nvae_d3s0;
                    }
                    switch (alt3)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:4: as2ClassDefinition[$annos.tree,$mods.tree]
                            {
                                PushFollow(FOLLOW_as2ClassDefinition_in_as2Type396);
                                as2ClassDefinition5 = as2ClassDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, as2ClassDefinition5.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:112:4: as2InterfaceDefinition[$annos.tree,$mods.tree]
                            {
                                PushFollow(FOLLOW_as2InterfaceDefinition_in_as2Type402);
                                as2InterfaceDefinition6 = as2InterfaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, as2InterfaceDefinition6.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 3, as2Type_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2Type

        public class as3CompilationUnit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as3CompilationUnit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:1: as3CompilationUnit : packageDecl ( packageBlockEntry )* EOF ;
        public as3CompilationUnit_return as3CompilationUnit() // throws RecognitionException [1]
        {
            as3CompilationUnit_return retval = new as3CompilationUnit_return();
            retval.start = input.LT(1);
            int as3CompilationUnit_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EOF9 = null;
            packageDecl_return packageDecl7 = null;

            packageBlockEntry_return packageBlockEntry8 = null;


            CommonTree EOF9_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 4))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:4: ( packageDecl ( packageBlockEntry )* EOF )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:4: packageDecl ( packageBlockEntry )* EOF
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_packageDecl_in_as3CompilationUnit418);
                    packageDecl7 = packageDecl();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, packageDecl7.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:118:3: ( packageBlockEntry )*
                    do
                    {
                        int alt4 = 2;
                        int LA4_0 = input.LA(1);

                        if (((LA4_0 >= SEMI && LA4_0 <= INTERFACE) || LA4_0 == FUNCTION || (LA4_0 >= NAMESPACE && LA4_0 <= CONST) || (LA4_0 >= IDENT && LA4_0 <= LBRACK) || (LA4_0 >= STATIC && LA4_0 <= DYNAMIC) || LA4_0 == 170 || (LA4_0 >= 176 && LA4_0 <= 180)))
                        {
                            alt4 = 1;
                        }


                        switch (alt4)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
                                {
                                    PushFollow(FOLLOW_packageBlockEntry_in_as3CompilationUnit422);
                                    packageBlockEntry8 = packageBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, packageBlockEntry8.Tree);

                                }
                                break;

                            default:
                                goto loop4;
                        }
                    } while (true);

                loop4:
                    ;	// Stops C# compiler whinging that label 'loop4' has no statements

                    EOF9 = (IToken)input.LT(1);
                    Match(input, EOF, FOLLOW_EOF_in_as3CompilationUnit427); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 4, as3CompilationUnit_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as3CompilationUnit

        public class packageDecl_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageDecl
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:122:1: packageDecl : PACKAGE ( identifier )? packageBlock ;
        public packageDecl_return packageDecl() // throws RecognitionException [1]
        {
            packageDecl_return retval = new packageDecl_return();
            retval.start = input.LT(1);
            int packageDecl_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken PACKAGE10 = null;
            identifier_return identifier11 = null;

            packageBlock_return packageBlock12 = null;


            CommonTree PACKAGE10_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 5))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:4: ( PACKAGE ( identifier )? packageBlock )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:4: PACKAGE ( identifier )? packageBlock
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PACKAGE10 = (IToken)input.LT(1);
                    Match(input, PACKAGE, FOLLOW_PACKAGE_in_packageDecl439); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        PACKAGE10_tree = (CommonTree)adaptor.Create(PACKAGE10);
                        root_0 = (CommonTree)adaptor.BecomeRoot(PACKAGE10_tree, root_0);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:13: ( identifier )?
                    int alt5 = 2;
                    int LA5_0 = input.LA(1);

                    if (((LA5_0 >= GET && LA5_0 <= USE) || LA5_0 == XML || (LA5_0 >= IDENT && LA5_0 <= INTERNAL) || LA5_0 == DYNAMIC || (LA5_0 >= IS && LA5_0 <= AS)))
                    {
                        alt5 = 1;
                    }
                    switch (alt5)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: identifier
                            {
                                PushFollow(FOLLOW_identifier_in_packageDecl442);
                                identifier11 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier11.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_packageBlock_in_packageDecl447);
                    packageBlock12 = packageBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, packageBlock12.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 5, packageDecl_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageDecl

        public class packageBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:127:1: packageBlock : LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) ;
        public packageBlock_return packageBlock() // throws RecognitionException [1]
        {
            packageBlock_return retval = new packageBlock_return();
            retval.start = input.LT(1);
            int packageBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY13 = null;
            IToken RCURLY15 = null;
            packageBlockEntry_return packageBlockEntry14 = null;


            CommonTree LCURLY13_tree = null;
            CommonTree RCURLY15_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_packageBlockEntry = new RewriteRuleSubtreeStream(adaptor, "rule packageBlockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 6))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:128:4: ( LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:128:4: LCURLY ( packageBlockEntry )* RCURLY
                {
                    LCURLY13 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_packageBlock458); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY13);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:129:3: ( packageBlockEntry )*
                    do
                    {
                        int alt6 = 2;
                        int LA6_0 = input.LA(1);

                        if (((LA6_0 >= SEMI && LA6_0 <= INTERFACE) || LA6_0 == FUNCTION || (LA6_0 >= NAMESPACE && LA6_0 <= CONST) || (LA6_0 >= IDENT && LA6_0 <= LBRACK) || (LA6_0 >= STATIC && LA6_0 <= DYNAMIC) || LA6_0 == 170 || (LA6_0 >= 176 && LA6_0 <= 180)))
                        {
                            alt6 = 1;
                        }


                        switch (alt6)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
                                {
                                    PushFollow(FOLLOW_packageBlockEntry_in_packageBlock462);
                                    packageBlockEntry14 = packageBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_packageBlockEntry.Add(packageBlockEntry14.Tree);

                                }
                                break;

                            default:
                                goto loop6;
                        }
                    } while (true);

                loop6:
                    ;	// Stops C# compiler whinging that label 'loop6' has no statements

                    RCURLY15 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_packageBlock467); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY15);


                    // AST REWRITE
                    // elements:          packageBlockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 131:3: -> ^( BLOCK ( packageBlockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:131:6: ^( BLOCK ( packageBlockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:131:14: ( packageBlockEntry )*
                                while (stream_packageBlockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_packageBlockEntry.Next());

                                }
                                stream_packageBlockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 6, packageBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageBlock

        public class packageBlockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start packageBlockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:134:1: packageBlockEntry : ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI ) ;
        public packageBlockEntry_return packageBlockEntry() // throws RecognitionException [1]
        {
            packageBlockEntry_return retval = new packageBlockEntry_return();
            retval.start = input.LT(1);
            int packageBlockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI23 = null;
            annotations_return annos = null;

            modifiers_return mods = null;

            importDefinition_return importDefinition16 = null;

            classDefinition_return classDefinition17 = null;

            interfaceDefinition_return interfaceDefinition18 = null;

            variableDefinition_return variableDefinition19 = null;

            methodDefinition_return methodDefinition20 = null;

            namespaceDefinition_return namespaceDefinition21 = null;

            useNamespaceDirective_return useNamespaceDirective22 = null;


            CommonTree SEMI23_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 7))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )
                    int alt8 = 3;
                    switch (input.LA(1))
                    {
                        case IMPORT:
                            {
                                alt8 = 1;
                            }
                            break;
                        case CLASS:
                        case INTERFACE:
                        case FUNCTION:
                        case NAMESPACE:
                        case USE:
                        case VAR:
                        case CONST:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case LBRACK:
                        case STATIC:
                        case DYNAMIC:
                        case 170:
                        case 176:
                        case 177:
                        case 178:
                        case 179:
                        case 180:
                            {
                                alt8 = 2;
                            }
                            break;
                        case SEMI:
                            {
                                alt8 = 3;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d8s0 =
                                new NoViableAltException("135:4: ( importDefinition | annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective ) | SEMI )", 8, 0, input);

                            throw nvae_d8s0;
                    }

                    switch (alt8)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:6: importDefinition
                            {
                                PushFollow(FOLLOW_importDefinition_in_packageBlockEntry491);
                                importDefinition16 = importDefinition();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, importDefinition16.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:137:5: annos= annotations mods= modifiers ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )
                            {
                                PushFollow(FOLLOW_annotations_in_packageBlockEntry500);
                                annos = annotations();
                                followingStackPointer_--;
                                if (failed) return retval;
                                PushFollow(FOLLOW_modifiers_in_packageBlockEntry508);
                                mods = modifiers();
                                followingStackPointer_--;
                                if (failed) return retval;
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:139:4: ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )
                                int alt7 = 6;
                                switch (input.LA(1))
                                {
                                    case CLASS:
                                        {
                                            alt7 = 1;
                                        }
                                        break;
                                    case INTERFACE:
                                        {
                                            alt7 = 2;
                                        }
                                        break;
                                    case VAR:
                                    case CONST:
                                        {
                                            alt7 = 3;
                                        }
                                        break;
                                    case FUNCTION:
                                        {
                                            alt7 = 4;
                                        }
                                        break;
                                    case NAMESPACE:
                                        {
                                            alt7 = 5;
                                        }
                                        break;
                                    case USE:
                                        {
                                            alt7 = 6;
                                        }
                                        break;
                                    default:
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d7s0 =
                                            new NoViableAltException("139:4: ( classDefinition[$annos.tree,$mods.tree] | interfaceDefinition[$annos.tree,$mods.tree] | variableDefinition[$annos.tree,$mods.tree] | methodDefinition[$annos.tree,$mods.tree] | namespaceDefinition[$annos.tree,$mods.tree] | useNamespaceDirective )", 7, 0, input);

                                        throw nvae_d7s0;
                                }

                                switch (alt7)
                                {
                                    case 1:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:139:6: classDefinition[$annos.tree,$mods.tree]
                                        {
                                            PushFollow(FOLLOW_classDefinition_in_packageBlockEntry516);
                                            classDefinition17 = classDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, classDefinition17.Tree);

                                        }
                                        break;
                                    case 2:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:140:6: interfaceDefinition[$annos.tree,$mods.tree]
                                        {
                                            PushFollow(FOLLOW_interfaceDefinition_in_packageBlockEntry524);
                                            interfaceDefinition18 = interfaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, interfaceDefinition18.Tree);

                                        }
                                        break;
                                    case 3:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:141:6: variableDefinition[$annos.tree,$mods.tree]
                                        {
                                            PushFollow(FOLLOW_variableDefinition_in_packageBlockEntry532);
                                            variableDefinition19 = variableDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, variableDefinition19.Tree);

                                        }
                                        break;
                                    case 4:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:6: methodDefinition[$annos.tree,$mods.tree]
                                        {
                                            PushFollow(FOLLOW_methodDefinition_in_packageBlockEntry540);
                                            methodDefinition20 = methodDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, methodDefinition20.Tree);

                                        }
                                        break;
                                    case 5:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:6: namespaceDefinition[$annos.tree,$mods.tree]
                                        {
                                            PushFollow(FOLLOW_namespaceDefinition_in_packageBlockEntry548);
                                            namespaceDefinition21 = namespaceDefinition(((CommonTree)annos.tree), ((CommonTree)mods.tree));
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, namespaceDefinition21.Tree);

                                        }
                                        break;
                                    case 6:
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:144:6: useNamespaceDirective
                                        {
                                            PushFollow(FOLLOW_useNamespaceDirective_in_packageBlockEntry556);
                                            useNamespaceDirective22 = useNamespaceDirective();
                                            followingStackPointer_--;
                                            if (failed) return retval;
                                            if (backtracking == 0) adaptor.AddChild(root_0, useNamespaceDirective22.Tree);

                                        }
                                        break;

                                }


                            }
                            break;
                        case 3:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:146:5: SEMI
                            {
                                SEMI23 = (IToken)input.LT(1);
                                Match(input, SEMI, FOLLOW_SEMI_in_packageBlockEntry567); if (failed) return retval;

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 7, packageBlockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end packageBlockEntry

        public class endOfFile_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start endOfFile
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:151:1: endOfFile : EOF ;
        public endOfFile_return endOfFile() // throws RecognitionException [1]
        {
            endOfFile_return retval = new endOfFile_return();
            retval.start = input.LT(1);
            int endOfFile_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EOF24 = null;

            CommonTree EOF24_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 8))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:152:4: ( EOF )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:152:4: EOF
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    EOF24 = (IToken)input.LT(1);
                    Match(input, EOF, FOLLOW_EOF_in_endOfFile584); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 8, endOfFile_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end endOfFile

        public class importDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start importDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:155:1: importDefinition : IMPORT identifierStar semi ;
        public importDefinition_return importDefinition() // throws RecognitionException [1]
        {
            importDefinition_return retval = new importDefinition_return();
            retval.start = input.LT(1);
            int importDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IMPORT25 = null;
            identifierStar_return identifierStar26 = null;

            semi_return semi27 = null;


            CommonTree IMPORT25_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 9))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:156:4: ( IMPORT identifierStar semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:156:4: IMPORT identifierStar semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    IMPORT25 = (IToken)input.LT(1);
                    Match(input, IMPORT, FOLLOW_IMPORT_in_importDefinition596); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        IMPORT25_tree = (CommonTree)adaptor.Create(IMPORT25);
                        root_0 = (CommonTree)adaptor.BecomeRoot(IMPORT25_tree, root_0);
                    }
                    PushFollow(FOLLOW_identifierStar_in_importDefinition599);
                    identifierStar26 = identifierStar();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, identifierStar26.Tree);
                    PushFollow(FOLLOW_semi_in_importDefinition601);
                    semi27 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi27.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 9, importDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end importDefinition

        public class semi_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start semi
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:159:1: semi : SEMI ;
        public semi_return semi() // throws RecognitionException [1]
        {
            semi_return retval = new semi_return();
            retval.start = input.LT(1);
            int semi_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI28 = null;

            CommonTree SEMI28_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 10))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:160:4: ( SEMI )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:160:4: SEMI
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    SEMI28 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_semi612); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 10, semi_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end semi

        public class classDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start classDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:163:1: classDefinition[CommonTree annos, CommonTree mods] : CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) ;
        public classDefinition_return classDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            classDefinition_return retval = new classDefinition_return();
            retval.start = input.LT(1);
            int classDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CLASS29 = null;
            ident_return ident30 = null;

            classExtendsClause_return classExtendsClause31 = null;

            implementsClause_return implementsClause32 = null;

            typeBlock_return typeBlock33 = null;


            CommonTree CLASS29_tree = null;
            RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor, "token CLASS");
            RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule classExtendsClause");
            RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor, "rule implementsClause");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 11))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:164:4: ( CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:164:4: CLASS ident classExtendsClause implementsClause typeBlock
                {
                    CLASS29 = (IToken)input.LT(1);
                    Match(input, CLASS, FOLLOW_CLASS_in_classDefinition626); if (failed) return retval;
                    if (backtracking == 0) stream_CLASS.Add(CLASS29);

                    PushFollow(FOLLOW_ident_in_classDefinition628);
                    ident30 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident30.Tree);
                    PushFollow(FOLLOW_classExtendsClause_in_classDefinition632);
                    classExtendsClause31 = classExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_classExtendsClause.Add(classExtendsClause31.Tree);
                    PushFollow(FOLLOW_implementsClause_in_classDefinition636);
                    implementsClause32 = implementsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_implementsClause.Add(implementsClause32.Tree);
                    PushFollow(FOLLOW_typeBlock_in_classDefinition640);
                    typeBlock33 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock33.Tree);

                    // AST REWRITE
                    // elements:          implementsClause, typeBlock, classExtendsClause, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 168:3: -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:168:6: ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_classExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_implementsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 11, classDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end classDefinition

        public class as2ClassDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2ClassDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:1: as2ClassDefinition[CommonTree annos, CommonTree mods] : CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) ;
        public as2ClassDefinition_return as2ClassDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            as2ClassDefinition_return retval = new as2ClassDefinition_return();
            retval.start = input.LT(1);
            int as2ClassDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CLASS34 = null;
            identifier_return identifier35 = null;

            classExtendsClause_return classExtendsClause36 = null;

            implementsClause_return implementsClause37 = null;

            typeBlock_return typeBlock38 = null;


            CommonTree CLASS34_tree = null;
            RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor, "token CLASS");
            RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule classExtendsClause");
            RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor, "rule implementsClause");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 12))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:172:4: ( CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:172:4: CLASS identifier classExtendsClause implementsClause typeBlock
                {
                    CLASS34 = (IToken)input.LT(1);
                    Match(input, CLASS, FOLLOW_CLASS_in_as2ClassDefinition672); if (failed) return retval;
                    if (backtracking == 0) stream_CLASS.Add(CLASS34);

                    PushFollow(FOLLOW_identifier_in_as2ClassDefinition674);
                    identifier35 = identifier();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_identifier.Add(identifier35.Tree);
                    PushFollow(FOLLOW_classExtendsClause_in_as2ClassDefinition678);
                    classExtendsClause36 = classExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_classExtendsClause.Add(classExtendsClause36.Tree);
                    PushFollow(FOLLOW_implementsClause_in_as2ClassDefinition682);
                    implementsClause37 = implementsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_implementsClause.Add(implementsClause37.Tree);
                    PushFollow(FOLLOW_typeBlock_in_as2ClassDefinition686);
                    typeBlock38 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock38.Tree);

                    // AST REWRITE
                    // elements:          identifier, implementsClause, classExtendsClause, typeBlock
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 176:3: -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:176:6: ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_identifier.Next());
                                adaptor.AddChild(root_1, stream_classExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_implementsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 12, as2ClassDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2ClassDefinition

        public class interfaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start interfaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:1: interfaceDefinition[CommonTree annos, CommonTree mods] : INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) ;
        public interfaceDefinition_return interfaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            interfaceDefinition_return retval = new interfaceDefinition_return();
            retval.start = input.LT(1);
            int interfaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INTERFACE39 = null;
            ident_return ident40 = null;

            interfaceExtendsClause_return interfaceExtendsClause41 = null;

            typeBlock_return typeBlock42 = null;


            CommonTree INTERFACE39_tree = null;
            RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor, "token INTERFACE");
            RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule interfaceExtendsClause");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 13))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:180:4: ( INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:180:4: INTERFACE ident interfaceExtendsClause typeBlock
                {
                    INTERFACE39 = (IToken)input.LT(1);
                    Match(input, INTERFACE, FOLLOW_INTERFACE_in_interfaceDefinition718); if (failed) return retval;
                    if (backtracking == 0) stream_INTERFACE.Add(INTERFACE39);

                    PushFollow(FOLLOW_ident_in_interfaceDefinition720);
                    ident40 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident40.Tree);
                    PushFollow(FOLLOW_interfaceExtendsClause_in_interfaceDefinition724);
                    interfaceExtendsClause41 = interfaceExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause41.Tree);
                    PushFollow(FOLLOW_typeBlock_in_interfaceDefinition728);
                    typeBlock42 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock42.Tree);

                    // AST REWRITE
                    // elements:          interfaceExtendsClause, ident, typeBlock
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 183:3: -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:183:6: ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 13, interfaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end interfaceDefinition

        public class as2InterfaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2InterfaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:186:1: as2InterfaceDefinition[CommonTree annos, CommonTree mods] : INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) ;
        public as2InterfaceDefinition_return as2InterfaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            as2InterfaceDefinition_return retval = new as2InterfaceDefinition_return();
            retval.start = input.LT(1);
            int as2InterfaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INTERFACE43 = null;
            identifier_return identifier44 = null;

            interfaceExtendsClause_return interfaceExtendsClause45 = null;

            typeBlock_return typeBlock46 = null;


            CommonTree INTERFACE43_tree = null;
            RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor, "token INTERFACE");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor, "rule interfaceExtendsClause");
            RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor, "rule typeBlock");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 14))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:187:4: ( INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:187:4: INTERFACE identifier interfaceExtendsClause typeBlock
                {
                    INTERFACE43 = (IToken)input.LT(1);
                    Match(input, INTERFACE, FOLLOW_INTERFACE_in_as2InterfaceDefinition758); if (failed) return retval;
                    if (backtracking == 0) stream_INTERFACE.Add(INTERFACE43);

                    PushFollow(FOLLOW_identifier_in_as2InterfaceDefinition760);
                    identifier44 = identifier();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_identifier.Add(identifier44.Tree);
                    PushFollow(FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition764);
                    interfaceExtendsClause45 = interfaceExtendsClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause45.Tree);
                    PushFollow(FOLLOW_typeBlock_in_as2InterfaceDefinition768);
                    typeBlock46 = typeBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_typeBlock.Add(typeBlock46.Tree);

                    // AST REWRITE
                    // elements:          identifier, typeBlock, interfaceExtendsClause
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 190:3: -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:190:6: ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_identifier.Next());
                                adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
                                adaptor.AddChild(root_1, stream_typeBlock.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 14, as2InterfaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2InterfaceDefinition

        public class classExtendsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start classExtendsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:193:1: classExtendsClause : ( EXTENDS identifier )? ;
        public classExtendsClause_return classExtendsClause() // throws RecognitionException [1]
        {
            classExtendsClause_return retval = new classExtendsClause_return();
            retval.start = input.LT(1);
            int classExtendsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EXTENDS47 = null;
            identifier_return identifier48 = null;


            CommonTree EXTENDS47_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 15))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:4: ( ( EXTENDS identifier )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:4: ( EXTENDS identifier )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:4: ( EXTENDS identifier )?
                    int alt9 = 2;
                    int LA9_0 = input.LA(1);

                    if ((LA9_0 == EXTENDS))
                    {
                        alt9 = 1;
                    }
                    switch (alt9)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:5: EXTENDS identifier
                            {
                                EXTENDS47 = (IToken)input.LT(1);
                                Match(input, EXTENDS, FOLLOW_EXTENDS_in_classExtendsClause798); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    EXTENDS47_tree = (CommonTree)adaptor.Create(EXTENDS47);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS47_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_classExtendsClause801);
                                identifier48 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier48.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 15, classExtendsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end classExtendsClause

        public class interfaceExtendsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start interfaceExtendsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:1: interfaceExtendsClause : ( EXTENDS identifier ( COMMA identifier )* )? ;
        public interfaceExtendsClause_return interfaceExtendsClause() // throws RecognitionException [1]
        {
            interfaceExtendsClause_return retval = new interfaceExtendsClause_return();
            retval.start = input.LT(1);
            int interfaceExtendsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken EXTENDS49 = null;
            IToken COMMA51 = null;
            identifier_return identifier50 = null;

            identifier_return identifier52 = null;


            CommonTree EXTENDS49_tree = null;
            CommonTree COMMA51_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 16))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:4: ( ( EXTENDS identifier ( COMMA identifier )* )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:4: ( EXTENDS identifier ( COMMA identifier )* )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:4: ( EXTENDS identifier ( COMMA identifier )* )?
                    int alt11 = 2;
                    int LA11_0 = input.LA(1);

                    if ((LA11_0 == EXTENDS))
                    {
                        alt11 = 1;
                    }
                    switch (alt11)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:5: EXTENDS identifier ( COMMA identifier )*
                            {
                                EXTENDS49 = (IToken)input.LT(1);
                                Match(input, EXTENDS, FOLLOW_EXTENDS_in_interfaceExtendsClause814); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    EXTENDS49_tree = (CommonTree)adaptor.Create(EXTENDS49);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS49_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_interfaceExtendsClause817);
                                identifier50 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier50.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:25: ( COMMA identifier )*
                                do
                                {
                                    int alt10 = 2;
                                    int LA10_0 = input.LA(1);

                                    if ((LA10_0 == COMMA))
                                    {
                                        alt10 = 1;
                                    }


                                    switch (alt10)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:197:27: COMMA identifier
                                            {
                                                COMMA51 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_interfaceExtendsClause821); if (failed) return retval;
                                                PushFollow(FOLLOW_identifier_in_interfaceExtendsClause824);
                                                identifier52 = identifier();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, identifier52.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop10;
                                    }
                                } while (true);

                            loop10:
                                ;	// Stops C# compiler whinging that label 'loop10' has no statements


                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 16, interfaceExtendsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end interfaceExtendsClause

        public class implementsClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start implementsClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:1: implementsClause : ( IMPLEMENTS identifier ( COMMA identifier )* )? ;
        public implementsClause_return implementsClause() // throws RecognitionException [1]
        {
            implementsClause_return retval = new implementsClause_return();
            retval.start = input.LT(1);
            int implementsClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IMPLEMENTS53 = null;
            IToken COMMA55 = null;
            identifier_return identifier54 = null;

            identifier_return identifier56 = null;


            CommonTree IMPLEMENTS53_tree = null;
            CommonTree COMMA55_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 17))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:4: ( ( IMPLEMENTS identifier ( COMMA identifier )* )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
                    int alt13 = 2;
                    int LA13_0 = input.LA(1);

                    if ((LA13_0 == IMPLEMENTS))
                    {
                        alt13 = 1;
                    }
                    switch (alt13)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:5: IMPLEMENTS identifier ( COMMA identifier )*
                            {
                                IMPLEMENTS53 = (IToken)input.LT(1);
                                Match(input, IMPLEMENTS, FOLLOW_IMPLEMENTS_in_implementsClause839); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    IMPLEMENTS53_tree = (CommonTree)adaptor.Create(IMPLEMENTS53);
                                    root_0 = (CommonTree)adaptor.BecomeRoot(IMPLEMENTS53_tree, root_0);
                                }
                                PushFollow(FOLLOW_identifier_in_implementsClause842);
                                identifier54 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, identifier54.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:28: ( COMMA identifier )*
                                do
                                {
                                    int alt12 = 2;
                                    int LA12_0 = input.LA(1);

                                    if ((LA12_0 == COMMA))
                                    {
                                        alt12 = 1;
                                    }


                                    switch (alt12)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:200:30: COMMA identifier
                                            {
                                                COMMA55 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_implementsClause846); if (failed) return retval;
                                                PushFollow(FOLLOW_identifier_in_implementsClause849);
                                                identifier56 = identifier();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, identifier56.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop12;
                                    }
                                } while (true);

                            loop12:
                                ;	// Stops C# compiler whinging that label 'loop12' has no statements


                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 17, implementsClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end implementsClause

        public class typeBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:202:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) ;
        public typeBlock_return typeBlock() // throws RecognitionException [1]
        {
            typeBlock_return retval = new typeBlock_return();
            retval.start = input.LT(1);
            int typeBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY57 = null;
            IToken RCURLY59 = null;
            typeBlockEntry_return typeBlockEntry58 = null;


            CommonTree LCURLY57_tree = null;
            CommonTree RCURLY59_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_typeBlockEntry = new RewriteRuleSubtreeStream(adaptor, "rule typeBlockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 18))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: LCURLY ( typeBlockEntry )* RCURLY
                {
                    LCURLY57 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_typeBlock863); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY57);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:204:3: ( typeBlockEntry )*
                    do
                    {
                        int alt14 = 2;
                        int LA14_0 = input.LA(1);

                        if ((LA14_0 == IMPORT || LA14_0 == INCLUDE_DIRECTIVE || LA14_0 == FUNCTION || (LA14_0 >= VAR && LA14_0 <= CONST) || (LA14_0 >= IDENT && LA14_0 <= LBRACK) || (LA14_0 >= STATIC && LA14_0 <= DYNAMIC) || LA14_0 == 170 || (LA14_0 >= 176 && LA14_0 <= 180)))
                        {
                            alt14 = 1;
                        }


                        switch (alt14)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeBlockEntry
                                {
                                    PushFollow(FOLLOW_typeBlockEntry_in_typeBlock867);
                                    typeBlockEntry58 = typeBlockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_typeBlockEntry.Add(typeBlockEntry58.Tree);

                                }
                                break;

                            default:
                                goto loop14;
                        }
                    } while (true);

                loop14:
                    ;	// Stops C# compiler whinging that label 'loop14' has no statements

                    RCURLY59 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_typeBlock872); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY59);


                    // AST REWRITE
                    // elements:          typeBlockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 206:3: -> ^( TYPE_BLOCK ( typeBlockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:6: ^( TYPE_BLOCK ( typeBlockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:19: ( typeBlockEntry )*
                                while (stream_typeBlockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeBlockEntry.Next());

                                }
                                stream_typeBlockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 18, typeBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeBlock

        public class typeBlockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeBlockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:1: typeBlockEntry : (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective );
        public typeBlockEntry_return typeBlockEntry() // throws RecognitionException [1]
        {
            typeBlockEntry_return retval = new typeBlockEntry_return();
            retval.start = input.LT(1);
            int typeBlockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotations_return a = null;

            modifiers_return m = null;

            variableDefinition_return variableDefinition60 = null;

            methodDefinition_return methodDefinition61 = null;

            importDefinition_return importDefinition62 = null;

            as2IncludeDirective_return as2IncludeDirective63 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 19))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:211:17: (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective )
                int alt16 = 3;
                switch (input.LA(1))
                {
                    case FUNCTION:
                    case VAR:
                    case CONST:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case STATIC:
                    case DYNAMIC:
                    case 170:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 180:
                        {
                            alt16 = 1;
                        }
                        break;
                    case IMPORT:
                        {
                            alt16 = 2;
                        }
                        break;
                    case INCLUDE_DIRECTIVE:
                        {
                            alt16 = 3;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d16s0 =
                            new NoViableAltException("209:1: typeBlockEntry : (a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] ) | importDefinition | as2IncludeDirective );", 16, 0, input);

                        throw nvae_d16s0;
                }

                switch (alt16)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:211:17: a= annotations m= modifiers ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_annotations_in_typeBlockEntry898);
                            a = annotations();
                            followingStackPointer_--;
                            if (failed) return retval;
                            PushFollow(FOLLOW_modifiers_in_typeBlockEntry906);
                            m = modifiers();
                            followingStackPointer_--;
                            if (failed) return retval;
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:213:3: ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )
                            int alt15 = 2;
                            int LA15_0 = input.LA(1);

                            if (((LA15_0 >= VAR && LA15_0 <= CONST)))
                            {
                                alt15 = 1;
                            }
                            else if ((LA15_0 == FUNCTION))
                            {
                                alt15 = 2;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d15s0 =
                                    new NoViableAltException("213:3: ( variableDefinition[$a.tree,$m.tree] | methodDefinition[$a.tree,$m.tree] )", 15, 0, input);

                                throw nvae_d15s0;
                            }
                            switch (alt15)
                            {
                                case 1:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:213:5: variableDefinition[$a.tree,$m.tree]
                                    {
                                        PushFollow(FOLLOW_variableDefinition_in_typeBlockEntry913);
                                        variableDefinition60 = variableDefinition(((CommonTree)a.tree), ((CommonTree)m.tree));
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        if (backtracking == 0) adaptor.AddChild(root_0, variableDefinition60.Tree);

                                    }
                                    break;
                                case 2:
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:214:5: methodDefinition[$a.tree,$m.tree]
                                    {
                                        PushFollow(FOLLOW_methodDefinition_in_typeBlockEntry920);
                                        methodDefinition61 = methodDefinition(((CommonTree)a.tree), ((CommonTree)m.tree));
                                        followingStackPointer_--;
                                        if (failed) return retval;
                                        if (backtracking == 0) adaptor.AddChild(root_0, methodDefinition61.Tree);

                                    }
                                    break;

                            }


                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:216:4: importDefinition
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_importDefinition_in_typeBlockEntry930);
                            importDefinition62 = importDefinition();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, importDefinition62.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:217:4: as2IncludeDirective
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_as2IncludeDirective_in_typeBlockEntry935);
                            as2IncludeDirective63 = as2IncludeDirective();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, as2IncludeDirective63.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 19, typeBlockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeBlockEntry

        public class as2IncludeDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start as2IncludeDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:221:1: as2IncludeDirective : INCLUDE_DIRECTIVE STRING_LITERAL ;
        public as2IncludeDirective_return as2IncludeDirective() // throws RecognitionException [1]
        {
            as2IncludeDirective_return retval = new as2IncludeDirective_return();
            retval.start = input.LT(1);
            int as2IncludeDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken INCLUDE_DIRECTIVE64 = null;
            IToken STRING_LITERAL65 = null;

            CommonTree INCLUDE_DIRECTIVE64_tree = null;
            CommonTree STRING_LITERAL65_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 20))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:222:4: ( INCLUDE_DIRECTIVE STRING_LITERAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:222:4: INCLUDE_DIRECTIVE STRING_LITERAL
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    INCLUDE_DIRECTIVE64 = (IToken)input.LT(1);
                    Match(input, INCLUDE_DIRECTIVE, FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective947); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        INCLUDE_DIRECTIVE64_tree = (CommonTree)adaptor.Create(INCLUDE_DIRECTIVE64);
                        adaptor.AddChild(root_0, INCLUDE_DIRECTIVE64_tree);
                    }
                    STRING_LITERAL65 = (IToken)input.LT(1);
                    Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_as2IncludeDirective951); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        STRING_LITERAL65_tree = (CommonTree)adaptor.Create(STRING_LITERAL65);
                        adaptor.AddChild(root_0, STRING_LITERAL65_tree);
                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 20, as2IncludeDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end as2IncludeDirective

        public class includeDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start includeDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:226:1: includeDirective : 'include' STRING_LITERAL semi ;
        public includeDirective_return includeDirective() // throws RecognitionException [1]
        {
            includeDirective_return retval = new includeDirective_return();
            retval.start = input.LT(1);
            int includeDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal66 = null;
            IToken STRING_LITERAL67 = null;
            semi_return semi68 = null;


            CommonTree string_literal66_tree = null;
            CommonTree STRING_LITERAL67_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 21))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:227:4: ( 'include' STRING_LITERAL semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:227:4: 'include' STRING_LITERAL semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal66 = (IToken)input.LT(1);
                    Match(input, 170, FOLLOW_170_in_includeDirective962); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal66_tree = (CommonTree)adaptor.Create(string_literal66);
                        adaptor.AddChild(root_0, string_literal66_tree);
                    }
                    STRING_LITERAL67 = (IToken)input.LT(1);
                    Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_includeDirective966); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        STRING_LITERAL67_tree = (CommonTree)adaptor.Create(STRING_LITERAL67);
                        adaptor.AddChild(root_0, STRING_LITERAL67_tree);
                    }
                    PushFollow(FOLLOW_semi_in_includeDirective970);
                    semi68 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi68.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 21, includeDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end includeDirective

        public class methodDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start methodDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:233:1: methodDefinition[CommonTree annos, CommonTree mods] : FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) ;
        public methodDefinition_return methodDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            methodDefinition_return retval = new methodDefinition_return();
            retval.start = input.LT(1);
            int methodDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken FUNCTION69 = null;
            optionalAccessorRole_return r = null;

            ident_return ident70 = null;

            parameterDeclarationList_return parameterDeclarationList71 = null;

            typeExpression_return typeExpression72 = null;

            block_return block73 = null;

            semi_return semi74 = null;


            CommonTree FUNCTION69_tree = null;
            RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor, "token FUNCTION");
            RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor, "rule optionalAccessorRole");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclarationList");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor, "rule block");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 22))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:234:4: ( FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:234:4: FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi )
                {
                    FUNCTION69 = (IToken)input.LT(1);
                    Match(input, FUNCTION, FOLLOW_FUNCTION_in_methodDefinition983); if (failed) return retval;
                    if (backtracking == 0) stream_FUNCTION.Add(FUNCTION69);

                    PushFollow(FOLLOW_optionalAccessorRole_in_methodDefinition989);
                    r = optionalAccessorRole();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_optionalAccessorRole.Add(r.Tree);
                    PushFollow(FOLLOW_ident_in_methodDefinition993);
                    ident70 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident70.Tree);
                    PushFollow(FOLLOW_parameterDeclarationList_in_methodDefinition997);
                    parameterDeclarationList71 = parameterDeclarationList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList71.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:238:3: ( typeExpression )?
                    int alt17 = 2;
                    int LA17_0 = input.LA(1);

                    if ((LA17_0 == COLON))
                    {
                        alt17 = 1;
                    }
                    switch (alt17)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_methodDefinition1001);
                                typeExpression72 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression72.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:239:3: ( block | semi )
                    int alt18 = 2;
                    int LA18_0 = input.LA(1);

                    if ((LA18_0 == LCURLY))
                    {
                        alt18 = 1;
                    }
                    else if ((LA18_0 == SEMI))
                    {
                        alt18 = 2;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d18s0 =
                            new NoViableAltException("239:3: ( block | semi )", 18, 0, input);

                        throw nvae_d18s0;
                    }
                    switch (alt18)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:239:4: block
                            {
                                PushFollow(FOLLOW_block_in_methodDefinition1007);
                                block73 = block();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_block.Add(block73.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:239:10: semi
                            {
                                PushFollow(FOLLOW_semi_in_methodDefinition1009);
                                semi74 = semi();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_semi.Add(semi74.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          block, parameterDeclarationList, typeExpression, ident, optionalAccessorRole
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 240:3: -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:240:6: ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
                                adaptor.AddChild(root_1, stream_ident.Next());
                                adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:243:5: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:244:5: ( block )?
                                if (stream_block.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_block.Next());

                                }
                                stream_block.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 22, methodDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end methodDefinition

        public class optionalAccessorRole_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start optionalAccessorRole
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:247:1: optionalAccessorRole : ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) ;
        public optionalAccessorRole_return optionalAccessorRole() // throws RecognitionException [1]
        {
            optionalAccessorRole_return retval = new optionalAccessorRole_return();
            retval.start = input.LT(1);
            int optionalAccessorRole_StartIndex = input.Index();
            CommonTree root_0 = null;

            accessorRole_return accessorRole75 = null;


            RewriteRuleSubtreeStream stream_accessorRole = new RewriteRuleSubtreeStream(adaptor, "rule accessorRole");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 23))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:248:4: ( ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:248:4: ( accessorRole )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:248:4: ( accessorRole )?
                    int alt19 = 2;
                    int LA19_0 = input.LA(1);

                    if ((LA19_0 == GET))
                    {
                        int LA19_1 = input.LA(2);

                        if (((LA19_1 >= GET && LA19_1 <= USE) || LA19_1 == XML || LA19_1 == IDENT || LA19_1 == DYNAMIC || (LA19_1 >= IS && LA19_1 <= AS)))
                        {
                            alt19 = 1;
                        }
                    }
                    else if ((LA19_0 == SET))
                    {
                        int LA19_9 = input.LA(2);

                        if (((LA19_9 >= GET && LA19_9 <= USE) || LA19_9 == XML || LA19_9 == IDENT || LA19_9 == DYNAMIC || (LA19_9 >= IS && LA19_9 <= AS)))
                        {
                            alt19 = 1;
                        }
                    }
                    switch (alt19)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: accessorRole
                            {
                                PushFollow(FOLLOW_accessorRole_in_optionalAccessorRole1075);
                                accessorRole75 = accessorRole();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_accessorRole.Add(accessorRole75.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          accessorRole
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 249:3: -> ^( ACCESSOR_ROLE ( accessorRole )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:249:6: ^( ACCESSOR_ROLE ( accessorRole )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ACCESSOR_ROLE, "ACCESSOR_ROLE"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:249:22: ( accessorRole )?
                                if (stream_accessorRole.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_accessorRole.Next());

                                }
                                stream_accessorRole.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 23, optionalAccessorRole_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end optionalAccessorRole

        public class accessorRole_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start accessorRole
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:252:1: accessorRole : ( GET | SET );
        public accessorRole_return accessorRole() // throws RecognitionException [1]
        {
            accessorRole_return retval = new accessorRole_return();
            retval.start = input.LT(1);
            int accessorRole_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set76 = null;

            CommonTree set76_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 24))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:253:4: ( GET | SET )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set76 = (IToken)input.LT(1);
                    if ((input.LA(1) >= GET && input.LA(1) <= SET))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set76));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_accessorRole0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 24, accessorRole_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end accessorRole

        public class namespaceDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start namespaceDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:256:1: namespaceDefinition[CommonTree annos, CommonTree mods] : NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) ;
        public namespaceDefinition_return namespaceDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            namespaceDefinition_return retval = new namespaceDefinition_return();
            retval.start = input.LT(1);
            int namespaceDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NAMESPACE77 = null;
            ident_return ident78 = null;


            CommonTree NAMESPACE77_tree = null;
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 25))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:257:4: ( NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:257:4: NAMESPACE ident
                {
                    NAMESPACE77 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_namespaceDefinition1114); if (failed) return retval;
                    if (backtracking == 0) stream_NAMESPACE.Add(NAMESPACE77);

                    PushFollow(FOLLOW_ident_in_namespaceDefinition1116);
                    ident78 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident78.Tree);

                    // AST REWRITE
                    // elements:          ident, NAMESPACE
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 258:3: -> ^( NAMESPACE_DEF NAMESPACE ident )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:258:6: ^( NAMESPACE_DEF NAMESPACE ident )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_NAMESPACE.Next());
                                adaptor.AddChild(root_1, stream_ident.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 25, namespaceDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end namespaceDefinition

        public class useNamespaceDirective_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start useNamespaceDirective
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:261:1: useNamespaceDirective : USE NAMESPACE ident semi ;
        public useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
        {
            useNamespaceDirective_return retval = new useNamespaceDirective_return();
            retval.start = input.LT(1);
            int useNamespaceDirective_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken USE79 = null;
            IToken NAMESPACE80 = null;
            ident_return ident81 = null;

            semi_return semi82 = null;


            CommonTree USE79_tree = null;
            CommonTree NAMESPACE80_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 26))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:262:4: ( USE NAMESPACE ident semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:262:4: USE NAMESPACE ident semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    USE79 = (IToken)input.LT(1);
                    Match(input, USE, FOLLOW_USE_in_useNamespaceDirective1143); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        USE79_tree = (CommonTree)adaptor.Create(USE79);
                        adaptor.AddChild(root_0, USE79_tree);
                    }
                    NAMESPACE80 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_useNamespaceDirective1145); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NAMESPACE80_tree = (CommonTree)adaptor.Create(NAMESPACE80);
                        adaptor.AddChild(root_0, NAMESPACE80_tree);
                    }
                    PushFollow(FOLLOW_ident_in_useNamespaceDirective1147);
                    ident81 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident81.Tree);
                    PushFollow(FOLLOW_semi_in_useNamespaceDirective1149);
                    semi82 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi82.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 26, useNamespaceDirective_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end useNamespaceDirective

        public class variableDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:265:1: variableDefinition[CommonTree annos, CommonTree mods] : decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) ;
        public variableDefinition_return variableDefinition(CommonTree annos, CommonTree mods) // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            variableDefinition_return retval = new variableDefinition_return();
            retval.start = input.LT(1);
            int variableDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA84 = null;
            varOrConst_return decl = null;

            variableDeclarator_return variableDeclarator83 = null;

            variableDeclarator_return variableDeclarator85 = null;

            semi_return semi86 = null;


            CommonTree COMMA84_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_varOrConst = new RewriteRuleSubtreeStream(adaptor, "rule varOrConst");
            RewriteRuleSubtreeStream stream_variableDeclarator = new RewriteRuleSubtreeStream(adaptor, "rule variableDeclarator");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 27))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:270:4: (decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:270:4: decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi
                {
                    PushFollow(FOLLOW_varOrConst_in_variableDefinition1173);
                    decl = varOrConst();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_varOrConst.Add(decl.Tree);
                    PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1175);
                    variableDeclarator83 = variableDeclarator();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_variableDeclarator.Add(variableDeclarator83.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:271:3: ( COMMA variableDeclarator )*
                    do
                    {
                        int alt20 = 2;
                        int LA20_0 = input.LA(1);

                        if ((LA20_0 == COMMA))
                        {
                            alt20 = 1;
                        }


                        switch (alt20)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:271:4: COMMA variableDeclarator
                                {
                                    COMMA84 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_variableDefinition1180); if (failed) return retval;
                                    if (backtracking == 0) stream_COMMA.Add(COMMA84);

                                    PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1182);
                                    variableDeclarator85 = variableDeclarator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_variableDeclarator.Add(variableDeclarator85.Tree);

                                }
                                break;

                            default:
                                goto loop20;
                        }
                    } while (true);

                loop20:
                    ;	// Stops C# compiler whinging that label 'loop20' has no statements

                    PushFollow(FOLLOW_semi_in_variableDefinition1188);
                    semi86 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi86.Tree);

                    // AST REWRITE
                    // elements:          variableDeclarator, decl
                    // token labels:      
                    // rule labels:       decl, retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_decl = new RewriteRuleSubtreeStream(adaptor, "token decl", (decl != null ? decl.Tree : null));
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 273:3: -> ^( VAR_DEF $decl ( variableDeclarator )+ )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:273:6: ^( VAR_DEF $decl ( variableDeclarator )+ )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);

                                adaptor.AddChild(root_1, annos);
                                adaptor.AddChild(root_1, mods);
                                adaptor.AddChild(root_1, stream_decl.Next());
                                if (!(stream_variableDeclarator.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_variableDeclarator.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_variableDeclarator.Next());

                                }
                                stream_variableDeclarator.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 27, variableDefinition_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end variableDefinition

        public class varOrConst_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start varOrConst
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:276:1: varOrConst : ( VAR | CONST );
        public varOrConst_return varOrConst() // throws RecognitionException [1]
        {
            varOrConst_return retval = new varOrConst_return();
            retval.start = input.LT(1);
            int varOrConst_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set87 = null;

            CommonTree set87_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 28))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:277:4: ( VAR | CONST )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set87 = (IToken)input.LT(1);
                    if ((input.LA(1) >= VAR && input.LA(1) <= CONST))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set87));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_varOrConst0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 28, varOrConst_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end varOrConst

        public class variableDeclarator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableDeclarator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:280:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? ;
        public variableDeclarator_return variableDeclarator() // throws RecognitionException [1]
        {
            variableDeclarator_return retval = new variableDeclarator_return();
            retval.start = input.LT(1);
            int variableDeclarator_StartIndex = input.Index();
            CommonTree root_0 = null;

            ident_return ident88 = null;

            typeExpression_return typeExpression89 = null;

            variableInitializer_return variableInitializer90 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 29))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:4: ( ident ( typeExpression )? ( variableInitializer )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:4: ident ( typeExpression )? ( variableInitializer )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_ident_in_variableDeclarator1232);
                    ident88 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(ident88.Tree, root_0);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:11: ( typeExpression )?
                    int alt21 = 2;
                    int LA21_0 = input.LA(1);

                    if ((LA21_0 == COLON))
                    {
                        alt21 = 1;
                    }
                    switch (alt21)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_variableDeclarator1235);
                                typeExpression89 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, typeExpression89.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:281:27: ( variableInitializer )?
                    int alt22 = 2;
                    int LA22_0 = input.LA(1);

                    if ((LA22_0 == ASSIGN))
                    {
                        alt22 = 1;
                    }
                    switch (alt22)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: variableInitializer
                            {
                                PushFollow(FOLLOW_variableInitializer_in_variableDeclarator1238);
                                variableInitializer90 = variableInitializer();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, variableInitializer90.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 29, variableDeclarator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end variableDeclarator

        public class declaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:283:1: declaration : varOrConst variableDeclarator declarationTail ;
        public declaration_return declaration() // throws RecognitionException [1]
        {
            declaration_return retval = new declaration_return();
            retval.start = input.LT(1);
            int declaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            varOrConst_return varOrConst91 = null;

            variableDeclarator_return variableDeclarator92 = null;

            declarationTail_return declarationTail93 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 30))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:284:4: ( varOrConst variableDeclarator declarationTail )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:284:4: varOrConst variableDeclarator declarationTail
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_varOrConst_in_declaration1249);
                    varOrConst91 = varOrConst();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(varOrConst91.Tree, root_0);
                    PushFollow(FOLLOW_variableDeclarator_in_declaration1252);
                    variableDeclarator92 = variableDeclarator();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, variableDeclarator92.Tree);
                    PushFollow(FOLLOW_declarationTail_in_declaration1256);
                    declarationTail93 = declarationTail();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, declarationTail93.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 30, declaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end declaration

        public class declarationTail_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declarationTail
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:288:1: declarationTail : ( COMMA variableDeclarator )* ;
        public declarationTail_return declarationTail() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            declarationTail_return retval = new declarationTail_return();
            retval.start = input.LT(1);
            int declarationTail_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA94 = null;
            variableDeclarator_return variableDeclarator95 = null;


            CommonTree COMMA94_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 31))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:4: ( ( COMMA variableDeclarator )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:4: ( COMMA variableDeclarator )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:4: ( COMMA variableDeclarator )*
                    do
                    {
                        int alt23 = 2;
                        int LA23_0 = input.LA(1);

                        if ((LA23_0 == COMMA))
                        {
                            alt23 = 1;
                        }


                        switch (alt23)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:293:5: COMMA variableDeclarator
                                {
                                    COMMA94 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_declarationTail1278); if (failed) return retval;
                                    PushFollow(FOLLOW_variableDeclarator_in_declarationTail1281);
                                    variableDeclarator95 = variableDeclarator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, variableDeclarator95.Tree);

                                }
                                break;

                            default:
                                goto loop23;
                        }
                    } while (true);

                loop23:
                    ;	// Stops C# compiler whinging that label 'loop23' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 31, declarationTail_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end declarationTail

        public class variableInitializer_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start variableInitializer
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:296:1: variableInitializer : ASSIGN assignmentExpression ;
        public variableInitializer_return variableInitializer() // throws RecognitionException [1]
        {
            variableInitializer_return retval = new variableInitializer_return();
            retval.start = input.LT(1);
            int variableInitializer_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN96 = null;
            assignmentExpression_return assignmentExpression97 = null;


            CommonTree ASSIGN96_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 32))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:297:4: ( ASSIGN assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:297:4: ASSIGN assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ASSIGN96 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_variableInitializer1294); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ASSIGN96_tree = (CommonTree)adaptor.Create(ASSIGN96);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN96_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_variableInitializer1297);
                    assignmentExpression97 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression97.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 32, variableInitializer_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end variableInitializer

        public class parameterDeclarationList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDeclarationList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:302:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) ;
        public parameterDeclarationList_return parameterDeclarationList() // throws RecognitionException [1]
        {
            parameterDeclarationList_return retval = new parameterDeclarationList_return();
            retval.start = input.LT(1);
            int parameterDeclarationList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN98 = null;
            IToken COMMA100 = null;
            IToken RPAREN102 = null;
            parameterDeclaration_return parameterDeclaration99 = null;

            parameterDeclaration_return parameterDeclaration101 = null;


            CommonTree LPAREN98_tree = null;
            CommonTree COMMA100_tree = null;
            CommonTree RPAREN102_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_parameterDeclaration = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclaration");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 33))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:303:4: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:303:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
                {
                    LPAREN98 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_parameterDeclarationList1310); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN98);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:304:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
                    int alt25 = 2;
                    int LA25_0 = input.LA(1);

                    if (((LA25_0 >= GET && LA25_0 <= USE) || LA25_0 == CONST || LA25_0 == REST || LA25_0 == XML || LA25_0 == IDENT || LA25_0 == DYNAMIC || (LA25_0 >= IS && LA25_0 <= AS)))
                    {
                        alt25 = 1;
                    }
                    switch (alt25)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:304:5: parameterDeclaration ( COMMA parameterDeclaration )*
                            {
                                PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1316);
                                parameterDeclaration99 = parameterDeclaration();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration99.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:305:4: ( COMMA parameterDeclaration )*
                                do
                                {
                                    int alt24 = 2;
                                    int LA24_0 = input.LA(1);

                                    if ((LA24_0 == COMMA))
                                    {
                                        alt24 = 1;
                                    }


                                    switch (alt24)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:305:5: COMMA parameterDeclaration
                                            {
                                                COMMA100 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_parameterDeclarationList1322); if (failed) return retval;
                                                if (backtracking == 0) stream_COMMA.Add(COMMA100);

                                                PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1324);
                                                parameterDeclaration101 = parameterDeclaration();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration101.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop24;
                                    }
                                } while (true);

                            loop24:
                                ;	// Stops C# compiler whinging that label 'loop24' has no statements


                            }
                            break;

                    }

                    RPAREN102 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_parameterDeclarationList1335); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN102);


                    // AST REWRITE
                    // elements:          parameterDeclaration
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 308:3: -> ^( PARAMS ( parameterDeclaration )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:308:6: ^( PARAMS ( parameterDeclaration )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAMS, "PARAMS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:308:15: ( parameterDeclaration )*
                                while (stream_parameterDeclaration.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_parameterDeclaration.Next());

                                }
                                stream_parameterDeclaration.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 33, parameterDeclarationList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterDeclarationList

        public class parameterDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:312:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
        public parameterDeclaration_return parameterDeclaration() // throws RecognitionException [1]
        {
            parameterDeclaration_return retval = new parameterDeclaration_return();
            retval.start = input.LT(1);
            int parameterDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            basicParameterDeclaration_return basicParameterDeclaration103 = null;

            parameterRestDeclaration_return parameterRestDeclaration104 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 34))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:313:4: ( basicParameterDeclaration | parameterRestDeclaration )
                int alt26 = 2;
                int LA26_0 = input.LA(1);

                if (((LA26_0 >= GET && LA26_0 <= USE) || LA26_0 == CONST || LA26_0 == XML || LA26_0 == IDENT || LA26_0 == DYNAMIC || (LA26_0 >= IS && LA26_0 <= AS)))
                {
                    alt26 = 1;
                }
                else if ((LA26_0 == REST))
                {
                    alt26 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d26s0 =
                        new NoViableAltException("312:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );", 26, 0, input);

                    throw nvae_d26s0;
                }
                switch (alt26)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:313:4: basicParameterDeclaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_basicParameterDeclaration_in_parameterDeclaration1358);
                            basicParameterDeclaration103 = basicParameterDeclaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, basicParameterDeclaration103.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:313:32: parameterRestDeclaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_parameterRestDeclaration_in_parameterDeclaration1362);
                            parameterRestDeclaration104 = parameterRestDeclaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, parameterRestDeclaration104.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 34, parameterDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterDeclaration

        public class basicParameterDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start basicParameterDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:316:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
        public basicParameterDeclaration_return basicParameterDeclaration() // throws RecognitionException [1]
        {
            basicParameterDeclaration_return retval = new basicParameterDeclaration_return();
            retval.start = input.LT(1);
            int basicParameterDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CONST105 = null;
            ident_return ident106 = null;

            typeExpression_return typeExpression107 = null;

            parameterDefault_return parameterDefault108 = null;


            CommonTree CONST105_tree = null;
            RewriteRuleTokenStream stream_CONST = new RewriteRuleTokenStream(adaptor, "token CONST");
            RewriteRuleSubtreeStream stream_parameterDefault = new RewriteRuleSubtreeStream(adaptor, "rule parameterDefault");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 35))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:4: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:4: ( CONST )?
                    int alt27 = 2;
                    int LA27_0 = input.LA(1);

                    if ((LA27_0 == CONST))
                    {
                        alt27 = 1;
                    }
                    switch (alt27)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: CONST
                            {
                                CONST105 = (IToken)input.LT(1);
                                Match(input, CONST, FOLLOW_CONST_in_basicParameterDeclaration1373); if (failed) return retval;
                                if (backtracking == 0) stream_CONST.Add(CONST105);


                            }
                            break;

                    }

                    PushFollow(FOLLOW_ident_in_basicParameterDeclaration1376);
                    ident106 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident106.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:17: ( typeExpression )?
                    int alt28 = 2;
                    int LA28_0 = input.LA(1);

                    if ((LA28_0 == COLON))
                    {
                        alt28 = 1;
                    }
                    switch (alt28)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_basicParameterDeclaration1378);
                                typeExpression107 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression107.Tree);

                            }
                            break;

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:317:33: ( parameterDefault )?
                    int alt29 = 2;
                    int LA29_0 = input.LA(1);

                    if ((LA29_0 == ASSIGN))
                    {
                        alt29 = 1;
                    }
                    switch (alt29)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: parameterDefault
                            {
                                PushFollow(FOLLOW_parameterDefault_in_basicParameterDeclaration1381);
                                parameterDefault108 = parameterDefault();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_parameterDefault.Add(parameterDefault108.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          parameterDefault, typeExpression, CONST, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 318:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:318:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:318:14: ( CONST )?
                                if (stream_CONST.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_CONST.Next());

                                }
                                stream_CONST.Reset();
                                adaptor.AddChild(root_1, stream_ident.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:318:27: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:318:43: ( parameterDefault )?
                                if (stream_parameterDefault.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_parameterDefault.Next());

                                }
                                stream_parameterDefault.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 35, basicParameterDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end basicParameterDeclaration

        public class parameterDefault_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterDefault
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:321:1: parameterDefault : ASSIGN assignmentExpression ;
        public parameterDefault_return parameterDefault() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            parameterDefault_return retval = new parameterDefault_return();
            retval.start = input.LT(1);
            int parameterDefault_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN109 = null;
            assignmentExpression_return assignmentExpression110 = null;


            CommonTree ASSIGN109_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 36))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:327:4: ( ASSIGN assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:327:4: ASSIGN assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ASSIGN109 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_parameterDefault1425); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ASSIGN109_tree = (CommonTree)adaptor.Create(ASSIGN109);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN109_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_parameterDefault1428);
                    assignmentExpression110 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression110.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 36, parameterDefault_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end parameterDefault

        public class parameterRestDeclaration_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start parameterRestDeclaration
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:330:1: parameterRestDeclaration : REST ( ident )? -> ^( PARAM REST ( ident )? ) ;
        public parameterRestDeclaration_return parameterRestDeclaration() // throws RecognitionException [1]
        {
            parameterRestDeclaration_return retval = new parameterRestDeclaration_return();
            retval.start = input.LT(1);
            int parameterRestDeclaration_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken REST111 = null;
            ident_return ident112 = null;


            CommonTree REST111_tree = null;
            RewriteRuleTokenStream stream_REST = new RewriteRuleTokenStream(adaptor, "token REST");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 37))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:331:4: ( REST ( ident )? -> ^( PARAM REST ( ident )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:331:4: REST ( ident )?
                {
                    REST111 = (IToken)input.LT(1);
                    Match(input, REST, FOLLOW_REST_in_parameterRestDeclaration1439); if (failed) return retval;
                    if (backtracking == 0) stream_REST.Add(REST111);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:331:9: ( ident )?
                    int alt30 = 2;
                    int LA30_0 = input.LA(1);

                    if (((LA30_0 >= GET && LA30_0 <= USE) || LA30_0 == XML || LA30_0 == IDENT || LA30_0 == DYNAMIC || (LA30_0 >= IS && LA30_0 <= AS)))
                    {
                        alt30 = 1;
                    }
                    switch (alt30)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: ident
                            {
                                PushFollow(FOLLOW_ident_in_parameterRestDeclaration1441);
                                ident112 = ident();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_ident.Add(ident112.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          ident, REST
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 332:3: -> ^( PARAM REST ( ident )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:332:6: ^( PARAM REST ( ident )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);

                                adaptor.AddChild(root_1, stream_REST.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:332:19: ( ident )?
                                if (stream_ident.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_ident.Next());

                                }
                                stream_ident.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 37, parameterRestDeclaration_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end parameterRestDeclaration

        public class block_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start block
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:334:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) ;
        public block_return block() // throws RecognitionException [1]
        {
            block_return retval = new block_return();
            retval.start = input.LT(1);
            int block_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY113 = null;
            IToken RCURLY115 = null;
            blockEntry_return blockEntry114 = null;


            CommonTree LCURLY113_tree = null;
            CommonTree RCURLY115_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_blockEntry = new RewriteRuleSubtreeStream(adaptor, "rule blockEntry");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 38))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:335:4: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:335:4: LCURLY ( blockEntry )* RCURLY
                {
                    LCURLY113 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_block1465); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY113);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:335:11: ( blockEntry )*
                    do
                    {
                        int alt31 = 2;
                        int LA31_0 = input.LA(1);

                        if ((LA31_0 == LCURLY || LA31_0 == SEMI || (LA31_0 >= STRING_LITERAL && LA31_0 <= CONST) || LA31_0 == LPAREN || LA31_0 == IF || (LA31_0 >= RETURN && LA31_0 <= SWITCH) || (LA31_0 >= DEFAULT && LA31_0 <= FOR) || (LA31_0 >= WHILE && LA31_0 <= XML) || (LA31_0 >= IDENT && LA31_0 <= LBRACK) || LA31_0 == DYNAMIC || LA31_0 == LT || (LA31_0 >= IS && LA31_0 <= AS) || (LA31_0 >= PLUS && LA31_0 <= DIV) || (LA31_0 >= INC && LA31_0 <= BNOT) || (LA31_0 >= E4X_ATTRI && LA31_0 <= NEW) || (LA31_0 >= 171 && LA31_0 <= 172) || LA31_0 == 175))
                        {
                            alt31 = 1;
                        }


                        switch (alt31)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: blockEntry
                                {
                                    PushFollow(FOLLOW_blockEntry_in_block1467);
                                    blockEntry114 = blockEntry();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_blockEntry.Add(blockEntry114.Tree);

                                }
                                break;

                            default:
                                goto loop31;
                        }
                    } while (true);

                loop31:
                    ;	// Stops C# compiler whinging that label 'loop31' has no statements

                    RCURLY115 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_block1470); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY115);


                    // AST REWRITE
                    // elements:          blockEntry
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 336:3: -> ^( BLOCK ( blockEntry )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:336:6: ^( BLOCK ( blockEntry )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:336:14: ( blockEntry )*
                                while (stream_blockEntry.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_blockEntry.Next());

                                }
                                stream_blockEntry.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 38, block_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end block

        public class blockEntry_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start blockEntry
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:339:1: blockEntry : statement ;
        public blockEntry_return blockEntry() // throws RecognitionException [1]
        {
            blockEntry_return retval = new blockEntry_return();
            retval.start = input.LT(1);
            int blockEntry_StartIndex = input.Index();
            CommonTree root_0 = null;

            statement_return statement116 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 39))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:6: ( statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:6: statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_statement_in_blockEntry1494);
                    statement116 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement116.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 39, blockEntry_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end blockEntry

        public class condition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start condition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:350:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
        public condition_return condition() // throws RecognitionException [1]
        {
            condition_return retval = new condition_return();
            retval.start = input.LT(1);
            int condition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN117 = null;
            IToken RPAREN119 = null;
            expression_return expression118 = null;


            CommonTree LPAREN117_tree = null;
            CommonTree RPAREN119_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 40))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:351:4: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:351:4: LPAREN expression RPAREN
                {
                    LPAREN117 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_condition1505); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN117);

                    PushFollow(FOLLOW_expression_in_condition1507);
                    expression118 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expression.Add(expression118.Tree);
                    RPAREN119 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_condition1509); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN119);


                    // AST REWRITE
                    // elements:          expression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 352:3: -> ^( CONDITION expression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:352:6: ^( CONDITION expression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CONDITION, "CONDITION"), root_1);

                                adaptor.AddChild(root_1, stream_expression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 40, condition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end condition

        public class statement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start statement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );
        public statement_return statement() // throws RecognitionException [1]
        {
            statement_return retval = new statement_return();
            retval.start = input.LT(1);
            int statement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI136 = null;
            block_return block120 = null;

            declarationStatement_return declarationStatement121 = null;

            expressionStatement_return expressionStatement122 = null;

            ifStatement_return ifStatement123 = null;

            forEachStatement_return forEachStatement124 = null;

            forStatement_return forStatement125 = null;

            whileStatement_return whileStatement126 = null;

            doWhileStatement_return doWhileStatement127 = null;

            withStatement_return withStatement128 = null;

            switchStatement_return switchStatement129 = null;

            breakStatement_return breakStatement130 = null;

            continueStatement_return continueStatement131 = null;

            returnStatement_return returnStatement132 = null;

            throwStatement_return throwStatement133 = null;

            tryStatement_return tryStatement134 = null;

            defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement135 = null;


            CommonTree SEMI136_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 41))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI )
                int alt32 = 17;
                switch (input.LA(1))
                {
                    case LCURLY:
                        {
                            int LA32_1 = input.LA(2);

                            if ((LA32_1 == LCURLY) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if (((LA32_1 >= VAR && LA32_1 <= CONST)) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == INC) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == DEC) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == MINUS) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == PLUS) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == DELETE) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == 175) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == TYPEOF) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == LNOT) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == BNOT) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == UNDEFINED) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == LT) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == DIV) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if (((LA32_1 >= HEX_LITERAL && LA32_1 <= FLOAT_LITERAL)))
                            {
                                int LA32_62 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s62 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 62, input);

                                    throw nvae_d32s62;
                                }
                            }
                            else if ((LA32_1 == STRING_LITERAL) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == TRUE) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == FALSE) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == NULL) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == LBRACK) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == FUNCTION) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == NEW) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == LPAREN) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == E4X_ATTRI) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == IDENT))
                            {
                                int LA32_72 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s72 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 72, input);

                                    throw nvae_d32s72;
                                }
                            }
                            else if (((LA32_1 >= PUBLIC && LA32_1 <= INTERNAL)) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == USE))
                            {
                                int LA32_74 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s74 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 74, input);

                                    throw nvae_d32s74;
                                }
                            }
                            else if ((LA32_1 == XML))
                            {
                                int LA32_75 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s75 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 75, input);

                                    throw nvae_d32s75;
                                }
                            }
                            else if ((LA32_1 == DYNAMIC))
                            {
                                int LA32_76 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s76 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 76, input);

                                    throw nvae_d32s76;
                                }
                            }
                            else if ((LA32_1 == NAMESPACE))
                            {
                                int LA32_77 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s77 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 77, input);

                                    throw nvae_d32s77;
                                }
                            }
                            else if ((LA32_1 == IS))
                            {
                                int LA32_78 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s78 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 78, input);

                                    throw nvae_d32s78;
                                }
                            }
                            else if ((LA32_1 == AS))
                            {
                                int LA32_79 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s79 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 79, input);

                                    throw nvae_d32s79;
                                }
                            }
                            else if ((LA32_1 == GET))
                            {
                                int LA32_80 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s80 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 80, input);

                                    throw nvae_d32s80;
                                }
                            }
                            else if ((LA32_1 == SET))
                            {
                                int LA32_81 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s81 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 81, input);

                                    throw nvae_d32s81;
                                }
                            }
                            else if ((LA32_1 == IF) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == FOR) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == WHILE) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == DO) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == WITH) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == SWITCH) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == BREAK) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == CONTINUE) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == RETURN) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == 171) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == 172) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == DEFAULT) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == SEMI) && (synpred40()))
                            {
                                alt32 = 1;
                            }
                            else if ((LA32_1 == RCURLY))
                            {
                                int LA32_95 = input.LA(3);

                                if ((synpred40()))
                                {
                                    alt32 = 1;
                                }
                                else if ((synpred42()))
                                {
                                    alt32 = 3;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d32s95 =
                                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 95, input);

                                    throw nvae_d32s95;
                                }
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d32s1 =
                                    new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 1, input);

                                throw nvae_d32s1;
                            }
                        }
                        break;
                    case VAR:
                    case CONST:
                        {
                            alt32 = 2;
                        }
                        break;
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case PLUS:
                    case MINUS:
                    case DIV:
                    case INC:
                    case DEC:
                    case DELETE:
                    case TYPEOF:
                    case LNOT:
                    case BNOT:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                    case 175:
                        {
                            alt32 = 3;
                        }
                        break;
                    case IF:
                        {
                            alt32 = 4;
                        }
                        break;
                    case FOR:
                        {
                            int LA32_36 = input.LA(2);

                            if ((LA32_36 == LPAREN))
                            {
                                alt32 = 6;
                            }
                            else if ((LA32_36 == EACH))
                            {
                                alt32 = 5;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d32s36 =
                                    new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 36, input);

                                throw nvae_d32s36;
                            }
                        }
                        break;
                    case WHILE:
                        {
                            alt32 = 7;
                        }
                        break;
                    case DO:
                        {
                            alt32 = 8;
                        }
                        break;
                    case WITH:
                        {
                            alt32 = 9;
                        }
                        break;
                    case SWITCH:
                        {
                            alt32 = 10;
                        }
                        break;
                    case BREAK:
                        {
                            alt32 = 11;
                        }
                        break;
                    case CONTINUE:
                        {
                            alt32 = 12;
                        }
                        break;
                    case RETURN:
                        {
                            alt32 = 13;
                        }
                        break;
                    case 171:
                        {
                            alt32 = 14;
                        }
                        break;
                    case 172:
                        {
                            alt32 = 15;
                        }
                        break;
                    case DEFAULT:
                        {
                            alt32 = 16;
                        }
                        break;
                    case SEMI:
                        {
                            alt32 = 17;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d32s0 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | SEMI );", 32, 0, input);

                        throw nvae_d32s0;
                }

                switch (alt32)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( LCURLY )=> block
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_block_in_statement1535);
                            block120 = block();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, block120.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:357:4: declarationStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_declarationStatement_in_statement1540);
                            declarationStatement121 = declarationStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, declarationStatement121.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: expressionStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_expressionStatement_in_statement1545);
                            expressionStatement122 = expressionStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, expressionStatement122.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:359:4: ifStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ifStatement_in_statement1550);
                            ifStatement123 = ifStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ifStatement123.Tree);

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:4: forEachStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_forEachStatement_in_statement1557);
                            forEachStatement124 = forEachStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, forEachStatement124.Tree);

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:4: forStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_forStatement_in_statement1562);
                            forStatement125 = forStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, forStatement125.Tree);

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:365:4: whileStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_whileStatement_in_statement1570);
                            whileStatement126 = whileStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, whileStatement126.Tree);

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:368:4: doWhileStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_doWhileStatement_in_statement1578);
                            doWhileStatement127 = doWhileStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, doWhileStatement127.Tree);

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:371:4: withStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_withStatement_in_statement1587);
                            withStatement128 = withStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, withStatement128.Tree);

                        }
                        break;
                    case 10:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:374:4: switchStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_switchStatement_in_statement1596);
                            switchStatement129 = switchStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, switchStatement129.Tree);

                        }
                        break;
                    case 11:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:377:4: breakStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_breakStatement_in_statement1605);
                            breakStatement130 = breakStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, breakStatement130.Tree);

                        }
                        break;
                    case 12:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:380:4: continueStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_continueStatement_in_statement1613);
                            continueStatement131 = continueStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, continueStatement131.Tree);

                        }
                        break;
                    case 13:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:383:4: returnStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_returnStatement_in_statement1621);
                            returnStatement132 = returnStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, returnStatement132.Tree);

                        }
                        break;
                    case 14:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:386:4: throwStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_throwStatement_in_statement1629);
                            throwStatement133 = throwStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, throwStatement133.Tree);

                        }
                        break;
                    case 15:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:389:4: tryStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_tryStatement_in_statement1638);
                            tryStatement134 = tryStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, tryStatement134.Tree);

                        }
                        break;
                    case 16:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:392:4: defaultXMLNamespaceStatement
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_defaultXMLNamespaceStatement_in_statement1647);
                            defaultXMLNamespaceStatement135 = defaultXMLNamespaceStatement();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, defaultXMLNamespaceStatement135.Tree);

                        }
                        break;
                    case 17:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:395:4: SEMI
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            SEMI136 = (IToken)input.LT(1);
                            Match(input, SEMI, FOLLOW_SEMI_in_statement1655); if (failed) return retval;

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 41, statement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end statement

        public class declarationStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start declarationStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:398:1: declarationStatement : declaration semi ;
        public declarationStatement_return declarationStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            declarationStatement_return retval = new declarationStatement_return();
            retval.start = input.LT(1);
            int declarationStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration137 = null;

            semi_return semi138 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 42))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:403:4: ( declaration semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:403:4: declaration semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_declaration_in_declarationStatement1677);
                    declaration137 = declaration();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, declaration137.Tree);
                    PushFollow(FOLLOW_semi_in_declarationStatement1679);
                    semi138 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi138.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 42, declarationStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end declarationStatement

        public class expressionStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expressionStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:406:1: expressionStatement : expressionList semi -> ^( EXPR_STMNT expressionList ) ;
        public expressionStatement_return expressionStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            expressionStatement_return retval = new expressionStatement_return();
            retval.start = input.LT(1);
            int expressionStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList139 = null;

            semi_return semi140 = null;


            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 43))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:4: ( expressionList semi -> ^( EXPR_STMNT expressionList ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:411:4: expressionList semi
                {
                    PushFollow(FOLLOW_expressionList_in_expressionStatement1700);
                    expressionList139 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expressionList.Add(expressionList139.Tree);
                    PushFollow(FOLLOW_semi_in_expressionStatement1702);
                    semi140 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi140.Tree);

                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 412:3: -> ^( EXPR_STMNT expressionList )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:412:6: ^( EXPR_STMNT expressionList )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);

                                adaptor.AddChild(root_1, stream_expressionList.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 43, expressionStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end expressionStatement

        public class ifStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start ifStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:415:1: ifStatement : IF condition statement ( ( ELSE )=> elseClause )? ;
        public ifStatement_return ifStatement() // throws RecognitionException [1]
        {
            ifStatement_return retval = new ifStatement_return();
            retval.start = input.LT(1);
            int ifStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IF141 = null;
            condition_return condition142 = null;

            statement_return statement143 = null;

            elseClause_return elseClause144 = null;


            CommonTree IF141_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 44))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:416:4: ( IF condition statement ( ( ELSE )=> elseClause )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:416:4: IF condition statement ( ( ELSE )=> elseClause )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    IF141 = (IToken)input.LT(1);
                    Match(input, IF, FOLLOW_IF_in_ifStatement1724); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        IF141_tree = (CommonTree)adaptor.Create(IF141);
                        root_0 = (CommonTree)adaptor.BecomeRoot(IF141_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_ifStatement1727);
                    condition142 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition142.Tree);
                    PushFollow(FOLLOW_statement_in_ifStatement1729);
                    statement143 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement143.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:417:3: ( ( ELSE )=> elseClause )?
                    int alt33 = 2;
                    int LA33_0 = input.LA(1);

                    if ((LA33_0 == ELSE))
                    {
                        int LA33_1 = input.LA(2);

                        if ((synpred56()))
                        {
                            alt33 = 1;
                        }
                    }
                    switch (alt33)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:417:4: ( ELSE )=> elseClause
                            {
                                PushFollow(FOLLOW_elseClause_in_ifStatement1738);
                                elseClause144 = elseClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, elseClause144.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 44, ifStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end ifStatement

        public class elseClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start elseClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:1: elseClause : ELSE statement ;
        public elseClause_return elseClause() // throws RecognitionException [1]
        {
            elseClause_return retval = new elseClause_return();
            retval.start = input.LT(1);
            int elseClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ELSE145 = null;
            statement_return statement146 = null;


            CommonTree ELSE145_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 45))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:421:4: ( ELSE statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:421:4: ELSE statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    ELSE145 = (IToken)input.LT(1);
                    Match(input, ELSE, FOLLOW_ELSE_in_elseClause1751); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        ELSE145_tree = (CommonTree)adaptor.Create(ELSE145);
                        root_0 = (CommonTree)adaptor.BecomeRoot(ELSE145_tree, root_0);
                    }
                    PushFollow(FOLLOW_statement_in_elseClause1754);
                    statement146 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement146.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 45, elseClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end elseClause

        public class throwStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start throwStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:1: throwStatement : 'throw' expression semi ;
        public throwStatement_return throwStatement() // throws RecognitionException [1]
        {
            throwStatement_return retval = new throwStatement_return();
            retval.start = input.LT(1);
            int throwStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal147 = null;
            expression_return expression148 = null;

            semi_return semi149 = null;


            CommonTree string_literal147_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 46))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:425:4: ( 'throw' expression semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:425:4: 'throw' expression semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal147 = (IToken)input.LT(1);
                    Match(input, 171, FOLLOW_171_in_throwStatement1765); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal147_tree = (CommonTree)adaptor.Create(string_literal147);
                        root_0 = (CommonTree)adaptor.BecomeRoot(string_literal147_tree, root_0);
                    }
                    PushFollow(FOLLOW_expression_in_throwStatement1768);
                    expression148 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression148.Tree);
                    PushFollow(FOLLOW_semi_in_throwStatement1770);
                    semi149 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi149.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 46, throwStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end throwStatement

        public class tryStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start tryStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:428:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? ;
        public tryStatement_return tryStatement() // throws RecognitionException [1]
        {
            tryStatement_return retval = new tryStatement_return();
            retval.start = input.LT(1);
            int tryStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal150 = null;
            block_return block151 = null;

            catchBlock_return catchBlock152 = null;

            finallyBlock_return finallyBlock153 = null;


            CommonTree string_literal150_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 47))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:429:4: ( 'try' block ( catchBlock )* ( finallyBlock )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:429:4: 'try' block ( catchBlock )* ( finallyBlock )?
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal150 = (IToken)input.LT(1);
                    Match(input, 172, FOLLOW_172_in_tryStatement1781); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal150_tree = (CommonTree)adaptor.Create(string_literal150);
                        adaptor.AddChild(root_0, string_literal150_tree);
                    }
                    PushFollow(FOLLOW_block_in_tryStatement1785);
                    block151 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block151.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:431:3: ( catchBlock )*
                    do
                    {
                        int alt34 = 2;
                        int LA34_0 = input.LA(1);

                        if ((LA34_0 == 173))
                        {
                            alt34 = 1;
                        }


                        switch (alt34)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: catchBlock
                                {
                                    PushFollow(FOLLOW_catchBlock_in_tryStatement1789);
                                    catchBlock152 = catchBlock();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, catchBlock152.Tree);

                                }
                                break;

                            default:
                                goto loop34;
                        }
                    } while (true);

                loop34:
                    ;	// Stops C# compiler whinging that label 'loop34' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:432:3: ( finallyBlock )?
                    int alt35 = 2;
                    int LA35_0 = input.LA(1);

                    if ((LA35_0 == 174))
                    {
                        alt35 = 1;
                    }
                    switch (alt35)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: finallyBlock
                            {
                                PushFollow(FOLLOW_finallyBlock_in_tryStatement1794);
                                finallyBlock153 = finallyBlock();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, finallyBlock153.Tree);

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 47, tryStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end tryStatement

        public class catchBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start catchBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:435:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
        public catchBlock_return catchBlock() // throws RecognitionException [1]
        {
            catchBlock_return retval = new catchBlock_return();
            retval.start = input.LT(1);
            int catchBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal154 = null;
            IToken LPAREN155 = null;
            IToken RPAREN158 = null;
            ident_return ident156 = null;

            typeExpression_return typeExpression157 = null;

            block_return block159 = null;


            CommonTree string_literal154_tree = null;
            CommonTree LPAREN155_tree = null;
            CommonTree RPAREN158_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 48))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:436:4: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:436:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal154 = (IToken)input.LT(1);
                    Match(input, 173, FOLLOW_173_in_catchBlock1806); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal154_tree = (CommonTree)adaptor.Create(string_literal154);
                        adaptor.AddChild(root_0, string_literal154_tree);
                    }
                    LPAREN155 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_catchBlock1808); if (failed) return retval;
                    PushFollow(FOLLOW_ident_in_catchBlock1811);
                    ident156 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident156.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:436:26: ( typeExpression )?
                    int alt36 = 2;
                    int LA36_0 = input.LA(1);

                    if ((LA36_0 == COLON))
                    {
                        alt36 = 1;
                    }
                    switch (alt36)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_catchBlock1813);
                                typeExpression157 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, typeExpression157.Tree);

                            }
                            break;

                    }

                    RPAREN158 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_catchBlock1816); if (failed) return retval;
                    PushFollow(FOLLOW_block_in_catchBlock1821);
                    block159 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block159.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 48, catchBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end catchBlock

        public class finallyBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start finallyBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:440:1: finallyBlock : 'finally' block ;
        public finallyBlock_return finallyBlock() // throws RecognitionException [1]
        {
            finallyBlock_return retval = new finallyBlock_return();
            retval.start = input.LT(1);
            int finallyBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken string_literal160 = null;
            block_return block161 = null;


            CommonTree string_literal160_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 49))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:441:4: ( 'finally' block )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:441:4: 'finally' block
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    string_literal160 = (IToken)input.LT(1);
                    Match(input, 174, FOLLOW_174_in_finallyBlock1832); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        string_literal160_tree = (CommonTree)adaptor.Create(string_literal160);
                        adaptor.AddChild(root_0, string_literal160_tree);
                    }
                    PushFollow(FOLLOW_block_in_finallyBlock1834);
                    block161 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, block161.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 49, finallyBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end finallyBlock

        public class returnStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start returnStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:444:1: returnStatement : RETURN ( expression )? semi ;
        public returnStatement_return returnStatement() // throws RecognitionException [1]
        {
            returnStatement_return retval = new returnStatement_return();
            retval.start = input.LT(1);
            int returnStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken RETURN162 = null;
            expression_return expression163 = null;

            semi_return semi164 = null;


            CommonTree RETURN162_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 50))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:445:4: ( RETURN ( expression )? semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:445:4: RETURN ( expression )? semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    RETURN162 = (IToken)input.LT(1);
                    Match(input, RETURN, FOLLOW_RETURN_in_returnStatement1845); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        RETURN162_tree = (CommonTree)adaptor.Create(RETURN162);
                        root_0 = (CommonTree)adaptor.BecomeRoot(RETURN162_tree, root_0);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:445:12: ( expression )?
                    int alt37 = 2;
                    int LA37_0 = input.LA(1);

                    if ((LA37_0 == LCURLY || (LA37_0 >= STRING_LITERAL && LA37_0 <= USE) || LA37_0 == LPAREN || LA37_0 == XML || (LA37_0 >= IDENT && LA37_0 <= LBRACK) || LA37_0 == DYNAMIC || LA37_0 == LT || (LA37_0 >= IS && LA37_0 <= AS) || (LA37_0 >= PLUS && LA37_0 <= DIV) || (LA37_0 >= INC && LA37_0 <= BNOT) || (LA37_0 >= E4X_ATTRI && LA37_0 <= NEW) || LA37_0 == 175))
                    {
                        alt37 = 1;
                    }
                    switch (alt37)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expression
                            {
                                PushFollow(FOLLOW_expression_in_returnStatement1848);
                                expression163 = expression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, expression163.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_semi_in_returnStatement1851);
                    semi164 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi164.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 50, returnStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end returnStatement

        public class continueStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start continueStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:1: continueStatement : CONTINUE semi ;
        public continueStatement_return continueStatement() // throws RecognitionException [1]
        {
            continueStatement_return retval = new continueStatement_return();
            retval.start = input.LT(1);
            int continueStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CONTINUE165 = null;
            semi_return semi166 = null;


            CommonTree CONTINUE165_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 51))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:449:4: ( CONTINUE semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:449:4: CONTINUE semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    CONTINUE165 = (IToken)input.LT(1);
                    Match(input, CONTINUE, FOLLOW_CONTINUE_in_continueStatement1864); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        CONTINUE165_tree = (CommonTree)adaptor.Create(CONTINUE165);
                        root_0 = (CommonTree)adaptor.BecomeRoot(CONTINUE165_tree, root_0);
                    }
                    PushFollow(FOLLOW_semi_in_continueStatement1867);
                    semi166 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi166.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 51, continueStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end continueStatement

        public class breakStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start breakStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:452:1: breakStatement : BREAK semi ;
        public breakStatement_return breakStatement() // throws RecognitionException [1]
        {
            breakStatement_return retval = new breakStatement_return();
            retval.start = input.LT(1);
            int breakStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BREAK167 = null;
            semi_return semi168 = null;


            CommonTree BREAK167_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 52))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:453:4: ( BREAK semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:453:4: BREAK semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    BREAK167 = (IToken)input.LT(1);
                    Match(input, BREAK, FOLLOW_BREAK_in_breakStatement1878); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        BREAK167_tree = (CommonTree)adaptor.Create(BREAK167);
                        root_0 = (CommonTree)adaptor.BecomeRoot(BREAK167_tree, root_0);
                    }
                    PushFollow(FOLLOW_semi_in_breakStatement1881);
                    semi168 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi168.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 52, breakStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end breakStatement

        public class switchStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:1: switchStatement : SWITCH condition switchBlock ;
        public switchStatement_return switchStatement() // throws RecognitionException [1]
        {
            switchStatement_return retval = new switchStatement_return();
            retval.start = input.LT(1);
            int switchStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SWITCH169 = null;
            condition_return condition170 = null;

            switchBlock_return switchBlock171 = null;


            CommonTree SWITCH169_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 53))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:4: ( SWITCH condition switchBlock )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:457:4: SWITCH condition switchBlock
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    SWITCH169 = (IToken)input.LT(1);
                    Match(input, SWITCH, FOLLOW_SWITCH_in_switchStatement1892); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        SWITCH169_tree = (CommonTree)adaptor.Create(SWITCH169);
                        root_0 = (CommonTree)adaptor.BecomeRoot(SWITCH169_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_switchStatement1895);
                    condition170 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition170.Tree);
                    PushFollow(FOLLOW_switchBlock_in_switchStatement1899);
                    switchBlock171 = switchBlock();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, switchBlock171.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 53, switchStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchStatement

        public class switchBlock_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchBlock
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:461:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
        public switchBlock_return switchBlock() // throws RecognitionException [1]
        {
            switchBlock_return retval = new switchBlock_return();
            retval.start = input.LT(1);
            int switchBlock_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY172 = null;
            IToken RCURLY175 = null;
            caseStatement_return caseStatement173 = null;

            defaultStatement_return defaultStatement174 = null;


            CommonTree LCURLY172_tree = null;
            CommonTree RCURLY175_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_caseStatement = new RewriteRuleSubtreeStream(adaptor, "rule caseStatement");
            RewriteRuleSubtreeStream stream_defaultStatement = new RewriteRuleSubtreeStream(adaptor, "rule defaultStatement");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 54))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:462:4: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:462:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
                {
                    LCURLY172 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_switchBlock1910); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY172);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:463:3: ( caseStatement )*
                    do
                    {
                        int alt38 = 2;
                        int LA38_0 = input.LA(1);

                        if ((LA38_0 == CASE))
                        {
                            alt38 = 1;
                        }


                        switch (alt38)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:463:4: caseStatement
                                {
                                    PushFollow(FOLLOW_caseStatement_in_switchBlock1915);
                                    caseStatement173 = caseStatement();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_caseStatement.Add(caseStatement173.Tree);

                                }
                                break;

                            default:
                                goto loop38;
                        }
                    } while (true);

                loop38:
                    ;	// Stops C# compiler whinging that label 'loop38' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:3: ( defaultStatement )?
                    int alt39 = 2;
                    int LA39_0 = input.LA(1);

                    if ((LA39_0 == DEFAULT))
                    {
                        alt39 = 1;
                    }
                    switch (alt39)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:4: defaultStatement
                            {
                                PushFollow(FOLLOW_defaultStatement_in_switchBlock1922);
                                defaultStatement174 = defaultStatement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_defaultStatement.Add(defaultStatement174.Tree);

                            }
                            break;

                    }

                    RCURLY175 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_switchBlock1928); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY175);


                    // AST REWRITE
                    // elements:          caseStatement, defaultStatement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 466:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:466:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:466:14: ( caseStatement )*
                                while (stream_caseStatement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_caseStatement.Next());

                                }
                                stream_caseStatement.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:466:29: ( defaultStatement )?
                                if (stream_defaultStatement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_defaultStatement.Next());

                                }
                                stream_defaultStatement.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 54, switchBlock_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchBlock

        public class caseStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start caseStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:1: caseStatement : CASE expression COLON l= switchStatementList ;
        public caseStatement_return caseStatement() // throws RecognitionException [1]
        {
            caseStatement_return retval = new caseStatement_return();
            retval.start = input.LT(1);
            int caseStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken CASE176 = null;
            IToken COLON178 = null;
            switchStatementList_return l = null;

            expression_return expression177 = null;


            CommonTree CASE176_tree = null;
            CommonTree COLON178_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 55))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:470:4: ( CASE expression COLON l= switchStatementList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:470:4: CASE expression COLON l= switchStatementList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    CASE176 = (IToken)input.LT(1);
                    Match(input, CASE, FOLLOW_CASE_in_caseStatement1953); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        CASE176_tree = (CommonTree)adaptor.Create(CASE176);
                        root_0 = (CommonTree)adaptor.BecomeRoot(CASE176_tree, root_0);
                    }
                    PushFollow(FOLLOW_expression_in_caseStatement1956);
                    expression177 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression177.Tree);
                    COLON178 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_caseStatement1958); if (failed) return retval;
                    PushFollow(FOLLOW_switchStatementList_in_caseStatement1963);
                    l = switchStatementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, l.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 55, caseStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end caseStatement

        public class defaultStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start defaultStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:473:1: defaultStatement : DEFAULT COLON l= switchStatementList ;
        public defaultStatement_return defaultStatement() // throws RecognitionException [1]
        {
            defaultStatement_return retval = new defaultStatement_return();
            retval.start = input.LT(1);
            int defaultStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DEFAULT179 = null;
            IToken COLON180 = null;
            switchStatementList_return l = null;


            CommonTree DEFAULT179_tree = null;
            CommonTree COLON180_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 56))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:474:4: ( DEFAULT COLON l= switchStatementList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:474:4: DEFAULT COLON l= switchStatementList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    DEFAULT179 = (IToken)input.LT(1);
                    Match(input, DEFAULT, FOLLOW_DEFAULT_in_defaultStatement1975); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        DEFAULT179_tree = (CommonTree)adaptor.Create(DEFAULT179);
                        root_0 = (CommonTree)adaptor.BecomeRoot(DEFAULT179_tree, root_0);
                    }
                    COLON180 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_defaultStatement1978); if (failed) return retval;
                    PushFollow(FOLLOW_switchStatementList_in_defaultStatement1983);
                    l = switchStatementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, l.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 56, defaultStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end defaultStatement

        public class switchStatementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start switchStatementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:477:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
        public switchStatementList_return switchStatementList() // throws RecognitionException [1]
        {
            switchStatementList_return retval = new switchStatementList_return();
            retval.start = input.LT(1);
            int switchStatementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            statement_return statement181 = null;


            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 57))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:478:4: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:478:4: ( statement )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:478:4: ( statement )*
                    do
                    {
                        int alt40 = 2;
                        int LA40_0 = input.LA(1);

                        if ((LA40_0 == DEFAULT))
                        {
                            int LA40_1 = input.LA(2);

                            if ((LA40_1 == XML))
                            {
                                alt40 = 1;
                            }


                        }
                        else if ((LA40_0 == LCURLY || LA40_0 == SEMI || (LA40_0 >= STRING_LITERAL && LA40_0 <= CONST) || LA40_0 == LPAREN || LA40_0 == IF || (LA40_0 >= RETURN && LA40_0 <= SWITCH) || LA40_0 == FOR || (LA40_0 >= WHILE && LA40_0 <= XML) || (LA40_0 >= IDENT && LA40_0 <= LBRACK) || LA40_0 == DYNAMIC || LA40_0 == LT || (LA40_0 >= IS && LA40_0 <= AS) || (LA40_0 >= PLUS && LA40_0 <= DIV) || (LA40_0 >= INC && LA40_0 <= BNOT) || (LA40_0 >= E4X_ATTRI && LA40_0 <= NEW) || (LA40_0 >= 171 && LA40_0 <= 172) || LA40_0 == 175))
                        {
                            alt40 = 1;
                        }


                        switch (alt40)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: statement
                                {
                                    PushFollow(FOLLOW_statement_in_switchStatementList1994);
                                    statement181 = statement();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_statement.Add(statement181.Tree);

                                }
                                break;

                            default:
                                goto loop40;
                        }
                    } while (true);

                loop40:
                    ;	// Stops C# compiler whinging that label 'loop40' has no statements


                    // AST REWRITE
                    // elements:          statement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 478:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:478:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:478:42: ( statement )*
                                while (stream_statement.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_statement.Next());

                                }
                                stream_statement.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 57, switchStatementList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end switchStatementList

        public class forEachStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forEachStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) ;
        public forEachStatement_return forEachStatement() // throws RecognitionException [1]
        {
            forEachStatement_return retval = new forEachStatement_return();
            retval.start = input.LT(1);
            int forEachStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken f = null;
            IToken EACH182 = null;
            IToken LPAREN183 = null;
            IToken RPAREN185 = null;
            forInClause_return forInClause184 = null;

            statement_return statement186 = null;


            CommonTree f_tree = null;
            CommonTree EACH182_tree = null;
            CommonTree LPAREN183_tree = null;
            CommonTree RPAREN185_tree = null;
            RewriteRuleTokenStream stream_EACH = new RewriteRuleTokenStream(adaptor, "token EACH");
            RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor, "token FOR");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor, "rule forInClause");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 58))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:482:4: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:482:4: f= FOR EACH LPAREN forInClause RPAREN statement
                {
                    f = (IToken)input.LT(1);
                    Match(input, FOR, FOLLOW_FOR_in_forEachStatement2017); if (failed) return retval;
                    if (backtracking == 0) stream_FOR.Add(f);

                    EACH182 = (IToken)input.LT(1);
                    Match(input, EACH, FOLLOW_EACH_in_forEachStatement2019); if (failed) return retval;
                    if (backtracking == 0) stream_EACH.Add(EACH182);

                    LPAREN183 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_forEachStatement2023); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN183);

                    PushFollow(FOLLOW_forInClause_in_forEachStatement2027);
                    forInClause184 = forInClause();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_forInClause.Add(forInClause184.Tree);
                    RPAREN185 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_forEachStatement2031); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN185);

                    PushFollow(FOLLOW_statement_in_forEachStatement2035);
                    statement186 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_statement.Add(statement186.Tree);

                    // AST REWRITE
                    // elements:          forInClause, statement
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 487:3: -> ^( FOR_EACH[$f] forInClause statement )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:487:6: ^( FOR_EACH[$f] forInClause statement )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_EACH, f), root_1);

                                adaptor.AddChild(root_1, stream_forInClause.Next());
                                adaptor.AddChild(root_1, stream_statement.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 58, forEachStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end forEachStatement

        public class forStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:490:1: forStatement : f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) ;
        public forStatement_return forStatement() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forStatement_return retval = new forStatement_return();
            retval.start = input.LT(1);
            int forStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken f = null;
            IToken LPAREN187 = null;
            IToken RPAREN189 = null;
            IToken RPAREN192 = null;
            forInClause_return forInClause188 = null;

            statement_return statement190 = null;

            traditionalForClause_return traditionalForClause191 = null;

            statement_return statement193 = null;


            CommonTree f_tree = null;
            CommonTree LPAREN187_tree = null;
            CommonTree RPAREN189_tree = null;
            CommonTree RPAREN192_tree = null;
            RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor, "token FOR");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor, "rule statement");
            RewriteRuleSubtreeStream stream_traditionalForClause = new RewriteRuleSubtreeStream(adaptor, "rule traditionalForClause");
            RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor, "rule forInClause");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 59))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:495:4: (f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:495:4: f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
                {
                    f = (IToken)input.LT(1);
                    Match(input, FOR, FOLLOW_FOR_in_forStatement2071); if (failed) return retval;
                    if (backtracking == 0) stream_FOR.Add(f);

                    LPAREN187 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_forStatement2075); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN187);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
                    int alt41 = 2;
                    switch (input.LA(1))
                    {
                        case VAR:
                        case CONST:
                            {
                                switch (input.LA(2))
                                {
                                    case IDENT:
                                        {
                                            int LA41_36 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s36 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 36, input);

                                                throw nvae_d41s36;
                                            }
                                        }
                                        break;
                                    case USE:
                                        {
                                            int LA41_37 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s37 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 37, input);

                                                throw nvae_d41s37;
                                            }
                                        }
                                        break;
                                    case XML:
                                        {
                                            int LA41_38 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s38 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 38, input);

                                                throw nvae_d41s38;
                                            }
                                        }
                                        break;
                                    case DYNAMIC:
                                        {
                                            int LA41_39 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s39 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 39, input);

                                                throw nvae_d41s39;
                                            }
                                        }
                                        break;
                                    case NAMESPACE:
                                        {
                                            int LA41_40 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s40 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 40, input);

                                                throw nvae_d41s40;
                                            }
                                        }
                                        break;
                                    case IS:
                                        {
                                            int LA41_41 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s41 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 41, input);

                                                throw nvae_d41s41;
                                            }
                                        }
                                        break;
                                    case AS:
                                        {
                                            int LA41_42 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s42 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 42, input);

                                                throw nvae_d41s42;
                                            }
                                        }
                                        break;
                                    case GET:
                                        {
                                            int LA41_43 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s43 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 43, input);

                                                throw nvae_d41s43;
                                            }
                                        }
                                        break;
                                    case SET:
                                        {
                                            int LA41_44 = input.LA(3);

                                            if ((synpred64()))
                                            {
                                                alt41 = 1;
                                            }
                                            else if ((true))
                                            {
                                                alt41 = 2;
                                            }
                                            else
                                            {
                                                if (backtracking > 0) { failed = true; return retval; }
                                                NoViableAltException nvae_d41s44 =
                                                    new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 44, input);

                                                throw nvae_d41s44;
                                            }
                                        }
                                        break;
                                    default:
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s1 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 1, input);

                                        throw nvae_d41s1;
                                }

                            }
                            break;
                        case IDENT:
                            {
                                int LA41_2 = input.LA(2);

                                if ((LA41_2 == SEMI || LA41_2 == COMMA || (LA41_2 >= ASSIGN && LA41_2 <= LPAREN) || (LA41_2 >= STAR && LA41_2 <= DBL_COLON) || LA41_2 == LBRACK || (LA41_2 >= STAR_ASSIGN && LA41_2 <= DEC) || LA41_2 == E4X_DESC || (LA41_2 >= 181 && LA41_2 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else if ((LA41_2 == IN))
                                {
                                    int LA41_54 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s54 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 54, input);

                                        throw nvae_d41s54;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s2 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 2, input);

                                    throw nvae_d41s2;
                                }
                            }
                            break;
                        case USE:
                            {
                                int LA41_3 = input.LA(2);

                                if ((LA41_3 == IN))
                                {
                                    int LA41_73 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s73 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 73, input);

                                        throw nvae_d41s73;
                                    }
                                }
                                else if ((LA41_3 == SEMI || LA41_3 == COMMA || (LA41_3 >= ASSIGN && LA41_3 <= LPAREN) || (LA41_3 >= STAR && LA41_3 <= DOT) || LA41_3 == LBRACK || (LA41_3 >= STAR_ASSIGN && LA41_3 <= DEC) || LA41_3 == E4X_DESC || (LA41_3 >= 181 && LA41_3 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s3 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 3, input);

                                    throw nvae_d41s3;
                                }
                            }
                            break;
                        case XML:
                            {
                                int LA41_4 = input.LA(2);

                                if ((LA41_4 == IN))
                                {
                                    int LA41_100 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s100 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 100, input);

                                        throw nvae_d41s100;
                                    }
                                }
                                else if ((LA41_4 == SEMI || LA41_4 == COMMA || (LA41_4 >= ASSIGN && LA41_4 <= LPAREN) || (LA41_4 >= STAR && LA41_4 <= DOT) || LA41_4 == LBRACK || (LA41_4 >= STAR_ASSIGN && LA41_4 <= DEC) || LA41_4 == E4X_DESC || (LA41_4 >= 181 && LA41_4 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s4 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 4, input);

                                    throw nvae_d41s4;
                                }
                            }
                            break;
                        case DYNAMIC:
                            {
                                int LA41_5 = input.LA(2);

                                if ((LA41_5 == SEMI || LA41_5 == COMMA || (LA41_5 >= ASSIGN && LA41_5 <= LPAREN) || (LA41_5 >= STAR && LA41_5 <= DOT) || LA41_5 == LBRACK || (LA41_5 >= STAR_ASSIGN && LA41_5 <= DEC) || LA41_5 == E4X_DESC || (LA41_5 >= 181 && LA41_5 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else if ((LA41_5 == IN))
                                {
                                    int LA41_136 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s136 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 136, input);

                                        throw nvae_d41s136;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s5 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 5, input);

                                    throw nvae_d41s5;
                                }
                            }
                            break;
                        case NAMESPACE:
                            {
                                int LA41_6 = input.LA(2);

                                if ((LA41_6 == IN))
                                {
                                    int LA41_154 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s154 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 154, input);

                                        throw nvae_d41s154;
                                    }
                                }
                                else if ((LA41_6 == SEMI || LA41_6 == COMMA || (LA41_6 >= ASSIGN && LA41_6 <= LPAREN) || (LA41_6 >= STAR && LA41_6 <= DOT) || LA41_6 == LBRACK || (LA41_6 >= STAR_ASSIGN && LA41_6 <= DEC) || LA41_6 == E4X_DESC || (LA41_6 >= 181 && LA41_6 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s6 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 6, input);

                                    throw nvae_d41s6;
                                }
                            }
                            break;
                        case IS:
                            {
                                int LA41_7 = input.LA(2);

                                if ((LA41_7 == IN))
                                {
                                    int LA41_181 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s181 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 181, input);

                                        throw nvae_d41s181;
                                    }
                                }
                                else if ((LA41_7 == SEMI || LA41_7 == COMMA || (LA41_7 >= ASSIGN && LA41_7 <= LPAREN) || (LA41_7 >= STAR && LA41_7 <= DOT) || LA41_7 == LBRACK || (LA41_7 >= STAR_ASSIGN && LA41_7 <= DEC) || LA41_7 == E4X_DESC || (LA41_7 >= 181 && LA41_7 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s7 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 7, input);

                                    throw nvae_d41s7;
                                }
                            }
                            break;
                        case AS:
                            {
                                int LA41_8 = input.LA(2);

                                if ((LA41_8 == SEMI || LA41_8 == COMMA || (LA41_8 >= ASSIGN && LA41_8 <= LPAREN) || (LA41_8 >= STAR && LA41_8 <= DOT) || LA41_8 == LBRACK || (LA41_8 >= STAR_ASSIGN && LA41_8 <= DEC) || LA41_8 == E4X_DESC || (LA41_8 >= 181 && LA41_8 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else if ((LA41_8 == IN))
                                {
                                    int LA41_217 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s217 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 217, input);

                                        throw nvae_d41s217;
                                    }
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s8 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 8, input);

                                    throw nvae_d41s8;
                                }
                            }
                            break;
                        case GET:
                            {
                                int LA41_9 = input.LA(2);

                                if ((LA41_9 == IN))
                                {
                                    int LA41_235 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s235 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 235, input);

                                        throw nvae_d41s235;
                                    }
                                }
                                else if ((LA41_9 == SEMI || LA41_9 == COMMA || (LA41_9 >= ASSIGN && LA41_9 <= LPAREN) || (LA41_9 >= STAR && LA41_9 <= DOT) || LA41_9 == LBRACK || (LA41_9 >= STAR_ASSIGN && LA41_9 <= DEC) || LA41_9 == E4X_DESC || (LA41_9 >= 181 && LA41_9 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s9 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 9, input);

                                    throw nvae_d41s9;
                                }
                            }
                            break;
                        case SET:
                            {
                                int LA41_10 = input.LA(2);

                                if ((LA41_10 == IN))
                                {
                                    int LA41_262 = input.LA(3);

                                    if ((synpred64()))
                                    {
                                        alt41 = 1;
                                    }
                                    else if ((true))
                                    {
                                        alt41 = 2;
                                    }
                                    else
                                    {
                                        if (backtracking > 0) { failed = true; return retval; }
                                        NoViableAltException nvae_d41s262 =
                                            new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 262, input);

                                        throw nvae_d41s262;
                                    }
                                }
                                else if ((LA41_10 == SEMI || LA41_10 == COMMA || (LA41_10 >= ASSIGN && LA41_10 <= LPAREN) || (LA41_10 >= STAR && LA41_10 <= DOT) || LA41_10 == LBRACK || (LA41_10 >= STAR_ASSIGN && LA41_10 <= DEC) || LA41_10 == E4X_DESC || (LA41_10 >= 181 && LA41_10 <= 182)))
                                {
                                    alt41 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d41s10 =
                                        new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 10, input);

                                    throw nvae_d41s10;
                                }
                            }
                            break;
                        case LCURLY:
                        case SEMI:
                        case STRING_LITERAL:
                        case FUNCTION:
                        case LPAREN:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case LBRACK:
                        case LT:
                        case PLUS:
                        case MINUS:
                        case DIV:
                        case INC:
                        case DEC:
                        case DELETE:
                        case TYPEOF:
                        case LNOT:
                        case BNOT:
                        case E4X_ATTRI:
                        case UNDEFINED:
                        case TRUE:
                        case FALSE:
                        case NULL:
                        case HEX_LITERAL:
                        case DECIMAL_LITERAL:
                        case OCTAL_LITERAL:
                        case FLOAT_LITERAL:
                        case NEW:
                        case 175:
                            {
                                alt41 = 2;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d41s0 =
                                new NoViableAltException("497:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 41, 0, input);

                            throw nvae_d41s0;
                    }

                    switch (alt41)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:5: ( forInClauseDecl IN )=> forInClause RPAREN statement
                            {
                                PushFollow(FOLLOW_forInClause_in_forStatement2087);
                                forInClause188 = forInClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_forInClause.Add(forInClause188.Tree);
                                RPAREN189 = (IToken)input.LT(1);
                                Match(input, RPAREN, FOLLOW_RPAREN_in_forStatement2089); if (failed) return retval;
                                if (backtracking == 0) stream_RPAREN.Add(RPAREN189);

                                PushFollow(FOLLOW_statement_in_forStatement2091);
                                statement190 = statement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_statement.Add(statement190.Tree);

                                // AST REWRITE
                                // elements:          statement, forInClause
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 498:4: -> ^( FOR_IN[$f] forInClause statement )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:498:7: ^( FOR_IN[$f] forInClause statement )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_IN, f), root_1);

                                            adaptor.AddChild(root_1, stream_forInClause.Next());
                                            adaptor.AddChild(root_1, stream_statement.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:5: traditionalForClause RPAREN statement
                            {
                                PushFollow(FOLLOW_traditionalForClause_in_forStatement2112);
                                traditionalForClause191 = traditionalForClause();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_traditionalForClause.Add(traditionalForClause191.Tree);
                                RPAREN192 = (IToken)input.LT(1);
                                Match(input, RPAREN, FOLLOW_RPAREN_in_forStatement2114); if (failed) return retval;
                                if (backtracking == 0) stream_RPAREN.Add(RPAREN192);

                                PushFollow(FOLLOW_statement_in_forStatement2116);
                                statement193 = statement();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_statement.Add(statement193.Tree);

                                // AST REWRITE
                                // elements:          traditionalForClause, f, statement
                                // token labels:      f
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleTokenStream stream_f = new RewriteRuleTokenStream(adaptor, "token f", f);
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 501:4: -> ^( $f traditionalForClause statement )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:501:7: ^( $f traditionalForClause statement )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(stream_f.Next(), root_1);

                                            adaptor.AddChild(root_1, stream_traditionalForClause.Next());
                                            adaptor.AddChild(root_1, stream_statement.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 59, forStatement_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forStatement

        public class traditionalForClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start traditionalForClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:505:1: traditionalForClause : a= forInit SEMI b= forCond SEMI c= forIter ;
        public traditionalForClause_return traditionalForClause() // throws RecognitionException [1]
        {
            traditionalForClause_return retval = new traditionalForClause_return();
            retval.start = input.LT(1);
            int traditionalForClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken SEMI194 = null;
            IToken SEMI195 = null;
            forInit_return a = null;

            forCond_return b = null;

            forIter_return c = null;


            CommonTree SEMI194_tree = null;
            CommonTree SEMI195_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 60))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:4: (a= forInit SEMI b= forCond SEMI c= forIter )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:506:4: a= forInit SEMI b= forCond SEMI c= forIter
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_forInit_in_traditionalForClause2147);
                    a = forInit();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, a.Tree);
                    SEMI194 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_traditionalForClause2149); if (failed) return retval;
                    PushFollow(FOLLOW_forCond_in_traditionalForClause2157);
                    b = forCond();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, b.Tree);
                    SEMI195 = (IToken)input.LT(1);
                    Match(input, SEMI, FOLLOW_SEMI_in_traditionalForClause2159); if (failed) return retval;
                    PushFollow(FOLLOW_forIter_in_traditionalForClause2167);
                    c = forIter();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, c.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 60, traditionalForClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end traditionalForClause

        public class forInClause_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClause
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:511:1: forInClause : forInClauseDecl IN forInClauseTail ;
        public forInClause_return forInClause() // throws RecognitionException [1]
        {
            forInClause_return retval = new forInClause_return();
            retval.start = input.LT(1);
            int forInClause_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IN197 = null;
            forInClauseDecl_return forInClauseDecl196 = null;

            forInClauseTail_return forInClauseTail198 = null;


            CommonTree IN197_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 61))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:512:4: ( forInClauseDecl IN forInClauseTail )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:512:4: forInClauseDecl IN forInClauseTail
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_forInClauseDecl_in_forInClause2179);
                    forInClauseDecl196 = forInClauseDecl();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, forInClauseDecl196.Tree);
                    IN197 = (IToken)input.LT(1);
                    Match(input, IN, FOLLOW_IN_in_forInClause2181); if (failed) return retval;
                    PushFollow(FOLLOW_forInClauseTail_in_forInClause2184);
                    forInClauseTail198 = forInClauseTail();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, forInClauseTail198.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 61, forInClause_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end forInClause

        public class forInClauseDecl_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClauseDecl
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:515:1: forInClauseDecl : ( declaration | ident );
        public forInClauseDecl_return forInClauseDecl() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInClauseDecl_return retval = new forInClauseDecl_return();
            retval.start = input.LT(1);
            int forInClauseDecl_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration199 = null;

            ident_return ident200 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 62))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:520:4: ( declaration | ident )
                int alt42 = 2;
                int LA42_0 = input.LA(1);

                if (((LA42_0 >= VAR && LA42_0 <= CONST)))
                {
                    alt42 = 1;
                }
                else if (((LA42_0 >= GET && LA42_0 <= USE) || LA42_0 == XML || LA42_0 == IDENT || LA42_0 == DYNAMIC || (LA42_0 >= IS && LA42_0 <= AS)))
                {
                    alt42 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d42s0 =
                        new NoViableAltException("515:1: forInClauseDecl : ( declaration | ident );", 42, 0, input);

                    throw nvae_d42s0;
                }
                switch (alt42)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:520:4: declaration
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_declaration_in_forInClauseDecl2205);
                            declaration199 = declaration();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, declaration199.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:520:18: ident
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ident_in_forInClauseDecl2209);
                            ident200 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ident200.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 62, forInClauseDecl_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInClauseDecl

        public class forInClauseTail_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInClauseTail
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:524:1: forInClauseTail : expressionList ;
        public forInClauseTail_return forInClauseTail() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInClauseTail_return retval = new forInClauseTail_return();
            retval.start = input.LT(1);
            int forInClauseTail_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList201 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 63))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:529:4: ( expressionList )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:529:4: expressionList
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_expressionList_in_forInClauseTail2231);
                    expressionList201 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expressionList201.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 63, forInClauseTail_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInClauseTail

        public class forInit_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forInit
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:533:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
        public forInit_return forInit() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forInit_return retval = new forInit_return();
            retval.start = input.LT(1);
            int forInit_StartIndex = input.Index();
            CommonTree root_0 = null;

            declaration_return declaration202 = null;

            expressionList_return expressionList203 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");
            RewriteRuleSubtreeStream stream_declaration = new RewriteRuleSubtreeStream(adaptor, "rule declaration");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = false;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 64))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:4: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:4: ( declaration | expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:4: ( declaration | expressionList )?
                    int alt43 = 3;
                    int LA43_0 = input.LA(1);

                    if (((LA43_0 >= VAR && LA43_0 <= CONST)))
                    {
                        alt43 = 1;
                    }
                    else if ((LA43_0 == LCURLY || (LA43_0 >= STRING_LITERAL && LA43_0 <= USE) || LA43_0 == LPAREN || LA43_0 == XML || (LA43_0 >= IDENT && LA43_0 <= LBRACK) || LA43_0 == DYNAMIC || LA43_0 == LT || (LA43_0 >= IS && LA43_0 <= AS) || (LA43_0 >= PLUS && LA43_0 <= DIV) || (LA43_0 >= INC && LA43_0 <= BNOT) || (LA43_0 >= E4X_ATTRI && LA43_0 <= NEW) || LA43_0 == 175))
                    {
                        alt43 = 2;
                    }
                    switch (alt43)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:5: declaration
                            {
                                PushFollow(FOLLOW_declaration_in_forInit2255);
                                declaration202 = declaration();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_declaration.Add(declaration202.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:538:19: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forInit2259);
                                expressionList203 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList203.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          declaration, expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 539:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:539:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:539:17: ( declaration )?
                                if (stream_declaration.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_declaration.Next());

                                }
                                stream_declaration.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:539:30: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 64, forInit_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forInit

        public class forCond_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forCond
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
        public forCond_return forCond() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forCond_return retval = new forCond_return();
            retval.start = input.LT(1);
            int forCond_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList204 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 65))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:547:4: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:547:4: ( expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:547:4: ( expressionList )?
                    int alt44 = 2;
                    int LA44_0 = input.LA(1);

                    if ((LA44_0 == LCURLY || (LA44_0 >= STRING_LITERAL && LA44_0 <= USE) || LA44_0 == LPAREN || LA44_0 == XML || (LA44_0 >= IDENT && LA44_0 <= LBRACK) || LA44_0 == DYNAMIC || LA44_0 == LT || (LA44_0 >= IS && LA44_0 <= AS) || (LA44_0 >= PLUS && LA44_0 <= DIV) || (LA44_0 >= INC && LA44_0 <= BNOT) || (LA44_0 >= E4X_ATTRI && LA44_0 <= NEW) || LA44_0 == 175))
                    {
                        alt44 = 1;
                    }
                    switch (alt44)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forCond2297);
                                expressionList204 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList204.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 548:3: -> ^( FOR_CONDITION ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:548:6: ^( FOR_CONDITION ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:548:22: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 65, forCond_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forCond

        public class forIter_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start forIter
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
        public forIter_return forIter() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            forIter_return retval = new forIter_return();
            retval.start = input.LT(1);
            int forIter_StartIndex = input.Index();
            CommonTree root_0 = null;

            expressionList_return expressionList205 = null;


            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 66))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:556:4: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:556:4: ( expressionList )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:556:4: ( expressionList )?
                    int alt45 = 2;
                    int LA45_0 = input.LA(1);

                    if ((LA45_0 == LCURLY || (LA45_0 >= STRING_LITERAL && LA45_0 <= USE) || LA45_0 == LPAREN || LA45_0 == XML || (LA45_0 >= IDENT && LA45_0 <= LBRACK) || LA45_0 == DYNAMIC || LA45_0 == LT || (LA45_0 >= IS && LA45_0 <= AS) || (LA45_0 >= PLUS && LA45_0 <= DIV) || (LA45_0 >= INC && LA45_0 <= BNOT) || (LA45_0 >= E4X_ATTRI && LA45_0 <= NEW) || LA45_0 == 175))
                    {
                        alt45 = 1;
                    }
                    switch (alt45)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
                            {
                                PushFollow(FOLLOW_expressionList_in_forIter2330);
                                expressionList205 = expressionList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_expressionList.Add(expressionList205.Tree);

                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          expressionList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 557:3: -> ^( FOR_ITERATOR ( expressionList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:557:6: ^( FOR_ITERATOR ( expressionList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:557:21: ( expressionList )?
                                if (stream_expressionList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_expressionList.Next());

                                }
                                stream_expressionList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 66, forIter_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end forIter

        public class whileStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start whileStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:1: whileStatement : WHILE condition statement ;
        public whileStatement_return whileStatement() // throws RecognitionException [1]
        {
            whileStatement_return retval = new whileStatement_return();
            retval.start = input.LT(1);
            int whileStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken WHILE206 = null;
            condition_return condition207 = null;

            statement_return statement208 = null;


            CommonTree WHILE206_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 67))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:561:4: ( WHILE condition statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:561:4: WHILE condition statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    WHILE206 = (IToken)input.LT(1);
                    Match(input, WHILE, FOLLOW_WHILE_in_whileStatement2353); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        WHILE206_tree = (CommonTree)adaptor.Create(WHILE206);
                        root_0 = (CommonTree)adaptor.BecomeRoot(WHILE206_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_whileStatement2356);
                    condition207 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition207.Tree);
                    PushFollow(FOLLOW_statement_in_whileStatement2358);
                    statement208 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement208.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 67, whileStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end whileStatement

        public class doWhileStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start doWhileStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:1: doWhileStatement : DO statement WHILE condition semi ;
        public doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
        {
            doWhileStatement_return retval = new doWhileStatement_return();
            retval.start = input.LT(1);
            int doWhileStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DO209 = null;
            IToken WHILE211 = null;
            statement_return statement210 = null;

            condition_return condition212 = null;

            semi_return semi213 = null;


            CommonTree DO209_tree = null;
            CommonTree WHILE211_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 68))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:565:4: ( DO statement WHILE condition semi )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:565:4: DO statement WHILE condition semi
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    DO209 = (IToken)input.LT(1);
                    Match(input, DO, FOLLOW_DO_in_doWhileStatement2369); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        DO209_tree = (CommonTree)adaptor.Create(DO209);
                        root_0 = (CommonTree)adaptor.BecomeRoot(DO209_tree, root_0);
                    }
                    PushFollow(FOLLOW_statement_in_doWhileStatement2372);
                    statement210 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement210.Tree);
                    WHILE211 = (IToken)input.LT(1);
                    Match(input, WHILE, FOLLOW_WHILE_in_doWhileStatement2374); if (failed) return retval;
                    PushFollow(FOLLOW_condition_in_doWhileStatement2377);
                    condition212 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition212.Tree);
                    PushFollow(FOLLOW_semi_in_doWhileStatement2379);
                    semi213 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, semi213.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 68, doWhileStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end doWhileStatement

        public class withStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start withStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:1: withStatement : WITH condition statement ;
        public withStatement_return withStatement() // throws RecognitionException [1]
        {
            withStatement_return retval = new withStatement_return();
            retval.start = input.LT(1);
            int withStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken WITH214 = null;
            condition_return condition215 = null;

            statement_return statement216 = null;


            CommonTree WITH214_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 69))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:569:4: ( WITH condition statement )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:569:4: WITH condition statement
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    WITH214 = (IToken)input.LT(1);
                    Match(input, WITH, FOLLOW_WITH_in_withStatement2390); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        WITH214_tree = (CommonTree)adaptor.Create(WITH214);
                        root_0 = (CommonTree)adaptor.BecomeRoot(WITH214_tree, root_0);
                    }
                    PushFollow(FOLLOW_condition_in_withStatement2393);
                    condition215 = condition();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, condition215.Tree);
                    PushFollow(FOLLOW_statement_in_withStatement2395);
                    statement216 = statement();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, statement216.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 69, withStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end withStatement

        public class defaultXMLNamespaceStatement_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start defaultXMLNamespaceStatement
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
        public defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement() // throws RecognitionException [1]
        {
            defaultXMLNamespaceStatement_return retval = new defaultXMLNamespaceStatement_return();
            retval.start = input.LT(1);
            int defaultXMLNamespaceStatement_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DEFAULT217 = null;
            IToken XML218 = null;
            IToken NAMESPACE219 = null;
            IToken ASSIGN220 = null;
            expression_return expression221 = null;

            semi_return semi222 = null;


            CommonTree DEFAULT217_tree = null;
            CommonTree XML218_tree = null;
            CommonTree NAMESPACE219_tree = null;
            CommonTree ASSIGN220_tree = null;
            RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor, "token XML");
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleTokenStream stream_DEFAULT = new RewriteRuleTokenStream(adaptor, "token DEFAULT");
            RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor, "token ASSIGN");
            RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor, "rule semi");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 70))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:573:4: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:573:4: DEFAULT XML NAMESPACE ASSIGN expression semi
                {
                    DEFAULT217 = (IToken)input.LT(1);
                    Match(input, DEFAULT, FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2406); if (failed) return retval;
                    if (backtracking == 0) stream_DEFAULT.Add(DEFAULT217);

                    XML218 = (IToken)input.LT(1);
                    Match(input, XML, FOLLOW_XML_in_defaultXMLNamespaceStatement2408); if (failed) return retval;
                    if (backtracking == 0) stream_XML.Add(XML218);

                    NAMESPACE219 = (IToken)input.LT(1);
                    Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2410); if (failed) return retval;
                    if (backtracking == 0) stream_NAMESPACE.Add(NAMESPACE219);

                    ASSIGN220 = (IToken)input.LT(1);
                    Match(input, ASSIGN, FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2412); if (failed) return retval;
                    if (backtracking == 0) stream_ASSIGN.Add(ASSIGN220);

                    PushFollow(FOLLOW_expression_in_defaultXMLNamespaceStatement2414);
                    expression221 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_expression.Add(expression221.Tree);
                    PushFollow(FOLLOW_semi_in_defaultXMLNamespaceStatement2416);
                    semi222 = semi();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_semi.Add(semi222.Tree);

                    // AST REWRITE
                    // elements:          expression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 574:3: -> ^( DEFAULT_XML_NAMESPACE expression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:574:6: ^( DEFAULT_XML_NAMESPACE expression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);

                                adaptor.AddChild(root_1, stream_expression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 70, defaultXMLNamespaceStatement_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end defaultXMLNamespaceStatement

        public class typeExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start typeExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:577:1: typeExpression : c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) ;
        public typeExpression_return typeExpression() // throws RecognitionException [1]
        {
            typeExpression_return retval = new typeExpression_return();
            retval.start = input.LT(1);
            int typeExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken c = null;
            IToken string_literal224 = null;
            IToken STAR225 = null;
            identifier_return identifier223 = null;


            CommonTree c_tree = null;
            CommonTree string_literal224_tree = null;
            CommonTree STAR225_tree = null;
            RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor, "token STAR");
            RewriteRuleTokenStream stream_175 = new RewriteRuleTokenStream(adaptor, "token 175");
            RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor, "token COLON");
            RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor, "rule identifier");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 71))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:4: (c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:578:4: c= COLON ( identifier | 'void' | STAR )
                {
                    c = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_typeExpression2439); if (failed) return retval;
                    if (backtracking == 0) stream_COLON.Add(c);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:3: ( identifier | 'void' | STAR )
                    int alt46 = 3;
                    switch (input.LA(1))
                    {
                        case GET:
                        case SET:
                        case NAMESPACE:
                        case USE:
                        case XML:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case DYNAMIC:
                        case IS:
                        case AS:
                            {
                                alt46 = 1;
                            }
                            break;
                        case 175:
                            {
                                alt46 = 2;
                            }
                            break;
                        case STAR:
                            {
                                alt46 = 3;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d46s0 =
                                new NoViableAltException("580:3: ( identifier | 'void' | STAR )", 46, 0, input);

                            throw nvae_d46s0;
                    }

                    switch (alt46)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:4: identifier
                            {
                                PushFollow(FOLLOW_identifier_in_typeExpression2447);
                                identifier223 = identifier();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_identifier.Add(identifier223.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:17: 'void'
                            {
                                string_literal224 = (IToken)input.LT(1);
                                Match(input, 175, FOLLOW_175_in_typeExpression2451); if (failed) return retval;
                                if (backtracking == 0) stream_175.Add(string_literal224);


                            }
                            break;
                        case 3:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:26: STAR
                            {
                                STAR225 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_typeExpression2455); if (failed) return retval;
                                if (backtracking == 0) stream_STAR.Add(STAR225);


                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          STAR, 175, identifier
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 581:3: -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:6: ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_SPEC, c), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:22: ( identifier )?
                                if (stream_identifier.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_identifier.Next());

                                }
                                stream_identifier.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:34: ( 'void' )?
                                if (stream_175.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_175.Next());

                                }
                                stream_175.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:42: ( STAR )?
                                if (stream_STAR.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_STAR.Next());

                                }
                                stream_STAR.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 71, typeExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end typeExpression

        public class identifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start identifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:584:1: identifier : qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) ;
        public identifier_return identifier() // throws RecognitionException [1]
        {
            identifier_return retval = new identifier_return();
            retval.start = input.LT(1);
            int identifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT227 = null;
            qualifiedIdent_return qualifiedIdent226 = null;

            qualifiedIdent_return qualifiedIdent228 = null;


            CommonTree DOT227_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 72))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:585:4: ( qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:585:4: qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )*
                {
                    PushFollow(FOLLOW_qualifiedIdent_in_identifier2487);
                    qualifiedIdent226 = qualifiedIdent();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent226.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:586:3: ( options {greedy=true; } : DOT qualifiedIdent )*
                    do
                    {
                        int alt47 = 2;
                        int LA47_0 = input.LA(1);

                        if ((LA47_0 == DOT))
                        {
                            alt47 = 1;
                        }


                        switch (alt47)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:6: DOT qualifiedIdent
                                {
                                    DOT227 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_identifier2505); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT227);

                                    PushFollow(FOLLOW_qualifiedIdent_in_identifier2507);
                                    qualifiedIdent228 = qualifiedIdent();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent228.Tree);

                                }
                                break;

                            default:
                                goto loop47;
                        }
                    } while (true);

                loop47:
                    ;	// Stops C# compiler whinging that label 'loop47' has no statements


                    // AST REWRITE
                    // elements:          qualifiedIdent
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 589:3: -> ^( IDENTIFIER ( qualifiedIdent )+ )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:589:6: ^( IDENTIFIER ( qualifiedIdent )+ )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);

                                if (!(stream_qualifiedIdent.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_qualifiedIdent.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_qualifiedIdent.Next());

                                }
                                stream_qualifiedIdent.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 72, identifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end identifier

        public class qualifiedIdent_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start qualifiedIdent
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:592:1: qualifiedIdent : ( namespaceName DBL_COLON )? ident ;
        public qualifiedIdent_return qualifiedIdent() // throws RecognitionException [1]
        {
            qualifiedIdent_return retval = new qualifiedIdent_return();
            retval.start = input.LT(1);
            int qualifiedIdent_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DBL_COLON230 = null;
            namespaceName_return namespaceName229 = null;

            ident_return ident231 = null;


            CommonTree DBL_COLON230_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 73))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:593:4: ( ( namespaceName DBL_COLON )? ident )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:593:4: ( namespaceName DBL_COLON )? ident
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:593:4: ( namespaceName DBL_COLON )?
                    int alt48 = 2;
                    int LA48_0 = input.LA(1);

                    if ((LA48_0 == IDENT))
                    {
                        int LA48_1 = input.LA(2);

                        if ((LA48_1 == DBL_COLON))
                        {
                            alt48 = 1;
                        }
                    }
                    else if (((LA48_0 >= PUBLIC && LA48_0 <= INTERNAL)))
                    {
                        alt48 = 1;
                    }
                    switch (alt48)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:593:5: namespaceName DBL_COLON
                            {
                                PushFollow(FOLLOW_namespaceName_in_qualifiedIdent2535);
                                namespaceName229 = namespaceName();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, namespaceName229.Tree);
                                DBL_COLON230 = (IToken)input.LT(1);
                                Match(input, DBL_COLON, FOLLOW_DBL_COLON_in_qualifiedIdent2537); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    DBL_COLON230_tree = (CommonTree)adaptor.Create(DBL_COLON230);
                                    adaptor.AddChild(root_0, DBL_COLON230_tree);
                                }

                            }
                            break;

                    }

                    PushFollow(FOLLOW_ident_in_qualifiedIdent2541);
                    ident231 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, ident231.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 73, qualifiedIdent_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end qualifiedIdent

        public class namespaceName_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start namespaceName
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:1: namespaceName : ( IDENT | reservedNamespace );
        public namespaceName_return namespaceName() // throws RecognitionException [1]
        {
            namespaceName_return retval = new namespaceName_return();
            retval.start = input.LT(1);
            int namespaceName_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IDENT232 = null;
            reservedNamespace_return reservedNamespace233 = null;


            CommonTree IDENT232_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 74))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:597:4: ( IDENT | reservedNamespace )
                int alt49 = 2;
                int LA49_0 = input.LA(1);

                if ((LA49_0 == IDENT))
                {
                    alt49 = 1;
                }
                else if (((LA49_0 >= PUBLIC && LA49_0 <= INTERNAL)))
                {
                    alt49 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d49s0 =
                        new NoViableAltException("596:1: namespaceName : ( IDENT | reservedNamespace );", 49, 0, input);

                    throw nvae_d49s0;
                }
                switch (alt49)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:597:4: IDENT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IDENT232 = (IToken)input.LT(1);
                            Match(input, IDENT, FOLLOW_IDENT_in_namespaceName2553); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IDENT232_tree = (CommonTree)adaptor.Create(IDENT232);
                                adaptor.AddChild(root_0, IDENT232_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:597:12: reservedNamespace
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_reservedNamespace_in_namespaceName2557);
                            reservedNamespace233 = reservedNamespace();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, reservedNamespace233.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 74, namespaceName_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end namespaceName

        public class reservedNamespace_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start reservedNamespace
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:600:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
        public reservedNamespace_return reservedNamespace() // throws RecognitionException [1]
        {
            reservedNamespace_return retval = new reservedNamespace_return();
            retval.start = input.LT(1);
            int reservedNamespace_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set234 = null;

            CommonTree set234_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 75))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:601:4: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set234 = (IToken)input.LT(1);
                    if ((input.LA(1) >= PUBLIC && input.LA(1) <= INTERNAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set234));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_reservedNamespace0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 75, reservedNamespace_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end reservedNamespace

        public class identifierStar_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start identifierStar
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:607:1: identifierStar : ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) ;
        public identifierStar_return identifierStar() // throws RecognitionException [1]
        {
            identifierStar_return retval = new identifierStar_return();
            retval.start = input.LT(1);
            int identifierStar_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT236 = null;
            IToken DOT238 = null;
            IToken STAR239 = null;
            ident_return ident235 = null;

            ident_return ident237 = null;


            CommonTree DOT236_tree = null;
            CommonTree DOT238_tree = null;
            CommonTree STAR239_tree = null;
            RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor, "token STAR");
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 76))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:608:4: ( ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:608:4: ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )?
                {
                    PushFollow(FOLLOW_ident_in_identifierStar2594);
                    ident235 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident235.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:609:3: ( options {greedy=true; } : DOT ident )*
                    do
                    {
                        int alt50 = 2;
                        int LA50_0 = input.LA(1);

                        if ((LA50_0 == DOT))
                        {
                            int LA50_1 = input.LA(2);

                            if (((LA50_1 >= GET && LA50_1 <= USE) || LA50_1 == XML || LA50_1 == IDENT || LA50_1 == DYNAMIC || (LA50_1 >= IS && LA50_1 <= AS)))
                            {
                                alt50 = 1;
                            }


                        }


                        switch (alt50)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:610:5: DOT ident
                                {
                                    DOT236 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_identifierStar2611); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT236);

                                    PushFollow(FOLLOW_ident_in_identifierStar2613);
                                    ident237 = ident();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_ident.Add(ident237.Tree);

                                }
                                break;

                            default:
                                goto loop50;
                        }
                    } while (true);

                loop50:
                    ;	// Stops C# compiler whinging that label 'loop50' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:3: ( DOT STAR )?
                    int alt51 = 2;
                    int LA51_0 = input.LA(1);

                    if ((LA51_0 == DOT))
                    {
                        alt51 = 1;
                    }
                    switch (alt51)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:5: DOT STAR
                            {
                                DOT238 = (IToken)input.LT(1);
                                Match(input, DOT, FOLLOW_DOT_in_identifierStar2625); if (failed) return retval;
                                if (backtracking == 0) stream_DOT.Add(DOT238);

                                STAR239 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_identifierStar2627); if (failed) return retval;
                                if (backtracking == 0) stream_STAR.Add(STAR239);


                            }
                            break;

                    }


                    // AST REWRITE
                    // elements:          STAR, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 614:3: -> ^( IDENTIFIER ( ident )+ ( STAR )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:614:6: ^( IDENTIFIER ( ident )+ ( STAR )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);

                                if (!(stream_ident.HasNext()))
                                {
                                    throw new RewriteEarlyExitException();
                                }
                                while (stream_ident.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_ident.Next());

                                }
                                stream_ident.Reset();
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:614:26: ( STAR )?
                                if (stream_STAR.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_STAR.Next());

                                }
                                stream_STAR.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 76, identifierStar_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end identifierStar

        public class annotations_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotations
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:617:1: annotations : ( annotation | includeDirective )* -> ^( ANNOTATIONS ( annotation )* ) ;
        public annotations_return annotations() // throws RecognitionException [1]
        {
            annotations_return retval = new annotations_return();
            retval.start = input.LT(1);
            int annotations_StartIndex = input.Index();
            CommonTree root_0 = null;

            annotation_return annotation240 = null;

            includeDirective_return includeDirective241 = null;


            RewriteRuleSubtreeStream stream_includeDirective = new RewriteRuleSubtreeStream(adaptor, "rule includeDirective");
            RewriteRuleSubtreeStream stream_annotation = new RewriteRuleSubtreeStream(adaptor, "rule annotation");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 77))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:4: ( ( annotation | includeDirective )* -> ^( ANNOTATIONS ( annotation )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:4: ( annotation | includeDirective )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:4: ( annotation | includeDirective )*
                    do
                    {
                        int alt52 = 3;
                        int LA52_0 = input.LA(1);

                        if ((LA52_0 == LBRACK))
                        {
                            alt52 = 1;
                        }
                        else if ((LA52_0 == 170))
                        {
                            alt52 = 2;
                        }


                        switch (alt52)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:618:6: annotation
                                {
                                    PushFollow(FOLLOW_annotation_in_annotations2659);
                                    annotation240 = annotation();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_annotation.Add(annotation240.Tree);

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:619:5: includeDirective
                                {
                                    PushFollow(FOLLOW_includeDirective_in_annotations2665);
                                    includeDirective241 = includeDirective();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_includeDirective.Add(includeDirective241.Tree);

                                }
                                break;

                            default:
                                goto loop52;
                        }
                    } while (true);

                loop52:
                    ;	// Stops C# compiler whinging that label 'loop52' has no statements


                    // AST REWRITE
                    // elements:          annotation
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 621:3: -> ^( ANNOTATIONS ( annotation )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:6: ^( ANNOTATIONS ( annotation )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATIONS, "ANNOTATIONS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:20: ( annotation )*
                                while (stream_annotation.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotation.Next());

                                }
                                stream_annotation.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 77, annotations_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotations

        public class annotation_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotation
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:624:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
        public annotation_return annotation() // throws RecognitionException [1]
        {
            annotation_return retval = new annotation_return();
            retval.start = input.LT(1);
            int annotation_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK242 = null;
            IToken RBRACK245 = null;
            ident_return ident243 = null;

            annotationParamList_return annotationParamList244 = null;


            CommonTree LBRACK242_tree = null;
            CommonTree RBRACK245_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleSubtreeStream stream_annotationParamList = new RewriteRuleSubtreeStream(adaptor, "rule annotationParamList");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 78))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:625:4: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:625:4: LBRACK ident ( annotationParamList )? RBRACK
                {
                    LBRACK242 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_annotation2692); if (failed) return retval;
                    if (backtracking == 0) stream_LBRACK.Add(LBRACK242);

                    PushFollow(FOLLOW_ident_in_annotation2696);
                    ident243 = ident();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_ident.Add(ident243.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:627:3: ( annotationParamList )?
                    int alt53 = 2;
                    int LA53_0 = input.LA(1);

                    if ((LA53_0 == LPAREN))
                    {
                        alt53 = 1;
                    }
                    switch (alt53)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotationParamList
                            {
                                PushFollow(FOLLOW_annotationParamList_in_annotation2700);
                                annotationParamList244 = annotationParamList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_annotationParamList.Add(annotationParamList244.Tree);

                            }
                            break;

                    }

                    RBRACK245 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_annotation2705); if (failed) return retval;
                    if (backtracking == 0) stream_RBRACK.Add(RBRACK245);


                    // AST REWRITE
                    // elements:          annotationParamList, ident
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 629:3: -> ^( ANNOTATION ident ( annotationParamList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:629:6: ^( ANNOTATION ident ( annotationParamList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);

                                adaptor.AddChild(root_1, stream_ident.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:629:25: ( annotationParamList )?
                                if (stream_annotationParamList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotationParamList.Next());

                                }
                                stream_annotationParamList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 78, annotation_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotation

        public class annotationParamList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotationParamList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:632:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
        public annotationParamList_return annotationParamList() // throws RecognitionException [1]
        {
            annotationParamList_return retval = new annotationParamList_return();
            retval.start = input.LT(1);
            int annotationParamList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN246 = null;
            IToken COMMA248 = null;
            IToken RPAREN250 = null;
            annotationParam_return annotationParam247 = null;

            annotationParam_return annotationParam249 = null;


            CommonTree LPAREN246_tree = null;
            CommonTree COMMA248_tree = null;
            CommonTree RPAREN250_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_annotationParam = new RewriteRuleSubtreeStream(adaptor, "rule annotationParam");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 79))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:634:3: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:634:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
                {
                    LPAREN246 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_annotationParamList2731); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN246);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:635:3: ( annotationParam ( COMMA annotationParam )* )?
                    int alt55 = 2;
                    int LA55_0 = input.LA(1);

                    if ((LA55_0 == STRING_LITERAL || (LA55_0 >= GET && LA55_0 <= USE) || LA55_0 == XML || LA55_0 == IDENT || LA55_0 == DYNAMIC || LA55_0 == LT || (LA55_0 >= IS && LA55_0 <= AS) || LA55_0 == DIV || (LA55_0 >= TRUE && LA55_0 <= FLOAT_LITERAL)))
                    {
                        alt55 = 1;
                    }
                    switch (alt55)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:635:5: annotationParam ( COMMA annotationParam )*
                            {
                                PushFollow(FOLLOW_annotationParam_in_annotationParamList2737);
                                annotationParam247 = annotationParam();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_annotationParam.Add(annotationParam247.Tree);
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:636:4: ( COMMA annotationParam )*
                                do
                                {
                                    int alt54 = 2;
                                    int LA54_0 = input.LA(1);

                                    if ((LA54_0 == COMMA))
                                    {
                                        alt54 = 1;
                                    }


                                    switch (alt54)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:636:5: COMMA annotationParam
                                            {
                                                COMMA248 = (IToken)input.LT(1);
                                                Match(input, COMMA, FOLLOW_COMMA_in_annotationParamList2743); if (failed) return retval;
                                                if (backtracking == 0) stream_COMMA.Add(COMMA248);

                                                PushFollow(FOLLOW_annotationParam_in_annotationParamList2745);
                                                annotationParam249 = annotationParam();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) stream_annotationParam.Add(annotationParam249.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop54;
                                    }
                                } while (true);

                            loop54:
                                ;	// Stops C# compiler whinging that label 'loop54' has no statements


                            }
                            break;

                    }

                    RPAREN250 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_annotationParamList2756); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN250);


                    // AST REWRITE
                    // elements:          annotationParam
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 639:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:639:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:639:26: ( annotationParam )*
                                while (stream_annotationParam.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_annotationParam.Next());

                                }
                                stream_annotationParam.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 79, annotationParamList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotationParamList

        public class annotationParam_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start annotationParam
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );
        public annotationParam_return annotationParam() // throws RecognitionException [1]
        {
            annotationParam_return retval = new annotationParam_return();
            retval.start = input.LT(1);
            int annotationParam_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken ASSIGN252 = null;
            ident_return ident251 = null;

            constant_return constant253 = null;

            constant_return constant254 = null;

            ident_return ident255 = null;


            CommonTree ASSIGN252_tree = null;
            RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor, "token ASSIGN");
            RewriteRuleSubtreeStream stream_constant = new RewriteRuleSubtreeStream(adaptor, "rule constant");
            RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor, "rule ident");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 80))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:3: ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident )
                int alt56 = 3;
                switch (input.LA(1))
                {
                    case IDENT:
                        {
                            int LA56_1 = input.LA(2);

                            if ((LA56_1 == EOF || LA56_1 == COMMA || LA56_1 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_1 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s1 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 1, input);

                                throw nvae_d56s1;
                            }
                        }
                        break;
                    case USE:
                        {
                            int LA56_2 = input.LA(2);

                            if ((LA56_2 == EOF || LA56_2 == COMMA || LA56_2 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_2 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s2 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 2, input);

                                throw nvae_d56s2;
                            }
                        }
                        break;
                    case XML:
                        {
                            int LA56_3 = input.LA(2);

                            if ((LA56_3 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else if ((LA56_3 == EOF || LA56_3 == COMMA || LA56_3 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s3 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 3, input);

                                throw nvae_d56s3;
                            }
                        }
                        break;
                    case DYNAMIC:
                        {
                            int LA56_4 = input.LA(2);

                            if ((LA56_4 == EOF || LA56_4 == COMMA || LA56_4 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_4 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s4 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 4, input);

                                throw nvae_d56s4;
                            }
                        }
                        break;
                    case NAMESPACE:
                        {
                            int LA56_5 = input.LA(2);

                            if ((LA56_5 == EOF || LA56_5 == COMMA || LA56_5 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_5 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s5 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 5, input);

                                throw nvae_d56s5;
                            }
                        }
                        break;
                    case IS:
                        {
                            int LA56_6 = input.LA(2);

                            if ((LA56_6 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else if ((LA56_6 == EOF || LA56_6 == COMMA || LA56_6 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s6 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 6, input);

                                throw nvae_d56s6;
                            }
                        }
                        break;
                    case AS:
                        {
                            int LA56_7 = input.LA(2);

                            if ((LA56_7 == EOF || LA56_7 == COMMA || LA56_7 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_7 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s7 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 7, input);

                                throw nvae_d56s7;
                            }
                        }
                        break;
                    case GET:
                        {
                            int LA56_8 = input.LA(2);

                            if ((LA56_8 == EOF || LA56_8 == COMMA || LA56_8 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else if ((LA56_8 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s8 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 8, input);

                                throw nvae_d56s8;
                            }
                        }
                        break;
                    case SET:
                        {
                            int LA56_9 = input.LA(2);

                            if ((LA56_9 == ASSIGN))
                            {
                                alt56 = 1;
                            }
                            else if ((LA56_9 == EOF || LA56_9 == COMMA || LA56_9 == RPAREN))
                            {
                                alt56 = 3;
                            }
                            else
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                NoViableAltException nvae_d56s9 =
                                    new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 9, input);

                                throw nvae_d56s9;
                            }
                        }
                        break;
                    case STRING_LITERAL:
                    case LT:
                    case DIV:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt56 = 2;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d56s0 =
                            new NoViableAltException("653:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );", 56, 0, input);

                        throw nvae_d56s0;
                }

                switch (alt56)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:3: ident ASSIGN constant
                        {
                            PushFollow(FOLLOW_ident_in_annotationParam2783);
                            ident251 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_ident.Add(ident251.Tree);
                            ASSIGN252 = (IToken)input.LT(1);
                            Match(input, ASSIGN, FOLLOW_ASSIGN_in_annotationParam2785); if (failed) return retval;
                            if (backtracking == 0) stream_ASSIGN.Add(ASSIGN252);

                            PushFollow(FOLLOW_constant_in_annotationParam2787);
                            constant253 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_constant.Add(constant253.Tree);

                            // AST REWRITE
                            // elements:          constant, ASSIGN, ident
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 655:25: -> ^( ASSIGN ident constant )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:655:28: ^( ASSIGN ident constant )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_ident.Next());
                                        adaptor.AddChild(root_1, stream_constant.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:656:4: constant
                        {
                            PushFollow(FOLLOW_constant_in_annotationParam2802);
                            constant254 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_constant.Add(constant254.Tree);

                            // AST REWRITE
                            // elements:          constant
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 656:13: -> constant
                                {
                                    adaptor.AddChild(root_0, stream_constant.Next());

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:657:4: ident
                        {
                            PushFollow(FOLLOW_ident_in_annotationParam2811);
                            ident255 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_ident.Add(ident255.Tree);

                            // AST REWRITE
                            // elements:          ident
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 657:10: -> ident
                                {
                                    adaptor.AddChild(root_0, stream_ident.Next());

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 80, annotationParam_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end annotationParam

        public class modifiers_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start modifiers
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:660:1: modifiers : ( modifier )* -> ^( MODIFIERS ( modifier )* ) ;
        public modifiers_return modifiers() // throws RecognitionException [1]
        {
            modifiers_return retval = new modifiers_return();
            retval.start = input.LT(1);
            int modifiers_StartIndex = input.Index();
            CommonTree root_0 = null;

            modifier_return modifier256 = null;


            RewriteRuleSubtreeStream stream_modifier = new RewriteRuleSubtreeStream(adaptor, "rule modifier");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 81))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:661:4: ( ( modifier )* -> ^( MODIFIERS ( modifier )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:661:4: ( modifier )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:661:4: ( modifier )*
                    do
                    {
                        int alt57 = 2;
                        int LA57_0 = input.LA(1);

                        if (((LA57_0 >= IDENT && LA57_0 <= INTERNAL) || (LA57_0 >= STATIC && LA57_0 <= DYNAMIC) || (LA57_0 >= 176 && LA57_0 <= 180)))
                        {
                            alt57 = 1;
                        }


                        switch (alt57)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: modifier
                                {
                                    PushFollow(FOLLOW_modifier_in_modifiers2826);
                                    modifier256 = modifier();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_modifier.Add(modifier256.Tree);

                                }
                                break;

                            default:
                                goto loop57;
                        }
                    } while (true);

                loop57:
                    ;	// Stops C# compiler whinging that label 'loop57' has no statements


                    // AST REWRITE
                    // elements:          modifier
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 662:3: -> ^( MODIFIERS ( modifier )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:662:6: ^( MODIFIERS ( modifier )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MODIFIERS, "MODIFIERS"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:662:18: ( modifier )*
                                while (stream_modifier.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_modifier.Next());

                                }
                                stream_modifier.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 81, modifiers_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end modifiers

        public class modifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start modifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
        public modifier_return modifier() // throws RecognitionException [1]
        {
            modifier_return retval = new modifier_return();
            retval.start = input.LT(1);
            int modifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STATIC258 = null;
            IToken string_literal259 = null;
            IToken string_literal260 = null;
            IToken string_literal261 = null;
            IToken string_literal262 = null;
            IToken DYNAMIC263 = null;
            IToken string_literal264 = null;
            namespaceName_return namespaceName257 = null;


            CommonTree STATIC258_tree = null;
            CommonTree string_literal259_tree = null;
            CommonTree string_literal260_tree = null;
            CommonTree string_literal261_tree = null;
            CommonTree string_literal262_tree = null;
            CommonTree DYNAMIC263_tree = null;
            CommonTree string_literal264_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 82))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:666:4: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
                int alt58 = 8;
                switch (input.LA(1))
                {
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                        {
                            alt58 = 1;
                        }
                        break;
                    case STATIC:
                        {
                            alt58 = 2;
                        }
                        break;
                    case 176:
                        {
                            alt58 = 3;
                        }
                        break;
                    case 177:
                        {
                            alt58 = 4;
                        }
                        break;
                    case 178:
                        {
                            alt58 = 5;
                        }
                        break;
                    case 179:
                        {
                            alt58 = 6;
                        }
                        break;
                    case DYNAMIC:
                        {
                            alt58 = 7;
                        }
                        break;
                    case 180:
                        {
                            alt58 = 8;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d58s0 =
                            new NoViableAltException("665:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );", 58, 0, input);

                        throw nvae_d58s0;
                }

                switch (alt58)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:666:4: namespaceName
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_namespaceName_in_modifier2849);
                            namespaceName257 = namespaceName();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, namespaceName257.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:667:4: STATIC
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STATIC258 = (IToken)input.LT(1);
                            Match(input, STATIC, FOLLOW_STATIC_in_modifier2854); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STATIC258_tree = (CommonTree)adaptor.Create(STATIC258);
                                adaptor.AddChild(root_0, STATIC258_tree);
                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:668:4: 'final'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal259 = (IToken)input.LT(1);
                            Match(input, 176, FOLLOW_176_in_modifier2859); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal259_tree = (CommonTree)adaptor.Create(string_literal259);
                                adaptor.AddChild(root_0, string_literal259_tree);
                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:669:4: 'enumerable'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal260 = (IToken)input.LT(1);
                            Match(input, 177, FOLLOW_177_in_modifier2864); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal260_tree = (CommonTree)adaptor.Create(string_literal260);
                                adaptor.AddChild(root_0, string_literal260_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:670:4: 'explicit'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal261 = (IToken)input.LT(1);
                            Match(input, 178, FOLLOW_178_in_modifier2869); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal261_tree = (CommonTree)adaptor.Create(string_literal261);
                                adaptor.AddChild(root_0, string_literal261_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:671:4: 'override'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal262 = (IToken)input.LT(1);
                            Match(input, 179, FOLLOW_179_in_modifier2874); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal262_tree = (CommonTree)adaptor.Create(string_literal262);
                                adaptor.AddChild(root_0, string_literal262_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:672:4: DYNAMIC
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            DYNAMIC263 = (IToken)input.LT(1);
                            Match(input, DYNAMIC, FOLLOW_DYNAMIC_in_modifier2879); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                DYNAMIC263_tree = (CommonTree)adaptor.Create(DYNAMIC263);
                                adaptor.AddChild(root_0, DYNAMIC263_tree);
                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:673:4: 'intrinsic'
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            string_literal264 = (IToken)input.LT(1);
                            Match(input, 180, FOLLOW_180_in_modifier2884); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                string_literal264_tree = (CommonTree)adaptor.Create(string_literal264);
                                adaptor.AddChild(root_0, string_literal264_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 82, modifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end modifier

        public class arguments_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start arguments
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:676:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );
        public arguments_return arguments() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            arguments_return retval = new arguments_return();
            retval.start = input.LT(1);
            int arguments_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN265 = null;
            IToken RPAREN267 = null;
            IToken LPAREN268 = null;
            IToken RPAREN269 = null;
            expressionList_return expressionList266 = null;


            CommonTree LPAREN265_tree = null;
            CommonTree RPAREN267_tree = null;
            CommonTree LPAREN268_tree = null;
            CommonTree RPAREN269_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor, "rule expressionList");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 83))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:681:4: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS )
                int alt59 = 2;
                int LA59_0 = input.LA(1);

                if ((LA59_0 == LPAREN))
                {
                    int LA59_1 = input.LA(2);

                    if ((LA59_1 == RPAREN))
                    {
                        alt59 = 2;
                    }
                    else if ((LA59_1 == LCURLY || (LA59_1 >= STRING_LITERAL && LA59_1 <= USE) || LA59_1 == LPAREN || LA59_1 == XML || (LA59_1 >= IDENT && LA59_1 <= LBRACK) || LA59_1 == DYNAMIC || LA59_1 == LT || (LA59_1 >= IS && LA59_1 <= AS) || (LA59_1 >= PLUS && LA59_1 <= DIV) || (LA59_1 >= INC && LA59_1 <= BNOT) || (LA59_1 >= E4X_ATTRI && LA59_1 <= NEW) || LA59_1 == 175))
                    {
                        alt59 = 1;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d59s1 =
                            new NoViableAltException("676:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 59, 1, input);

                        throw nvae_d59s1;
                    }
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d59s0 =
                        new NoViableAltException("676:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 59, 0, input);

                    throw nvae_d59s0;
                }
                switch (alt59)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:681:4: LPAREN expressionList RPAREN
                        {
                            LPAREN265 = (IToken)input.LT(1);
                            Match(input, LPAREN, FOLLOW_LPAREN_in_arguments2905); if (failed) return retval;
                            if (backtracking == 0) stream_LPAREN.Add(LPAREN265);

                            PushFollow(FOLLOW_expressionList_in_arguments2907);
                            expressionList266 = expressionList();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_expressionList.Add(expressionList266.Tree);
                            RPAREN267 = (IToken)input.LT(1);
                            Match(input, RPAREN, FOLLOW_RPAREN_in_arguments2909); if (failed) return retval;
                            if (backtracking == 0) stream_RPAREN.Add(RPAREN267);


                            // AST REWRITE
                            // elements:          expressionList
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 682:3: -> ^( ARGUMENTS expressionList )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:682:6: ^( ARGUMENTS expressionList )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

                                        adaptor.AddChild(root_1, stream_expressionList.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:683:4: LPAREN RPAREN
                        {
                            LPAREN268 = (IToken)input.LT(1);
                            Match(input, LPAREN, FOLLOW_LPAREN_in_arguments2924); if (failed) return retval;
                            if (backtracking == 0) stream_LPAREN.Add(LPAREN268);

                            RPAREN269 = (IToken)input.LT(1);
                            Match(input, RPAREN, FOLLOW_RPAREN_in_arguments2926); if (failed) return retval;
                            if (backtracking == 0) stream_RPAREN.Add(RPAREN269);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 684:3: -> ARGUMENTS
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(ARGUMENTS, "ARGUMENTS"));

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 83, arguments_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end arguments

        public class element_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start element
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:688:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
        public element_return element() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            element_return retval = new element_return();
            retval.start = input.LT(1);
            int element_StartIndex = input.Index();
            CommonTree root_0 = null;

            assignmentExpression_return assignmentExpression270 = null;


            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 84))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:4: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:693:4: assignmentExpression
                {
                    PushFollow(FOLLOW_assignmentExpression_in_element2956);
                    assignmentExpression270 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression270.Tree);

                    // AST REWRITE
                    // elements:          assignmentExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 694:3: -> ^( ELEMENT assignmentExpression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:694:6: ^( ELEMENT assignmentExpression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELEMENT, "ELEMENT"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 84, element_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end element

        public class arrayLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start arrayLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:698:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) ;
        public arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
        {
            arrayLiteral_return retval = new arrayLiteral_return();
            retval.start = input.LT(1);
            int arrayLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK271 = null;
            IToken RBRACK273 = null;
            elementList_return elementList272 = null;


            CommonTree LBRACK271_tree = null;
            CommonTree RBRACK273_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleSubtreeStream stream_elementList = new RewriteRuleSubtreeStream(adaptor, "rule elementList");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 85))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:699:4: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:699:4: LBRACK ( elementList )? RBRACK
                {
                    LBRACK271 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_arrayLiteral2978); if (failed) return retval;
                    if (backtracking == 0) stream_LBRACK.Add(LBRACK271);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:699:11: ( elementList )?
                    int alt60 = 2;
                    int LA60_0 = input.LA(1);

                    if ((LA60_0 == LCURLY || (LA60_0 >= STRING_LITERAL && LA60_0 <= USE) || LA60_0 == LPAREN || LA60_0 == XML || (LA60_0 >= IDENT && LA60_0 <= LBRACK) || LA60_0 == DYNAMIC || LA60_0 == LT || (LA60_0 >= IS && LA60_0 <= AS) || (LA60_0 >= PLUS && LA60_0 <= DIV) || (LA60_0 >= INC && LA60_0 <= BNOT) || (LA60_0 >= E4X_ATTRI && LA60_0 <= NEW) || LA60_0 == 175))
                    {
                        alt60 = 1;
                    }
                    switch (alt60)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: elementList
                            {
                                PushFollow(FOLLOW_elementList_in_arrayLiteral2980);
                                elementList272 = elementList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_elementList.Add(elementList272.Tree);

                            }
                            break;

                    }

                    RBRACK273 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_arrayLiteral2983); if (failed) return retval;
                    if (backtracking == 0) stream_RBRACK.Add(RBRACK273);


                    // AST REWRITE
                    // elements:          elementList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 700:3: -> ^( ARRAY_LITERAL ( elementList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:700:6: ^( ARRAY_LITERAL ( elementList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:700:22: ( elementList )?
                                if (stream_elementList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_elementList.Next());

                                }
                                stream_elementList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 85, arrayLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end arrayLiteral

        public class elementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start elementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:703:1: elementList : nonemptyElementList ( COMMA ( nonemptyElementList )? )* ;
        public elementList_return elementList() // throws RecognitionException [1]
        {
            elementList_return retval = new elementList_return();
            retval.start = input.LT(1);
            int elementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA275 = null;
            nonemptyElementList_return nonemptyElementList274 = null;

            nonemptyElementList_return nonemptyElementList276 = null;


            CommonTree COMMA275_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 86))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:704:4: ( nonemptyElementList ( COMMA ( nonemptyElementList )? )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:704:4: nonemptyElementList ( COMMA ( nonemptyElementList )? )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_nonemptyElementList_in_elementList3005);
                    nonemptyElementList274 = nonemptyElementList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList274.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:704:24: ( COMMA ( nonemptyElementList )? )*
                    do
                    {
                        int alt62 = 2;
                        int LA62_0 = input.LA(1);

                        if ((LA62_0 == COMMA))
                        {
                            alt62 = 1;
                        }


                        switch (alt62)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:704:25: COMMA ( nonemptyElementList )?
                                {
                                    COMMA275 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_elementList3008); if (failed) return retval;
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:704:32: ( nonemptyElementList )?
                                    int alt61 = 2;
                                    int LA61_0 = input.LA(1);

                                    if ((LA61_0 == LCURLY || (LA61_0 >= STRING_LITERAL && LA61_0 <= USE) || LA61_0 == LPAREN || LA61_0 == XML || (LA61_0 >= IDENT && LA61_0 <= LBRACK) || LA61_0 == DYNAMIC || LA61_0 == LT || (LA61_0 >= IS && LA61_0 <= AS) || (LA61_0 >= PLUS && LA61_0 <= DIV) || (LA61_0 >= INC && LA61_0 <= BNOT) || (LA61_0 >= E4X_ATTRI && LA61_0 <= NEW) || LA61_0 == 175))
                                    {
                                        alt61 = 1;
                                    }
                                    switch (alt61)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: nonemptyElementList
                                            {
                                                PushFollow(FOLLOW_nonemptyElementList_in_elementList3011);
                                                nonemptyElementList276 = nonemptyElementList();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList276.Tree);

                                            }
                                            break;

                                    }


                                }
                                break;

                            default:
                                goto loop62;
                        }
                    } while (true);

                loop62:
                    ;	// Stops C# compiler whinging that label 'loop62' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 86, elementList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end elementList

        public class nonemptyElementList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start nonemptyElementList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:1: nonemptyElementList : assignmentExpression ( COMMA assignmentExpression )* ;
        public nonemptyElementList_return nonemptyElementList() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            nonemptyElementList_return retval = new nonemptyElementList_return();
            retval.start = input.LT(1);
            int nonemptyElementList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA278 = null;
            assignmentExpression_return assignmentExpression277 = null;

            assignmentExpression_return assignmentExpression279 = null;


            CommonTree COMMA278_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 87))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:4: ( assignmentExpression ( COMMA assignmentExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:4: assignmentExpression ( COMMA assignmentExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3036);
                    assignmentExpression277 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression277.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:25: ( COMMA assignmentExpression )*
                    do
                    {
                        int alt63 = 2;
                        int LA63_0 = input.LA(1);

                        if ((LA63_0 == COMMA))
                        {
                            switch (input.LA(2))
                            {
                                case INC:
                                    {
                                        int LA63_4 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case DEC:
                                    {
                                        int LA63_5 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case MINUS:
                                    {
                                        int LA63_6 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case PLUS:
                                    {
                                        int LA63_7 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case DELETE:
                                    {
                                        int LA63_8 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case 175:
                                    {
                                        int LA63_9 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case TYPEOF:
                                    {
                                        int LA63_10 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case LNOT:
                                    {
                                        int LA63_11 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case BNOT:
                                    {
                                        int LA63_12 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case UNDEFINED:
                                    {
                                        int LA63_13 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case LT:
                                    {
                                        int LA63_14 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA63_15 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA63_16 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA63_17 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA63_18 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA63_19 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA63_20 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA63_21 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA63_22 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA63_23 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA63_24 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA63_25 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA63_26 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA63_27 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA63_28 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case USE:
                                    {
                                        int LA63_29 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case XML:
                                    {
                                        int LA63_30 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA63_31 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA63_32 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case IS:
                                    {
                                        int LA63_33 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case AS:
                                    {
                                        int LA63_34 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case GET:
                                    {
                                        int LA63_35 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;
                                case SET:
                                    {
                                        int LA63_36 = input.LA(3);

                                        if ((synpred99()))
                                        {
                                            alt63 = 1;
                                        }


                                    }
                                    break;

                            }

                        }


                        switch (alt63)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:26: COMMA assignmentExpression
                                {
                                    COMMA278 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_nonemptyElementList3039); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        COMMA278_tree = (CommonTree)adaptor.Create(COMMA278);
                                        adaptor.AddChild(root_0, COMMA278_tree);
                                    }
                                    PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3041);
                                    assignmentExpression279 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression279.Tree);

                                }
                                break;

                            default:
                                goto loop63;
                        }
                    } while (true);

                loop63:
                    ;	// Stops C# compiler whinging that label 'loop63' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 87, nonemptyElementList_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end nonemptyElementList

        public class objectLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start objectLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:716:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
        public objectLiteral_return objectLiteral() // throws RecognitionException [1]
        {
            objectLiteral_return retval = new objectLiteral_return();
            retval.start = input.LT(1);
            int objectLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LCURLY280 = null;
            IToken RCURLY282 = null;
            fieldList_return fieldList281 = null;


            CommonTree LCURLY280_tree = null;
            CommonTree RCURLY282_tree = null;
            RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor, "token LCURLY");
            RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor, "token RCURLY");
            RewriteRuleSubtreeStream stream_fieldList = new RewriteRuleSubtreeStream(adaptor, "rule fieldList");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 88))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:717:4: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:717:4: LCURLY ( fieldList )? RCURLY
                {
                    LCURLY280 = (IToken)input.LT(1);
                    Match(input, LCURLY, FOLLOW_LCURLY_in_objectLiteral3056); if (failed) return retval;
                    if (backtracking == 0) stream_LCURLY.Add(LCURLY280);

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:717:11: ( fieldList )?
                    int alt64 = 2;
                    int LA64_0 = input.LA(1);

                    if (((LA64_0 >= GET && LA64_0 <= USE) || LA64_0 == XML || LA64_0 == IDENT || LA64_0 == DYNAMIC || (LA64_0 >= IS && LA64_0 <= AS) || (LA64_0 >= HEX_LITERAL && LA64_0 <= FLOAT_LITERAL)))
                    {
                        alt64 = 1;
                    }
                    switch (alt64)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: fieldList
                            {
                                PushFollow(FOLLOW_fieldList_in_objectLiteral3058);
                                fieldList281 = fieldList();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_fieldList.Add(fieldList281.Tree);

                            }
                            break;

                    }

                    RCURLY282 = (IToken)input.LT(1);
                    Match(input, RCURLY, FOLLOW_RCURLY_in_objectLiteral3061); if (failed) return retval;
                    if (backtracking == 0) stream_RCURLY.Add(RCURLY282);


                    // AST REWRITE
                    // elements:          fieldList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 718:3: -> ^( OBJECT_LITERAL ( fieldList )? )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:718:6: ^( OBJECT_LITERAL ( fieldList )? )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);

                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:718:23: ( fieldList )?
                                if (stream_fieldList.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_fieldList.Next());

                                }
                                stream_fieldList.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 88, objectLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end objectLiteral

        public class fieldList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fieldList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:1: fieldList : literalField ( COMMA ( literalField )? )* ;
        public fieldList_return fieldList() // throws RecognitionException [1]
        {
            fieldList_return retval = new fieldList_return();
            retval.start = input.LT(1);
            int fieldList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA284 = null;
            literalField_return literalField283 = null;

            literalField_return literalField285 = null;


            CommonTree COMMA284_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 89))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:4: ( literalField ( COMMA ( literalField )? )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:4: literalField ( COMMA ( literalField )? )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_literalField_in_fieldList3084);
                    literalField283 = literalField();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, literalField283.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:17: ( COMMA ( literalField )? )*
                    do
                    {
                        int alt66 = 2;
                        int LA66_0 = input.LA(1);

                        if ((LA66_0 == COMMA))
                        {
                            alt66 = 1;
                        }


                        switch (alt66)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:18: COMMA ( literalField )?
                                {
                                    COMMA284 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_fieldList3087); if (failed) return retval;
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:722:25: ( literalField )?
                                    int alt65 = 2;
                                    int LA65_0 = input.LA(1);

                                    if (((LA65_0 >= GET && LA65_0 <= USE) || LA65_0 == XML || LA65_0 == IDENT || LA65_0 == DYNAMIC || (LA65_0 >= IS && LA65_0 <= AS) || (LA65_0 >= HEX_LITERAL && LA65_0 <= FLOAT_LITERAL)))
                                    {
                                        alt65 = 1;
                                    }
                                    switch (alt65)
                                    {
                                        case 1:
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: literalField
                                            {
                                                PushFollow(FOLLOW_literalField_in_fieldList3090);
                                                literalField285 = literalField();
                                                followingStackPointer_--;
                                                if (failed) return retval;
                                                if (backtracking == 0) adaptor.AddChild(root_0, literalField285.Tree);

                                            }
                                            break;

                                    }


                                }
                                break;

                            default:
                                goto loop66;
                        }
                    } while (true);

                loop66:
                    ;	// Stops C# compiler whinging that label 'loop66' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 89, fieldList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fieldList

        public class literalField_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start literalField
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
        public literalField_return literalField() // throws RecognitionException [1]
        {
            literalField_return retval = new literalField_return();
            retval.start = input.LT(1);
            int literalField_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COLON287 = null;
            fieldName_return fieldName286 = null;

            element_return element288 = null;


            CommonTree COLON287_tree = null;
            RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor, "token COLON");
            RewriteRuleSubtreeStream stream_element = new RewriteRuleSubtreeStream(adaptor, "rule element");
            RewriteRuleSubtreeStream stream_fieldName = new RewriteRuleSubtreeStream(adaptor, "rule fieldName");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 90))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:726:5: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:726:5: fieldName COLON element
                {
                    PushFollow(FOLLOW_fieldName_in_literalField3107);
                    fieldName286 = fieldName();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_fieldName.Add(fieldName286.Tree);
                    COLON287 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_literalField3109); if (failed) return retval;
                    if (backtracking == 0) stream_COLON.Add(COLON287);

                    PushFollow(FOLLOW_element_in_literalField3111);
                    element288 = element();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_element.Add(element288.Tree);

                    // AST REWRITE
                    // elements:          element, fieldName
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 727:3: -> ^( OBJECT_FIELD fieldName element )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:727:6: ^( OBJECT_FIELD fieldName element )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);

                                adaptor.AddChild(root_1, stream_fieldName.Next());
                                adaptor.AddChild(root_1, stream_element.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 90, literalField_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end literalField

        public class fieldName_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fieldName
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:730:1: fieldName : ( ident | number );
        public fieldName_return fieldName() // throws RecognitionException [1]
        {
            fieldName_return retval = new fieldName_return();
            retval.start = input.LT(1);
            int fieldName_StartIndex = input.Index();
            CommonTree root_0 = null;

            ident_return ident289 = null;

            number_return number290 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 91))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:731:4: ( ident | number )
                int alt67 = 2;
                int LA67_0 = input.LA(1);

                if (((LA67_0 >= GET && LA67_0 <= USE) || LA67_0 == XML || LA67_0 == IDENT || LA67_0 == DYNAMIC || (LA67_0 >= IS && LA67_0 <= AS)))
                {
                    alt67 = 1;
                }
                else if (((LA67_0 >= HEX_LITERAL && LA67_0 <= FLOAT_LITERAL)))
                {
                    alt67 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d67s0 =
                        new NoViableAltException("730:1: fieldName : ( ident | number );", 67, 0, input);

                    throw nvae_d67s0;
                }
                switch (alt67)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:731:4: ident
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_ident_in_fieldName3135);
                            ident289 = ident();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, ident289.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:732:4: number
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_number_in_fieldName3140);
                            number290 = number();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, number290.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 91, fieldName_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fieldName

        public class expression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:736:1: expression : assignmentExpression ;
        public expression_return expression() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            expression_return retval = new expression_return();
            retval.start = input.LT(1);
            int expression_StartIndex = input.Index();
            CommonTree root_0 = null;

            assignmentExpression_return assignmentExpression291 = null;




            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 92))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:741:4: ( assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:741:4: assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_expression3162);
                    assignmentExpression291 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression291.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 92, expression_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end expression

        public class expressionList_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start expressionList
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:745:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) ;
        public expressionList_return expressionList() // throws RecognitionException [1]
        {
            expressionList_return retval = new expressionList_return();
            retval.start = input.LT(1);
            int expressionList_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COMMA293 = null;
            assignmentExpression_return assignmentExpression292 = null;

            assignmentExpression_return assignmentExpression294 = null;


            CommonTree COMMA293_tree = null;
            RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor, "token COMMA");
            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 93))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:4: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:4: assignmentExpression ( COMMA assignmentExpression )*
                {
                    PushFollow(FOLLOW_assignmentExpression_in_expressionList3174);
                    assignmentExpression292 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression292.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:25: ( COMMA assignmentExpression )*
                    do
                    {
                        int alt68 = 2;
                        int LA68_0 = input.LA(1);

                        if ((LA68_0 == COMMA))
                        {
                            alt68 = 1;
                        }


                        switch (alt68)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:26: COMMA assignmentExpression
                                {
                                    COMMA293 = (IToken)input.LT(1);
                                    Match(input, COMMA, FOLLOW_COMMA_in_expressionList3177); if (failed) return retval;
                                    if (backtracking == 0) stream_COMMA.Add(COMMA293);

                                    PushFollow(FOLLOW_assignmentExpression_in_expressionList3179);
                                    assignmentExpression294 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression294.Tree);

                                }
                                break;

                            default:
                                goto loop68;
                        }
                    } while (true);

                loop68:
                    ;	// Stops C# compiler whinging that label 'loop68' has no statements


                    // AST REWRITE
                    // elements:          assignmentExpression, assignmentExpression, COMMA
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 746:55: -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:58: ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELIST, "ELIST"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:746:87: ( COMMA assignmentExpression )*
                                while (stream_assignmentExpression.HasNext() || stream_COMMA.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_COMMA.Next());
                                    adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                }
                                stream_assignmentExpression.Reset();
                                stream_COMMA.Reset();

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 93, expressionList_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end expressionList

        public class assignmentExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start assignmentExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:750:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
        public assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
        {
            assignmentExpression_return retval = new assignmentExpression_return();
            retval.start = input.LT(1);
            int assignmentExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            conditionalExpression_return conditionalExpression295 = null;

            assignmentOperator_return assignmentOperator296 = null;

            assignmentExpression_return assignmentExpression297 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 94))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:751:4: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:751:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression3208);
                    conditionalExpression295 = conditionalExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, conditionalExpression295.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:2: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
                    do
                    {
                        int alt69 = 2;
                        int LA69_0 = input.LA(1);

                        if ((LA69_0 == ASSIGN || (LA69_0 >= STAR_ASSIGN && LA69_0 <= LOR_ASSIGN)))
                        {
                            int LA69_9 = input.LA(2);

                            if ((synpred105()))
                            {
                                alt69 = 1;
                            }


                        }


                        switch (alt69)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:4: ( assignmentOperator )=> assignmentOperator assignmentExpression
                                {
                                    PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression3218);
                                    assignmentOperator296 = assignmentOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentOperator296.Tree);
                                    PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression3222);
                                    assignmentExpression297 = assignmentExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression297.Tree);

                                }
                                break;

                            default:
                                goto loop69;
                        }
                    } while (true);

                loop69:
                    ;	// Stops C# compiler whinging that label 'loop69' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 94, assignmentExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end assignmentExpression

        public class assignmentOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start assignmentOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:757:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
        public assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
        {
            assignmentOperator_return retval = new assignmentOperator_return();
            retval.start = input.LT(1);
            int assignmentOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set298 = null;

            CommonTree set298_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 95))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:758:4: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set298 = (IToken)input.LT(1);
                    if (input.LA(1) == ASSIGN || (input.LA(1) >= STAR_ASSIGN && input.LA(1) <= LOR_ASSIGN))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set298));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_assignmentOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 95, assignmentOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end assignmentOperator

        public class conditionalExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start conditionalExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:775:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
        public conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
        {
            conditionalExpression_return retval = new conditionalExpression_return();
            retval.start = input.LT(1);
            int conditionalExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken QUESTION300 = null;
            logicalOrExpression_return logicalOrExpression299 = null;

            conditionalSubExpression_return conditionalSubExpression301 = null;


            CommonTree QUESTION300_tree = null;
            RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream(adaptor, "token QUESTION");
            RewriteRuleSubtreeStream stream_logicalOrExpression = new RewriteRuleSubtreeStream(adaptor, "rule logicalOrExpression");
            RewriteRuleSubtreeStream stream_conditionalSubExpression = new RewriteRuleSubtreeStream(adaptor, "rule conditionalSubExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 96))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:776:4: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:776:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:776:4: ( logicalOrExpression -> logicalOrExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:776:5: logicalOrExpression
                    {
                        PushFollow(FOLLOW_logicalOrExpression_in_conditionalExpression3316);
                        logicalOrExpression299 = logicalOrExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_logicalOrExpression.Add(logicalOrExpression299.Tree);

                        // AST REWRITE
                        // elements:          logicalOrExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 776:25: -> logicalOrExpression
                            {
                                adaptor.AddChild(root_0, stream_logicalOrExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:777:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
                    int alt70 = 2;
                    int LA70_0 = input.LA(1);

                    if ((LA70_0 == QUESTION))
                    {
                        alt70 = 1;
                    }
                    switch (alt70)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:778:4: QUESTION conditionalSubExpression
                            {
                                QUESTION300 = (IToken)input.LT(1);
                                Match(input, QUESTION, FOLLOW_QUESTION_in_conditionalExpression3330); if (failed) return retval;
                                if (backtracking == 0) stream_QUESTION.Add(QUESTION300);

                                PushFollow(FOLLOW_conditionalSubExpression_in_conditionalExpression3335);
                                conditionalSubExpression301 = conditionalSubExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_conditionalSubExpression.Add(conditionalSubExpression301.Tree);

                                // AST REWRITE
                                // elements:          conditionalExpression, QUESTION, conditionalSubExpression
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 780:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:780:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.Next(), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());
                                            adaptor.AddChild(root_1, stream_conditionalSubExpression.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 96, conditionalExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end conditionalExpression

        public class conditionalSubExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start conditionalSubExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:783:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
        public conditionalSubExpression_return conditionalSubExpression() // throws RecognitionException [1]
        {
            conditionalSubExpression_return retval = new conditionalSubExpression_return();
            retval.start = input.LT(1);
            int conditionalSubExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken COLON303 = null;
            assignmentExpression_return assignmentExpression302 = null;

            assignmentExpression_return assignmentExpression304 = null;


            CommonTree COLON303_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 97))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:784:4: ( assignmentExpression COLON assignmentExpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:784:4: assignmentExpression COLON assignmentExpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3364);
                    assignmentExpression302 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression302.Tree);
                    COLON303 = (IToken)input.LT(1);
                    Match(input, COLON, FOLLOW_COLON_in_conditionalSubExpression3366); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        COLON303_tree = (CommonTree)adaptor.Create(COLON303);
                        root_0 = (CommonTree)adaptor.BecomeRoot(COLON303_tree, root_0);
                    }
                    PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3369);
                    assignmentExpression304 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, assignmentExpression304.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 97, conditionalSubExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end conditionalSubExpression

        public class logicalOrExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalOrExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:790:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
        public logicalOrExpression_return logicalOrExpression() // throws RecognitionException [1]
        {
            logicalOrExpression_return retval = new logicalOrExpression_return();
            retval.start = input.LT(1);
            int logicalOrExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            logicalAndExpression_return logicalAndExpression305 = null;

            logicalOrOperator_return logicalOrOperator306 = null;

            logicalAndExpression_return logicalAndExpression307 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 98))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:791:4: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:791:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3383);
                    logicalAndExpression305 = logicalAndExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression305.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:3: ( logicalOrOperator logicalAndExpression )*
                    do
                    {
                        int alt71 = 2;
                        int LA71_0 = input.LA(1);

                        if ((LA71_0 == LOR || LA71_0 == 181))
                        {
                            alt71 = 1;
                        }


                        switch (alt71)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:792:4: logicalOrOperator logicalAndExpression
                                {
                                    PushFollow(FOLLOW_logicalOrOperator_in_logicalOrExpression3388);
                                    logicalOrOperator306 = logicalOrOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(logicalOrOperator306.Tree, root_0);
                                    PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3391);
                                    logicalAndExpression307 = logicalAndExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression307.Tree);

                                }
                                break;

                            default:
                                goto loop71;
                        }
                    } while (true);

                loop71:
                    ;	// Stops C# compiler whinging that label 'loop71' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 98, logicalOrExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalOrExpression

        public class logicalOrOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalOrOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:795:1: logicalOrOperator : ( LOR | 'or' );
        public logicalOrOperator_return logicalOrOperator() // throws RecognitionException [1]
        {
            logicalOrOperator_return retval = new logicalOrOperator_return();
            retval.start = input.LT(1);
            int logicalOrOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set308 = null;

            CommonTree set308_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 99))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:796:4: ( LOR | 'or' )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set308 = (IToken)input.LT(1);
                    if (input.LA(1) == LOR || input.LA(1) == 181)
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set308));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_logicalOrOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 99, logicalOrOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalOrOperator

        public class logicalAndExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalAndExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:800:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
        public logicalAndExpression_return logicalAndExpression() // throws RecognitionException [1]
        {
            logicalAndExpression_return retval = new logicalAndExpression_return();
            retval.start = input.LT(1);
            int logicalAndExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            bitwiseOrExpression_return bitwiseOrExpression309 = null;

            logicalAndOperator_return logicalAndOperator310 = null;

            bitwiseOrExpression_return bitwiseOrExpression311 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 100))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:801:4: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:801:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3420);
                    bitwiseOrExpression309 = bitwiseOrExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression309.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:802:3: ( logicalAndOperator bitwiseOrExpression )*
                    do
                    {
                        int alt72 = 2;
                        int LA72_0 = input.LA(1);

                        if ((LA72_0 == LAND || LA72_0 == 182))
                        {
                            alt72 = 1;
                        }


                        switch (alt72)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:802:4: logicalAndOperator bitwiseOrExpression
                                {
                                    PushFollow(FOLLOW_logicalAndOperator_in_logicalAndExpression3425);
                                    logicalAndOperator310 = logicalAndOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(logicalAndOperator310.Tree, root_0);
                                    PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3428);
                                    bitwiseOrExpression311 = bitwiseOrExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression311.Tree);

                                }
                                break;

                            default:
                                goto loop72;
                        }
                    } while (true);

                loop72:
                    ;	// Stops C# compiler whinging that label 'loop72' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 100, logicalAndExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalAndExpression

        public class logicalAndOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start logicalAndOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:805:1: logicalAndOperator : ( LAND | 'and' );
        public logicalAndOperator_return logicalAndOperator() // throws RecognitionException [1]
        {
            logicalAndOperator_return retval = new logicalAndOperator_return();
            retval.start = input.LT(1);
            int logicalAndOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set312 = null;

            CommonTree set312_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 101))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:806:4: ( LAND | 'and' )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set312 = (IToken)input.LT(1);
                    if (input.LA(1) == LAND || input.LA(1) == 182)
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set312));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_logicalAndOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 101, logicalAndOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end logicalAndOperator

        public class bitwiseOrExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseOrExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:810:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
        public bitwiseOrExpression_return bitwiseOrExpression() // throws RecognitionException [1]
        {
            bitwiseOrExpression_return retval = new bitwiseOrExpression_return();
            retval.start = input.LT(1);
            int bitwiseOrExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BOR314 = null;
            bitwiseXorExpression_return bitwiseXorExpression313 = null;

            bitwiseXorExpression_return bitwiseXorExpression315 = null;


            CommonTree BOR314_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 102))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:811:4: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:811:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3457);
                    bitwiseXorExpression313 = bitwiseXorExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression313.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:812:3: ( BOR bitwiseXorExpression )*
                    do
                    {
                        int alt73 = 2;
                        int LA73_0 = input.LA(1);

                        if ((LA73_0 == BOR))
                        {
                            alt73 = 1;
                        }


                        switch (alt73)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:812:4: BOR bitwiseXorExpression
                                {
                                    BOR314 = (IToken)input.LT(1);
                                    Match(input, BOR, FOLLOW_BOR_in_bitwiseOrExpression3462); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BOR314_tree = (CommonTree)adaptor.Create(BOR314);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BOR314_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3465);
                                    bitwiseXorExpression315 = bitwiseXorExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression315.Tree);

                                }
                                break;

                            default:
                                goto loop73;
                        }
                    } while (true);

                loop73:
                    ;	// Stops C# compiler whinging that label 'loop73' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 102, bitwiseOrExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseOrExpression

        public class bitwiseXorExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseXorExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:816:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
        public bitwiseXorExpression_return bitwiseXorExpression() // throws RecognitionException [1]
        {
            bitwiseXorExpression_return retval = new bitwiseXorExpression_return();
            retval.start = input.LT(1);
            int bitwiseXorExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BXOR317 = null;
            bitwiseAndExpression_return bitwiseAndExpression316 = null;

            bitwiseAndExpression_return bitwiseAndExpression318 = null;


            CommonTree BXOR317_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 103))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:817:4: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:817:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3479);
                    bitwiseAndExpression316 = bitwiseAndExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression316.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:818:3: ( BXOR bitwiseAndExpression )*
                    do
                    {
                        int alt74 = 2;
                        int LA74_0 = input.LA(1);

                        if ((LA74_0 == BXOR))
                        {
                            alt74 = 1;
                        }


                        switch (alt74)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:818:4: BXOR bitwiseAndExpression
                                {
                                    BXOR317 = (IToken)input.LT(1);
                                    Match(input, BXOR, FOLLOW_BXOR_in_bitwiseXorExpression3484); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BXOR317_tree = (CommonTree)adaptor.Create(BXOR317);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BXOR317_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3487);
                                    bitwiseAndExpression318 = bitwiseAndExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression318.Tree);

                                }
                                break;

                            default:
                                goto loop74;
                        }
                    } while (true);

                loop74:
                    ;	// Stops C# compiler whinging that label 'loop74' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 103, bitwiseXorExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseXorExpression

        public class bitwiseAndExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start bitwiseAndExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:822:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
        public bitwiseAndExpression_return bitwiseAndExpression() // throws RecognitionException [1]
        {
            bitwiseAndExpression_return retval = new bitwiseAndExpression_return();
            retval.start = input.LT(1);
            int bitwiseAndExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken BAND320 = null;
            equalityExpression_return equalityExpression319 = null;

            equalityExpression_return equalityExpression321 = null;


            CommonTree BAND320_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 104))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:823:4: ( equalityExpression ( BAND equalityExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:823:4: equalityExpression ( BAND equalityExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3501);
                    equalityExpression319 = equalityExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, equalityExpression319.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:3: ( BAND equalityExpression )*
                    do
                    {
                        int alt75 = 2;
                        int LA75_0 = input.LA(1);

                        if ((LA75_0 == BAND))
                        {
                            alt75 = 1;
                        }


                        switch (alt75)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:824:4: BAND equalityExpression
                                {
                                    BAND320 = (IToken)input.LT(1);
                                    Match(input, BAND, FOLLOW_BAND_in_bitwiseAndExpression3506); if (failed) return retval;
                                    if (backtracking == 0)
                                    {
                                        BAND320_tree = (CommonTree)adaptor.Create(BAND320);
                                        root_0 = (CommonTree)adaptor.BecomeRoot(BAND320_tree, root_0);
                                    }
                                    PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3509);
                                    equalityExpression321 = equalityExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, equalityExpression321.Tree);

                                }
                                break;

                            default:
                                goto loop75;
                        }
                    } while (true);

                loop75:
                    ;	// Stops C# compiler whinging that label 'loop75' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 104, bitwiseAndExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end bitwiseAndExpression

        public class equalityExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start equalityExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:828:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
        public equalityExpression_return equalityExpression() // throws RecognitionException [1]
        {
            equalityExpression_return retval = new equalityExpression_return();
            retval.start = input.LT(1);
            int equalityExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            relationalExpression_return relationalExpression322 = null;

            equalityOperator_return equalityOperator323 = null;

            relationalExpression_return relationalExpression324 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 105))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:829:4: ( relationalExpression ( equalityOperator relationalExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:829:4: relationalExpression ( equalityOperator relationalExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_relationalExpression_in_equalityExpression3523);
                    relationalExpression322 = relationalExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, relationalExpression322.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:830:2: ( equalityOperator relationalExpression )*
                    do
                    {
                        int alt76 = 2;
                        int LA76_0 = input.LA(1);

                        if (((LA76_0 >= STRICT_EQUAL && LA76_0 <= EQUAL)))
                        {
                            alt76 = 1;
                        }


                        switch (alt76)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:830:4: equalityOperator relationalExpression
                                {
                                    PushFollow(FOLLOW_equalityOperator_in_equalityExpression3528);
                                    equalityOperator323 = equalityOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(equalityOperator323.Tree, root_0);
                                    PushFollow(FOLLOW_relationalExpression_in_equalityExpression3533);
                                    relationalExpression324 = relationalExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, relationalExpression324.Tree);

                                }
                                break;

                            default:
                                goto loop76;
                        }
                    } while (true);

                loop76:
                    ;	// Stops C# compiler whinging that label 'loop76' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 105, equalityExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end equalityExpression

        public class equalityOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start equalityOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:835:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
        public equalityOperator_return equalityOperator() // throws RecognitionException [1]
        {
            equalityOperator_return retval = new equalityOperator_return();
            retval.start = input.LT(1);
            int equalityOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set325 = null;

            CommonTree set325_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 106))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:836:4: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set325 = (IToken)input.LT(1);
                    if ((input.LA(1) >= STRICT_EQUAL && input.LA(1) <= EQUAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set325));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_equalityOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 106, equalityOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end equalityOperator

        public class relationalExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start relationalExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:840:1: relationalExpression : shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* ;
        public relationalExpression_return relationalExpression() // throws RecognitionException [1]
        {
            relationalExpression_return retval = new relationalExpression_return();
            retval.start = input.LT(1);
            int relationalExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            shiftExpression_return shiftExpression326 = null;

            relationalOperator_return relationalOperator327 = null;

            shiftExpression_return shiftExpression328 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 107))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:4: ( shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:841:4: shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_shiftExpression_in_relationalExpression3573);
                    shiftExpression326 = shiftExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, shiftExpression326.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:3: ( ( relationalOperator )=> relationalOperator shiftExpression )*
                    do
                    {
                        int alt77 = 2;
                        int LA77_0 = input.LA(1);

                        if ((LA77_0 == IN))
                        {
                            switch (input.LA(2))
                            {
                                case INC:
                                    {
                                        int LA77_24 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case DEC:
                                    {
                                        int LA77_25 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case MINUS:
                                    {
                                        int LA77_26 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case PLUS:
                                    {
                                        int LA77_27 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case DELETE:
                                    {
                                        int LA77_28 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case 175:
                                    {
                                        int LA77_29 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case TYPEOF:
                                    {
                                        int LA77_30 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case LNOT:
                                    {
                                        int LA77_31 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case BNOT:
                                    {
                                        int LA77_32 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case UNDEFINED:
                                    {
                                        int LA77_33 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case LT:
                                    {
                                        int LA77_34 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA77_35 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA77_36 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA77_37 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA77_38 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA77_39 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA77_40 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA77_41 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA77_42 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA77_43 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA77_44 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA77_45 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA77_46 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA77_47 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA77_48 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case USE:
                                    {
                                        int LA77_49 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case XML:
                                    {
                                        int LA77_50 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA77_51 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA77_52 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case IS:
                                    {
                                        int LA77_53 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case AS:
                                    {
                                        int LA77_54 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case GET:
                                    {
                                        int LA77_55 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;
                                case SET:
                                    {
                                        int LA77_56 = input.LA(3);

                                        if (((synpred131() && ((InOperator_scope)InOperator_stack.Peek()).allowed)))
                                        {
                                            alt77 = 1;
                                        }


                                    }
                                    break;

                            }

                        }
                        else if ((LA77_0 == LT) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == GT) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == LE) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == GE) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == IS) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == AS) && (synpred131()))
                        {
                            alt77 = 1;
                        }
                        else if ((LA77_0 == INSTANCEOF) && (synpred131()))
                        {
                            alt77 = 1;
                        }


                        switch (alt77)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:4: ( relationalOperator )=> relationalOperator shiftExpression
                                {
                                    PushFollow(FOLLOW_relationalOperator_in_relationalExpression3583);
                                    relationalOperator327 = relationalOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(relationalOperator327.Tree, root_0);
                                    PushFollow(FOLLOW_shiftExpression_in_relationalExpression3586);
                                    shiftExpression328 = shiftExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, shiftExpression328.Tree);

                                }
                                break;

                            default:
                                goto loop77;
                        }
                    } while (true);

                loop77:
                    ;	// Stops C# compiler whinging that label 'loop77' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 107, relationalExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end relationalExpression

        public class relationalOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start relationalOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );
        public relationalOperator_return relationalOperator() // throws RecognitionException [1]
        {
            relationalOperator_return retval = new relationalOperator_return();
            retval.start = input.LT(1);
            int relationalOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken IN329 = null;
            IToken LT330 = null;
            IToken GT331 = null;
            IToken LE332 = null;
            IToken GE333 = null;
            IToken IS334 = null;
            IToken AS335 = null;
            IToken INSTANCEOF336 = null;

            CommonTree IN329_tree = null;
            CommonTree LT330_tree = null;
            CommonTree GT331_tree = null;
            CommonTree LE332_tree = null;
            CommonTree GE333_tree = null;
            CommonTree IS334_tree = null;
            CommonTree AS335_tree = null;
            CommonTree INSTANCEOF336_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 108))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:846:4: ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF )
                int alt78 = 8;
                switch (input.LA(1))
                {
                    case IN:
                        {
                            alt78 = 1;
                        }
                        break;
                    case LT:
                        {
                            alt78 = 2;
                        }
                        break;
                    case GT:
                        {
                            alt78 = 3;
                        }
                        break;
                    case LE:
                        {
                            alt78 = 4;
                        }
                        break;
                    case GE:
                        {
                            alt78 = 5;
                        }
                        break;
                    case IS:
                        {
                            alt78 = 6;
                        }
                        break;
                    case AS:
                        {
                            alt78 = 7;
                        }
                        break;
                    case INSTANCEOF:
                        {
                            alt78 = 8;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d78s0 =
                            new NoViableAltException("845:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );", 78, 0, input);

                        throw nvae_d78s0;
                }

                switch (alt78)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:846:4: {...}? IN
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            if (!(((InOperator_scope)InOperator_stack.Peek()).allowed))
                            {
                                if (backtracking > 0) { failed = true; return retval; }
                                throw new FailedPredicateException(input, "relationalOperator", "$InOperator::allowed");
                            }
                            IN329 = (IToken)input.LT(1);
                            Match(input, IN, FOLLOW_IN_in_relationalOperator3601); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IN329_tree = (CommonTree)adaptor.Create(IN329);
                                adaptor.AddChild(root_0, IN329_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:4: LT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            LT330 = (IToken)input.LT(1);
                            Match(input, LT, FOLLOW_LT_in_relationalOperator3606); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                LT330_tree = (CommonTree)adaptor.Create(LT330);
                                adaptor.AddChild(root_0, LT330_tree);
                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:9: GT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            GT331 = (IToken)input.LT(1);
                            Match(input, GT, FOLLOW_GT_in_relationalOperator3610); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                GT331_tree = (CommonTree)adaptor.Create(GT331);
                                adaptor.AddChild(root_0, GT331_tree);
                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:14: LE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            LE332 = (IToken)input.LT(1);
                            Match(input, LE, FOLLOW_LE_in_relationalOperator3614); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                LE332_tree = (CommonTree)adaptor.Create(LE332);
                                adaptor.AddChild(root_0, LE332_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:19: GE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            GE333 = (IToken)input.LT(1);
                            Match(input, GE, FOLLOW_GE_in_relationalOperator3618); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                GE333_tree = (CommonTree)adaptor.Create(GE333);
                                adaptor.AddChild(root_0, GE333_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:24: IS
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IS334 = (IToken)input.LT(1);
                            Match(input, IS, FOLLOW_IS_in_relationalOperator3622); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IS334_tree = (CommonTree)adaptor.Create(IS334);
                                adaptor.AddChild(root_0, IS334_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:29: AS
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            AS335 = (IToken)input.LT(1);
                            Match(input, AS, FOLLOW_AS_in_relationalOperator3626); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                AS335_tree = (CommonTree)adaptor.Create(AS335);
                                adaptor.AddChild(root_0, AS335_tree);
                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:847:34: INSTANCEOF
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            INSTANCEOF336 = (IToken)input.LT(1);
                            Match(input, INSTANCEOF, FOLLOW_INSTANCEOF_in_relationalOperator3630); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                INSTANCEOF336_tree = (CommonTree)adaptor.Create(INSTANCEOF336);
                                adaptor.AddChild(root_0, INSTANCEOF336_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 108, relationalOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end relationalOperator

        public class shiftExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shiftExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:851:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
        public shiftExpression_return shiftExpression() // throws RecognitionException [1]
        {
            shiftExpression_return retval = new shiftExpression_return();
            retval.start = input.LT(1);
            int shiftExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            additiveExpression_return additiveExpression337 = null;

            shiftOperator_return shiftOperator338 = null;

            additiveExpression_return additiveExpression339 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 109))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:852:4: ( additiveExpression ( shiftOperator additiveExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:852:4: additiveExpression ( shiftOperator additiveExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_additiveExpression_in_shiftExpression3642);
                    additiveExpression337 = additiveExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, additiveExpression337.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:853:3: ( shiftOperator additiveExpression )*
                    do
                    {
                        int alt79 = 2;
                        int LA79_0 = input.LA(1);

                        if (((LA79_0 >= SL && LA79_0 <= BSR)))
                        {
                            alt79 = 1;
                        }


                        switch (alt79)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:853:4: shiftOperator additiveExpression
                                {
                                    PushFollow(FOLLOW_shiftOperator_in_shiftExpression3647);
                                    shiftOperator338 = shiftOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(shiftOperator338.Tree, root_0);
                                    PushFollow(FOLLOW_additiveExpression_in_shiftExpression3650);
                                    additiveExpression339 = additiveExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, additiveExpression339.Tree);

                                }
                                break;

                            default:
                                goto loop79;
                        }
                    } while (true);

                loop79:
                    ;	// Stops C# compiler whinging that label 'loop79' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 109, shiftExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shiftExpression

        public class shiftOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shiftOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:1: shiftOperator : ( SL | SR | BSR );
        public shiftOperator_return shiftOperator() // throws RecognitionException [1]
        {
            shiftOperator_return retval = new shiftOperator_return();
            retval.start = input.LT(1);
            int shiftOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set340 = null;

            CommonTree set340_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 110))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:857:4: ( SL | SR | BSR )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set340 = (IToken)input.LT(1);
                    if ((input.LA(1) >= SL && input.LA(1) <= BSR))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set340));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_shiftOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 110, shiftOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shiftOperator

        public class additiveExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start additiveExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:861:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
        public additiveExpression_return additiveExpression() // throws RecognitionException [1]
        {
            additiveExpression_return retval = new additiveExpression_return();
            retval.start = input.LT(1);
            int additiveExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            multiplicativeExpression_return multiplicativeExpression341 = null;

            additiveOperator_return additiveOperator342 = null;

            multiplicativeExpression_return multiplicativeExpression343 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 111))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:862:4: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:862:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3683);
                    multiplicativeExpression341 = multiplicativeExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression341.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:863:3: ( additiveOperator multiplicativeExpression )*
                    do
                    {
                        int alt80 = 2;
                        int LA80_0 = input.LA(1);

                        if (((LA80_0 >= PLUS && LA80_0 <= MINUS)))
                        {
                            alt80 = 1;
                        }


                        switch (alt80)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:863:4: additiveOperator multiplicativeExpression
                                {
                                    PushFollow(FOLLOW_additiveOperator_in_additiveExpression3688);
                                    additiveOperator342 = additiveOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(additiveOperator342.Tree, root_0);
                                    PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3691);
                                    multiplicativeExpression343 = multiplicativeExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression343.Tree);

                                }
                                break;

                            default:
                                goto loop80;
                        }
                    } while (true);

                loop80:
                    ;	// Stops C# compiler whinging that label 'loop80' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 111, additiveExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end additiveExpression

        public class additiveOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start additiveOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:1: additiveOperator : ( PLUS | MINUS );
        public additiveOperator_return additiveOperator() // throws RecognitionException [1]
        {
            additiveOperator_return retval = new additiveOperator_return();
            retval.start = input.LT(1);
            int additiveOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set344 = null;

            CommonTree set344_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 112))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:867:4: ( PLUS | MINUS )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set344 = (IToken)input.LT(1);
                    if ((input.LA(1) >= PLUS && input.LA(1) <= MINUS))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set344));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_additiveOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 112, additiveOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end additiveOperator

        public class multiplicativeExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start multiplicativeExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:871:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
        public multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
        {
            multiplicativeExpression_return retval = new multiplicativeExpression_return();
            retval.start = input.LT(1);
            int multiplicativeExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            unaryExpression_return unaryExpression345 = null;

            multiplicativeOperator_return multiplicativeOperator346 = null;

            unaryExpression_return unaryExpression347 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 113))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:872:4: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:872:4: unaryExpression ( multiplicativeOperator unaryExpression )*
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3721);
                    unaryExpression345 = unaryExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, unaryExpression345.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:873:3: ( multiplicativeOperator unaryExpression )*
                    do
                    {
                        int alt81 = 2;
                        int LA81_0 = input.LA(1);

                        if ((LA81_0 == STAR || (LA81_0 >= DIV && LA81_0 <= MOD)))
                        {
                            alt81 = 1;
                        }


                        switch (alt81)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:873:5: multiplicativeOperator unaryExpression
                                {
                                    PushFollow(FOLLOW_multiplicativeOperator_in_multiplicativeExpression3727);
                                    multiplicativeOperator346 = multiplicativeOperator();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(multiplicativeOperator346.Tree, root_0);
                                    PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3733);
                                    unaryExpression347 = unaryExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) adaptor.AddChild(root_0, unaryExpression347.Tree);

                                }
                                break;

                            default:
                                goto loop81;
                        }
                    } while (true);

                loop81:
                    ;	// Stops C# compiler whinging that label 'loop81' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 113, multiplicativeExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end multiplicativeExpression

        public class multiplicativeOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start multiplicativeOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:878:1: multiplicativeOperator : ( STAR | DIV | MOD );
        public multiplicativeOperator_return multiplicativeOperator() // throws RecognitionException [1]
        {
            multiplicativeOperator_return retval = new multiplicativeOperator_return();
            retval.start = input.LT(1);
            int multiplicativeOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set348 = null;

            CommonTree set348_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 114))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:879:4: ( STAR | DIV | MOD )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set348 = (IToken)input.LT(1);
                    if (input.LA(1) == STAR || (input.LA(1) >= DIV && input.LA(1) <= MOD))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set348));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_multiplicativeOperator0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 114, multiplicativeOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end multiplicativeOperator

        public class unaryExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start unaryExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:883:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );
        public unaryExpression_return unaryExpression() // throws RecognitionException [1]
        {
            unaryExpression_return retval = new unaryExpression_return();
            retval.start = input.LT(1);
            int unaryExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken iin = null;
            IToken dde = null;
            IToken MINUS351 = null;
            IToken PLUS353 = null;
            unaryExpression_return unaryExpression349 = null;

            unaryExpression_return unaryExpression350 = null;

            unaryExpression_return unaryExpression352 = null;

            unaryExpression_return unaryExpression354 = null;

            unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus355 = null;


            CommonTree iin_tree = null;
            CommonTree dde_tree = null;
            CommonTree MINUS351_tree = null;
            CommonTree PLUS353_tree = null;
            RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream(adaptor, "token PLUS");
            RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor, "token INC");
            RewriteRuleTokenStream stream_MINUS = new RewriteRuleTokenStream(adaptor, "token MINUS");
            RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor, "token DEC");
            RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule unaryExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 115))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:884:4: (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus )
                int alt82 = 5;
                switch (input.LA(1))
                {
                    case INC:
                        {
                            alt82 = 1;
                        }
                        break;
                    case DEC:
                        {
                            alt82 = 2;
                        }
                        break;
                    case MINUS:
                        {
                            alt82 = 3;
                        }
                        break;
                    case PLUS:
                        {
                            alt82 = 4;
                        }
                        break;
                    case LCURLY:
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case DIV:
                    case DELETE:
                    case TYPEOF:
                    case LNOT:
                    case BNOT:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                    case 175:
                        {
                            alt82 = 5;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d82s0 =
                            new NoViableAltException("883:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );", 82, 0, input);

                        throw nvae_d82s0;
                }

                switch (alt82)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:884:4: iin= INC unaryExpression
                        {
                            iin = (IToken)input.LT(1);
                            Match(input, INC, FOLLOW_INC_in_unaryExpression3771); if (failed) return retval;
                            if (backtracking == 0) stream_INC.Add(iin);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3773);
                            unaryExpression349 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression349.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 884:28: -> ^( PRE_INC[$iin] unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:884:31: ^( PRE_INC[$iin] unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_INC, iin), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:885:4: dde= DEC unaryExpression
                        {
                            dde = (IToken)input.LT(1);
                            Match(input, DEC, FOLLOW_DEC_in_unaryExpression3789); if (failed) return retval;
                            if (backtracking == 0) stream_DEC.Add(dde);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3791);
                            unaryExpression350 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression350.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 885:28: -> ^( PRE_DEC[$dde] unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:885:31: ^( PRE_DEC[$dde] unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_DEC, dde), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:4: MINUS unaryExpression
                        {
                            MINUS351 = (IToken)input.LT(1);
                            Match(input, MINUS, FOLLOW_MINUS_in_unaryExpression3805); if (failed) return retval;
                            if (backtracking == 0) stream_MINUS.Add(MINUS351);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3807);
                            unaryExpression352 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression352.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 886:26: -> ^( UNARY_MINUS unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:29: ^( UNARY_MINUS unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:4: PLUS unaryExpression
                        {
                            PLUS353 = (IToken)input.LT(1);
                            Match(input, PLUS, FOLLOW_PLUS_in_unaryExpression3820); if (failed) return retval;
                            if (backtracking == 0) stream_PLUS.Add(PLUS353);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpression3822);
                            unaryExpression354 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression354.Tree);

                            // AST REWRITE
                            // elements:          unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 887:25: -> ^( UNARY_PLUS unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:28: ^( UNARY_PLUS unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_PLUS, "UNARY_PLUS"), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:888:4: unaryExpressionNotPlusMinus
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3835);
                            unaryExpressionNotPlusMinus355 = unaryExpressionNotPlusMinus();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus355.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 115, unaryExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end unaryExpression

        public class unaryExpressionNotPlusMinus_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start unaryExpressionNotPlusMinus
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:891:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
        public unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus() // throws RecognitionException [1]
        {
            unaryExpressionNotPlusMinus_return retval = new unaryExpressionNotPlusMinus_return();
            retval.start = input.LT(1);
            int unaryExpressionNotPlusMinus_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DELETE356 = null;
            IToken string_literal358 = null;
            IToken TYPEOF360 = null;
            IToken LNOT362 = null;
            IToken BNOT364 = null;
            postfixExpression_return postfixExpression357 = null;

            unaryExpression_return unaryExpression359 = null;

            unaryExpression_return unaryExpression361 = null;

            unaryExpression_return unaryExpression363 = null;

            unaryExpression_return unaryExpression365 = null;

            postfixExpression_return postfixExpression366 = null;


            CommonTree DELETE356_tree = null;
            CommonTree string_literal358_tree = null;
            CommonTree TYPEOF360_tree = null;
            CommonTree LNOT362_tree = null;
            CommonTree BNOT364_tree = null;
            RewriteRuleTokenStream stream_BNOT = new RewriteRuleTokenStream(adaptor, "token BNOT");
            RewriteRuleTokenStream stream_175 = new RewriteRuleTokenStream(adaptor, "token 175");
            RewriteRuleTokenStream stream_LNOT = new RewriteRuleTokenStream(adaptor, "token LNOT");
            RewriteRuleTokenStream stream_TYPEOF = new RewriteRuleTokenStream(adaptor, "token TYPEOF");
            RewriteRuleTokenStream stream_DELETE = new RewriteRuleTokenStream(adaptor, "token DELETE");
            RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule unaryExpression");
            RewriteRuleSubtreeStream stream_postfixExpression = new RewriteRuleSubtreeStream(adaptor, "rule postfixExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 116))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:892:4: ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
                int alt83 = 6;
                switch (input.LA(1))
                {
                    case DELETE:
                        {
                            alt83 = 1;
                        }
                        break;
                    case 175:
                        {
                            alt83 = 2;
                        }
                        break;
                    case TYPEOF:
                        {
                            alt83 = 3;
                        }
                        break;
                    case LNOT:
                        {
                            alt83 = 4;
                        }
                        break;
                    case BNOT:
                        {
                            alt83 = 5;
                        }
                        break;
                    case LCURLY:
                    case STRING_LITERAL:
                    case FUNCTION:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case LPAREN:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case LBRACK:
                    case DYNAMIC:
                    case LT:
                    case IS:
                    case AS:
                    case DIV:
                    case E4X_ATTRI:
                    case UNDEFINED:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                    case NEW:
                        {
                            alt83 = 6;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d83s0 =
                            new NoViableAltException("891:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );", 83, 0, input);

                        throw nvae_d83s0;
                }

                switch (alt83)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:892:4: DELETE postfixExpression
                        {
                            DELETE356 = (IToken)input.LT(1);
                            Match(input, DELETE, FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3846); if (failed) return retval;
                            if (backtracking == 0) stream_DELETE.Add(DELETE356);

                            PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3848);
                            postfixExpression357 = postfixExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_postfixExpression.Add(postfixExpression357.Tree);

                            // AST REWRITE
                            // elements:          postfixExpression, DELETE
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 892:29: -> ^( DELETE postfixExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:892:32: ^( DELETE postfixExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_DELETE.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_postfixExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:893:4: 'void' unaryExpression
                        {
                            string_literal358 = (IToken)input.LT(1);
                            Match(input, 175, FOLLOW_175_in_unaryExpressionNotPlusMinus3861); if (failed) return retval;
                            if (backtracking == 0) stream_175.Add(string_literal358);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3863);
                            unaryExpression359 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression359.Tree);

                            // AST REWRITE
                            // elements:          175, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 893:27: -> ^( 'void' unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:893:30: ^( 'void' unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_175.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:894:4: TYPEOF unaryExpression
                        {
                            TYPEOF360 = (IToken)input.LT(1);
                            Match(input, TYPEOF, FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3876); if (failed) return retval;
                            if (backtracking == 0) stream_TYPEOF.Add(TYPEOF360);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3878);
                            unaryExpression361 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression361.Tree);

                            // AST REWRITE
                            // elements:          TYPEOF, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 894:27: -> ^( TYPEOF unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:894:30: ^( TYPEOF unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_TYPEOF.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:4: LNOT unaryExpression
                        {
                            LNOT362 = (IToken)input.LT(1);
                            Match(input, LNOT, FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3891); if (failed) return retval;
                            if (backtracking == 0) stream_LNOT.Add(LNOT362);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3893);
                            unaryExpression363 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression363.Tree);

                            // AST REWRITE
                            // elements:          LNOT, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 895:25: -> ^( LNOT unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:28: ^( LNOT unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:4: BNOT unaryExpression
                        {
                            BNOT364 = (IToken)input.LT(1);
                            Match(input, BNOT, FOLLOW_BNOT_in_unaryExpressionNotPlusMinus3906); if (failed) return retval;
                            if (backtracking == 0) stream_BNOT.Add(BNOT364);

                            PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3908);
                            unaryExpression365 = unaryExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) stream_unaryExpression.Add(unaryExpression365.Tree);

                            // AST REWRITE
                            // elements:          BNOT, unaryExpression
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 896:25: -> ^( BNOT unaryExpression )
                                {
                                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:28: ^( BNOT unaryExpression )
                                    {
                                        CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                        root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.Next(), root_1);

                                        adaptor.AddChild(root_1, stream_unaryExpression.Next());

                                        adaptor.AddChild(root_0, root_1);
                                    }

                                }

                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:4: postfixExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3921);
                            postfixExpression366 = postfixExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, postfixExpression366.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 116, unaryExpressionNotPlusMinus_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end unaryExpressionNotPlusMinus

        public class postfixExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start postfixExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:901:1: postfixExpression : ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? ;
        public postfixExpression_return postfixExpression() // throws RecognitionException [1]
        {
            postfixExpression_return retval = new postfixExpression_return();
            retval.start = input.LT(1);
            int postfixExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken iin = null;
            IToken dde = null;
            IToken DOT368 = null;
            IToken LBRACK370 = null;
            IToken RBRACK372 = null;
            IToken E4X_DESC373 = null;
            propOrIdent_return poi = null;

            primaryExpression_return primaryExpression367 = null;

            e4xExpression_return e4xExpression369 = null;

            expression_return expression371 = null;

            e4xExpression_return e4xExpression374 = null;

            arguments_return arguments375 = null;


            CommonTree iin_tree = null;
            CommonTree dde_tree = null;
            CommonTree DOT368_tree = null;
            CommonTree LBRACK370_tree = null;
            CommonTree RBRACK372_tree = null;
            CommonTree E4X_DESC373_tree = null;
            RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor, "token LBRACK");
            RewriteRuleTokenStream stream_E4X_DESC = new RewriteRuleTokenStream(adaptor, "token E4X_DESC");
            RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor, "token INC");
            RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor, "token RBRACK");
            RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor, "token DEC");
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_arguments = new RewriteRuleSubtreeStream(adaptor, "rule arguments");
            RewriteRuleSubtreeStream stream_e4xExpression = new RewriteRuleSubtreeStream(adaptor, "rule e4xExpression");
            RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule primaryExpression");
            RewriteRuleSubtreeStream stream_propOrIdent = new RewriteRuleSubtreeStream(adaptor, "rule propOrIdent");
            RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor, "rule expression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 117))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:4: ( ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:4: ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:4: ( primaryExpression -> primaryExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:902:5: primaryExpression
                    {
                        PushFollow(FOLLOW_primaryExpression_in_postfixExpression3934);
                        primaryExpression367 = primaryExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_primaryExpression.Add(primaryExpression367.Tree);

                        // AST REWRITE
                        // elements:          primaryExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 902:23: -> primaryExpression
                            {
                                adaptor.AddChild(root_0, stream_primaryExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:3: (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )*
                    do
                    {
                        int alt84 = 6;
                        switch (input.LA(1))
                        {
                            case DOT:
                                {
                                    int LA84_29 = input.LA(2);

                                    if (((LA84_29 >= GET && LA84_29 <= USE) || LA84_29 == XML || (LA84_29 >= IDENT && LA84_29 <= INTERNAL) || LA84_29 == DYNAMIC || (LA84_29 >= IS && LA84_29 <= AS)))
                                    {
                                        alt84 = 1;
                                    }
                                    else if ((LA84_29 == LPAREN || LA84_29 == STAR || LA84_29 == E4X_ATTRI))
                                    {
                                        alt84 = 2;
                                    }


                                }
                                break;
                            case LBRACK:
                                {
                                    alt84 = 3;
                                }
                                break;
                            case E4X_DESC:
                                {
                                    alt84 = 4;
                                }
                                break;
                            case LPAREN:
                                {
                                    alt84 = 5;
                                }
                                break;

                        }

                        switch (alt84)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:903:5: poi= propOrIdent[root_0, retval.start]
                                {
                                    PushFollow(FOLLOW_propOrIdent_in_postfixExpression3947);
                                    poi = propOrIdent(root_0, retval.start);
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_propOrIdent.Add(poi.Tree);

                                    // AST REWRITE
                                    // elements:          poi
                                    // token labels:      
                                    // rule labels:       retval, poi
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));
                                        RewriteRuleSubtreeStream stream_poi = new RewriteRuleSubtreeStream(adaptor, "token poi", (poi != null ? poi.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 903:43: -> $poi
                                        {
                                            adaptor.AddChild(root_0, stream_poi.Next());

                                        }

                                    }

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:904:5: DOT e4xExpression
                                {
                                    DOT368 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_postfixExpression3959); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT368);

                                    PushFollow(FOLLOW_e4xExpression_in_postfixExpression3961);
                                    e4xExpression369 = e4xExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_e4xExpression.Add(e4xExpression369.Tree);

                                }
                                break;
                            case 3:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:5: LBRACK expression RBRACK
                                {
                                    LBRACK370 = (IToken)input.LT(1);
                                    Match(input, LBRACK, FOLLOW_LBRACK_in_postfixExpression3967); if (failed) return retval;
                                    if (backtracking == 0) stream_LBRACK.Add(LBRACK370);

                                    PushFollow(FOLLOW_expression_in_postfixExpression3969);
                                    expression371 = expression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_expression.Add(expression371.Tree);
                                    RBRACK372 = (IToken)input.LT(1);
                                    Match(input, RBRACK, FOLLOW_RBRACK_in_postfixExpression3971); if (failed) return retval;
                                    if (backtracking == 0) stream_RBRACK.Add(RBRACK372);


                                    // AST REWRITE
                                    // elements:          expression, postfixExpression
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 905:30: -> ^( ARRAY_ACC $postfixExpression expression )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:33: ^( ARRAY_ACC $postfixExpression expression )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_expression.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;
                            case 4:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:906:5: E4X_DESC e4xExpression
                                {
                                    E4X_DESC373 = (IToken)input.LT(1);
                                    Match(input, E4X_DESC, FOLLOW_E4X_DESC_in_postfixExpression3988); if (failed) return retval;
                                    if (backtracking == 0) stream_E4X_DESC.Add(E4X_DESC373);

                                    PushFollow(FOLLOW_e4xExpression_in_postfixExpression3990);
                                    e4xExpression374 = e4xExpression();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_e4xExpression.Add(e4xExpression374.Tree);

                                }
                                break;
                            case 5:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:907:5: arguments
                                {
                                    PushFollow(FOLLOW_arguments_in_postfixExpression3996);
                                    arguments375 = arguments();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_arguments.Add(arguments375.Tree);

                                    // AST REWRITE
                                    // elements:          postfixExpression, arguments
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 907:15: -> ^( METHOD_CALL $postfixExpression arguments )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:907:18: ^( METHOD_CALL $postfixExpression arguments )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_CALL, "METHOD_CALL"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_arguments.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;

                            default:
                                goto loop84;
                        }
                    } while (true);

                loop84:
                    ;	// Stops C# compiler whinging that label 'loop84' has no statements

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:3: (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
                    int alt85 = 3;
                    int LA85_0 = input.LA(1);

                    if ((LA85_0 == INC))
                    {
                        alt85 = 1;
                    }
                    else if ((LA85_0 == DEC))
                    {
                        alt85 = 2;
                    }
                    switch (alt85)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:6: iin= INC
                            {
                                iin = (IToken)input.LT(1);
                                Match(input, INC, FOLLOW_INC_in_postfixExpression4022); if (failed) return retval;
                                if (backtracking == 0) stream_INC.Add(iin);


                                // AST REWRITE
                                // elements:          postfixExpression
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 910:14: -> ^( POST_INC[$iin] $postfixExpression)
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:17: ^( POST_INC[$iin] $postfixExpression)
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_INC, iin), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:911:6: dde= DEC
                            {
                                dde = (IToken)input.LT(1);
                                Match(input, DEC, FOLLOW_DEC_in_postfixExpression4041); if (failed) return retval;
                                if (backtracking == 0) stream_DEC.Add(dde);


                                // AST REWRITE
                                // elements:          postfixExpression
                                // token labels:      
                                // rule labels:       retval
                                // token list labels: 
                                // rule list labels:  
                                if (backtracking == 0)
                                {
                                    retval.tree = root_0;
                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                    root_0 = (CommonTree)adaptor.GetNilNode();
                                    // 911:14: -> ^( POST_DEC[$dde] $postfixExpression)
                                    {
                                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:911:17: ^( POST_DEC[$dde] $postfixExpression)
                                        {
                                            CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                            root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_DEC, dde), root_1);

                                            adaptor.AddChild(root_1, stream_retval.Next());

                                            adaptor.AddChild(root_0, root_1);
                                        }

                                    }

                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 117, postfixExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end postfixExpression

        public class e4xExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:915:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
        public e4xExpression_return e4xExpression() // throws RecognitionException [1]
        {
            e4xExpression_return retval = new e4xExpression_return();
            retval.start = input.LT(1);
            int e4xExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STAR376 = null;
            e4xAttributeIdentifier_return e4xAttributeIdentifier377 = null;

            e4xFilterPredicate_return e4xFilterPredicate378 = null;


            CommonTree STAR376_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 118))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:916:4: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
                int alt86 = 3;
                switch (input.LA(1))
                {
                    case STAR:
                        {
                            alt86 = 1;
                        }
                        break;
                    case E4X_ATTRI:
                        {
                            alt86 = 2;
                        }
                        break;
                    case LPAREN:
                        {
                            alt86 = 3;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d86s0 =
                            new NoViableAltException("915:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );", 86, 0, input);

                        throw nvae_d86s0;
                }

                switch (alt86)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:916:4: STAR
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STAR376 = (IToken)input.LT(1);
                            Match(input, STAR, FOLLOW_STAR_in_e4xExpression4068); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STAR376_tree = (CommonTree)adaptor.Create(STAR376);
                                root_0 = (CommonTree)adaptor.BecomeRoot(STAR376_tree, root_0);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:917:4: e4xAttributeIdentifier
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xAttributeIdentifier_in_e4xExpression4074);
                            e4xAttributeIdentifier377 = e4xAttributeIdentifier();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier377.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:918:4: e4xFilterPredicate
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xFilterPredicate_in_e4xExpression4079);
                            e4xFilterPredicate378 = e4xFilterPredicate();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xFilterPredicate378.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 118, e4xExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xExpression

        public class e4xAttributeIdentifier_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xAttributeIdentifier
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:921:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
        public e4xAttributeIdentifier_return e4xAttributeIdentifier() // throws RecognitionException [1]
        {
            e4xAttributeIdentifier_return retval = new e4xAttributeIdentifier_return();
            retval.start = input.LT(1);
            int e4xAttributeIdentifier_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken E4X_ATTRI379 = null;
            IToken STAR381 = null;
            IToken LBRACK382 = null;
            IToken RBRACK384 = null;
            qualifiedIdent_return qualifiedIdent380 = null;

            expression_return expression383 = null;


            CommonTree E4X_ATTRI379_tree = null;
            CommonTree STAR381_tree = null;
            CommonTree LBRACK382_tree = null;
            CommonTree RBRACK384_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 119))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:922:4: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:922:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    E4X_ATTRI379 = (IToken)input.LT(1);
                    Match(input, E4X_ATTRI, FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4090); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        E4X_ATTRI379_tree = (CommonTree)adaptor.Create(E4X_ATTRI379);
                        adaptor.AddChild(root_0, E4X_ATTRI379_tree);
                    }
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:923:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
                    int alt87 = 3;
                    switch (input.LA(1))
                    {
                        case GET:
                        case SET:
                        case NAMESPACE:
                        case USE:
                        case XML:
                        case IDENT:
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                        case DYNAMIC:
                        case IS:
                        case AS:
                            {
                                alt87 = 1;
                            }
                            break;
                        case STAR:
                            {
                                alt87 = 2;
                            }
                            break;
                        case LBRACK:
                            {
                                alt87 = 3;
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d87s0 =
                                new NoViableAltException("923:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )", 87, 0, input);

                            throw nvae_d87s0;
                    }

                    switch (alt87)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:923:5: qualifiedIdent
                            {
                                PushFollow(FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4096);
                                qualifiedIdent380 = qualifiedIdent();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent380.Tree);

                            }
                            break;
                        case 2:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:5: STAR
                            {
                                STAR381 = (IToken)input.LT(1);
                                Match(input, STAR, FOLLOW_STAR_in_e4xAttributeIdentifier4102); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    STAR381_tree = (CommonTree)adaptor.Create(STAR381);
                                    adaptor.AddChild(root_0, STAR381_tree);
                                }

                            }
                            break;
                        case 3:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:925:5: LBRACK expression RBRACK
                            {
                                LBRACK382 = (IToken)input.LT(1);
                                Match(input, LBRACK, FOLLOW_LBRACK_in_e4xAttributeIdentifier4108); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    LBRACK382_tree = (CommonTree)adaptor.Create(LBRACK382);
                                    adaptor.AddChild(root_0, LBRACK382_tree);
                                }
                                PushFollow(FOLLOW_expression_in_e4xAttributeIdentifier4110);
                                expression383 = expression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) adaptor.AddChild(root_0, expression383.Tree);
                                RBRACK384 = (IToken)input.LT(1);
                                Match(input, RBRACK, FOLLOW_RBRACK_in_e4xAttributeIdentifier4112); if (failed) return retval;
                                if (backtracking == 0)
                                {
                                    RBRACK384_tree = (CommonTree)adaptor.Create(RBRACK384);
                                    adaptor.AddChild(root_0, RBRACK384_tree);
                                }

                            }
                            break;

                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 119, e4xAttributeIdentifier_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xAttributeIdentifier

        public class e4xFilterPredicate_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start e4xFilterPredicate
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:929:1: e4xFilterPredicate : LPAREN expression RPAREN ;
        public e4xFilterPredicate_return e4xFilterPredicate() // throws RecognitionException [1]
        {
            e4xFilterPredicate_return retval = new e4xFilterPredicate_return();
            retval.start = input.LT(1);
            int e4xFilterPredicate_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN385 = null;
            IToken RPAREN387 = null;
            expression_return expression386 = null;


            CommonTree LPAREN385_tree = null;
            CommonTree RPAREN387_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 120))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:930:4: ( LPAREN expression RPAREN )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:930:4: LPAREN expression RPAREN
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    LPAREN385 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_e4xFilterPredicate4127); if (failed) return retval;
                    PushFollow(FOLLOW_expression_in_e4xFilterPredicate4132);
                    expression386 = expression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expression386.Tree);
                    RPAREN387 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_e4xFilterPredicate4136); if (failed) return retval;

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 120, e4xFilterPredicate_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end e4xFilterPredicate

        public class primaryExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start primaryExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
        public primaryExpression_return primaryExpression() // throws RecognitionException [1]
        {
            primaryExpression_return retval = new primaryExpression_return();
            retval.start = input.LT(1);
            int primaryExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken UNDEFINED388 = null;
            constant_return constant389 = null;

            arrayLiteral_return arrayLiteral390 = null;

            objectLiteral_return objectLiteral391 = null;

            functionDefinition_return functionDefinition392 = null;

            newFullExpression_return newFullExpression393 = null;

            newShortExpression_return newShortExpression394 = null;

            encapsulatedExpression_return encapsulatedExpression395 = null;

            e4xAttributeIdentifier_return e4xAttributeIdentifier396 = null;

            qualifiedIdent_return qualifiedIdent397 = null;


            CommonTree UNDEFINED388_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 121))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
                int alt88 = 10;
                switch (input.LA(1))
                {
                    case UNDEFINED:
                        {
                            alt88 = 1;
                        }
                        break;
                    case STRING_LITERAL:
                    case LT:
                    case DIV:
                    case TRUE:
                    case FALSE:
                    case NULL:
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt88 = 2;
                        }
                        break;
                    case LBRACK:
                        {
                            alt88 = 3;
                        }
                        break;
                    case LCURLY:
                        {
                            alt88 = 4;
                        }
                        break;
                    case FUNCTION:
                        {
                            alt88 = 5;
                        }
                        break;
                    case NEW:
                        {
                            switch (input.LA(2))
                            {
                                case UNDEFINED:
                                    {
                                        int LA88_25 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s25 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 25, input);

                                            throw nvae_d88s25;
                                        }
                                    }
                                    break;
                                case LT:
                                    {
                                        int LA88_26 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s26 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 26, input);

                                            throw nvae_d88s26;
                                        }
                                    }
                                    break;
                                case DIV:
                                    {
                                        int LA88_27 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s27 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 27, input);

                                            throw nvae_d88s27;
                                        }
                                    }
                                    break;
                                case HEX_LITERAL:
                                case DECIMAL_LITERAL:
                                case OCTAL_LITERAL:
                                case FLOAT_LITERAL:
                                    {
                                        int LA88_28 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s28 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 28, input);

                                            throw nvae_d88s28;
                                        }
                                    }
                                    break;
                                case STRING_LITERAL:
                                    {
                                        int LA88_29 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s29 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 29, input);

                                            throw nvae_d88s29;
                                        }
                                    }
                                    break;
                                case TRUE:
                                    {
                                        int LA88_30 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s30 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 30, input);

                                            throw nvae_d88s30;
                                        }
                                    }
                                    break;
                                case FALSE:
                                    {
                                        int LA88_31 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s31 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 31, input);

                                            throw nvae_d88s31;
                                        }
                                    }
                                    break;
                                case NULL:
                                    {
                                        int LA88_32 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s32 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 32, input);

                                            throw nvae_d88s32;
                                        }
                                    }
                                    break;
                                case LBRACK:
                                    {
                                        int LA88_33 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s33 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 33, input);

                                            throw nvae_d88s33;
                                        }
                                    }
                                    break;
                                case LCURLY:
                                    {
                                        int LA88_34 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s34 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 34, input);

                                            throw nvae_d88s34;
                                        }
                                    }
                                    break;
                                case FUNCTION:
                                    {
                                        int LA88_35 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s35 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 35, input);

                                            throw nvae_d88s35;
                                        }
                                    }
                                    break;
                                case NEW:
                                    {
                                        int LA88_36 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s36 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 36, input);

                                            throw nvae_d88s36;
                                        }
                                    }
                                    break;
                                case LPAREN:
                                    {
                                        int LA88_37 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s37 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 37, input);

                                            throw nvae_d88s37;
                                        }
                                    }
                                    break;
                                case E4X_ATTRI:
                                    {
                                        int LA88_38 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s38 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 38, input);

                                            throw nvae_d88s38;
                                        }
                                    }
                                    break;
                                case IDENT:
                                    {
                                        int LA88_39 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s39 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 39, input);

                                            throw nvae_d88s39;
                                        }
                                    }
                                    break;
                                case PUBLIC:
                                case PRIVATE:
                                case PROTECTED:
                                case INTERNAL:
                                    {
                                        int LA88_40 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s40 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 40, input);

                                            throw nvae_d88s40;
                                        }
                                    }
                                    break;
                                case USE:
                                    {
                                        int LA88_41 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s41 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 41, input);

                                            throw nvae_d88s41;
                                        }
                                    }
                                    break;
                                case XML:
                                    {
                                        int LA88_42 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s42 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 42, input);

                                            throw nvae_d88s42;
                                        }
                                    }
                                    break;
                                case DYNAMIC:
                                    {
                                        int LA88_43 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s43 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 43, input);

                                            throw nvae_d88s43;
                                        }
                                    }
                                    break;
                                case NAMESPACE:
                                    {
                                        int LA88_44 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s44 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 44, input);

                                            throw nvae_d88s44;
                                        }
                                    }
                                    break;
                                case IS:
                                    {
                                        int LA88_45 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s45 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 45, input);

                                            throw nvae_d88s45;
                                        }
                                    }
                                    break;
                                case AS:
                                    {
                                        int LA88_46 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s46 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 46, input);

                                            throw nvae_d88s46;
                                        }
                                    }
                                    break;
                                case GET:
                                    {
                                        int LA88_47 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s47 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 47, input);

                                            throw nvae_d88s47;
                                        }
                                    }
                                    break;
                                case SET:
                                    {
                                        int LA88_48 = input.LA(3);

                                        if ((synpred172()))
                                        {
                                            alt88 = 6;
                                        }
                                        else if ((synpred173()))
                                        {
                                            alt88 = 7;
                                        }
                                        else
                                        {
                                            if (backtracking > 0) { failed = true; return retval; }
                                            NoViableAltException nvae_d88s48 =
                                                new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 48, input);

                                            throw nvae_d88s48;
                                        }
                                    }
                                    break;
                                default:
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d88s12 =
                                        new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 12, input);

                                    throw nvae_d88s12;
                            }

                        }
                        break;
                    case LPAREN:
                        {
                            alt88 = 8;
                        }
                        break;
                    case E4X_ATTRI:
                        {
                            alt88 = 9;
                        }
                        break;
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case USE:
                    case XML:
                    case IDENT:
                    case PUBLIC:
                    case PRIVATE:
                    case PROTECTED:
                    case INTERNAL:
                    case DYNAMIC:
                    case IS:
                    case AS:
                        {
                            alt88 = 10;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d88s0 =
                            new NoViableAltException("935:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 88, 0, input);

                        throw nvae_d88s0;
                }

                switch (alt88)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:936:4: UNDEFINED
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            UNDEFINED388 = (IToken)input.LT(1);
                            Match(input, UNDEFINED, FOLLOW_UNDEFINED_in_primaryExpression4148); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                UNDEFINED388_tree = (CommonTree)adaptor.Create(UNDEFINED388);
                                adaptor.AddChild(root_0, UNDEFINED388_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:937:4: constant
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_constant_in_primaryExpression4153);
                            constant389 = constant();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, constant389.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:938:4: arrayLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_arrayLiteral_in_primaryExpression4158);
                            arrayLiteral390 = arrayLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, arrayLiteral390.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:939:4: objectLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_objectLiteral_in_primaryExpression4163);
                            objectLiteral391 = objectLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, objectLiteral391.Tree);

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:940:4: functionDefinition
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_functionDefinition_in_primaryExpression4168);
                            functionDefinition392 = functionDefinition();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, functionDefinition392.Tree);

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:941:4: newFullExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newFullExpression_in_primaryExpression4173);
                            newFullExpression393 = newFullExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newFullExpression393.Tree);

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: newShortExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newShortExpression_in_primaryExpression4178);
                            newShortExpression394 = newShortExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newShortExpression394.Tree);

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:943:4: encapsulatedExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_encapsulatedExpression_in_primaryExpression4183);
                            encapsulatedExpression395 = encapsulatedExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, encapsulatedExpression395.Tree);

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:944:4: e4xAttributeIdentifier
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_e4xAttributeIdentifier_in_primaryExpression4188);
                            e4xAttributeIdentifier396 = e4xAttributeIdentifier();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier396.Tree);

                        }
                        break;
                    case 10:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:4: qualifiedIdent
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_qualifiedIdent_in_primaryExpression4193);
                            qualifiedIdent397 = qualifiedIdent();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent397.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 121, primaryExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end primaryExpression

        public class propOrIdent_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start propOrIdent
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:949:1: propOrIdent[CommonTree identPrimary, IToken startToken] : DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) ;
        public propOrIdent_return propOrIdent(CommonTree identPrimary, IToken startToken) // throws RecognitionException [1]
        {
            propOrIdent_return retval = new propOrIdent_return();
            retval.start = input.LT(1);
            int propOrIdent_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT398 = null;
            qualifiedIdent_return propId = null;


            CommonTree DOT398_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 122))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:3: ( DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:951:3: DOT propId= qualifiedIdent
                {
                    if (backtracking == 0)
                    {
                        retval.start = startToken;
                    }
                    DOT398 = (IToken)input.LT(1);
                    Match(input, DOT, FOLLOW_DOT_in_propOrIdent4213); if (failed) return retval;
                    if (backtracking == 0) stream_DOT.Add(DOT398);

                    PushFollow(FOLLOW_qualifiedIdent_in_propOrIdent4217);
                    propId = qualifiedIdent();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_qualifiedIdent.Add(propId.Tree);

                    // AST REWRITE
                    // elements:          propId
                    // token labels:      
                    // rule labels:       propId, retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_propId = new RewriteRuleSubtreeStream(adaptor, "token propId", (propId != null ? propId.Tree : null));
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 958:3: -> ^( PROPERTY_OR_IDENTIFIER $propId)
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:958:6: ^( PROPERTY_OR_IDENTIFIER $propId)
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PROPERTY_OR_IDENTIFIER, "PROPERTY_OR_IDENTIFIER"), root_1);

                                adaptor.AddChild(root_1, identPrimary);
                                adaptor.AddChild(root_1, stream_propId.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 122, propOrIdent_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end propOrIdent

        public class constant_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start constant
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:961:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );
        public constant_return constant() // throws RecognitionException [1]
        {
            constant_return retval = new constant_return();
            retval.start = input.LT(1);
            int constant_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken STRING_LITERAL402 = null;
            IToken TRUE403 = null;
            IToken FALSE404 = null;
            IToken NULL405 = null;
            xmlLiteral_return xmlLiteral399 = null;

            regexpLiteral_return regexpLiteral400 = null;

            number_return number401 = null;


            CommonTree STRING_LITERAL402_tree = null;
            CommonTree TRUE403_tree = null;
            CommonTree FALSE404_tree = null;
            CommonTree NULL405_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 123))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:962:4: ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL )
                int alt89 = 7;
                switch (input.LA(1))
                {
                    case LT:
                        {
                            alt89 = 1;
                        }
                        break;
                    case DIV:
                        {
                            alt89 = 2;
                        }
                        break;
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    case FLOAT_LITERAL:
                        {
                            alt89 = 3;
                        }
                        break;
                    case STRING_LITERAL:
                        {
                            alt89 = 4;
                        }
                        break;
                    case TRUE:
                        {
                            alt89 = 5;
                        }
                        break;
                    case FALSE:
                        {
                            alt89 = 6;
                        }
                        break;
                    case NULL:
                        {
                            alt89 = 7;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d89s0 =
                            new NoViableAltException("961:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );", 89, 0, input);

                        throw nvae_d89s0;
                }

                switch (alt89)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:962:4: xmlLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_xmlLiteral_in_constant4245);
                            xmlLiteral399 = xmlLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, xmlLiteral399.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:963:4: regexpLiteral
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_regexpLiteral_in_constant4250);
                            regexpLiteral400 = regexpLiteral();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, regexpLiteral400.Tree);

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:964:4: number
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_number_in_constant4255);
                            number401 = number();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, number401.Tree);

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:4: STRING_LITERAL
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            STRING_LITERAL402 = (IToken)input.LT(1);
                            Match(input, STRING_LITERAL, FOLLOW_STRING_LITERAL_in_constant4260); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                STRING_LITERAL402_tree = (CommonTree)adaptor.Create(STRING_LITERAL402);
                                adaptor.AddChild(root_0, STRING_LITERAL402_tree);
                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:966:4: TRUE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            TRUE403 = (IToken)input.LT(1);
                            Match(input, TRUE, FOLLOW_TRUE_in_constant4265); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                TRUE403_tree = (CommonTree)adaptor.Create(TRUE403);
                                adaptor.AddChild(root_0, TRUE403_tree);
                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:967:4: FALSE
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            FALSE404 = (IToken)input.LT(1);
                            Match(input, FALSE, FOLLOW_FALSE_in_constant4270); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                FALSE404_tree = (CommonTree)adaptor.Create(FALSE404);
                                adaptor.AddChild(root_0, FALSE404_tree);
                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:968:4: NULL
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            NULL405 = (IToken)input.LT(1);
                            Match(input, NULL, FOLLOW_NULL_in_constant4275); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                NULL405_tree = (CommonTree)adaptor.Create(NULL405);
                                adaptor.AddChild(root_0, NULL405_tree);
                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 123, constant_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end constant

        public class number_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start number
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:971:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
        public number_return number() // throws RecognitionException [1]
        {
            number_return retval = new number_return();
            retval.start = input.LT(1);
            int number_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken set406 = null;

            CommonTree set406_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 124))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:971:10: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    set406 = (IToken)input.LT(1);
                    if ((input.LA(1) >= HEX_LITERAL && input.LA(1) <= FLOAT_LITERAL))
                    {
                        input.Consume();
                        if (backtracking == 0) adaptor.AddChild(root_0, adaptor.Create(set406));
                        errorRecovery = false; failed = false;
                    }
                    else
                    {
                        if (backtracking > 0) { failed = true; return retval; }
                        MismatchedSetException mse =
                            new MismatchedSetException(null, input);
                        RecoverFromMismatchedSet(input, mse, FOLLOW_set_in_number0); throw mse;
                    }


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 124, number_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end number

        public class xmlLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start xmlLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:978:1: xmlLiteral : LT ->;
        public xmlLiteral_return xmlLiteral() // throws RecognitionException [1]
        {
            xmlLiteral_return retval = new xmlLiteral_return();
            retval.start = input.LT(1);
            int xmlLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LT407 = null;

            CommonTree LT407_tree = null;
            RewriteRuleTokenStream stream_LT = new RewriteRuleTokenStream(adaptor, "token LT");


            CommonTree xml = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 125))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:985:3: ( LT ->)
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:985:3: LT
                {
                    LT407 = (IToken)input.LT(1);
                    Match(input, LT, FOLLOW_LT_in_xmlLiteral4328); if (failed) return retval;
                    if (backtracking == 0) stream_LT.Add(LT407);

                    if (backtracking == 0)
                    {
                        /*xml=parseXMLLiteral();*/
                    }

                    // AST REWRITE
                    // elements:          
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 987:3: ->
                        {
                            adaptor.AddChild(root_0, xml);

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 125, xmlLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end xmlLiteral

        public class regexpLiteral_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start regexpLiteral
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:991:1: regexpLiteral : s= DIV -> ^() ;
        public regexpLiteral_return regexpLiteral() // throws RecognitionException [1]
        {
            regexpLiteral_return retval = new regexpLiteral_return();
            retval.start = input.LT(1);
            int regexpLiteral_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken s = null;

            CommonTree s_tree = null;
            RewriteRuleTokenStream stream_DIV = new RewriteRuleTokenStream(adaptor, "token DIV");


            CommonTree regexp = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 126))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:995:4: (s= DIV -> ^() )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:995:4: s= DIV
                {
                    s = (IToken)input.LT(1);
                    Match(input, DIV, FOLLOW_DIV_in_regexpLiteral4358); if (failed) return retval;
                    if (backtracking == 0) stream_DIV.Add(s);

                    if (backtracking == 0)
                    {
                        /*regexp=parseRegexpLiteral((LinkedListToken)s);*/
                    }

                    // AST REWRITE
                    // elements:          
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 996:3: -> ^()
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:996:6: ^()
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(regexp, root_1);

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 126, regexpLiteral_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end regexpLiteral

        public class newFullExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start newFullExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:999:1: newFullExpression : NEW fullNewSubexpression arguments ;
        public newFullExpression_return newFullExpression() // throws RecognitionException [1]
        {
            newFullExpression_return retval = new newFullExpression_return();
            retval.start = input.LT(1);
            int newFullExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NEW408 = null;
            fullNewSubexpression_return fullNewSubexpression409 = null;

            arguments_return arguments410 = null;


            CommonTree NEW408_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 127))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:4: ( NEW fullNewSubexpression arguments )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1000:4: NEW fullNewSubexpression arguments
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    NEW408 = (IToken)input.LT(1);
                    Match(input, NEW, FOLLOW_NEW_in_newFullExpression4379); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NEW408_tree = (CommonTree)adaptor.Create(NEW408);
                        root_0 = (CommonTree)adaptor.BecomeRoot(NEW408_tree, root_0);
                    }
                    PushFollow(FOLLOW_fullNewSubexpression_in_newFullExpression4382);
                    fullNewSubexpression409 = fullNewSubexpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, fullNewSubexpression409.Tree);
                    PushFollow(FOLLOW_arguments_in_newFullExpression4384);
                    arguments410 = arguments();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, arguments410.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 127, newFullExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end newFullExpression

        public class fullNewSubexpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start fullNewSubexpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1003:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
        public fullNewSubexpression_return fullNewSubexpression() // throws RecognitionException [1]
        {
            fullNewSubexpression_return retval = new fullNewSubexpression_return();
            retval.start = input.LT(1);
            int fullNewSubexpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT412 = null;
            primaryExpression_return primaryExpression411 = null;

            qualifiedIdent_return qualifiedIdent413 = null;

            brackets_return brackets414 = null;


            CommonTree DOT412_tree = null;
            RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor, "token DOT");
            RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor, "rule primaryExpression");
            RewriteRuleSubtreeStream stream_brackets = new RewriteRuleSubtreeStream(adaptor, "rule brackets");
            RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor, "rule qualifiedIdent");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 128))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1004:4: ( ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1004:4: ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
                {
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1004:4: ( primaryExpression -> primaryExpression )
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1004:6: primaryExpression
                    {
                        PushFollow(FOLLOW_primaryExpression_in_fullNewSubexpression4397);
                        primaryExpression411 = primaryExpression();
                        followingStackPointer_--;
                        if (failed) return retval;
                        if (backtracking == 0) stream_primaryExpression.Add(primaryExpression411.Tree);

                        // AST REWRITE
                        // elements:          primaryExpression
                        // token labels:      
                        // rule labels:       retval
                        // token list labels: 
                        // rule list labels:  
                        if (backtracking == 0)
                        {
                            retval.tree = root_0;
                            RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                            root_0 = (CommonTree)adaptor.GetNilNode();
                            // 1004:24: -> primaryExpression
                            {
                                adaptor.AddChild(root_0, stream_primaryExpression.Next());

                            }

                        }

                    }

                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:3: ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
                    do
                    {
                        int alt90 = 3;
                        int LA90_0 = input.LA(1);

                        if ((LA90_0 == DOT))
                        {
                            int LA90_2 = input.LA(2);

                            if ((synpred185()))
                            {
                                alt90 = 1;
                            }


                        }
                        else if ((LA90_0 == LBRACK))
                        {
                            int LA90_3 = input.LA(2);

                            if ((synpred186()))
                            {
                                alt90 = 2;
                            }


                        }


                        switch (alt90)
                        {
                            case 1:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:5: DOT qualifiedIdent
                                {
                                    DOT412 = (IToken)input.LT(1);
                                    Match(input, DOT, FOLLOW_DOT_in_fullNewSubexpression4411); if (failed) return retval;
                                    if (backtracking == 0) stream_DOT.Add(DOT412);

                                    PushFollow(FOLLOW_qualifiedIdent_in_fullNewSubexpression4413);
                                    qualifiedIdent413 = qualifiedIdent();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent413.Tree);

                                    // AST REWRITE
                                    // elements:          fullNewSubexpression, DOT, qualifiedIdent
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 1006:24: -> ^( DOT $fullNewSubexpression qualifiedIdent )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:27: ^( DOT $fullNewSubexpression qualifiedIdent )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(stream_DOT.Next(), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_qualifiedIdent.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;
                            case 2:
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:5: brackets
                                {
                                    PushFollow(FOLLOW_brackets_in_fullNewSubexpression4430);
                                    brackets414 = brackets();
                                    followingStackPointer_--;
                                    if (failed) return retval;
                                    if (backtracking == 0) stream_brackets.Add(brackets414.Tree);

                                    // AST REWRITE
                                    // elements:          fullNewSubexpression, brackets
                                    // token labels:      
                                    // rule labels:       retval
                                    // token list labels: 
                                    // rule list labels:  
                                    if (backtracking == 0)
                                    {
                                        retval.tree = root_0;
                                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                        root_0 = (CommonTree)adaptor.GetNilNode();
                                        // 1007:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
                                        {
                                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
                                            {
                                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

                                                adaptor.AddChild(root_1, stream_retval.Next());
                                                adaptor.AddChild(root_1, stream_brackets.Next());

                                                adaptor.AddChild(root_0, root_1);
                                            }

                                        }

                                    }

                                }
                                break;

                            default:
                                goto loop90;
                        }
                    } while (true);

                loop90:
                    ;	// Stops C# compiler whinging that label 'loop90' has no statements


                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 128, fullNewSubexpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end fullNewSubexpression

        public class newShortExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start newShortExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1011:1: newShortExpression : NEW shortNewSubexpression ;
        public newShortExpression_return newShortExpression() // throws RecognitionException [1]
        {
            newShortExpression_return retval = new newShortExpression_return();
            retval.start = input.LT(1);
            int newShortExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken NEW415 = null;
            shortNewSubexpression_return shortNewSubexpression416 = null;


            CommonTree NEW415_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 129))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1012:4: ( NEW shortNewSubexpression )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1012:4: NEW shortNewSubexpression
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    NEW415 = (IToken)input.LT(1);
                    Match(input, NEW, FOLLOW_NEW_in_newShortExpression4458); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        NEW415_tree = (CommonTree)adaptor.Create(NEW415);
                        root_0 = (CommonTree)adaptor.BecomeRoot(NEW415_tree, root_0);
                    }
                    PushFollow(FOLLOW_shortNewSubexpression_in_newShortExpression4461);
                    shortNewSubexpression416 = shortNewSubexpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, shortNewSubexpression416.Tree);

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 129, newShortExpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end newShortExpression

        public class shortNewSubexpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start shortNewSubexpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );
        public shortNewSubexpression_return shortNewSubexpression() // throws RecognitionException [1]
        {
            shortNewSubexpression_return retval = new shortNewSubexpression_return();
            retval.start = input.LT(1);
            int shortNewSubexpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            fullNewSubexpression_return fullNewSubexpression417 = null;

            newShortExpression_return newShortExpression418 = null;



            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 130))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1016:4: ( fullNewSubexpression | newShortExpression )
                int alt91 = 2;
                int LA91_0 = input.LA(1);

                if ((LA91_0 == LCURLY || (LA91_0 >= STRING_LITERAL && LA91_0 <= USE) || LA91_0 == LPAREN || LA91_0 == XML || (LA91_0 >= IDENT && LA91_0 <= LBRACK) || LA91_0 == DYNAMIC || LA91_0 == LT || (LA91_0 >= IS && LA91_0 <= AS) || LA91_0 == DIV || (LA91_0 >= E4X_ATTRI && LA91_0 <= FLOAT_LITERAL)))
                {
                    alt91 = 1;
                }
                else if ((LA91_0 == NEW))
                {
                    switch (input.LA(2))
                    {
                        case UNDEFINED:
                            {
                                int LA91_25 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s25 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 25, input);

                                    throw nvae_d91s25;
                                }
                            }
                            break;
                        case LT:
                            {
                                int LA91_26 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s26 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 26, input);

                                    throw nvae_d91s26;
                                }
                            }
                            break;
                        case DIV:
                            {
                                int LA91_27 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s27 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 27, input);

                                    throw nvae_d91s27;
                                }
                            }
                            break;
                        case HEX_LITERAL:
                        case DECIMAL_LITERAL:
                        case OCTAL_LITERAL:
                        case FLOAT_LITERAL:
                            {
                                int LA91_28 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s28 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 28, input);

                                    throw nvae_d91s28;
                                }
                            }
                            break;
                        case STRING_LITERAL:
                            {
                                int LA91_29 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s29 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 29, input);

                                    throw nvae_d91s29;
                                }
                            }
                            break;
                        case TRUE:
                            {
                                int LA91_30 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s30 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 30, input);

                                    throw nvae_d91s30;
                                }
                            }
                            break;
                        case FALSE:
                            {
                                int LA91_31 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s31 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 31, input);

                                    throw nvae_d91s31;
                                }
                            }
                            break;
                        case NULL:
                            {
                                int LA91_32 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s32 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 32, input);

                                    throw nvae_d91s32;
                                }
                            }
                            break;
                        case LBRACK:
                            {
                                int LA91_33 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s33 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 33, input);

                                    throw nvae_d91s33;
                                }
                            }
                            break;
                        case LCURLY:
                            {
                                int LA91_34 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s34 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 34, input);

                                    throw nvae_d91s34;
                                }
                            }
                            break;
                        case FUNCTION:
                            {
                                int LA91_35 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s35 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 35, input);

                                    throw nvae_d91s35;
                                }
                            }
                            break;
                        case NEW:
                            {
                                int LA91_36 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s36 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 36, input);

                                    throw nvae_d91s36;
                                }
                            }
                            break;
                        case LPAREN:
                            {
                                int LA91_37 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s37 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 37, input);

                                    throw nvae_d91s37;
                                }
                            }
                            break;
                        case E4X_ATTRI:
                            {
                                int LA91_38 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s38 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 38, input);

                                    throw nvae_d91s38;
                                }
                            }
                            break;
                        case IDENT:
                            {
                                int LA91_39 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s39 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 39, input);

                                    throw nvae_d91s39;
                                }
                            }
                            break;
                        case PUBLIC:
                        case PRIVATE:
                        case PROTECTED:
                        case INTERNAL:
                            {
                                int LA91_40 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s40 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 40, input);

                                    throw nvae_d91s40;
                                }
                            }
                            break;
                        case USE:
                            {
                                int LA91_41 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s41 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 41, input);

                                    throw nvae_d91s41;
                                }
                            }
                            break;
                        case XML:
                            {
                                int LA91_42 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s42 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 42, input);

                                    throw nvae_d91s42;
                                }
                            }
                            break;
                        case DYNAMIC:
                            {
                                int LA91_43 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s43 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 43, input);

                                    throw nvae_d91s43;
                                }
                            }
                            break;
                        case NAMESPACE:
                            {
                                int LA91_44 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s44 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 44, input);

                                    throw nvae_d91s44;
                                }
                            }
                            break;
                        case IS:
                            {
                                int LA91_45 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s45 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 45, input);

                                    throw nvae_d91s45;
                                }
                            }
                            break;
                        case AS:
                            {
                                int LA91_46 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s46 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 46, input);

                                    throw nvae_d91s46;
                                }
                            }
                            break;
                        case GET:
                            {
                                int LA91_47 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s47 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 47, input);

                                    throw nvae_d91s47;
                                }
                            }
                            break;
                        case SET:
                            {
                                int LA91_48 = input.LA(3);

                                if ((synpred187()))
                                {
                                    alt91 = 1;
                                }
                                else if ((true))
                                {
                                    alt91 = 2;
                                }
                                else
                                {
                                    if (backtracking > 0) { failed = true; return retval; }
                                    NoViableAltException nvae_d91s48 =
                                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 48, input);

                                    throw nvae_d91s48;
                                }
                            }
                            break;
                        default:
                            if (backtracking > 0) { failed = true; return retval; }
                            NoViableAltException nvae_d91s12 =
                                new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 12, input);

                            throw nvae_d91s12;
                    }

                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d91s0 =
                        new NoViableAltException("1015:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 91, 0, input);

                    throw nvae_d91s0;
                }
                switch (alt91)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1016:4: fullNewSubexpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_fullNewSubexpression_in_shortNewSubexpression4474);
                            fullNewSubexpression417 = fullNewSubexpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, fullNewSubexpression417.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1017:4: newShortExpression
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_newShortExpression_in_shortNewSubexpression4479);
                            newShortExpression418 = newShortExpression();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, newShortExpression418.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 130, shortNewSubexpression_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end shortNewSubexpression

        public class propertyOperator_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start propertyOperator
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1020:1: propertyOperator : ( DOT qualifiedIdent | brackets );
        public propertyOperator_return propertyOperator() // throws RecognitionException [1]
        {
            propertyOperator_return retval = new propertyOperator_return();
            retval.start = input.LT(1);
            int propertyOperator_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken DOT419 = null;
            qualifiedIdent_return qualifiedIdent420 = null;

            brackets_return brackets421 = null;


            CommonTree DOT419_tree = null;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 131))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1021:4: ( DOT qualifiedIdent | brackets )
                int alt92 = 2;
                int LA92_0 = input.LA(1);

                if ((LA92_0 == DOT))
                {
                    alt92 = 1;
                }
                else if ((LA92_0 == LBRACK))
                {
                    alt92 = 2;
                }
                else
                {
                    if (backtracking > 0) { failed = true; return retval; }
                    NoViableAltException nvae_d92s0 =
                        new NoViableAltException("1020:1: propertyOperator : ( DOT qualifiedIdent | brackets );", 92, 0, input);

                    throw nvae_d92s0;
                }
                switch (alt92)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1021:4: DOT qualifiedIdent
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            DOT419 = (IToken)input.LT(1);
                            Match(input, DOT, FOLLOW_DOT_in_propertyOperator4491); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                DOT419_tree = (CommonTree)adaptor.Create(DOT419);
                                root_0 = (CommonTree)adaptor.BecomeRoot(DOT419_tree, root_0);
                            }
                            PushFollow(FOLLOW_qualifiedIdent_in_propertyOperator4494);
                            qualifiedIdent420 = qualifiedIdent();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent420.Tree);

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1022:4: brackets
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            PushFollow(FOLLOW_brackets_in_propertyOperator4499);
                            brackets421 = brackets();
                            followingStackPointer_--;
                            if (failed) return retval;
                            if (backtracking == 0) adaptor.AddChild(root_0, brackets421.Tree);

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 131, propertyOperator_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end propertyOperator

        public class brackets_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start brackets
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1025:1: brackets : LBRACK expressionList RBRACK ;
        public brackets_return brackets() // throws RecognitionException [1]
        {
            brackets_return retval = new brackets_return();
            retval.start = input.LT(1);
            int brackets_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LBRACK422 = null;
            IToken RBRACK424 = null;
            expressionList_return expressionList423 = null;


            CommonTree LBRACK422_tree = null;
            CommonTree RBRACK424_tree = null;


            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 132))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1029:4: ( LBRACK expressionList RBRACK )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1029:4: LBRACK expressionList RBRACK
                {
                    root_0 = (CommonTree)adaptor.GetNilNode();

                    LBRACK422 = (IToken)input.LT(1);
                    Match(input, LBRACK, FOLLOW_LBRACK_in_brackets4515); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        LBRACK422_tree = (CommonTree)adaptor.Create(LBRACK422);
                        adaptor.AddChild(root_0, LBRACK422_tree);
                    }
                    PushFollow(FOLLOW_expressionList_in_brackets4517);
                    expressionList423 = expressionList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) adaptor.AddChild(root_0, expressionList423.Tree);
                    RBRACK424 = (IToken)input.LT(1);
                    Match(input, RBRACK, FOLLOW_RBRACK_in_brackets4519); if (failed) return retval;
                    if (backtracking == 0)
                    {
                        RBRACK424_tree = (CommonTree)adaptor.Create(RBRACK424);
                        adaptor.AddChild(root_0, RBRACK424_tree);
                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 132, brackets_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end brackets

        public class encapsulatedExpression_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start encapsulatedExpression
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1032:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
        public encapsulatedExpression_return encapsulatedExpression() // throws RecognitionException [1]
        {
            InOperator_stack.Push(new InOperator_scope());

            encapsulatedExpression_return retval = new encapsulatedExpression_return();
            retval.start = input.LT(1);
            int encapsulatedExpression_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken LPAREN425 = null;
            IToken RPAREN427 = null;
            assignmentExpression_return assignmentExpression426 = null;


            CommonTree LPAREN425_tree = null;
            CommonTree RPAREN427_tree = null;
            RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor, "token RPAREN");
            RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor, "token LPAREN");
            RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor, "rule assignmentExpression");

            ((InOperator_scope)InOperator_stack.Peek()).allowed = true;

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 133))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1037:4: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1037:4: LPAREN assignmentExpression RPAREN
                {
                    LPAREN425 = (IToken)input.LT(1);
                    Match(input, LPAREN, FOLLOW_LPAREN_in_encapsulatedExpression4540); if (failed) return retval;
                    if (backtracking == 0) stream_LPAREN.Add(LPAREN425);

                    PushFollow(FOLLOW_assignmentExpression_in_encapsulatedExpression4542);
                    assignmentExpression426 = assignmentExpression();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_assignmentExpression.Add(assignmentExpression426.Tree);
                    RPAREN427 = (IToken)input.LT(1);
                    Match(input, RPAREN, FOLLOW_RPAREN_in_encapsulatedExpression4544); if (failed) return retval;
                    if (backtracking == 0) stream_RPAREN.Add(RPAREN427);


                    // AST REWRITE
                    // elements:          assignmentExpression
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 1038:3: -> ^( ENCPS_EXPR assignmentExpression )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1038:6: ^( ENCPS_EXPR assignmentExpression )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);

                                adaptor.AddChild(root_1, stream_assignmentExpression.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 133, encapsulatedExpression_StartIndex);
                }
                InOperator_stack.Pop();

            }
            return retval;
        }
        // $ANTLR end encapsulatedExpression

        public class functionDefinition_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start functionDefinition
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1044:1: functionDefinition : FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
        public functionDefinition_return functionDefinition() // throws RecognitionException [1]
        {
            functionDefinition_return retval = new functionDefinition_return();
            retval.start = input.LT(1);
            int functionDefinition_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken FUNCTION428 = null;
            parameterDeclarationList_return parameterDeclarationList429 = null;

            typeExpression_return typeExpression430 = null;

            block_return block431 = null;


            CommonTree FUNCTION428_tree = null;
            RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor, "token FUNCTION");
            RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor, "rule parameterDeclarationList");
            RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor, "rule block");
            RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor, "rule typeExpression");
            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 134))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:4: ( FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:4: FUNCTION parameterDeclarationList ( typeExpression )? block
                {
                    FUNCTION428 = (IToken)input.LT(1);
                    Match(input, FUNCTION, FOLLOW_FUNCTION_in_functionDefinition4568); if (failed) return retval;
                    if (backtracking == 0) stream_FUNCTION.Add(FUNCTION428);

                    PushFollow(FOLLOW_parameterDeclarationList_in_functionDefinition4570);
                    parameterDeclarationList429 = parameterDeclarationList();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList429.Tree);
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1045:38: ( typeExpression )?
                    int alt93 = 2;
                    int LA93_0 = input.LA(1);

                    if ((LA93_0 == COLON))
                    {
                        alt93 = 1;
                    }
                    switch (alt93)
                    {
                        case 1:
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
                            {
                                PushFollow(FOLLOW_typeExpression_in_functionDefinition4572);
                                typeExpression430 = typeExpression();
                                followingStackPointer_--;
                                if (failed) return retval;
                                if (backtracking == 0) stream_typeExpression.Add(typeExpression430.Tree);

                            }
                            break;

                    }

                    PushFollow(FOLLOW_block_in_functionDefinition4575);
                    block431 = block();
                    followingStackPointer_--;
                    if (failed) return retval;
                    if (backtracking == 0) stream_block.Add(block431.Tree);

                    // AST REWRITE
                    // elements:          block, typeExpression, parameterDeclarationList
                    // token labels:      
                    // rule labels:       retval
                    // token list labels: 
                    // rule list labels:  
                    if (backtracking == 0)
                    {
                        retval.tree = root_0;
                        RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                        root_0 = (CommonTree)adaptor.GetNilNode();
                        // 1046:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
                        {
                            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
                            {
                                CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                                root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

                                adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
                                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1046:42: ( typeExpression )?
                                if (stream_typeExpression.HasNext())
                                {
                                    adaptor.AddChild(root_1, stream_typeExpression.Next());

                                }
                                stream_typeExpression.Reset();
                                adaptor.AddChild(root_1, stream_block.Next());

                                adaptor.AddChild(root_0, root_1);
                            }

                        }

                    }

                }

                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 134, functionDefinition_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end functionDefinition

        public class ident_return : ParserRuleReturnScope
        {
            internal CommonTree tree;
            override public object Tree
            {
                get { return tree; }
            }
        };

        // $ANTLR start ident
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1050:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );
        public ident_return ident() // throws RecognitionException [1]
        {
            ident_return retval = new ident_return();
            retval.start = input.LT(1);
            int ident_StartIndex = input.Index();
            CommonTree root_0 = null;

            IToken i = null;
            IToken IDENT432 = null;

            CommonTree i_tree = null;
            CommonTree IDENT432_tree = null;
            RewriteRuleTokenStream stream_GET = new RewriteRuleTokenStream(adaptor, "token GET");
            RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor, "token XML");
            RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor, "token AS");
            RewriteRuleTokenStream stream_DYNAMIC = new RewriteRuleTokenStream(adaptor, "token DYNAMIC");
            RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor, "token NAMESPACE");
            RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor, "token SET");
            RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor, "token IS");
            RewriteRuleTokenStream stream_USE = new RewriteRuleTokenStream(adaptor, "token USE");

            try
            {
                if ((backtracking > 0) && AlreadyParsedRule(input, 135))
                {
                    return retval;
                }
                // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] )
                int alt94 = 9;
                switch (input.LA(1))
                {
                    case IDENT:
                        {
                            alt94 = 1;
                        }
                        break;
                    case USE:
                        {
                            alt94 = 2;
                        }
                        break;
                    case XML:
                        {
                            alt94 = 3;
                        }
                        break;
                    case DYNAMIC:
                        {
                            alt94 = 4;
                        }
                        break;
                    case NAMESPACE:
                        {
                            alt94 = 5;
                        }
                        break;
                    case IS:
                        {
                            alt94 = 6;
                        }
                        break;
                    case AS:
                        {
                            alt94 = 7;
                        }
                        break;
                    case GET:
                        {
                            alt94 = 8;
                        }
                        break;
                    case SET:
                        {
                            alt94 = 9;
                        }
                        break;
                    default:
                        if (backtracking > 0) { failed = true; return retval; }
                        NoViableAltException nvae_d94s0 =
                            new NoViableAltException("1050:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );", 94, 0, input);

                        throw nvae_d94s0;
                }

                switch (alt94)
                {
                    case 1:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: IDENT
                        {
                            root_0 = (CommonTree)adaptor.GetNilNode();

                            IDENT432 = (IToken)input.LT(1);
                            Match(input, IDENT, FOLLOW_IDENT_in_ident4602); if (failed) return retval;
                            if (backtracking == 0)
                            {
                                IDENT432_tree = (CommonTree)adaptor.Create(IDENT432);
                                adaptor.AddChild(root_0, IDENT432_tree);
                            }

                        }
                        break;
                    case 2:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1052:4: i= USE
                        {
                            i = (IToken)input.LT(1);
                            Match(input, USE, FOLLOW_USE_in_ident4609); if (failed) return retval;
                            if (backtracking == 0) stream_USE.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1052:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 3:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1053:4: i= XML
                        {
                            i = (IToken)input.LT(1);
                            Match(input, XML, FOLLOW_XML_in_ident4621); if (failed) return retval;
                            if (backtracking == 0) stream_XML.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1053:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 4:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1054:4: i= DYNAMIC
                        {
                            i = (IToken)input.LT(1);
                            Match(input, DYNAMIC, FOLLOW_DYNAMIC_in_ident4633); if (failed) return retval;
                            if (backtracking == 0) stream_DYNAMIC.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1054:14: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 5:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1055:4: i= NAMESPACE
                        {
                            i = (IToken)input.LT(1);
                            Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_ident4645); if (failed) return retval;
                            if (backtracking == 0) stream_NAMESPACE.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1055:16: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 6:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1056:4: i= IS
                        {
                            i = (IToken)input.LT(1);
                            Match(input, IS, FOLLOW_IS_in_ident4657); if (failed) return retval;
                            if (backtracking == 0) stream_IS.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1056:9: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 7:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1057:4: i= AS
                        {
                            i = (IToken)input.LT(1);
                            Match(input, AS, FOLLOW_AS_in_ident4669); if (failed) return retval;
                            if (backtracking == 0) stream_AS.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1057:9: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 8:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1058:4: i= GET
                        {
                            i = (IToken)input.LT(1);
                            Match(input, GET, FOLLOW_GET_in_ident4681); if (failed) return retval;
                            if (backtracking == 0) stream_GET.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1058:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;
                    case 9:
                        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1059:4: i= SET
                        {
                            i = (IToken)input.LT(1);
                            Match(input, SET, FOLLOW_SET_in_ident4693); if (failed) return retval;
                            if (backtracking == 0) stream_SET.Add(i);


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (backtracking == 0)
                            {
                                retval.tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (CommonTree)adaptor.GetNilNode();
                                // 1059:10: -> IDENT[$i]
                                {
                                    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));

                                }

                            }

                        }
                        break;

                }
                retval.stop = input.LT(-1);

                if (backtracking == 0)
                {
                    retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
                    adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
                }
            }
            finally
            {
                if (backtracking > 0)
                {
                    Memoize(input, 135, ident_StartIndex);
                }
            }
            return retval;
        }
        // $ANTLR end ident

        // $ANTLR start synpred40
        public void synpred40_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( LCURLY )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:5: LCURLY
            {
                Match(input, LCURLY, FOLLOW_LCURLY_in_synpred401531); if (failed) return;

            }
        }
        // $ANTLR end synpred40

        // $ANTLR start synpred42
        public void synpred42_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: ( expressionStatement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: expressionStatement
            {
                PushFollow(FOLLOW_expressionStatement_in_synpred421545);
                expressionStatement();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred42

        // $ANTLR start synpred56
        public void synpred56_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:417:4: ( ELSE )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:417:5: ELSE
            {
                Match(input, ELSE, FOLLOW_ELSE_in_synpred561735); if (failed) return;

            }
        }
        // $ANTLR end synpred56

        // $ANTLR start synpred64
        public void synpred64_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:5: ( forInClauseDecl IN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:497:6: forInClauseDecl IN
            {
                PushFollow(FOLLOW_forInClauseDecl_in_synpred642082);
                forInClauseDecl();
                followingStackPointer_--;
                if (failed) return;
                Match(input, IN, FOLLOW_IN_in_synpred642084); if (failed) return;

            }
        }
        // $ANTLR end synpred64

        // $ANTLR start synpred99
        public void synpred99_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:26: ( COMMA assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:712:26: COMMA assignmentExpression
            {
                Match(input, COMMA, FOLLOW_COMMA_in_synpred993039); if (failed) return;
                PushFollow(FOLLOW_assignmentExpression_in_synpred993041);
                assignmentExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred99

        // $ANTLR start synpred105
        public void synpred105_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:4: ( assignmentOperator )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:752:5: assignmentOperator
            {
                PushFollow(FOLLOW_assignmentOperator_in_synpred1053214);
                assignmentOperator();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred105

        // $ANTLR start synpred131
        public void synpred131_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:4: ( relationalOperator )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:842:5: relationalOperator
            {
                PushFollow(FOLLOW_relationalOperator_in_synpred1313579);
                relationalOperator();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred131

        // $ANTLR start synpred172
        public void synpred172_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:941:4: ( newFullExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:941:4: newFullExpression
            {
                PushFollow(FOLLOW_newFullExpression_in_synpred1724173);
                newFullExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred172

        // $ANTLR start synpred173
        public void synpred173_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: ( newShortExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: newShortExpression
            {
                PushFollow(FOLLOW_newShortExpression_in_synpred1734178);
                newShortExpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred173

        // $ANTLR start synpred185
        public void synpred185_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:5: ( DOT qualifiedIdent )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:5: DOT qualifiedIdent
            {
                Match(input, DOT, FOLLOW_DOT_in_synpred1854411); if (failed) return;
                PushFollow(FOLLOW_qualifiedIdent_in_synpred1854413);
                qualifiedIdent();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred185

        // $ANTLR start synpred186
        public void synpred186_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:5: ( brackets )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:5: brackets
            {
                PushFollow(FOLLOW_brackets_in_synpred1864430);
                brackets();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred186

        // $ANTLR start synpred187
        public void synpred187_fragment() //throws RecognitionException
        {
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1016:4: ( fullNewSubexpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1016:4: fullNewSubexpression
            {
                PushFollow(FOLLOW_fullNewSubexpression_in_synpred1874474);
                fullNewSubexpression();
                followingStackPointer_--;
                if (failed) return;

            }
        }
        // $ANTLR end synpred187

        public bool synpred99()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred99_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred105()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred105_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred42()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred42_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred40()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred40_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred187()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred187_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred131()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred131_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred186()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred186_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred185()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred185_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred64()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred64_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred56()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred56_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred173()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred173_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }
        public bool synpred172()
        {
            backtracking++;
            int start = input.Mark();
            try
            {
                synpred172_fragment(); // can never throw exception
            }
            catch (RecognitionException re)
            {
                Console.Error.WriteLine("impossible: " + re);
            }
            bool success = !failed;
            input.Rewind(start);
            backtracking--;
            failed = false;
            return success;
        }


        private void InitializeCyclicDFAs()
        {
        }



        public static readonly BitSet FOLLOW_as2CompilationUnit_in_compilationUnit331 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as3CompilationUnit_in_compilationUnit337 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_importDefinition_in_as2CompilationUnit365 = new BitSet(new ulong[] { 0x0380000000000000UL, 0x00000037E0000000UL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_as2Type_in_as2CompilationUnit370 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_as2Type383 = new BitSet(new ulong[] { 0x0300000000000000UL, 0x00000033E0000000UL, 0x001F000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_as2Type390 = new BitSet(new ulong[] { 0x0300000000000000UL });
        public static readonly BitSet FOLLOW_as2ClassDefinition_in_as2Type396 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as2InterfaceDefinition_in_as2Type402 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_packageDecl_in_as3CompilationUnit418 = new BitSet(new ulong[] { 0x83C0000000000000UL, 0x00000037E000003CUL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_packageBlockEntry_in_as3CompilationUnit422 = new BitSet(new ulong[] { 0x83C0000000000000UL, 0x00000037E000003CUL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_EOF_in_as3CompilationUnit427 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_PACKAGE_in_packageDecl439 = new BitSet(new ulong[] { 0x0010000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_packageDecl442 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_packageBlock_in_packageDecl447 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_packageBlock458 = new BitSet(new ulong[] { 0x83E0000000000000UL, 0x00000037E000003CUL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_packageBlockEntry_in_packageBlock462 = new BitSet(new ulong[] { 0x83E0000000000000UL, 0x00000037E000003CUL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_packageBlock467 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_importDefinition_in_packageBlockEntry491 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_packageBlockEntry500 = new BitSet(new ulong[] { 0x8300000000000000UL, 0x00000033E000003CUL, 0x001F000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_packageBlockEntry508 = new BitSet(new ulong[] { 0x8300000000000000UL, 0x000000000000003CUL });
        public static readonly BitSet FOLLOW_classDefinition_in_packageBlockEntry516 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_interfaceDefinition_in_packageBlockEntry524 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_variableDefinition_in_packageBlockEntry532 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_methodDefinition_in_packageBlockEntry540 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_namespaceDefinition_in_packageBlockEntry548 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_useNamespaceDirective_in_packageBlockEntry556 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_packageBlockEntry567 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EOF_in_endOfFile584 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IMPORT_in_importDefinition596 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifierStar_in_importDefinition599 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_importDefinition601 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_semi612 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CLASS_in_classDefinition626 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_classDefinition628 = new BitSet(new ulong[] { 0x1410000000000000UL });
        public static readonly BitSet FOLLOW_classExtendsClause_in_classDefinition632 = new BitSet(new ulong[] { 0x1010000000000000UL });
        public static readonly BitSet FOLLOW_implementsClause_in_classDefinition636 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_classDefinition640 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CLASS_in_as2ClassDefinition672 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_as2ClassDefinition674 = new BitSet(new ulong[] { 0x1410000000000000UL });
        public static readonly BitSet FOLLOW_classExtendsClause_in_as2ClassDefinition678 = new BitSet(new ulong[] { 0x1010000000000000UL });
        public static readonly BitSet FOLLOW_implementsClause_in_as2ClassDefinition682 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_as2ClassDefinition686 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDefinition718 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_interfaceDefinition720 = new BitSet(new ulong[] { 0x0410000000000000UL });
        public static readonly BitSet FOLLOW_interfaceExtendsClause_in_interfaceDefinition724 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_interfaceDefinition728 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INTERFACE_in_as2InterfaceDefinition758 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_as2InterfaceDefinition760 = new BitSet(new ulong[] { 0x0410000000000000UL });
        public static readonly BitSet FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition764 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_typeBlock_in_as2InterfaceDefinition768 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EXTENDS_in_classExtendsClause798 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_classExtendsClause801 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_EXTENDS_in_interfaceExtendsClause814 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause817 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_interfaceExtendsClause821 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause824 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_IMPLEMENTS_in_implementsClause839 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_implementsClause842 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_implementsClause846 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_implementsClause849 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_typeBlock863 = new BitSet(new ulong[] { 0xA0A0000000000000UL, 0x00000037E0000030UL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_typeBlockEntry_in_typeBlock867 = new BitSet(new ulong[] { 0xA0A0000000000000UL, 0x00000037E0000030UL, 0x001F040000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_typeBlock872 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotations_in_typeBlockEntry898 = new BitSet(new ulong[] { 0x8000000000000000UL, 0x00000033E0000030UL, 0x001F000000000000UL });
        public static readonly BitSet FOLLOW_modifiers_in_typeBlockEntry906 = new BitSet(new ulong[] { 0x8000000000000000UL, 0x0000000000000030UL });
        public static readonly BitSet FOLLOW_variableDefinition_in_typeBlockEntry913 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_methodDefinition_in_typeBlockEntry920 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_importDefinition_in_typeBlockEntry930 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_as2IncludeDirective_in_typeBlockEntry935 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective947 = new BitSet(new ulong[] { 0x4000000000000000UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_as2IncludeDirective951 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_170_in_includeDirective962 = new BitSet(new ulong[] { 0x4000000000000000UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_includeDirective966 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_includeDirective970 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FUNCTION_in_methodDefinition983 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_optionalAccessorRole_in_methodDefinition989 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_methodDefinition993 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_parameterDeclarationList_in_methodDefinition997 = new BitSet(new ulong[] { 0x0050000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_typeExpression_in_methodDefinition1001 = new BitSet(new ulong[] { 0x0050000000000000UL });
        public static readonly BitSet FOLLOW_block_in_methodDefinition1007 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_semi_in_methodDefinition1009 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_accessorRole_in_optionalAccessorRole1075 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_accessorRole0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDefinition1114 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_namespaceDefinition1116 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective1143 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000004UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective1145 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_useNamespaceDirective1147 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_useNamespaceDirective1149 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_varOrConst_in_variableDefinition1173 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1175 = new BitSet(new ulong[] { 0x0840000000000000UL });
        public static readonly BitSet FOLLOW_COMMA_in_variableDefinition1180 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1182 = new BitSet(new ulong[] { 0x0840000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_variableDefinition1188 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_varOrConst0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_variableDeclarator1232 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000020040UL });
        public static readonly BitSet FOLLOW_typeExpression_in_variableDeclarator1235 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000040UL });
        public static readonly BitSet FOLLOW_variableInitializer_in_variableDeclarator1238 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_varOrConst_in_declaration1249 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_declaration1252 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_declarationTail_in_declaration1256 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_declarationTail1278 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_variableDeclarator_in_declarationTail1281 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_variableInitializer1294 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_variableInitializer1297 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_parameterDeclarationList1310 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200032FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1316 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_COMMA_in_parameterDeclarationList1322 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200022FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1324 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_parameterDeclarationList1335 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_basicParameterDeclaration_in_parameterDeclaration1358 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_parameterRestDeclaration_in_parameterDeclaration1362 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CONST_in_basicParameterDeclaration1373 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_basicParameterDeclaration1376 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000020040UL });
        public static readonly BitSet FOLLOW_typeExpression_in_basicParameterDeclaration1378 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000040UL });
        public static readonly BitSet FOLLOW_parameterDefault_in_basicParameterDeclaration1381 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_parameterDefault1425 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_parameterDefault1428 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_REST_in_parameterRestDeclaration1439 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_parameterRestDeclaration1441 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_block1465 = new BitSet(new ulong[] { 0xC070000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_blockEntry_in_block1467 = new BitSet(new ulong[] { 0xC070000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_RCURLY_in_block1470 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_statement_in_blockEntry1494 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_condition1505 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_condition1507 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_condition1509 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_block_in_statement1535 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declarationStatement_in_statement1540 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionStatement_in_statement1545 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ifStatement_in_statement1550 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forEachStatement_in_statement1557 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forStatement_in_statement1562 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_whileStatement_in_statement1570 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_doWhileStatement_in_statement1578 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_withStatement_in_statement1587 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_switchStatement_in_statement1596 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_breakStatement_in_statement1605 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_continueStatement_in_statement1613 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_returnStatement_in_statement1621 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_throwStatement_in_statement1629 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_tryStatement_in_statement1638 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_defaultXMLNamespaceStatement_in_statement1647 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SEMI_in_statement1655 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_declarationStatement1677 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_declarationStatement1679 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_expressionStatement1700 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_expressionStatement1702 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IF_in_ifStatement1724 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_condition_in_ifStatement1727 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_ifStatement1729 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000800UL });
        public static readonly BitSet FOLLOW_elseClause_in_ifStatement1738 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ELSE_in_elseClause1751 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_elseClause1754 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_171_in_throwStatement1765 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_throwStatement1768 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_throwStatement1770 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_172_in_tryStatement1781 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_block_in_tryStatement1785 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000600000000000UL });
        public static readonly BitSet FOLLOW_catchBlock_in_tryStatement1789 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000600000000000UL });
        public static readonly BitSet FOLLOW_finallyBlock_in_tryStatement1794 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_173_in_catchBlock1806 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_LPAREN_in_catchBlock1808 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_catchBlock1811 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000020100UL });
        public static readonly BitSet FOLLOW_typeExpression_in_catchBlock1813 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_catchBlock1816 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_block_in_catchBlock1821 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_174_in_finallyBlock1832 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_block_in_finallyBlock1834 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_RETURN_in_returnStatement1845 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_returnStatement1848 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_returnStatement1851 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement1864 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_continueStatement1867 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_BREAK_in_breakStatement1878 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_breakStatement1881 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SWITCH_in_switchStatement1892 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_condition_in_switchStatement1895 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_switchBlock_in_switchStatement1899 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_switchBlock1910 = new BitSet(new ulong[] { 0x0020000000000000UL, 0x0000000000050000UL });
        public static readonly BitSet FOLLOW_caseStatement_in_switchBlock1915 = new BitSet(new ulong[] { 0x0020000000000000UL, 0x0000000000050000UL });
        public static readonly BitSet FOLLOW_defaultStatement_in_switchBlock1922 = new BitSet(new ulong[] { 0x0020000000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_switchBlock1928 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_CASE_in_caseStatement1953 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_caseStatement1956 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_COLON_in_caseStatement1958 = new BitSet(new ulong[] { 0xC050000000000002UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_switchStatementList_in_caseStatement1963 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEFAULT_in_defaultStatement1975 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_COLON_in_defaultStatement1978 = new BitSet(new ulong[] { 0xC050000000000002UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_switchStatementList_in_defaultStatement1983 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_statement_in_switchStatementList1994 = new BitSet(new ulong[] { 0xC050000000000002UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_FOR_in_forEachStatement2017 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000100000UL });
        public static readonly BitSet FOLLOW_EACH_in_forEachStatement2019 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_LPAREN_in_forEachStatement2023 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200003FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_forInClause_in_forEachStatement2027 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forEachStatement2031 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_forEachStatement2035 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FOR_in_forStatement2071 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_LPAREN_in_forStatement2075 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E20000BFUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_forInClause_in_forStatement2087 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forStatement2089 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_forStatement2091 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_traditionalForClause_in_forStatement2112 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_forStatement2114 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_forStatement2116 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInit_in_traditionalForClause2147 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2149 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_forCond_in_traditionalForClause2157 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2159 = new BitSet(new ulong[] { 0xC010000000000002UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_forIter_in_traditionalForClause2167 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInClauseDecl_in_forInClause2179 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000200000UL });
        public static readonly BitSet FOLLOW_IN_in_forInClause2181 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_forInClauseTail_in_forInClause2184 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_forInClauseDecl2205 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_forInClauseDecl2209 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forInClauseTail2231 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_declaration_in_forInit2255 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forInit2259 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forCond2297 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionList_in_forIter2330 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_WHILE_in_whileStatement2353 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_condition_in_whileStatement2356 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_whileStatement2358 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DO_in_doWhileStatement2369 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_doWhileStatement2372 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000400000UL });
        public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement2374 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_condition_in_doWhileStatement2377 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_doWhileStatement2379 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_WITH_in_withStatement2390 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_condition_in_withStatement2393 = new BitSet(new ulong[] { 0xC050000000000000UL, 0x20000027E3CCF4BFUL, 0x000098000FFDFB86UL });
        public static readonly BitSet FOLLOW_statement_in_withStatement2395 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2406 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000002000000UL });
        public static readonly BitSet FOLLOW_XML_in_defaultXMLNamespaceStatement2408 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000004UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2410 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000040UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2412 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_defaultXMLNamespaceStatement2414 = new BitSet(new ulong[] { 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_semi_in_defaultXMLNamespaceStatement2416 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COLON_in_typeExpression2439 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E600000FUL, 0x0000800000000006UL });
        public static readonly BitSet FOLLOW_identifier_in_typeExpression2447 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_175_in_typeExpression2451 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_typeExpression2455 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2487 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifier2505 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2507 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
        public static readonly BitSet FOLLOW_namespaceName_in_qualifiedIdent2535 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000010000000UL });
        public static readonly BitSet FOLLOW_DBL_COLON_in_qualifiedIdent2537 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_qualifiedIdent2541 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IDENT_in_namespaceName2553 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_reservedNamespace_in_namespaceName2557 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_reservedNamespace0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_identifierStar2594 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifierStar2611 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_identifierStar2613 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
        public static readonly BitSet FOLLOW_DOT_in_identifierStar2625 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000004000000UL });
        public static readonly BitSet FOLLOW_STAR_in_identifierStar2627 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_annotation_in_annotations2659 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000400000000UL, 0x0000040000000000UL });
        public static readonly BitSet FOLLOW_includeDirective_in_annotations2665 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000400000000UL, 0x0000040000000000UL });
        public static readonly BitSet FOLLOW_LBRACK_in_annotation2692 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x000000202200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_ident_in_annotation2696 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000080UL });
        public static readonly BitSet FOLLOW_annotationParamList_in_annotation2700 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_annotation2705 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_annotationParamList2731 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x200000202200010FUL, 0x0000000007F00206UL });
        public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2737 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_COMMA_in_annotationParamList2743 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x200000202200000FUL, 0x0000000007F00206UL });
        public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2745 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_annotationParamList2756 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_annotationParam2783 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000040UL });
        public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam2785 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x2000000000000000UL, 0x0000000007F00200UL });
        public static readonly BitSet FOLLOW_constant_in_annotationParam2787 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_constant_in_annotationParam2802 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_annotationParam2811 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_modifier_in_modifiers2826 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x00000033E0000000UL, 0x001F000000000000UL });
        public static readonly BitSet FOLLOW_namespaceName_in_modifier2849 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STATIC_in_modifier2854 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_176_in_modifier2859 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_177_in_modifier2864 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_178_in_modifier2869 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_179_in_modifier2874 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DYNAMIC_in_modifier2879 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_180_in_modifier2884 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_arguments2905 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expressionList_in_arguments2907 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_arguments2909 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_arguments2924 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_arguments2926 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_element2956 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral2978 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x2000002FE200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_elementList_in_arrayLiteral2980 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral2983 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3005 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_elementList3008 = new BitSet(new ulong[] { 0xC010000000000002UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3011 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3036 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_nonemptyElementList3039 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3041 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral3056 = new BitSet(new ulong[] { 0x0020000000000000UL, 0x000000202200000FUL, 0x0000000007800006UL });
        public static readonly BitSet FOLLOW_fieldList_in_objectLiteral3058 = new BitSet(new ulong[] { 0x0020000000000000UL });
        public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral3061 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_literalField_in_fieldList3084 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_fieldList3087 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000202200000FUL, 0x0000000007800006UL });
        public static readonly BitSet FOLLOW_literalField_in_fieldList3090 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_fieldName_in_literalField3107 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_COLON_in_literalField3109 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_element_in_literalField3111 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ident_in_fieldName3135 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_number_in_fieldName3140 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expression3162 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3174 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_expressionList3177 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3179 = new BitSet(new ulong[] { 0x0800000000000002UL });
        public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression3208 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0007FFC000000040UL });
        public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression3218 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression3222 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0007FFC000000040UL });
        public static readonly BitSet FOLLOW_set_in_assignmentOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_logicalOrExpression_in_conditionalExpression3316 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0008000000000000UL });
        public static readonly BitSet FOLLOW_QUESTION_in_conditionalExpression3330 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_conditionalSubExpression_in_conditionalExpression3335 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3364 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_COLON_in_conditionalSubExpression3366 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3369 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3383 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0010000000000000UL, 0x0020000000000000UL });
        public static readonly BitSet FOLLOW_logicalOrOperator_in_logicalOrExpression3388 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3391 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0010000000000000UL, 0x0020000000000000UL });
        public static readonly BitSet FOLLOW_set_in_logicalOrOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3420 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0020000000000000UL, 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_logicalAndOperator_in_logicalAndExpression3425 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3428 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0020000000000000UL, 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_set_in_logicalAndOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3457 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_BOR_in_bitwiseOrExpression3462 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3465 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0040000000000000UL });
        public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3479 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_BXOR_in_bitwiseXorExpression3484 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3487 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0080000000000000UL });
        public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3501 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_BAND_in_bitwiseAndExpression3506 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3509 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0100000000000000UL });
        public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3523 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x1E00000000000000UL });
        public static readonly BitSet FOLLOW_equalityOperator_in_equalityExpression3528 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3533 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x1E00000000000000UL });
        public static readonly BitSet FOLLOW_set_in_equalityOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3573 = new BitSet(new ulong[] { 0x0000000000000002UL, 0xE000000000200000UL, 0x000000000000000FUL });
        public static readonly BitSet FOLLOW_relationalOperator_in_relationalExpression3583 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3586 = new BitSet(new ulong[] { 0x0000000000000002UL, 0xE000000000200000UL, 0x000000000000000FUL });
        public static readonly BitSet FOLLOW_IN_in_relationalOperator3601 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LT_in_relationalOperator3606 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GT_in_relationalOperator3610 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LE_in_relationalOperator3614 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GE_in_relationalOperator3618 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IS_in_relationalOperator3622 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_AS_in_relationalOperator3626 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INSTANCEOF_in_relationalOperator3630 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3642 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000070UL });
        public static readonly BitSet FOLLOW_shiftOperator_in_shiftExpression3647 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3650 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000070UL });
        public static readonly BitSet FOLLOW_set_in_shiftOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3683 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000180UL });
        public static readonly BitSet FOLLOW_additiveOperator_in_additiveExpression3688 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3691 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000000UL, 0x0000000000000180UL });
        public static readonly BitSet FOLLOW_set_in_additiveOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3721 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL, 0x0000000000000600UL });
        public static readonly BitSet FOLLOW_multiplicativeOperator_in_multiplicativeExpression3727 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3733 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL, 0x0000000000000600UL });
        public static readonly BitSet FOLLOW_set_in_multiplicativeOperator0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_INC_in_unaryExpression3771 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3773 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEC_in_unaryExpression3789 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3791 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_MINUS_in_unaryExpression3805 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3807 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_PLUS_in_unaryExpression3820 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3822 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3835 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3846 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000000000FFC0206UL });
        public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3848 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_175_in_unaryExpressionNotPlusMinus3861 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3863 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3876 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3878 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3891 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3893 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_BNOT_in_unaryExpressionNotPlusMinus3906 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3908 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3921 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_primaryExpression_in_postfixExpression3934 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_propOrIdent_in_postfixExpression3947 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_DOT_in_postfixExpression3959 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000004000080UL, 0x0000000000040000UL });
        public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression3961 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_LBRACK_in_postfixExpression3967 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_postfixExpression3969 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_postfixExpression3971 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_E4X_DESC_in_postfixExpression3988 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000004000080UL, 0x0000000000040000UL });
        public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression3990 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_arguments_in_postfixExpression3996 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000080UL, 0x0000000000021800UL });
        public static readonly BitSet FOLLOW_INC_in_postfixExpression4022 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DEC_in_postfixExpression4041 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_e4xExpression4068 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_e4xExpression4074 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xFilterPredicate_in_e4xExpression4079 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4090 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000027E600000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4096 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STAR_in_e4xAttributeIdentifier4102 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_e4xAttributeIdentifier4108 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_e4xAttributeIdentifier4110 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_e4xAttributeIdentifier4112 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_e4xFilterPredicate4127 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expression_in_e4xFilterPredicate4132 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_e4xFilterPredicate4136 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_UNDEFINED_in_primaryExpression4148 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_constant_in_primaryExpression4153 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpression4158 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpression4163 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_functionDefinition_in_primaryExpression4168 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newFullExpression_in_primaryExpression4173 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_primaryExpression4178 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_encapsulatedExpression_in_primaryExpression4183 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_primaryExpression4188 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_primaryExpression4193 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_propOrIdent4213 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_propOrIdent4217 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_xmlLiteral_in_constant4245 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_regexpLiteral_in_constant4250 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_number_in_constant4255 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_STRING_LITERAL_in_constant4260 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_TRUE_in_constant4265 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FALSE_in_constant4270 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NULL_in_constant4275 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_set_in_number0 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LT_in_xmlLiteral4328 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DIV_in_regexpLiteral4358 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NEW_in_newFullExpression4379 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000000000FFC0206UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_newFullExpression4382 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_arguments_in_newFullExpression4384 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_primaryExpression_in_fullNewSubexpression4397 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000000UL });
        public static readonly BitSet FOLLOW_DOT_in_fullNewSubexpression4411 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_fullNewSubexpression4413 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000000UL });
        public static readonly BitSet FOLLOW_brackets_in_fullNewSubexpression4430 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000408000000UL });
        public static readonly BitSet FOLLOW_NEW_in_newShortExpression4458 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000000000FFC0206UL });
        public static readonly BitSet FOLLOW_shortNewSubexpression_in_newShortExpression4461 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_shortNewSubexpression4474 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_shortNewSubexpression4479 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_propertyOperator4491 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_propertyOperator4494 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_brackets_in_propertyOperator4499 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LBRACK_in_brackets4515 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_expressionList_in_brackets4517 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000800000000UL });
        public static readonly BitSet FOLLOW_RBRACK_in_brackets4519 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LPAREN_in_encapsulatedExpression4540 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_encapsulatedExpression4542 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000100UL });
        public static readonly BitSet FOLLOW_RPAREN_in_encapsulatedExpression4544 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_FUNCTION_in_functionDefinition4568 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000080UL });
        public static readonly BitSet FOLLOW_parameterDeclarationList_in_functionDefinition4570 = new BitSet(new ulong[] { 0x0010000000000000UL, 0x0000000000020000UL });
        public static readonly BitSet FOLLOW_typeExpression_in_functionDefinition4572 = new BitSet(new ulong[] { 0x0010000000000000UL });
        public static readonly BitSet FOLLOW_block_in_functionDefinition4575 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IDENT_in_ident4602 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_USE_in_ident4609 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_XML_in_ident4621 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DYNAMIC_in_ident4633 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_NAMESPACE_in_ident4645 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_IS_in_ident4657 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_AS_in_ident4669 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_GET_in_ident4681 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_SET_in_ident4693 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_LCURLY_in_synpred401531 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_expressionStatement_in_synpred421545 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_ELSE_in_synpred561735 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_forInClauseDecl_in_synpred642082 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000200000UL });
        public static readonly BitSet FOLLOW_IN_in_synpred642084 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_COMMA_in_synpred993039 = new BitSet(new ulong[] { 0xC010000000000000UL, 0x20000027E200008FUL, 0x000080000FFDFB86UL });
        public static readonly BitSet FOLLOW_assignmentExpression_in_synpred993041 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_assignmentOperator_in_synpred1053214 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_relationalOperator_in_synpred1313579 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newFullExpression_in_synpred1724173 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_newShortExpression_in_synpred1734178 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_DOT_in_synpred1854411 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00000023E200000FUL, 0x0000000000000006UL });
        public static readonly BitSet FOLLOW_qualifiedIdent_in_synpred1854413 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_brackets_in_synpred1864430 = new BitSet(new ulong[] { 0x0000000000000002UL });
        public static readonly BitSet FOLLOW_fullNewSubexpression_in_synpred1874474 = new BitSet(new ulong[] { 0x0000000000000002UL });

    }
}