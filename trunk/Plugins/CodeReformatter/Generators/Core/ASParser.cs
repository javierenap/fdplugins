// $ANTLR 3.0 C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g 2007-09-17 08:49:46
namespace 
CodeReformatter.Generators.Core

{

using System.Text;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Text.RegularExpressions;


using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;

using IDictionary	= System.Collections.IDictionary;
using Hashtable 	= System.Collections.Hashtable;



using Antlr.Runtime.Tree;

public class ASParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"COMPILATION_UNIT", 
		"TYPE_BLOCK", 
		"METHOD_DEF", 
		"VAR_DEF", 
		"ANNOTATIONS", 
		"ANNOTATION", 
		"ANNOTATION_PARAMS", 
		"MODIFIERS", 
		"NAMESPACE_DEF", 
		"ACCESSOR_ROLE", 
		"CLASS_DEF", 
		"INTERFACE_DEF", 
		"PARAMS", 
		"PARAM", 
		"TYPE_SPEC", 
		"BLOCK", 
		"ELIST", 
		"CONDITION", 
		"ARGUMENTS", 
		"EXPR_STMNT", 
		"ENCPS_EXPR", 
		"VAR_INIT", 
		"METHOD_CALL", 
		"PROPERTY_OR_IDENTIFIER", 
		"PROPERTY_ACCESS", 
		"TYPE_NAME", 
		"ARRAY_ACC", 
		"UNARY_PLUS", 
		"UNARY_MINUS", 
		"POST_INC", 
		"POST_DEC", 
		"PRE_INC", 
		"PRE_DEC", 
		"ARRAY_LITERAL", 
		"ELEMENT", 
		"OBJECT_LITERAL", 
		"OBJECT_FIELD", 
		"FUNC_DEF", 
		"FOR_INIT", 
		"FOR_CONDITION", 
		"FOR_ITERATOR", 
		"FOR_EACH", 
		"FOR_IN", 
		"SWITCH_STATEMENT_LIST", 
		"IDENTIFIER", 
		"DEFAULT_XML_NAMESPACE", 
		"SINGLELINE_COMMENT", 
		"MULTILINE_COMMENT", 
		"COMMENT_LIST", 
		"COMMENT_ENTRY", 
		"VIRTUAL_PLACEHOLDER", 
		"ANNOTATION_ASSIGN", 
		"AS2_COMPILATION_UNIT", 
		"IMETHOD_DEF", 
		"IMPORT", 
		"SEMI", 
		"CLASS", 
		"INTERFACE", 
		"EXTENDS", 
		"COMMA", 
		"IMPLEMENTS", 
		"LCURLY", 
		"RCURLY", 
		"INCLUDE_DIRECTIVE", 
		"STRING_LITERAL", 
		"FUNCTION", 
		"GET", 
		"SET", 
		"VAR", 
		"CONST", 
		"ASSIGN", 
		"LPAREN", 
		"RPAREN", 
		"IF", 
		"ELSE", 
		"RETURN", 
		"CONTINUE", 
		"BREAK", 
		"SWITCH", 
		"CASE", 
		"COLON", 
		"DEFAULT", 
		"FOR", 
		"IN", 
		"WHILE", 
		"DO", 
		"WITH", 
		"VOID", 
		"STAR", 
		"DOT", 
		"IDENT", 
		"PUBLIC", 
		"PRIVATE", 
		"PROTECTED", 
		"INTERNAL", 
		"LBRACK", 
		"RBRACK", 
		"STATIC", 
		"DYNAMIC", 
		"STAR_ASSIGN", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"PLUS_ASSIGN", 
		"MINUS_ASSIGN", 
		"SL_ASSIGN", 
		"SR_ASSIGN", 
		"BSR_ASSIGN", 
		"BAND_ASSIGN", 
		"BXOR_ASSIGN", 
		"BOR_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"QUESTION", 
		"LOR", 
		"LAND", 
		"BOR", 
		"BXOR", 
		"BAND", 
		"STRICT_EQUAL", 
		"STRICT_NOT_EQUAL", 
		"NOT_EQUAL", 
		"EQUAL", 
		"LT", 
		"GT", 
		"LE", 
		"GE", 
		"IS", 
		"AS", 
		"INSTANCEOF", 
		"SL", 
		"SR", 
		"BSR", 
		"PLUS", 
		"MINUS", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"DELETE", 
		"TYPEOF", 
		"LNOT", 
		"BNOT", 
		"UNDEFINED", 
		"TRUE", 
		"FALSE", 
		"NULL", 
		"HEX_LITERAL", 
		"DECIMAL_LITERAL", 
		"OCTAL_LITERAL", 
		"FLOAT_LITERAL", 
		"NEW", 
		"SL_COMMENT", 
		"ML_COMMENT", 
		"USE", 
		"XML", 
		"PACKAGE", 
		"EACH", 
		"DBL_COLON", 
		"E4X_ATTRI", 
		"E4X_DESC", 
		"REST", 
		"ESC", 
		"HEX_DIGIT", 
		"EXPONENT", 
		"WS", 
		"NL", 
		"BOM", 
		"OCT_DIGIT", 
		"CTRLCHAR_ESC", 
		"UNICODE_ESC", 
		"OCTAL_ESC", 
		"'include'", 
		"'throw'", 
		"'try'", 
		"'catch'", 
		"'finally'", 
		"'final'", 
		"'enumerable'", 
		"'explicit'", 
		"'override'", 
		"'intrinsic'", 
		"'or'", 
		"'and'"
    };

    public const int INTERNAL = 98;
    public const int BLOCK = 19;
    public const int BOR_ASSIGN = 113;
    public const int STRING_LITERAL = 68;
    public const int GT = 127;
    public const int HEX_DIGIT = 166;
    public const int GET = 70;
    public const int UNDEFINED = 146;
    public const int SL_ASSIGN = 108;
    public const int PRE_DEC = 36;
    public const int LOR_ASSIGN = 115;
    public const int SR = 134;
    public const int IMPLEMENTS = 64;
    public const int GE = 129;
    public const int LBRACK = 99;
    public const int OCTAL_LITERAL = 152;
    public const int SL = 133;
    public const int PROPERTY_OR_IDENTIFIER = 27;
    public const int SINGLELINE_COMMENT = 50;
    public const int UNICODE_ESC = 173;
    public const int EXTENDS = 62;
    public const int NAMESPACE_DEF = 12;
    public const int FOR_IN = 46;
    public const int NOT_EQUAL = 124;
    public const int MOD_ASSIGN = 105;
    public const int LCURLY = 65;
    public const int UNARY_MINUS = 32;
    public const int LNOT = 144;
    public const int ANNOTATION_ASSIGN = 55;
    public const int ACCESSOR_ROLE = 13;
    public const int E4X_ATTRI = 162;
    public const int MULTILINE_COMMENT = 51;
    public const int DEFAULT = 85;
    public const int STATIC = 101;
    public const int ML_COMMENT = 156;
    public const int OCTAL_ESC = 174;
    public const int STRICT_NOT_EQUAL = 123;
    public const int OCT_DIGIT = 171;
    public const int ANNOTATIONS = 8;
    public const int E4X_DESC = 163;
    public const int POST_DEC = 34;
    public const int DECIMAL_LITERAL = 151;
    public const int MOD = 139;
    public const int INTERFACE_DEF = 15;
    public const int MODIFIERS = 11;
    public const int TYPE_SPEC = 18;
    public const int DIV = 138;
    public const int EACH = 160;
    public const int UNARY_PLUS = 31;
    public const int DEFAULT_XML_NAMESPACE = 49;
    public const int LAND_ASSIGN = 114;
    public const int CONDITION = 21;
    public const int ASSIGN = 74;
    public const int NULL = 149;
    public const int PRIVATE = 96;
    public const int DO = 89;
    public const int EOF = -1;
    public const int MINUS = 137;
    public const int SWITCH_STATEMENT_LIST = 47;
    public const int PARAM = 17;
    public const int TYPE_BLOCK = 5;
    public const int VIRTUAL_PLACEHOLDER = 54;
    public const int VAR_INIT = 25;
    public const int INSTANCEOF = 132;
    public const int VOID = 91;
    public const int FUNCTION = 69;
    public const int PROPERTY_ACCESS = 28;
    public const int TYPE_NAME = 29;
    public const int INC = 140;
    public const int RETURN = 79;
    public const int ELSE = 78;
    public const int EQUAL = 125;
    public const int BXOR_ASSIGN = 112;
    public const int CTRLCHAR_ESC = 172;
    public const int BSR_ASSIGN = 110;
    public const int TRUE = 147;
    public const int DBL_COLON = 161;
    public const int IDENTIFIER = 48;
    public const int COMMENT_ENTRY = 53;
    public const int COMMENT_LIST = 52;
    public const int SEMI = 59;
    public const int STRICT_EQUAL = 122;
    public const int PLUS_ASSIGN = 106;
    public const int BSR = 135;
    public const int OBJECT_FIELD = 40;
    public const int ELEMENT = 38;
    public const int NEW = 154;
    public const int DIV_ASSIGN = 104;
    public const int DELETE = 142;
    public const int NL = 169;
    public const int IDENT = 94;
    public const int BAND_ASSIGN = 111;
    public const int AS = 131;
    public const int AS2_COMPILATION_UNIT = 56;
    public const int CASE = 83;
    public const int OBJECT_LITERAL = 39;
    public const int RBRACK = 100;
    public const int LPAREN = 75;
    public const int PLUS = 136;
    public const int CLASS = 60;
    public const int FUNC_DEF = 41;
    public const int ARRAY_ACC = 30;
    public const int BREAK = 81;
    public const int WHILE = 88;
    public const int CONST = 73;
    public const int RCURLY = 66;
    public const int INTERFACE = 61;
    public const int PARAMS = 16;
    public const int FOR_INIT = 42;
    public const int DEC = 141;
    public const int COMMA = 63;
    public const int COMPILATION_UNIT = 4;
    public const int LT = 126;
    public const int FOR_ITERATOR = 44;
    public const int ARGUMENTS = 22;
    public const int LE = 128;
    public const int FOR_CONDITION = 43;
    public const int CLASS_DEF = 14;
    public const int MINUS_ASSIGN = 107;
    public const int ENCPS_EXPR = 24;
    public const int LOR = 117;
    public const int WITH = 90;
    public const int REST = 164;
    public const int INCLUDE_DIRECTIVE = 67;
    public const int BAND = 121;
    public const int STAR_ASSIGN = 103;
    public const int EXPONENT = 167;
    public const int SL_COMMENT = 155;
    public const int VAR = 72;
    public const int WS = 168;
    public const int PACKAGE = 159;
    public const int STAR = 92;
    public const int FOR = 86;
    public const int FALSE = 148;
    public const int IMPORT = 58;
    public const int XML = 158;
    public const int DOT = 93;
    public const int ANNOTATION = 9;
    public const int QUESTION = 116;
    public const int EXPR_STMNT = 23;
    public const int PRE_INC = 35;
    public const int BOR = 119;
    public const int BOM = 170;
    public const int SWITCH = 82;
    public const int CONTINUE = 80;
    public const int ARRAY_LITERAL = 37;
    public const int USE = 157;
    public const int SR_ASSIGN = 109;
    public const int IMETHOD_DEF = 57;
    public const int ANNOTATION_PARAMS = 10;
    public const int HEX_LITERAL = 150;
    public const int IS = 130;
    public const int METHOD_CALL = 26;
    public const int FOR_EACH = 45;
    public const int LAND = 118;
    public const int DYNAMIC = 102;
    public const int IN = 87;
    public const int BXOR = 120;
    public const int METHOD_DEF = 6;
    public const int VAR_DEF = 7;
    public const int IF = 77;
    public const int ELIST = 20;
    public const int TYPEOF = 143;
    public const int FLOAT_LITERAL = 153;
    public const int COLON = 84;
    public const int SET = 71;
    public const int PUBLIC = 95;
    public const int POST_INC = 33;
    public const int ESC = 165;
    public const int BNOT = 145;
    public const int RPAREN = 76;
    public const int PROTECTED = 97;
    protected class InOperator_scope 
    {
        protected internal Boolean allowed;
    }
    protected Stack InOperator_stack = new Stack();

    
    
        public ASParser(ITokenStream input) 
    		: base(input)
    	{
    		InitializeCyclicDFAs();
            ruleMemo = new IDictionary[311+1];
         }
        
    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();
    
    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set { this.adaptor = value; }
    }

    override public string[] TokenNames
	{
		get { return tokenNames; }
	}

    override public string GrammarFileName
	{
		get { return "C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g"; }
	}

    
    
    	#region Properties
    
    	private ReformatOptions options = new ReformatOptions();
    	private StringBuilder buffer;
    	private List<string> importList;
    	private int currentTab = 0;
        private String tabString = "\t";
        private String newline = "\n";
        private String tab = "";
        private Regex lineSplitterReg = new Regex("[\n\r]+", RegexOptions.Multiline);
    	private ASLexer lexer;
    	private ICharStream cs;
    	public static int CHANNEL_PLACEHOLDER = 999;
    	
    	
        public ASParser(ITokenStream input, ReformatOptions opt)
            : base(input)
        {
            options = opt;
            InitializeCyclicDFAs();
            ruleMemo = new IDictionary[307 + 1];
        }	
    	
        /// <summary>
        /// Get/Set the Tab Width
        /// </summary>
        public int CurrentTab
        {
            get { return this.currentTab; }
            set
            {
                this.currentTab = value;
                if (this.currentTab < 0) this.currentTab = 0;
                tab = "";
                for (int i = 0; i < currentTab; i++)
                {
                    tab += TabString;
                }
            }
        }
        
        public String TabString
        {
            get { return this.tabString; }
            set { this.tabString = value; }
        } 
        
        public String NewLine
        {
            get { return this.newline; }
            set { this.newline = value; }
        } 
    	
    	#endregion
    
    	#region Members
    
    	public void SetInput(ASLexer lexer, ICharStream cs) 
    	{
    		this.lexer = lexer;
    		this.cs = cs;
    	}
    	
    	public StringBuilder Buffer
    	{
    		get { return this.buffer; }
    	}
    	
        /// <summary>
        /// Return a dot separated identifier
        /// </summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        protected static String fromIdentifier(ITree tree)
        {
            tree = (CommonTree)tree;
            if (tree.Type == ASLexer.IDENT || tree.Type == ASLexer.VOID || tree.Type == ASLexer.STAR) return tree.Text;
            string[] buff = new string[tree.ChildCount];
            for (int i = 0; i < tree.ChildCount; i++)
            {
                buff[i] = tree.GetChild(i).Text;
            }
            return String.Join(".", buff);
        }
        
        /// <summary>
        /// Compute the MODIFIER node and return a string representation
        /// </summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        protected static String fromModifiers(ITree tree)
        {
            tree = (CommonTree)tree;
            List<string> mods = new List<string>();
            for (int i = 0; i < tree.ChildCount; i++)
            {
                mods.Add(tree.GetChild(i).Text);
            }
            mods.Sort();
            return String.Join(" ", mods.ToArray());
        }
        
        /// <summary>
        /// Insert a comment in the passed String builder
        /// </summary>
        /// <param name="tree"></param>    
        private void insertComment(ParserRuleReturnScope rule, Boolean newlineBefore, Boolean newlineAfter, int carriageReturns)
        {
    		CommonTree tree;
    		CommonTree comment;
    		
    		if(rule != null)
    		{
    			tree = (CommonTree)rule.Tree;   // COMMENT_LIST
    			for(int i = 0; i < tree.ChildCount; i++)
    			{
    				if(newlineBefore && i == 0)
    				{
    					for(int n = 0; n < carriageReturns; n++)
    					{
    						buffer.Append(NewLine + tab);
    					}
    				}
    			
    				comment = (CommonTree)tree.GetChild(i); // COMMENT_ENTRY
    				if(comment.GetChild(0).Type == ASLexer.MULTILINE_COMMENT)
    				{
    					string[] lines = lineSplitterReg.Split(comment.GetChild(0).GetChild(0).Text);
    					int k = 0;
    					foreach (string line in lines)
    					{
    						buffer.Append((k > 0 ? " " : "") + line.Trim() + (k < lines.Length-1 ? NewLine + tab : ""));
    						k++;
    					}				
    				} else {
    					buffer.Append(comment.GetChild(0).GetChild(0).Text.TrimEnd());
    				}
                    if(i < tree.ChildCount - 1 || newlineAfter)
                        buffer.Append(NewLine + tab);
    			}
    		}
        }
    
        private void insertComment(ParserRuleReturnScope rule, Boolean newlineBefore, Boolean newlineAfter)
        {
    		insertComment(rule, newlineBefore, newlineAfter, 1);
        }
        
        
        private void insertComment(ParserRuleReturnScope rule)
        {
    		insertComment(rule, false, false, 0);
        }
        
    	/// <summary>
        /// Remove duplicates from a list of strings
        /// </summary>
        /// <param name="inputList"></param>
        /// <returns>List<string></returns>
    	protected static List<string> removeDuplicates(List<string> inputList)
    	{
    		Dictionary<string, int> uniqueStore = new Dictionary<string, int>();
    		List<string> finalList = new List<string>();
    		foreach (string currValue in inputList)
    		{
    			if (!uniqueStore.ContainsKey(currValue))
    			{
    				uniqueStore.Add(currValue, 0);
    				finalList.Add(currValue);
    			}
    		}
    		return finalList;
    	}
        
        
            
        /// <summay>
        /// Finalize the code generation
        /// </summary>
        /// <returns></returns>
        private void finalize()
        {
            // organize imports
            List<string>  importListUnique = removeDuplicates(importList);
            importListUnique.Sort();
            if(importListUnique.Count > 0)
            {
    			foreach (string item in importListUnique)
    			{
    				buffer.Insert(0, NewLine + "import " + item + ";");
    			}
            }
            
            // newline at the end of file
            buffer.Append(NewLine);
        }
        
        
    	#endregion


    public class compilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start compilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:329:1: compilationUnit[StringBuilder ret] : as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) ;
    public compilationUnit_return compilationUnit(StringBuilder ret) // throws RecognitionException [1]
    {   
        compilationUnit_return retval = new compilationUnit_return();
        retval.start = input.LT(1);
        int compilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        as2CompilationUnit_return as2CompilationUnit1 = null;
        
        
        RewriteRuleSubtreeStream stream_as2CompilationUnit = new RewriteRuleSubtreeStream(adaptor,"rule as2CompilationUnit");
        
        	buffer = ret;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 1) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:336:4: ( as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:336:4: as2CompilationUnit
            {
            	PushFollow(FOLLOW_as2CompilationUnit_in_compilationUnit437);
            	as2CompilationUnit1 = as2CompilationUnit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);
            	
            	// AST REWRITE
            	// elements:          as2CompilationUnit
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 336:23: -> ^( COMPILATION_UNIT as2CompilationUnit )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:336:26: ^( COMPILATION_UNIT as2CompilationUnit )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_as2CompilationUnit.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
            if ( backtracking == 0 ) 
            {
              
              	finalize();
            
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 1, compilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end compilationUnit

    public class as2CompilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2CompilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:340:1: as2CompilationUnit : ( importDefinition | annotations | c= comments )* as2Type ;
    public as2CompilationUnit_return as2CompilationUnit() // throws RecognitionException [1]
    {   
        as2CompilationUnit_return retval = new as2CompilationUnit_return();
        retval.start = input.LT(1);
        int as2CompilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        comments_return c = null;

        importDefinition_return importDefinition2 = null;

        annotations_return annotations3 = null;

        as2Type_return as2Type4 = null;
        
        
    
        
        	importList = new List<string>();
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 2) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:344:4: ( ( importDefinition | annotations | c= comments )* as2Type )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:344:4: ( importDefinition | annotations | c= comments )* as2Type
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:344:4: ( importDefinition | annotations | c= comments )*
            	do 
            	{
            	    int alt1 = 4;
            	    switch ( input.LA(1) ) 
            	    {
            	    case IMPORT:
            	    	{
            	        alt1 = 1;
            	        }
            	        break;
            	    case LBRACK:
            	    case 175:
            	    	{
            	        alt1 = 2;
            	        }
            	        break;
            	    case SL_COMMENT:
            	    case ML_COMMENT:
            	    	{
            	        alt1 = 3;
            	        }
            	        break;
            	    
            	    }
            	
            	    switch (alt1) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:345:4: importDefinition
            			    {
            			    	PushFollow(FOLLOW_importDefinition_in_as2CompilationUnit468);
            			    	importDefinition2 = importDefinition();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition2.Tree);
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:346:5: annotations
            			    {
            			    	PushFollow(FOLLOW_annotations_in_as2CompilationUnit474);
            			    	annotations3 = annotations();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations3.Tree);
            			    
            			    }
            			    break;
            			case 3 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:347:5: c= comments
            			    {
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append(NewLine + tab + NewLine + tab); 
            			    	}
            			    	PushFollow(FOLLOW_comments_in_as2CompilationUnit484);
            			    	c = comments();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   insertComment(c); 
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop1;
            	    }
            	} while (true);
            	
            	loop1:
            		;	// Stops C# compiler whinging that label 'loop1' has no statements

            	PushFollow(FOLLOW_as2Type_in_as2CompilationUnit495);
            	as2Type4 = as2Type();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, as2Type4.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 2, as2CompilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2CompilationUnit

    public class as2Type_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2Type
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:352:1: as2Type : mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) ;
    public as2Type_return as2Type() // throws RecognitionException [1]
    {   
        as2Type_return retval = new as2Type_return();
        retval.start = input.LT(1);
        int as2Type_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return mods = null;

        as2ClassDefinition_return as2ClassDefinition5 = null;

        as2InterfaceDefinition_return as2InterfaceDefinition6 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 3) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:353:4: (mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:353:4: mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_modifiers_in_as2Type508);
            	mods = modifiers();
            	followingStackPointer_--;
            	if (failed) return retval;
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:354:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            	int alt2 = 2;
            	int LA2_0 = input.LA(1);
            	
            	if ( (LA2_0 == CLASS) )
            	{
            	    alt2 = 1;
            	}
            	else if ( (LA2_0 == INTERFACE) )
            	{
            	    alt2 = 2;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d2s0 =
            	        new NoViableAltException("354:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )", 2, 0, input);
            	
            	    throw nvae_d2s0;
            	}
            	switch (alt2) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:354:4: as2ClassDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2ClassDefinition_in_as2Type514);
            	        	as2ClassDefinition5 = as2ClassDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2ClassDefinition5.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:355:4: as2InterfaceDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2InterfaceDefinition_in_as2Type520);
            	        	as2InterfaceDefinition6 = as2InterfaceDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2InterfaceDefinition6.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 3, as2Type_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2Type

    public class endOfFile_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start endOfFile
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:360:1: endOfFile : EOF ;
    public endOfFile_return endOfFile() // throws RecognitionException [1]
    {   
        endOfFile_return retval = new endOfFile_return();
        retval.start = input.LT(1);
        int endOfFile_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken EOF7 = null;
        
        CommonTree EOF7_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 4) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:361:4: ( EOF )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:361:4: EOF
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	EOF7 = (CommonToken)input.LT(1);
            	Match(input,EOF,FOLLOW_EOF_in_endOfFile537); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 4, endOfFile_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end endOfFile

    public class importDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start importDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:364:1: importDefinition : IMPORT ide= identifierStar semi ;
    public importDefinition_return importDefinition() // throws RecognitionException [1]
    {   
        importDefinition_return retval = new importDefinition_return();
        retval.start = input.LT(1);
        int importDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IMPORT8 = null;
        identifierStar_return ide = null;

        semi_return semi9 = null;
        
        
        CommonTree IMPORT8_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 5) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:365:4: ( IMPORT ide= identifierStar semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:365:4: IMPORT ide= identifierStar semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IMPORT8 = (CommonToken)input.LT(1);
            	Match(input,IMPORT,FOLLOW_IMPORT_in_importDefinition549); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IMPORT8_tree = (CommonTree)adaptor.Create(IMPORT8);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IMPORT8_tree, root_0);
            	}
            	PushFollow(FOLLOW_identifierStar_in_importDefinition556);
            	ide = identifierStar();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   importList.Add(fromIdentifier((CommonTree)ide.Tree)); 
            	}
            	PushFollow(FOLLOW_semi_in_importDefinition564);
            	semi9 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi9.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 5, importDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end importDefinition

    public class semi_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start semi
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:370:1: semi : ( SEMI | );
    public semi_return semi() // throws RecognitionException [1]
    {   
        semi_return retval = new semi_return();
        retval.start = input.LT(1);
        int semi_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken SEMI10 = null;
        
        CommonTree SEMI10_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 6) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:371:4: ( SEMI | )
            int alt3 = 2;
            int LA3_0 = input.LA(1);
            
            if ( (LA3_0 == SEMI) )
            {
                int LA3_1 = input.LA(2);
                
                if ( (synpred5()) )
                {
                    alt3 = 1;
                }
                else if ( (true) )
                {
                    alt3 = 2;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d3s1 =
                        new NoViableAltException("370:1: semi : ( SEMI | );", 3, 1, input);
                
                    throw nvae_d3s1;
                }
            }
            else if ( (LA3_0 == EOF || LA3_0 == IMPORT || (LA3_0 >= CLASS && LA3_0 <= INTERFACE) || (LA3_0 >= LCURLY && LA3_0 <= CONST) || LA3_0 == LPAREN || (LA3_0 >= IF && LA3_0 <= CASE) || (LA3_0 >= DEFAULT && LA3_0 <= FOR) || (LA3_0 >= WHILE && LA3_0 <= VOID) || (LA3_0 >= IDENT && LA3_0 <= LBRACK) || (LA3_0 >= STATIC && LA3_0 <= DYNAMIC) || (LA3_0 >= IS && LA3_0 <= AS) || (LA3_0 >= PLUS && LA3_0 <= MINUS) || (LA3_0 >= INC && LA3_0 <= XML) || (LA3_0 >= 175 && LA3_0 <= 177) || (LA3_0 >= 180 && LA3_0 <= 184)) )
            {
                alt3 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d3s0 =
                    new NoViableAltException("370:1: semi : ( SEMI | );", 3, 0, input);
            
                throw nvae_d3s0;
            }
            switch (alt3) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:371:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI10 = (CommonToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_semi575); if (failed) return retval;
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:373:2: 
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 6, semi_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end semi

    public class as2ClassDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2ClassDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:375:1: as2ClassDefinition[CommonTree mods] : cl= CLASS ide= identifier ext= classExtendsClause imp= implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) ;
    public as2ClassDefinition_return as2ClassDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2ClassDefinition_return retval = new as2ClassDefinition_return();
        retval.start = input.LT(1);
        int as2ClassDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken cl = null;
        identifier_return ide = null;

        classExtendsClause_return ext = null;

        implementsClause_return imp = null;

        typeBlock_return typeBlock11 = null;
        
        
        CommonTree cl_tree=null;
        RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor,"token CLASS");
        RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
        RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 7) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:376:4: (cl= CLASS ide= identifier ext= classExtendsClause imp= implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:376:4: cl= CLASS ide= identifier ext= classExtendsClause imp= implementsClause typeBlock
            {
            	cl = (CommonToken)input.LT(1);
            	Match(input,CLASS,FOLLOW_CLASS_in_as2ClassDefinition594); if (failed) return retval;
            	if ( backtracking==0 ) stream_CLASS.Add(cl);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(NewLine + tab + cl.Text + " "); 
            	}
            	PushFollow(FOLLOW_identifier_in_as2ClassDefinition606);
            	ide = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(ide.Tree);
            	PushFollow(FOLLOW_classExtendsClause_in_as2ClassDefinition612);
            	ext = classExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_classExtendsClause.Add(ext.Tree);
            	PushFollow(FOLLOW_implementsClause_in_as2ClassDefinition619);
            	imp = implementsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_implementsClause.Add(imp.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									buffer.Append(options.NewlineAfterMethod ? NewLine + tab : " ");
            	  									buffer.Append("{");
            	  									CurrentTab++; 
            	  								
            	}
            	PushFollow(FOLLOW_typeBlock_in_as2ClassDefinition625);
            	typeBlock11 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock11.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	  									CurrentTab--;
            	  									buffer.Append(NewLine + tab);
            	  									buffer.Append("}");
            	  								
            	}
            	
            	// AST REWRITE
            	// elements:          implementsClause, identifier, typeBlock, classExtendsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 390:3: -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:390:6: ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_classExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_implementsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 7, as2ClassDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2ClassDefinition

    public class interfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:394:1: interfaceDefinition[CommonTree mods] : tk= INTERFACE ide= ident interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock ) ;
    public interfaceDefinition_return interfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        interfaceDefinition_return retval = new interfaceDefinition_return();
        retval.start = input.LT(1);
        int interfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken tk = null;
        ident_return ide = null;

        interfaceExtendsClause_return interfaceExtendsClause12 = null;

        interfaceTypeBlock_return interfaceTypeBlock13 = null;
        
        
        CommonTree tk_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_interfaceTypeBlock = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlock");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 8) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:396:4: (tk= INTERFACE ide= ident interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:396:4: tk= INTERFACE ide= ident interfaceExtendsClause interfaceTypeBlock
            {
            	tk = (CommonToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_interfaceDefinition672); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(tk);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(NewLine + tab + NewLine + tab + tk.Text + " "); 
            	}
            	PushFollow(FOLLOW_ident_in_interfaceDefinition683);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_interfaceDefinition687);
            	interfaceExtendsClause12 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause12.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									buffer.Append(options.NewlineAfterMethod ? NewLine + tab : "");
            	  									buffer.Append("{");
            	  									CurrentTab++; 
            	  								
            	}
            	PushFollow(FOLLOW_interfaceTypeBlock_in_interfaceDefinition693);
            	interfaceTypeBlock13 = interfaceTypeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceTypeBlock.Add(interfaceTypeBlock13.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	  									CurrentTab--;
            	  									buffer.Append(NewLine + tab);
            	  									buffer.Append("}");
            	  								
            	}
            	
            	// AST REWRITE
            	// elements:          ident, interfaceTypeBlock, interfaceExtendsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 408:3: -> ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:408:6: ^( INTERFACE_DEF ident interfaceExtendsClause interfaceTypeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_interfaceTypeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 8, interfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceDefinition

    public class as2InterfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2InterfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:411:1: as2InterfaceDefinition[CommonTree mods] : INTERFACE identifier interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock ) ;
    public as2InterfaceDefinition_return as2InterfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2InterfaceDefinition_return retval = new as2InterfaceDefinition_return();
        retval.start = input.LT(1);
        int as2InterfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken INTERFACE14 = null;
        identifier_return identifier15 = null;

        interfaceExtendsClause_return interfaceExtendsClause16 = null;

        interfaceTypeBlock_return interfaceTypeBlock17 = null;
        
        
        CommonTree INTERFACE14_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_interfaceTypeBlock = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlock");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 9) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:413:4: ( INTERFACE identifier interfaceExtendsClause interfaceTypeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:413:4: INTERFACE identifier interfaceExtendsClause interfaceTypeBlock
            {
            	INTERFACE14 = (CommonToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_as2InterfaceDefinition729); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(INTERFACE14);

            	PushFollow(FOLLOW_identifier_in_as2InterfaceDefinition731);
            	identifier15 = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(identifier15.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition735);
            	interfaceExtendsClause16 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause16.Tree);
            	PushFollow(FOLLOW_interfaceTypeBlock_in_as2InterfaceDefinition739);
            	interfaceTypeBlock17 = interfaceTypeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceTypeBlock.Add(interfaceTypeBlock17.Tree);
            	
            	// AST REWRITE
            	// elements:          interfaceTypeBlock, interfaceExtendsClause, identifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 416:3: -> ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:416:6: ^( INTERFACE_DEF identifier interfaceExtendsClause interfaceTypeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_interfaceTypeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 9, as2InterfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2InterfaceDefinition

    public class classExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start classExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:419:1: classExtendsClause : (tk= EXTENDS ide= identifier )? ;
    public classExtendsClause_return classExtendsClause() // throws RecognitionException [1]
    {   
        classExtendsClause_return retval = new classExtendsClause_return();
        retval.start = input.LT(1);
        int classExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken tk = null;
        identifier_return ide = null;
        
        
        CommonTree tk_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 10) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:420:4: ( (tk= EXTENDS ide= identifier )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:420:4: (tk= EXTENDS ide= identifier )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:420:4: (tk= EXTENDS ide= identifier )?
            	int alt4 = 2;
            	int LA4_0 = input.LA(1);
            	
            	if ( (LA4_0 == EXTENDS) )
            	{
            	    alt4 = 1;
            	}
            	switch (alt4) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:421:4: tk= EXTENDS ide= identifier
            	        {
            	        	tk = (CommonToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_classExtendsClause773); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	tk_tree = (CommonTree)adaptor.Create(tk);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(tk_tree, root_0);
            	        	}
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(" " + tk.Text + " "); 
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_classExtendsClause785);
            	        	ide = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 10, classExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end classExtendsClause

    public class interfaceExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:425:1: interfaceExtendsClause : (tk= EXTENDS ide= identifier ( COMMA ide2= identifier )* )? ;
    public interfaceExtendsClause_return interfaceExtendsClause() // throws RecognitionException [1]
    {   
        interfaceExtendsClause_return retval = new interfaceExtendsClause_return();
        retval.start = input.LT(1);
        int interfaceExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken tk = null;
        CommonToken COMMA18 = null;
        identifier_return ide = null;

        identifier_return ide2 = null;
        
        
        CommonTree tk_tree=null;
        CommonTree COMMA18_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 11) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:426:4: ( (tk= EXTENDS ide= identifier ( COMMA ide2= identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:426:4: (tk= EXTENDS ide= identifier ( COMMA ide2= identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:426:4: (tk= EXTENDS ide= identifier ( COMMA ide2= identifier )* )?
            	int alt6 = 2;
            	int LA6_0 = input.LA(1);
            	
            	if ( (LA6_0 == EXTENDS) )
            	{
            	    alt6 = 1;
            	}
            	switch (alt6) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:427:4: tk= EXTENDS ide= identifier ( COMMA ide2= identifier )*
            	        {
            	        	tk = (CommonToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_interfaceExtendsClause808); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	tk_tree = (CommonTree)adaptor.Create(tk);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(tk_tree, root_0);
            	        	}
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(tk.Text + " "); 
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause820);
            	        	ide = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(" "); 
            	        	}
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:429:4: ( COMMA ide2= identifier )*
            	        	do 
            	        	{
            	        	    int alt5 = 2;
            	        	    int LA5_0 = input.LA(1);
            	        	    
            	        	    if ( (LA5_0 == COMMA) )
            	        	    {
            	        	        alt5 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt5) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:430:5: COMMA ide2= identifier
            	        			    {
            	        			    	COMMA18 = (CommonToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_interfaceExtendsClause834); if (failed) return retval;
            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	   buffer.Append(", "); 
            	        			    	}
            	        			    	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause848);
            	        			    	ide2 = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, ide2.Tree);
            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	   buffer.Append(" "); 
            	        			    	}
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop5;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop5:
            	        		;	// Stops C# compiler whinging that label 'loop5' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 11, interfaceExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceExtendsClause

    public class implementsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start implementsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:436:1: implementsClause : ( IMPLEMENTS ide= identifier ( COMMA ide= identifier )* )? ;
    public implementsClause_return implementsClause() // throws RecognitionException [1]
    {   
        implementsClause_return retval = new implementsClause_return();
        retval.start = input.LT(1);
        int implementsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IMPLEMENTS19 = null;
        CommonToken COMMA20 = null;
        identifier_return ide = null;
        
        
        CommonTree IMPLEMENTS19_tree=null;
        CommonTree COMMA20_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 12) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:437:4: ( ( IMPLEMENTS ide= identifier ( COMMA ide= identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:437:4: ( IMPLEMENTS ide= identifier ( COMMA ide= identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:437:4: ( IMPLEMENTS ide= identifier ( COMMA ide= identifier )* )?
            	int alt8 = 2;
            	int LA8_0 = input.LA(1);
            	
            	if ( (LA8_0 == IMPLEMENTS) )
            	{
            	    alt8 = 1;
            	}
            	switch (alt8) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:437:5: IMPLEMENTS ide= identifier ( COMMA ide= identifier )*
            	        {
            	        	IMPLEMENTS19 = (CommonToken)input.LT(1);
            	        	Match(input,IMPLEMENTS,FOLLOW_IMPLEMENTS_in_implementsClause875); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	IMPLEMENTS19_tree = (CommonTree)adaptor.Create(IMPLEMENTS19);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(IMPLEMENTS19_tree, root_0);
            	        	}
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(" implements "); 
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_implementsClause886);
            	        	ide = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   
            	        	}
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:439:4: ( COMMA ide= identifier )*
            	        	do 
            	        	{
            	        	    int alt7 = 2;
            	        	    int LA7_0 = input.LA(1);
            	        	    
            	        	    if ( (LA7_0 == COMMA) )
            	        	    {
            	        	        alt7 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt7) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:440:5: COMMA ide= identifier
            	        			    {
            	        			    	COMMA20 = (CommonToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_implementsClause900); if (failed) return retval;
            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	   buffer.Append(", "); 
            	        			    	}
            	        			    	PushFollow(FOLLOW_identifier_in_implementsClause913);
            	        			    	ide = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	    
            	        			    	}
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop7;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop7:
            	        		;	// Stops C# compiler whinging that label 'loop7' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 12, implementsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end implementsClause

    public class interfaceTypeBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceTypeBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:446:1: interfaceTypeBlock : LCURLY ( interfaceTypeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* ) ;
    public interfaceTypeBlock_return interfaceTypeBlock() // throws RecognitionException [1]
    {   
        interfaceTypeBlock_return retval = new interfaceTypeBlock_return();
        retval.start = input.LT(1);
        int interfaceTypeBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LCURLY21 = null;
        CommonToken RCURLY23 = null;
        interfaceTypeBlockEntry_return interfaceTypeBlockEntry22 = null;
        
        
        CommonTree LCURLY21_tree=null;
        CommonTree RCURLY23_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_interfaceTypeBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule interfaceTypeBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 13) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:447:4: ( LCURLY ( interfaceTypeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:447:4: LCURLY ( interfaceTypeBlockEntry )* RCURLY
            {
            	LCURLY21 = (CommonToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_interfaceTypeBlock939); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY21);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:448:3: ( interfaceTypeBlockEntry )*
            	do 
            	{
            	    int alt9 = 2;
            	    int LA9_0 = input.LA(1);
            	    
            	    if ( (LA9_0 == IMPORT || LA9_0 == INCLUDE_DIRECTIVE || LA9_0 == FUNCTION || (LA9_0 >= IDENT && LA9_0 <= LBRACK) || (LA9_0 >= STATIC && LA9_0 <= DYNAMIC) || LA9_0 == 175 || (LA9_0 >= 180 && LA9_0 <= 184)) )
            	    {
            	        alt9 = 1;
            	    }
            	    
            	
            	    switch (alt9) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:448:4: interfaceTypeBlockEntry
            			    {
            			    	PushFollow(FOLLOW_interfaceTypeBlockEntry_in_interfaceTypeBlock944);
            			    	interfaceTypeBlockEntry22 = interfaceTypeBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_interfaceTypeBlockEntry.Add(interfaceTypeBlockEntry22.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop9;
            	    }
            	} while (true);
            	
            	loop9:
            		;	// Stops C# compiler whinging that label 'loop9' has no statements

            	RCURLY23 = (CommonToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_interfaceTypeBlock950); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY23);

            	
            	// AST REWRITE
            	// elements:          interfaceTypeBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 450:3: -> ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:450:6: ^( TYPE_BLOCK ( interfaceTypeBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:450:19: ( interfaceTypeBlockEntry )*
            	    while ( stream_interfaceTypeBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_interfaceTypeBlockEntry.Next());
            	    
            	    }
            	    stream_interfaceTypeBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 13, interfaceTypeBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceTypeBlock

    public class typeBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:453:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) ;
    public typeBlock_return typeBlock() // throws RecognitionException [1]
    {   
        typeBlock_return retval = new typeBlock_return();
        retval.start = input.LT(1);
        int typeBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LCURLY24 = null;
        CommonToken RCURLY26 = null;
        typeBlockEntry_return typeBlockEntry25 = null;
        
        
        CommonTree LCURLY24_tree=null;
        CommonTree RCURLY26_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_typeBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule typeBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 14) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:454:4: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:454:4: LCURLY ( typeBlockEntry )* RCURLY
            {
            	LCURLY24 = (CommonToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_typeBlock973); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY24);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:455:3: ( typeBlockEntry )*
            	do 
            	{
            	    int alt10 = 2;
            	    int LA10_0 = input.LA(1);
            	    
            	    if ( (LA10_0 == IMPORT || LA10_0 == INCLUDE_DIRECTIVE || LA10_0 == FUNCTION || (LA10_0 >= VAR && LA10_0 <= CONST) || (LA10_0 >= IDENT && LA10_0 <= LBRACK) || (LA10_0 >= STATIC && LA10_0 <= DYNAMIC) || (LA10_0 >= SL_COMMENT && LA10_0 <= ML_COMMENT) || LA10_0 == 175 || (LA10_0 >= 180 && LA10_0 <= 184)) )
            	    {
            	        alt10 = 1;
            	    }
            	    
            	
            	    switch (alt10) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:455:4: typeBlockEntry
            			    {
            			    	PushFollow(FOLLOW_typeBlockEntry_in_typeBlock978);
            			    	typeBlockEntry25 = typeBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_typeBlockEntry.Add(typeBlockEntry25.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop10;
            	    }
            	} while (true);
            	
            	loop10:
            		;	// Stops C# compiler whinging that label 'loop10' has no statements

            	RCURLY26 = (CommonToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_typeBlock984); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY26);

            	
            	// AST REWRITE
            	// elements:          typeBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 457:3: -> ^( TYPE_BLOCK ( typeBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:457:6: ^( TYPE_BLOCK ( typeBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:457:19: ( typeBlockEntry )*
            	    while ( stream_typeBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeBlockEntry.Next());
            	    
            	    }
            	    stream_typeBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 14, typeBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlock

    public class interfaceTypeBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceTypeBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:460:1: interfaceTypeBlockEntry : (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations );
    public interfaceTypeBlockEntry_return interfaceTypeBlockEntry() // throws RecognitionException [1]
    {   
        interfaceTypeBlockEntry_return retval = new interfaceTypeBlockEntry_return();
        retval.start = input.LT(1);
        int interfaceTypeBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return m = null;

        interfaceMethodDefinition_return interfaceMethodDefinition27 = null;

        importDefinition_return importDefinition28 = null;

        as2IncludeDirective_return as2IncludeDirective29 = null;

        annotations_return annotations30 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 15) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:461:4: (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations )
            int alt11 = 4;
            switch ( input.LA(1) ) 
            {
            case FUNCTION:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case STATIC:
            case DYNAMIC:
            case 180:
            case 181:
            case 182:
            case 183:
            case 184:
            	{
                alt11 = 1;
                }
                break;
            case IMPORT:
            	{
                alt11 = 2;
                }
                break;
            case INCLUDE_DIRECTIVE:
            	{
                alt11 = 3;
                }
                break;
            case LBRACK:
            case 175:
            	{
                alt11 = 4;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d11s0 =
            	        new NoViableAltException("460:1: interfaceTypeBlockEntry : (m= modifiers ( interfaceMethodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations );", 11, 0, input);
            
            	    throw nvae_d11s0;
            }
            
            switch (alt11) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:461:4: m= modifiers ( interfaceMethodDefinition[$m.tree] )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_modifiers_in_interfaceTypeBlockEntry1012);
                    	m = modifiers();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:463:3: ( interfaceMethodDefinition[$m.tree] )
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:464:4: interfaceMethodDefinition[$m.tree]
                    	{
                    		PushFollow(FOLLOW_interfaceMethodDefinition_in_interfaceTypeBlockEntry1023);
                    		interfaceMethodDefinition27 = interfaceMethodDefinition(((CommonTree)m.tree));
                    		followingStackPointer_--;
                    		if (failed) return retval;
                    		if ( backtracking==0 ) adaptor.AddChild(root_0, interfaceMethodDefinition27.Tree);
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:466:4: importDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_importDefinition_in_interfaceTypeBlockEntry1033);
                    	importDefinition28 = importDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition28.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:467:4: as2IncludeDirective
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_as2IncludeDirective_in_interfaceTypeBlockEntry1040);
                    	as2IncludeDirective29 = as2IncludeDirective();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, as2IncludeDirective29.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:468:4: annotations
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_annotations_in_interfaceTypeBlockEntry1047);
                    	annotations30 = annotations();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations30.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 15, interfaceTypeBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceTypeBlockEntry

    public class typeBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:471:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations | c= comments );
    public typeBlockEntry_return typeBlockEntry() // throws RecognitionException [1]
    {   
        typeBlockEntry_return retval = new typeBlockEntry_return();
        retval.start = input.LT(1);
        int typeBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return m = null;

        comments_return c = null;

        variableDefinition_return variableDefinition31 = null;

        methodDefinition_return methodDefinition32 = null;

        importDefinition_return importDefinition33 = null;

        as2IncludeDirective_return as2IncludeDirective34 = null;

        annotations_return annotations35 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 16) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:472:4: (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations | c= comments )
            int alt13 = 5;
            switch ( input.LA(1) ) 
            {
            case FUNCTION:
            case VAR:
            case CONST:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case STATIC:
            case DYNAMIC:
            case 180:
            case 181:
            case 182:
            case 183:
            case 184:
            	{
                alt13 = 1;
                }
                break;
            case IMPORT:
            	{
                alt13 = 2;
                }
                break;
            case INCLUDE_DIRECTIVE:
            	{
                alt13 = 3;
                }
                break;
            case LBRACK:
            case 175:
            	{
                alt13 = 4;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt13 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d13s0 =
            	        new NoViableAltException("471:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | annotations | c= comments );", 13, 0, input);
            
            	    throw nvae_d13s0;
            }
            
            switch (alt13) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:472:4: m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_modifiers_in_typeBlockEntry1064);
                    	m = modifiers();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:474:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    	int alt12 = 2;
                    	int LA12_0 = input.LA(1);
                    	
                    	if ( ((LA12_0 >= VAR && LA12_0 <= CONST)) )
                    	{
                    	    alt12 = 1;
                    	}
                    	else if ( (LA12_0 == FUNCTION) )
                    	{
                    	    alt12 = 2;
                    	}
                    	else 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    NoViableAltException nvae_d12s0 =
                    	        new NoViableAltException("474:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )", 12, 0, input);
                    	
                    	    throw nvae_d12s0;
                    	}
                    	switch (alt12) 
                    	{
                    	    case 1 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:474:5: variableDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_variableDefinition_in_typeBlockEntry1071);
                    	        	variableDefinition31 = variableDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDefinition31.Tree);
                    	        	if ( backtracking == 0 ) 
                    	        	{
                    	        	   buffer.Append(";"); 
                    	        	}
                    	        
                    	        }
                    	        break;
                    	    case 2 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:475:5: methodDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_methodDefinition_in_typeBlockEntry1081);
                    	        	methodDefinition32 = methodDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, methodDefinition32.Tree);
                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:477:4: importDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_importDefinition_in_typeBlockEntry1091);
                    	importDefinition33 = importDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition33.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:478:4: as2IncludeDirective
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_as2IncludeDirective_in_typeBlockEntry1098);
                    	as2IncludeDirective34 = as2IncludeDirective();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, as2IncludeDirective34.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:479:4: annotations
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_annotations_in_typeBlockEntry1105);
                    	annotations35 = annotations();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations35.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:480:4: c= comments
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(NewLine + tab + NewLine + tab); 
                    	}
                    	PushFollow(FOLLOW_comments_in_typeBlockEntry1114);
                    	c = comments();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   insertComment(c); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 16, typeBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlockEntry

    public class as2IncludeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2IncludeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:483:1: as2IncludeDirective : INCLUDE_DIRECTIVE st= STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) ;
    public as2IncludeDirective_return as2IncludeDirective() // throws RecognitionException [1]
    {   
        as2IncludeDirective_return retval = new as2IncludeDirective_return();
        retval.start = input.LT(1);
        int as2IncludeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken st = null;
        CommonToken INCLUDE_DIRECTIVE36 = null;
        
        CommonTree st_tree=null;
        CommonTree INCLUDE_DIRECTIVE36_tree=null;
        RewriteRuleTokenStream stream_INCLUDE_DIRECTIVE = new RewriteRuleTokenStream(adaptor,"token INCLUDE_DIRECTIVE");
        RewriteRuleTokenStream stream_STRING_LITERAL = new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 17) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:484:4: ( INCLUDE_DIRECTIVE st= STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:484:4: INCLUDE_DIRECTIVE st= STRING_LITERAL
            {
            	INCLUDE_DIRECTIVE36 = (CommonToken)input.LT(1);
            	Match(input,INCLUDE_DIRECTIVE,FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1127); if (failed) return retval;
            	if ( backtracking==0 ) stream_INCLUDE_DIRECTIVE.Add(INCLUDE_DIRECTIVE36);

            	st = (CommonToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_as2IncludeDirective1131); if (failed) return retval;
            	if ( backtracking==0 ) stream_STRING_LITERAL.Add(st);

            	if ( backtracking == 0 ) 
            	{
            	  	buffer.Append("#include " + ((CommonToken)st).Text); 
            	}
            	
            	// AST REWRITE
            	// elements:          STRING_LITERAL, INCLUDE_DIRECTIVE
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 485:3: -> ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:485:6: ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_INCLUDE_DIRECTIVE.Next(), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_STRING_LITERAL.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 17, as2IncludeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2IncludeDirective

    public class includeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start includeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:488:1: includeDirective : 'include' STRING_LITERAL semi ;
    public includeDirective_return includeDirective() // throws RecognitionException [1]
    {   
        includeDirective_return retval = new includeDirective_return();
        retval.start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken string_literal37 = null;
        CommonToken STRING_LITERAL38 = null;
        semi_return semi39 = null;
        
        
        CommonTree string_literal37_tree=null;
        CommonTree STRING_LITERAL38_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 18) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:489:4: ( 'include' STRING_LITERAL semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:489:4: 'include' STRING_LITERAL semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal37 = (CommonToken)input.LT(1);
            	Match(input,175,FOLLOW_175_in_includeDirective1154); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal37_tree = (CommonTree)adaptor.Create(string_literal37);
            	adaptor.AddChild(root_0, string_literal37_tree);
            	}
            	STRING_LITERAL38 = (CommonToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_includeDirective1156); if (failed) return retval;
            	if ( backtracking==0 ) {
            	STRING_LITERAL38_tree = (CommonTree)adaptor.Create(STRING_LITERAL38);
            	adaptor.AddChild(root_0, STRING_LITERAL38_tree);
            	}
            	PushFollow(FOLLOW_semi_in_includeDirective1158);
            	semi39 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi39.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 18, includeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end includeDirective

    public class interfaceMethodDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceMethodDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:492:1: interfaceMethodDefinition[CommonTree mods] : FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( semi ) -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ) ;
    public interfaceMethodDefinition_return interfaceMethodDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        interfaceMethodDefinition_return retval = new interfaceMethodDefinition_return();
        retval.start = input.LT(1);
        int interfaceMethodDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken FUNCTION40 = null;
        optionalAccessorRole_return r = null;

        ident_return ide = null;

        typeExpression_return type_exp = null;

        parameterDeclarationList_return parameterDeclarationList41 = null;

        semi_return semi42 = null;
        
        
        CommonTree FUNCTION40_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor,"rule optionalAccessorRole");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 19) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:493:4: ( FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( semi ) -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:493:4: FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( semi )
            {
            	FUNCTION40 = (CommonToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_interfaceMethodDefinition1170); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION40);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("function "); 
            	}
            	PushFollow(FOLLOW_optionalAccessorRole_in_interfaceMethodDefinition1182);
            	r = optionalAccessorRole();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_optionalAccessorRole.Add(r.Tree);
            	PushFollow(FOLLOW_ident_in_interfaceMethodDefinition1188);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)ide.Tree).Text); 
            	}
            	PushFollow(FOLLOW_parameterDeclarationList_in_interfaceMethodDefinition1198);
            	parameterDeclarationList41 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList41.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:497:11: (type_exp= typeExpression )?
            	int alt14 = 2;
            	int LA14_0 = input.LA(1);
            	
            	if ( (LA14_0 == COLON) )
            	{
            	    alt14 = 1;
            	}
            	switch (alt14) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: type_exp= typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_interfaceMethodDefinition1204);
            	        	type_exp = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(type_exp.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  										if(options.NewlineAfterMethod) buffer.Append(NewLine + tab);
            	  										buffer.Append("{");
            	  										CurrentTab++;
            	  									
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:502:3: ( semi )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:502:4: semi
            	{
            		PushFollow(FOLLOW_semi_in_interfaceMethodDefinition1212);
            		semi42 = semi();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_semi.Add(semi42.Tree);
            	
            	}

            	
            	// AST REWRITE
            	// elements:          optionalAccessorRole, typeExpression, parameterDeclarationList, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 503:3: -> ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:503:6: ^( IMETHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IMETHOD_DEF, "IMETHOD_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:506:7: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 19, interfaceMethodDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceMethodDefinition

    public class methodDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start methodDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:511:1: methodDefinition[CommonTree mods] : FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( (c1= comments )? block semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? block ) ;
    public methodDefinition_return methodDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        methodDefinition_return retval = new methodDefinition_return();
        retval.start = input.LT(1);
        int methodDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken FUNCTION43 = null;
        optionalAccessorRole_return r = null;

        ident_return ide = null;

        typeExpression_return type_exp = null;

        comments_return c1 = null;

        parameterDeclarationList_return parameterDeclarationList44 = null;

        block_return block45 = null;

        semi_return semi46 = null;
        
        
        CommonTree FUNCTION43_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor,"rule optionalAccessorRole");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_comments = new RewriteRuleSubtreeStream(adaptor,"rule comments");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 20) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:512:4: ( FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( (c1= comments )? block semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? block ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:512:4: FUNCTION r= optionalAccessorRole ide= ident parameterDeclarationList (type_exp= typeExpression )? ( (c1= comments )? block semi )
            {
            	if ( backtracking == 0 ) 
            	{
            	   
            	  			if(mods.ChildCount > 0)
            	  				buffer.Append(fromModifiers(mods) + " ");
            	  		
            	}
            	FUNCTION43 = (CommonToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_methodDefinition1283); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION43);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("function "); 
            	}
            	PushFollow(FOLLOW_optionalAccessorRole_in_methodDefinition1295);
            	r = optionalAccessorRole();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_optionalAccessorRole.Add(r.Tree);
            	PushFollow(FOLLOW_ident_in_methodDefinition1301);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)ide.Tree).Text); 
            	}
            	PushFollow(FOLLOW_parameterDeclarationList_in_methodDefinition1319);
            	parameterDeclarationList44 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList44.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:522:11: (type_exp= typeExpression )?
            	int alt15 = 2;
            	int LA15_0 = input.LA(1);
            	
            	if ( (LA15_0 == COLON) )
            	{
            	    alt15 = 1;
            	}
            	switch (alt15) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: type_exp= typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_methodDefinition1325);
            	        	type_exp = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(type_exp.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  										if(options.NewlineAfterMethod) buffer.Append(NewLine + tab);
            	  										buffer.Append("{");
            	  										CurrentTab++;
            	  									
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:528:3: ( (c1= comments )? block semi )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:529:4: (c1= comments )? block semi
            	{
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:529:6: (c1= comments )?
            		int alt16 = 2;
            		int LA16_0 = input.LA(1);
            		
            		if ( ((LA16_0 >= SL_COMMENT && LA16_0 <= ML_COMMENT)) )
            		{
            		    alt16 = 1;
            		}
            		switch (alt16) 
            		{
            		    case 1 :
            		        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: c1= comments
            		        {
            		        	PushFollow(FOLLOW_comments_in_methodDefinition1348);
            		        	c1 = comments();
            		        	followingStackPointer_--;
            		        	if (failed) return retval;
            		        	if ( backtracking==0 ) stream_comments.Add(c1.Tree);
            		        
            		        }
            		        break;
            		
            		}

            		if ( backtracking == 0 ) 
            		{
            		   insertComment(c1, true, false); 
            		}
            		PushFollow(FOLLOW_block_in_methodDefinition1358);
            		block45 = block();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_block.Add(block45.Tree);
            		PushFollow(FOLLOW_semi_in_methodDefinition1360);
            		semi46 = semi();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_semi.Add(semi46.Tree);
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  										CurrentTab--;
            	  										buffer.Append(NewLine + tab);
            	  										buffer.Append("}");
            	  										buffer.Append(NewLine + tab);
            	  									
            	}
            	
            	// AST REWRITE
            	// elements:          block, parameterDeclarationList, ident, typeExpression, optionalAccessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 538:3: -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? block )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:538:6: ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? block )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:541:7: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 20, methodDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end methodDefinition

    public class optionalAccessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start optionalAccessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:546:1: optionalAccessorRole : ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) ;
    public optionalAccessorRole_return optionalAccessorRole() // throws RecognitionException [1]
    {   
        optionalAccessorRole_return retval = new optionalAccessorRole_return();
        retval.start = input.LT(1);
        int optionalAccessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        accessorRole_return accessorRole47 = null;
        
        
        RewriteRuleSubtreeStream stream_accessorRole = new RewriteRuleSubtreeStream(adaptor,"rule accessorRole");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 21) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:547:4: ( ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:547:4: ( accessorRole )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:547:4: ( accessorRole )?
            	int alt17 = 2;
            	int LA17_0 = input.LA(1);
            	
            	if ( (LA17_0 == GET) )
            	{
            	    int LA17_1 = input.LA(2);
            	    
            	    if ( ((LA17_1 >= GET && LA17_1 <= SET) || LA17_1 == IDENT || LA17_1 == DYNAMIC || (LA17_1 >= IS && LA17_1 <= AS) || (LA17_1 >= USE && LA17_1 <= XML)) )
            	    {
            	        alt17 = 1;
            	    }
            	}
            	else if ( (LA17_0 == SET) )
            	{
            	    int LA17_2 = input.LA(2);
            	    
            	    if ( ((LA17_2 >= GET && LA17_2 <= SET) || LA17_2 == IDENT || LA17_2 == DYNAMIC || (LA17_2 >= IS && LA17_2 <= AS) || (LA17_2 >= USE && LA17_2 <= XML)) )
            	    {
            	        alt17 = 1;
            	    }
            	}
            	switch (alt17) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: accessorRole
            	        {
            	        	PushFollow(FOLLOW_accessorRole_in_optionalAccessorRole1447);
            	        	accessorRole47 = accessorRole();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_accessorRole.Add(accessorRole47.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          accessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 548:3: -> ^( ACCESSOR_ROLE ( accessorRole )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:548:6: ^( ACCESSOR_ROLE ( accessorRole )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ACCESSOR_ROLE, "ACCESSOR_ROLE"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:548:22: ( accessorRole )?
            	    if ( stream_accessorRole.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_accessorRole.Next());
            	    
            	    }
            	    stream_accessorRole.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 21, optionalAccessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end optionalAccessorRole

    public class accessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start accessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:551:1: accessorRole : ( GET | SET );
    public accessorRole_return accessorRole() // throws RecognitionException [1]
    {   
        accessorRole_return retval = new accessorRole_return();
        retval.start = input.LT(1);
        int accessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken GET48 = null;
        CommonToken SET49 = null;
        
        CommonTree GET48_tree=null;
        CommonTree SET49_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 22) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:552:4: ( GET | SET )
            int alt18 = 2;
            int LA18_0 = input.LA(1);
            
            if ( (LA18_0 == GET) )
            {
                alt18 = 1;
            }
            else if ( (LA18_0 == SET) )
            {
                alt18 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d18s0 =
                    new NoViableAltException("551:1: accessorRole : ( GET | SET );", 18, 0, input);
            
                throw nvae_d18s0;
            }
            switch (alt18) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:552:4: GET
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GET48 = (CommonToken)input.LT(1);
                    	Match(input,GET,FOLLOW_GET_in_accessorRole1470); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GET48_tree = (CommonTree)adaptor.Create(GET48);
                    	adaptor.AddChild(root_0, GET48_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("get "); 
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:553:4: SET
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SET49 = (CommonToken)input.LT(1);
                    	Match(input,SET,FOLLOW_SET_in_accessorRole1478); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	SET49_tree = (CommonTree)adaptor.Create(SET49);
                    	adaptor.AddChild(root_0, SET49_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("set "); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 22, accessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end accessorRole

    public class variableDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:556:1: variableDefinition[CommonTree mods] : decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) ;
    public variableDefinition_return variableDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        variableDefinition_return retval = new variableDefinition_return();
        retval.start = input.LT(1);
        int variableDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA51 = null;
        varOrConst_return decl = null;

        variableDeclarator_return variableDeclarator50 = null;

        variableDeclarator_return variableDeclarator52 = null;

        semi_return semi53 = null;
        
        
        CommonTree COMMA51_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_varOrConst = new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
        RewriteRuleSubtreeStream stream_variableDeclarator = new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 23) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:561:4: (decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:561:4: decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi
            {
            	if ( backtracking == 0 ) 
            	{
            	   
            	  			if(mods.ChildCount > 0) buffer.Append(fromModifiers(mods) + " ");
            	  		
            	}
            	PushFollow(FOLLOW_varOrConst_in_variableDefinition1509);
            	decl = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_varOrConst.Add(decl.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)decl.Tree).Text + " "); 
            	}
            	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1518);
            	variableDeclarator50 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator50.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:566:3: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt19 = 2;
            	    int LA19_0 = input.LA(1);
            	    
            	    if ( (LA19_0 == COMMA) )
            	    {
            	        alt19 = 1;
            	    }
            	    
            	
            	    switch (alt19) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:567:10: COMMA variableDeclarator
            			    {
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	  	buffer.Append(";"); 
            			    	}
            			    	COMMA51 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_variableDefinition1538); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA51);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  										buffer.Append(NewLine + tab); 
            			    	  										if(mods.ChildCount > 0) buffer.Append(fromModifiers(mods) + " ");
            			    	  										buffer.Append(((CommonTree)decl.Tree).Text + " ");
            			    	  									
            			    	}
            			    	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1549);
            			    	variableDeclarator52 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator52.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop19;
            	    }
            	} while (true);
            	
            	loop19:
            		;	// Stops C# compiler whinging that label 'loop19' has no statements

            	PushFollow(FOLLOW_semi_in_variableDefinition1558);
            	semi53 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi53.Tree);
            	
            	// AST REWRITE
            	// elements:          variableDeclarator, decl
            	// token labels:      
            	// rule labels:       decl, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_decl = new RewriteRuleSubtreeStream(adaptor, "token decl", (decl!=null ? decl.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 576:3: -> ^( VAR_DEF $decl ( variableDeclarator )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:576:6: ^( VAR_DEF $decl ( variableDeclarator )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_decl.Next());
            	    if ( !(stream_variableDeclarator.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_variableDeclarator.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_variableDeclarator.Next());
            	    
            	    }
            	    stream_variableDeclarator.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 23, variableDefinition_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end variableDefinition

    public class varOrConst_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start varOrConst
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:579:1: varOrConst : ( VAR | CONST );
    public varOrConst_return varOrConst() // throws RecognitionException [1]
    {   
        varOrConst_return retval = new varOrConst_return();
        retval.start = input.LT(1);
        int varOrConst_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set54 = null;
        
        CommonTree set54_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 24) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:580:4: ( VAR | CONST )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set54 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= VAR && input.LA(1) <= CONST) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set54));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_varOrConst0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 24, varOrConst_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end varOrConst

    public class variableDeclarator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDeclarator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:583:1: variableDeclarator : ide= ident (type_exp= typeExpression )? ( variableInitializer )? ;
    public variableDeclarator_return variableDeclarator() // throws RecognitionException [1]
    {   
        variableDeclarator_return retval = new variableDeclarator_return();
        retval.start = input.LT(1);
        int variableDeclarator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ide = null;

        typeExpression_return type_exp = null;

        variableInitializer_return variableInitializer55 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 25) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:584:4: (ide= ident (type_exp= typeExpression )? ( variableInitializer )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:584:4: ide= ident (type_exp= typeExpression )? ( variableInitializer )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_ident_in_variableDeclarator1602);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(ide.Tree, root_0);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)ide.Tree).Text);  
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:585:11: (type_exp= typeExpression )?
            	int alt20 = 2;
            	int LA20_0 = input.LA(1);
            	
            	if ( (LA20_0 == COLON) )
            	{
            	    alt20 = 1;
            	}
            	switch (alt20) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: type_exp= typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_variableDeclarator1615);
            	        	type_exp = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, type_exp.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  									
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:587:3: ( variableInitializer )?
            	int alt21 = 2;
            	int LA21_0 = input.LA(1);
            	
            	if ( (LA21_0 == ASSIGN) )
            	{
            	    alt21 = 1;
            	}
            	switch (alt21) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: variableInitializer
            	        {
            	        	PushFollow(FOLLOW_variableInitializer_in_variableDeclarator1622);
            	        	variableInitializer55 = variableInitializer();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableInitializer55.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 25, variableDeclarator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableDeclarator

    public class declaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:590:1: declaration : decl= varOrConst variableDeclarator declarationTail ;
    public declaration_return declaration() // throws RecognitionException [1]
    {   
        declaration_return retval = new declaration_return();
        retval.start = input.LT(1);
        int declaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        varOrConst_return decl = null;

        variableDeclarator_return variableDeclarator56 = null;

        declarationTail_return declarationTail57 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 26) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:591:4: (decl= varOrConst variableDeclarator declarationTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:591:4: decl= varOrConst variableDeclarator declarationTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_varOrConst_in_declaration1637);
            	decl = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(decl.Tree, root_0);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)decl.Tree).Text + " "); 
            	}
            	PushFollow(FOLLOW_variableDeclarator_in_declaration1647);
            	variableDeclarator56 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator56.Tree);
            	PushFollow(FOLLOW_declarationTail_in_declaration1651);
            	declarationTail57 = declarationTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationTail57.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 26, declaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end declaration

    public class declarationTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:596:1: declarationTail : ( COMMA variableDeclarator )* ;
    public declarationTail_return declarationTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationTail_return retval = new declarationTail_return();
        retval.start = input.LT(1);
        int declarationTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA58 = null;
        variableDeclarator_return variableDeclarator59 = null;
        
        
        CommonTree COMMA58_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 27) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:601:4: ( ( COMMA variableDeclarator )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:601:4: ( COMMA variableDeclarator )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:601:4: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt22 = 2;
            	    int LA22_0 = input.LA(1);
            	    
            	    if ( (LA22_0 == COMMA) )
            	    {
            	        alt22 = 1;
            	    }
            	    
            	
            	    switch (alt22) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:602:4: COMMA variableDeclarator
            			    {
            			    	COMMA58 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_declarationTail1677); if (failed) return retval;
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            			    	}
            			    	PushFollow(FOLLOW_variableDeclarator_in_declarationTail1685);
            			    	variableDeclarator59 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator59.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop22;
            	    }
            	} while (true);
            	
            	loop22:
            		;	// Stops C# compiler whinging that label 'loop22' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 27, declarationTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationTail

    public class variableInitializer_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableInitializer
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:607:1: variableInitializer : ASSIGN assignmentExpression ;
    public variableInitializer_return variableInitializer() // throws RecognitionException [1]
    {   
        variableInitializer_return retval = new variableInitializer_return();
        retval.start = input.LT(1);
        int variableInitializer_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken ASSIGN60 = null;
        assignmentExpression_return assignmentExpression61 = null;
        
        
        CommonTree ASSIGN60_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 28) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:608:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:608:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN60 = (CommonToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableInitializer1701); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN60_tree = (CommonTree)adaptor.Create(ASSIGN60);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN60_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   
            	  								if(options.SpaceBetweenAssign) buffer.Append(" ");
            	  								buffer.Append("=");
            	  								if(options.SpaceBetweenAssign) buffer.Append(" ");
            	  							
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_variableInitializer1711);
            	assignmentExpression61 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression61.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 28, variableInitializer_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableInitializer

    public class parameterDeclarationList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclarationList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:618:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) ;
    public parameterDeclarationList_return parameterDeclarationList() // throws RecognitionException [1]
    {   
        parameterDeclarationList_return retval = new parameterDeclarationList_return();
        retval.start = input.LT(1);
        int parameterDeclarationList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LPAREN62 = null;
        CommonToken COMMA64 = null;
        CommonToken RPAREN66 = null;
        parameterDeclaration_return parameterDeclaration63 = null;

        parameterDeclaration_return parameterDeclaration65 = null;
        
        
        CommonTree LPAREN62_tree=null;
        CommonTree COMMA64_tree=null;
        CommonTree RPAREN66_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_parameterDeclaration = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclaration");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 29) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:619:4: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:619:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
            {
            	LPAREN62 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_parameterDeclarationList1724); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN62);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBeforeMethodDef ? " (" : "("); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:620:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
            	int alt24 = 2;
            	int LA24_0 = input.LA(1);
            	
            	if ( ((LA24_0 >= GET && LA24_0 <= SET) || LA24_0 == CONST || LA24_0 == IDENT || LA24_0 == DYNAMIC || (LA24_0 >= IS && LA24_0 <= AS) || (LA24_0 >= USE && LA24_0 <= XML)) )
            	{
            	    alt24 = 1;
            	}
            	switch (alt24) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:620:5: parameterDeclaration ( COMMA parameterDeclaration )*
            	        {
            	        	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1734);
            	        	parameterDeclaration63 = parameterDeclaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration63.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:621:4: ( COMMA parameterDeclaration )*
            	        	do 
            	        	{
            	        	    int alt23 = 2;
            	        	    int LA23_0 = input.LA(1);
            	        	    
            	        	    if ( (LA23_0 == COMMA) )
            	        	    {
            	        	        alt23 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt23) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:622:5: COMMA parameterDeclaration
            	        			    {
            	        			    	COMMA64 = (CommonToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_parameterDeclarationList1745); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA64);

            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	   buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            	        			    	}
            	        			    	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1754);
            	        			    	parameterDeclaration65 = parameterDeclaration();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration65.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop23;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop23:
            	        		;	// Stops C# compiler whinging that label 'loop23' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN66 = (CommonToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_parameterDeclarationList1769); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN66);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(")"); 
            	}
            	
            	// AST REWRITE
            	// elements:          parameterDeclaration
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 627:3: -> ^( PARAMS ( parameterDeclaration )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:627:6: ^( PARAMS ( parameterDeclaration )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAMS, "PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:627:15: ( parameterDeclaration )*
            	    while ( stream_parameterDeclaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDeclaration.Next());
            	    
            	    }
            	    stream_parameterDeclaration.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 29, parameterDeclarationList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclarationList

    public class parameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:631:1: parameterDeclaration : basicParameterDeclaration ;
    public parameterDeclaration_return parameterDeclaration() // throws RecognitionException [1]
    {   
        parameterDeclaration_return retval = new parameterDeclaration_return();
        retval.start = input.LT(1);
        int parameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        basicParameterDeclaration_return basicParameterDeclaration67 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 30) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:632:4: ( basicParameterDeclaration )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:632:4: basicParameterDeclaration
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_basicParameterDeclaration_in_parameterDeclaration1796);
            	basicParameterDeclaration67 = basicParameterDeclaration();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, basicParameterDeclaration67.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 30, parameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclaration

    public class basicParameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start basicParameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:635:1: basicParameterDeclaration : ( CONST )? ide= ident (type_exp= typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
    public basicParameterDeclaration_return basicParameterDeclaration() // throws RecognitionException [1]
    {   
        basicParameterDeclaration_return retval = new basicParameterDeclaration_return();
        retval.start = input.LT(1);
        int basicParameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken CONST68 = null;
        ident_return ide = null;

        typeExpression_return type_exp = null;

        parameterDefault_return parameterDefault69 = null;
        
        
        CommonTree CONST68_tree=null;
        RewriteRuleTokenStream stream_CONST = new RewriteRuleTokenStream(adaptor,"token CONST");
        RewriteRuleSubtreeStream stream_parameterDefault = new RewriteRuleSubtreeStream(adaptor,"rule parameterDefault");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 31) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:636:4: ( ( CONST )? ide= ident (type_exp= typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:636:4: ( CONST )? ide= ident (type_exp= typeExpression )? ( parameterDefault )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:636:4: ( CONST )?
            	int alt25 = 2;
            	int LA25_0 = input.LA(1);
            	
            	if ( (LA25_0 == CONST) )
            	{
            	    alt25 = 1;
            	}
            	switch (alt25) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: CONST
            	        {
            	        	CONST68 = (CommonToken)input.LT(1);
            	        	Match(input,CONST,FOLLOW_CONST_in_basicParameterDeclaration1807); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_CONST.Add(CONST68);

            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_ident_in_basicParameterDeclaration1815);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)ide.Tree).Text); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:638:11: (type_exp= typeExpression )?
            	int alt26 = 2;
            	int LA26_0 = input.LA(1);
            	
            	if ( (LA26_0 == COLON) )
            	{
            	    alt26 = 1;
            	}
            	switch (alt26) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: type_exp= typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_basicParameterDeclaration1827);
            	        	type_exp = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(type_exp.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	    
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:639:3: ( parameterDefault )?
            	int alt27 = 2;
            	int LA27_0 = input.LA(1);
            	
            	if ( (LA27_0 == ASSIGN) )
            	{
            	    alt27 = 1;
            	}
            	switch (alt27) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: parameterDefault
            	        {
            	        	PushFollow(FOLLOW_parameterDefault_in_basicParameterDeclaration1834);
            	        	parameterDefault69 = parameterDefault();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDefault.Add(parameterDefault69.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, CONST, parameterDefault, typeExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 640:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:640:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:640:14: ( CONST )?
            	    if ( stream_CONST.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_CONST.Next());
            	    
            	    }
            	    stream_CONST.Reset();
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:640:27: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:640:43: ( parameterDefault )?
            	    if ( stream_parameterDefault.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDefault.Next());
            	    
            	    }
            	    stream_parameterDefault.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 31, basicParameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end basicParameterDeclaration

    public class parameterDefault_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDefault
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:643:1: parameterDefault : ASSIGN assignmentExpression ;
    public parameterDefault_return parameterDefault() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        parameterDefault_return retval = new parameterDefault_return();
        retval.start = input.LT(1);
        int parameterDefault_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken ASSIGN70 = null;
        assignmentExpression_return assignmentExpression71 = null;
        
        
        CommonTree ASSIGN70_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 32) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:649:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:649:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN70 = (CommonToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_parameterDefault1878); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN70_tree = (CommonTree)adaptor.Create(ASSIGN70);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN70_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_parameterDefault1881);
            	assignmentExpression71 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression71.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 32, parameterDefault_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end parameterDefault

    public class block_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start block
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:652:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) ;
    public block_return block() // throws RecognitionException [1]
    {   
        block_return retval = new block_return();
        retval.start = input.LT(1);
        int block_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LCURLY72 = null;
        CommonToken RCURLY74 = null;
        blockEntry_return blockEntry73 = null;
        
        
        CommonTree LCURLY72_tree=null;
        CommonTree RCURLY74_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_blockEntry = new RewriteRuleSubtreeStream(adaptor,"rule blockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 33) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:653:4: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:653:4: LCURLY ( blockEntry )* RCURLY
            {
            	LCURLY72 = (CommonToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_block1892); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY72);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:654:3: ( blockEntry )*
            	do 
            	{
            	    int alt28 = 2;
            	    int LA28_0 = input.LA(1);
            	    
            	    if ( (LA28_0 == SEMI || LA28_0 == LCURLY || (LA28_0 >= STRING_LITERAL && LA28_0 <= CONST) || LA28_0 == LPAREN || LA28_0 == IF || (LA28_0 >= RETURN && LA28_0 <= SWITCH) || LA28_0 == FOR || (LA28_0 >= WHILE && LA28_0 <= VOID) || LA28_0 == IDENT || LA28_0 == LBRACK || LA28_0 == DYNAMIC || (LA28_0 >= IS && LA28_0 <= AS) || (LA28_0 >= PLUS && LA28_0 <= MINUS) || (LA28_0 >= INC && LA28_0 <= XML) || (LA28_0 >= 176 && LA28_0 <= 177)) )
            	    {
            	        alt28 = 1;
            	    }
            	    
            	
            	    switch (alt28) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: blockEntry
            			    {
            			    	PushFollow(FOLLOW_blockEntry_in_block1896);
            			    	blockEntry73 = blockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_blockEntry.Add(blockEntry73.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop28;
            	    }
            	} while (true);
            	
            	loop28:
            		;	// Stops C# compiler whinging that label 'loop28' has no statements

            	RCURLY74 = (CommonToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_block1902); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY74);

            	
            	// AST REWRITE
            	// elements:          blockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 656:3: -> ^( BLOCK ( blockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:656:6: ^( BLOCK ( blockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:656:14: ( blockEntry )*
            	    while ( stream_blockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_blockEntry.Next());
            	    
            	    }
            	    stream_blockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 33, block_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end block

    public class blockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start blockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:659:1: blockEntry : statement ;
    public blockEntry_return blockEntry() // throws RecognitionException [1]
    {   
        blockEntry_return retval = new blockEntry_return();
        retval.start = input.LT(1);
        int blockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement75 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 34) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:660:4: ( statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:660:4: statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(NewLine + tab); 
            	}
            	PushFollow(FOLLOW_statement_in_blockEntry1926);
            	statement75 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement75.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 34, blockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end blockEntry

    public class condition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start condition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:663:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
    public condition_return condition() // throws RecognitionException [1]
    {   
        condition_return retval = new condition_return();
        retval.start = input.LT(1);
        int condition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LPAREN76 = null;
        CommonToken RPAREN78 = null;
        expression_return expression77 = null;
        
        
        CommonTree LPAREN76_tree=null;
        CommonTree RPAREN78_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 35) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:664:4: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:664:4: LPAREN expression RPAREN
            {
            	LPAREN76 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_condition1937); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN76);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBeforeMethodDef ? " (" : "("); 
            	}
            	PushFollow(FOLLOW_expression_in_condition1945);
            	expression77 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expression.Add(expression77.Tree);
            	RPAREN78 = (CommonToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_condition1950); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN78);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(")"); 
            	}
            	
            	// AST REWRITE
            	// elements:          expression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 667:3: -> ^( CONDITION expression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:667:6: ^( CONDITION expression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CONDITION, "CONDITION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 35, condition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end condition

    public class statement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start statement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );
    public statement_return statement() // throws RecognitionException [1]
    {   
        statement_return retval = new statement_return();
        retval.start = input.LT(1);
        int statement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken SEMI93 = null;
        comments_return c = null;

        block_return block79 = null;

        declarationStatement_return declarationStatement80 = null;

        expressionStatement_return expressionStatement81 = null;

        ifStatement_return ifStatement82 = null;

        forStatement_return forStatement83 = null;

        whileStatement_return whileStatement84 = null;

        doWhileStatement_return doWhileStatement85 = null;

        withStatement_return withStatement86 = null;

        switchStatement_return switchStatement87 = null;

        breakStatement_return breakStatement88 = null;

        continueStatement_return continueStatement89 = null;

        returnStatement_return returnStatement90 = null;

        throwStatement_return throwStatement91 = null;

        tryStatement_return tryStatement92 = null;
        
        
        CommonTree SEMI93_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 36) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:673:4: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments )
            int alt29 = 16;
            switch ( input.LA(1) ) 
            {
            case LCURLY:
            	{
                int LA29_1 = input.LA(2);
                
                if ( (LA29_1 == LCURLY) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( ((LA29_1 >= VAR && LA29_1 <= CONST)) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == INC) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == DEC) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == MINUS) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == PLUS) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == DELETE) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == VOID) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == TYPEOF) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == LNOT) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == BNOT) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == UNDEFINED) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( ((LA29_1 >= HEX_LITERAL && LA29_1 <= FLOAT_LITERAL)) )
                {
                    int LA29_56 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s56 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 56, input);
                    
                        throw nvae_d29s56;
                    }
                }
                else if ( (LA29_1 == STRING_LITERAL) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == TRUE) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == FALSE) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == NULL) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == LBRACK) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == FUNCTION) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == NEW) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == LPAREN) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == IDENT) )
                {
                    int LA29_65 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s65 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 65, input);
                    
                        throw nvae_d29s65;
                    }
                }
                else if ( (LA29_1 == USE) )
                {
                    int LA29_66 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s66 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 66, input);
                    
                        throw nvae_d29s66;
                    }
                }
                else if ( (LA29_1 == XML) )
                {
                    int LA29_67 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s67 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 67, input);
                    
                        throw nvae_d29s67;
                    }
                }
                else if ( (LA29_1 == DYNAMIC) )
                {
                    int LA29_68 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s68 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 68, input);
                    
                        throw nvae_d29s68;
                    }
                }
                else if ( (LA29_1 == IS) )
                {
                    int LA29_69 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s69 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 69, input);
                    
                        throw nvae_d29s69;
                    }
                }
                else if ( (LA29_1 == AS) )
                {
                    int LA29_70 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s70 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 70, input);
                    
                        throw nvae_d29s70;
                    }
                }
                else if ( (LA29_1 == GET) )
                {
                    int LA29_71 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s71 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 71, input);
                    
                        throw nvae_d29s71;
                    }
                }
                else if ( (LA29_1 == SET) )
                {
                    int LA29_72 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s72 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 72, input);
                    
                        throw nvae_d29s72;
                    }
                }
                else if ( (LA29_1 == IF) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == FOR) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == WHILE) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == DO) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == WITH) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == SWITCH) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == BREAK) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == CONTINUE) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == RETURN) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == 176) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == 177) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == SEMI) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == SL_COMMENT) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == ML_COMMENT) && (synpred37()) )
                {
                    alt29 = 1;
                }
                else if ( (LA29_1 == RCURLY) )
                {
                    int LA29_87 = input.LA(3);
                    
                    if ( (synpred37()) )
                    {
                        alt29 = 1;
                    }
                    else if ( (synpred39()) )
                    {
                        alt29 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d29s87 =
                            new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 87, input);
                    
                        throw nvae_d29s87;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d29s1 =
                        new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 1, input);
                
                    throw nvae_d29s1;
                }
                }
                break;
            case VAR:
            case CONST:
            	{
                alt29 = 2;
                }
                break;
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case LPAREN:
            case VOID:
            case IDENT:
            case LBRACK:
            case DYNAMIC:
            case IS:
            case AS:
            case PLUS:
            case MINUS:
            case INC:
            case DEC:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case USE:
            case XML:
            	{
                alt29 = 3;
                }
                break;
            case IF:
            	{
                alt29 = 4;
                }
                break;
            case FOR:
            	{
                alt29 = 5;
                }
                break;
            case WHILE:
            	{
                alt29 = 6;
                }
                break;
            case DO:
            	{
                alt29 = 7;
                }
                break;
            case WITH:
            	{
                alt29 = 8;
                }
                break;
            case SWITCH:
            	{
                alt29 = 9;
                }
                break;
            case BREAK:
            	{
                alt29 = 10;
                }
                break;
            case CONTINUE:
            	{
                alt29 = 11;
                }
                break;
            case RETURN:
            	{
                alt29 = 12;
                }
                break;
            case 176:
            	{
                alt29 = 13;
                }
                break;
            case 177:
            	{
                alt29 = 14;
                }
                break;
            case SEMI:
            	{
                alt29 = 15;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt29 = 16;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d29s0 =
            	        new NoViableAltException("672:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | SEMI | c= comments );", 29, 0, input);
            
            	    throw nvae_d29s0;
            }
            
            switch (alt29) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:673:4: ( LCURLY )=> block
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_block_in_statement1982);
                    	block79 = block();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, block79.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:674:4: declarationStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declarationStatement_in_statement1987);
                    	declarationStatement80 = declarationStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationStatement80.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:675:4: expressionStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_expressionStatement_in_statement1996);
                    	expressionStatement81 = expressionStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionStatement81.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:676:4: ifStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ifStatement_in_statement2006);
                    	ifStatement82 = ifStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ifStatement82.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:677:4: forStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_forStatement_in_statement2011);
                    	forStatement83 = forStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, forStatement83.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:678:4: whileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_whileStatement_in_statement2016);
                    	whileStatement84 = whileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, whileStatement84.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:679:4: doWhileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_doWhileStatement_in_statement2021);
                    	doWhileStatement85 = doWhileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, doWhileStatement85.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:680:4: withStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_withStatement_in_statement2026);
                    	withStatement86 = withStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, withStatement86.Tree);
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:681:4: switchStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_switchStatement_in_statement2031);
                    	switchStatement87 = switchStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, switchStatement87.Tree);
                    
                    }
                    break;
                case 10 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:682:4: breakStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_breakStatement_in_statement2036);
                    	breakStatement88 = breakStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, breakStatement88.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 11 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:683:4: continueStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_continueStatement_in_statement2046);
                    	continueStatement89 = continueStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, continueStatement89.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 12 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:684:4: returnStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_returnStatement_in_statement2055);
                    	returnStatement90 = returnStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, returnStatement90.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 13 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:685:4: throwStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_throwStatement_in_statement2065);
                    	throwStatement91 = throwStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, throwStatement91.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(";"); 
                    	}
                    
                    }
                    break;
                case 14 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:686:4: tryStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_tryStatement_in_statement2075);
                    	tryStatement92 = tryStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, tryStatement92.Tree);
                    
                    }
                    break;
                case 15 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:687:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI93 = (CommonToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_statement2080); if (failed) return retval;
                    
                    }
                    break;
                case 16 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:688:4: c= comments
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_comments_in_statement2088);
                    	c = comments();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   insertComment(c); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 36, statement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end statement

    public class declarationStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:691:1: declarationStatement : declaration semi ;
    public declarationStatement_return declarationStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationStatement_return retval = new declarationStatement_return();
        retval.start = input.LT(1);
        int declarationStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration94 = null;

        semi_return semi95 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 37) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:696:4: ( declaration semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:696:4: declaration semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_declaration_in_declarationStatement2115);
            	declaration94 = declaration();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration94.Tree);
            	PushFollow(FOLLOW_semi_in_declarationStatement2120);
            	semi95 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi95.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 37, declarationStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationStatement

    public class expressionStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:700:1: expressionStatement : expressionList semi -> ^( EXPR_STMNT expressionList ) ;
    public expressionStatement_return expressionStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expressionStatement_return retval = new expressionStatement_return();
        retval.start = input.LT(1);
        int expressionStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList96 = null;

        semi_return semi97 = null;
        
        
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 38) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:705:4: ( expressionList semi -> ^( EXPR_STMNT expressionList ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:705:4: expressionList semi
            {
            	PushFollow(FOLLOW_expressionList_in_expressionStatement2141);
            	expressionList96 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expressionList.Add(expressionList96.Tree);
            	PushFollow(FOLLOW_semi_in_expressionStatement2143);
            	semi97 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi97.Tree);
            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 706:3: -> ^( EXPR_STMNT expressionList )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:706:6: ^( EXPR_STMNT expressionList )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 38, expressionStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expressionStatement

    public class ifStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ifStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:709:1: ifStatement : IF condition (c1= comments )? statement ( (c2= comments )? ( ELSE )=> elseClause )? ;
    public ifStatement_return ifStatement() // throws RecognitionException [1]
    {   
        ifStatement_return retval = new ifStatement_return();
        retval.start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IF98 = null;
        comments_return c1 = null;

        comments_return c2 = null;

        condition_return condition99 = null;

        statement_return statement100 = null;

        elseClause_return elseClause101 = null;
        
        
        CommonTree IF98_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 39) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:710:4: ( IF condition (c1= comments )? statement ( (c2= comments )? ( ELSE )=> elseClause )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:710:4: IF condition (c1= comments )? statement ( (c2= comments )? ( ELSE )=> elseClause )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IF98 = (CommonToken)input.LT(1);
            	Match(input,IF,FOLLOW_IF_in_ifStatement2165); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IF98_tree = (CommonTree)adaptor.Create(IF98);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IF98_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("if");
            	}
            	PushFollow(FOLLOW_condition_in_ifStatement2177);
            	condition99 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition99.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	}
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									buffer.Append( (options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  									CurrentTab++;
            	  									int next_test = input.LA(1);
            	  									if(next_test != ASLexer.LCURLY)	buffer.Append(NewLine + tab);
            	  								
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:718:5: (c1= comments )?
            	int alt30 = 2;
            	int LA30_0 = input.LA(1);
            	
            	if ( (LA30_0 == SL_COMMENT) )
            	{
            	    int LA30_1 = input.LA(2);
            	    
            	    if ( (synpred52()) )
            	    {
            	        alt30 = 1;
            	    }
            	}
            	else if ( (LA30_0 == ML_COMMENT) )
            	{
            	    int LA30_2 = input.LA(2);
            	    
            	    if ( (synpred52()) )
            	    {
            	        alt30 = 1;
            	    }
            	}
            	switch (alt30) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: c1= comments
            	        {
            	        	PushFollow(FOLLOW_comments_in_ifStatement2198);
            	        	c1 = comments();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, c1.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	   insertComment(c1, false, true); 
            	}
            	PushFollow(FOLLOW_statement_in_ifStatement2208);
            	statement100 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement100.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									CurrentTab--;
            	  									buffer.Append(NewLine + tab);
            	  									buffer.Append("}");
            	  								
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:725:3: ( (c2= comments )? ( ELSE )=> elseClause )?
            	int alt32 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case SL_COMMENT:
            	    	{
            	        int LA32_1 = input.LA(2);
            	        
            	        if ( (synpred55()) )
            	        {
            	            alt32 = 1;
            	        }
            	        }
            	        break;
            	    case ML_COMMENT:
            	    	{
            	        int LA32_2 = input.LA(2);
            	        
            	        if ( (synpred55()) )
            	        {
            	            alt32 = 1;
            	        }
            	        }
            	        break;
            	    case ELSE:
            	    	{
            	        int LA32_3 = input.LA(2);
            	        
            	        if ( (synpred55()) )
            	        {
            	            alt32 = 1;
            	        }
            	        }
            	        break;
            	}
            	
            	switch (alt32) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:726:4: (c2= comments )? ( ELSE )=> elseClause
            	        {
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:726:6: (c2= comments )?
            	        	int alt31 = 2;
            	        	int LA31_0 = input.LA(1);
            	        	
            	        	if ( ((LA31_0 >= SL_COMMENT && LA31_0 <= ML_COMMENT)) )
            	        	{
            	        	    alt31 = 1;
            	        	}
            	        	switch (alt31) 
            	        	{
            	        	    case 1 :
            	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: c2= comments
            	        	        {
            	        	        	PushFollow(FOLLOW_comments_in_ifStatement2229);
            	        	        	c2 = comments();
            	        	        	followingStackPointer_--;
            	        	        	if (failed) return retval;
            	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, c2.Tree);
            	        	        
            	        	        }
            	        	        break;
            	        	
            	        	}

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	  	insertComment(c2, true, true, 1);	
            	        	}
            	        	PushFollow(FOLLOW_elseClause_in_ifStatement2242);
            	        	elseClause101 = elseClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, elseClause101.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 39, ifStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ifStatement

    public class elseClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elseClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:733:1: elseClause : ELSE statement ;
    public elseClause_return elseClause() // throws RecognitionException [1]
    {   
        elseClause_return retval = new elseClause_return();
        retval.start = input.LT(1);
        int elseClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken ELSE102 = null;
        statement_return statement103 = null;
        
        
        CommonTree ELSE102_tree=null;
    
        
        	int next_test   = -1;
        	int next_test_2 = -1;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 40) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:738:4: ( ELSE statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:738:4: ELSE statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ELSE102 = (CommonToken)input.LT(1);
            	Match(input,ELSE,FOLLOW_ELSE_in_elseClause2264); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ELSE102_tree = (CommonTree)adaptor.Create(ELSE102);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ELSE102_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									buffer.Append(options.NewlineBeforeElse ? NewLine + tab : " ");
            	  									buffer.Append("else");
            	  									
            	  									next_test = input.LA(1);
            	  									if(next_test == ASLexer.IF) {
            	  										buffer.Append(" ");
            	  									} else {
            	  										buffer.Append( (options.NewlineAfterCondition ? NewLine + tab : " ") + "{"); 
            	  										next_test_2 = input.LA(1);
            	  										CurrentTab++;
            	  										if(next_test_2 != ASLexer.LCURLY) buffer.Append(NewLine + tab);										
            	  									}
            	  								
            	}
            	PushFollow(FOLLOW_statement_in_elseClause2275);
            	statement103 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement103.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  									if(next_test != ASLexer.IF) {
            	  										CurrentTab--;
            	  										buffer.Append(NewLine + tab);
            	  										buffer.Append("}");
            	  									} else {
            	  									}
            	  								
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 40, elseClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elseClause

    public class throwStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start throwStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:762:1: throwStatement : 'throw' expression semi ;
    public throwStatement_return throwStatement() // throws RecognitionException [1]
    {   
        throwStatement_return retval = new throwStatement_return();
        retval.start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken string_literal104 = null;
        expression_return expression105 = null;

        semi_return semi106 = null;
        
        
        CommonTree string_literal104_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 41) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:763:4: ( 'throw' expression semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:763:4: 'throw' expression semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal104 = (CommonToken)input.LT(1);
            	Match(input,176,FOLLOW_176_in_throwStatement2291); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal104_tree = (CommonTree)adaptor.Create(string_literal104);
            	root_0 = (CommonTree)adaptor.BecomeRoot(string_literal104_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("throw "); 
            	}
            	PushFollow(FOLLOW_expression_in_throwStatement2296);
            	expression105 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression105.Tree);
            	PushFollow(FOLLOW_semi_in_throwStatement2298);
            	semi106 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi106.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 41, throwStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end throwStatement

    public class tryStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start tryStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:766:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? ;
    public tryStatement_return tryStatement() // throws RecognitionException [1]
    {   
        tryStatement_return retval = new tryStatement_return();
        retval.start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken string_literal107 = null;
        block_return block108 = null;

        catchBlock_return catchBlock109 = null;

        finallyBlock_return finallyBlock110 = null;
        
        
        CommonTree string_literal107_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 42) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:767:4: ( 'try' block ( catchBlock )* ( finallyBlock )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:767:4: 'try' block ( catchBlock )* ( finallyBlock )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal107 = (CommonToken)input.LT(1);
            	Match(input,177,FOLLOW_177_in_tryStatement2309); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal107_tree = (CommonTree)adaptor.Create(string_literal107);
            	adaptor.AddChild(root_0, string_literal107_tree);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   
            	  							buffer.Append("try");
            	  							buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  							CurrentTab++;
            	  						
            	}
            	PushFollow(FOLLOW_block_in_tryStatement2317);
            	block108 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block108.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  							CurrentTab--;
            	  							buffer.Append(NewLine + tab);
            	  							buffer.Append("}");
            	  						
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:777:3: ( catchBlock )*
            	do 
            	{
            	    int alt33 = 2;
            	    int LA33_0 = input.LA(1);
            	    
            	    if ( (LA33_0 == 178) )
            	    {
            	        alt33 = 1;
            	    }
            	    
            	
            	    switch (alt33) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:777:5: catchBlock
            			    {
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append((options.NewlineBeforeElse ? NewLine + tab : " ")); 
            			    	}
            			    	PushFollow(FOLLOW_catchBlock_in_tryStatement2330);
            			    	catchBlock109 = catchBlock();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, catchBlock109.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop33;
            	    }
            	} while (true);
            	
            	loop33:
            		;	// Stops C# compiler whinging that label 'loop33' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:778:3: ( finallyBlock )?
            	int alt34 = 2;
            	int LA34_0 = input.LA(1);
            	
            	if ( (LA34_0 == 179) )
            	{
            	    alt34 = 1;
            	}
            	switch (alt34) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:778:5: finallyBlock
            	        {
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append((options.NewlineBeforeElse ? NewLine + tab : " ")); 
            	        	}
            	        	PushFollow(FOLLOW_finallyBlock_in_tryStatement2340);
            	        	finallyBlock110 = finallyBlock();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, finallyBlock110.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 42, tryStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end tryStatement

    public class catchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start catchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:781:1: catchBlock : 'catch' LPAREN ide= ident ( typeExpression )? RPAREN block ;
    public catchBlock_return catchBlock() // throws RecognitionException [1]
    {   
        catchBlock_return retval = new catchBlock_return();
        retval.start = input.LT(1);
        int catchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken string_literal111 = null;
        CommonToken LPAREN112 = null;
        CommonToken RPAREN114 = null;
        ident_return ide = null;

        typeExpression_return typeExpression113 = null;

        block_return block115 = null;
        
        
        CommonTree string_literal111_tree=null;
        CommonTree LPAREN112_tree=null;
        CommonTree RPAREN114_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 43) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:782:4: ( 'catch' LPAREN ide= ident ( typeExpression )? RPAREN block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:782:4: 'catch' LPAREN ide= ident ( typeExpression )? RPAREN block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal111 = (CommonToken)input.LT(1);
            	Match(input,178,FOLLOW_178_in_catchBlock2353); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal111_tree = (CommonTree)adaptor.Create(string_literal111);
            	adaptor.AddChild(root_0, string_literal111_tree);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("catch"); 
            	}
            	LPAREN112 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_catchBlock2360); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("("); 
            	}
            	PushFollow(FOLLOW_ident_in_catchBlock2370);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append( ((CommonTree)ide.Tree).Text ); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:785:3: ( typeExpression )?
            	int alt35 = 2;
            	int LA35_0 = input.LA(1);
            	
            	if ( (LA35_0 == COLON) )
            	{
            	    alt35 = 1;
            	}
            	switch (alt35) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_catchBlock2376);
            	        	typeExpression113 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, typeExpression113.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RPAREN114 = (CommonToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_catchBlock2382); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   
            	  						buffer.Append(")"); 
            	  						buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  						CurrentTab++;
            	  					
            	}
            	PushFollow(FOLLOW_block_in_catchBlock2390);
            	block115 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block115.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  						CurrentTab--;
            	  						buffer.Append(NewLine + tab);
            	  						buffer.Append("}");
            	  					
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 43, catchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end catchBlock

    public class finallyBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start finallyBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:798:1: finallyBlock : 'finally' block ;
    public finallyBlock_return finallyBlock() // throws RecognitionException [1]
    {   
        finallyBlock_return retval = new finallyBlock_return();
        retval.start = input.LT(1);
        int finallyBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken string_literal116 = null;
        block_return block117 = null;
        
        
        CommonTree string_literal116_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 44) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:799:4: ( 'finally' block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:799:4: 'finally' block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal116 = (CommonToken)input.LT(1);
            	Match(input,179,FOLLOW_179_in_finallyBlock2404); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal116_tree = (CommonTree)adaptor.Create(string_literal116);
            	adaptor.AddChild(root_0, string_literal116_tree);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   
            	  						buffer.Append("finally"); 
            	  						buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  						CurrentTab++;
            	  					
            	}
            	PushFollow(FOLLOW_block_in_finallyBlock2410);
            	block117 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block117.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  						CurrentTab--;
            	  						buffer.Append(NewLine + tab);
            	  						buffer.Append("}");
            	  					
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 44, finallyBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end finallyBlock

    public class returnStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start returnStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:811:1: returnStatement : ( RETURN expression semi | RETURN semi );
    public returnStatement_return returnStatement() // throws RecognitionException [1]
    {   
        returnStatement_return retval = new returnStatement_return();
        retval.start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken RETURN118 = null;
        CommonToken RETURN121 = null;
        expression_return expression119 = null;

        semi_return semi120 = null;

        semi_return semi122 = null;
        
        
        CommonTree RETURN118_tree=null;
        CommonTree RETURN121_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 45) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:812:4: ( RETURN expression semi | RETURN semi )
            int alt36 = 2;
            int LA36_0 = input.LA(1);
            
            if ( (LA36_0 == RETURN) )
            {
                switch ( input.LA(2) ) 
                {
                case INC:
                	{
                    int LA36_2 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s2 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 2, input);
                    
                        throw nvae_d36s2;
                    }
                    }
                    break;
                case DEC:
                	{
                    int LA36_3 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s3 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 3, input);
                    
                        throw nvae_d36s3;
                    }
                    }
                    break;
                case MINUS:
                	{
                    int LA36_4 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s4 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 4, input);
                    
                        throw nvae_d36s4;
                    }
                    }
                    break;
                case PLUS:
                	{
                    int LA36_5 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s5 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 5, input);
                    
                        throw nvae_d36s5;
                    }
                    }
                    break;
                case DELETE:
                	{
                    int LA36_6 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s6 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 6, input);
                    
                        throw nvae_d36s6;
                    }
                    }
                    break;
                case VOID:
                	{
                    int LA36_7 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s7 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 7, input);
                    
                        throw nvae_d36s7;
                    }
                    }
                    break;
                case TYPEOF:
                	{
                    int LA36_8 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s8 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 8, input);
                    
                        throw nvae_d36s8;
                    }
                    }
                    break;
                case LNOT:
                	{
                    int LA36_9 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s9 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 9, input);
                    
                        throw nvae_d36s9;
                    }
                    }
                    break;
                case BNOT:
                	{
                    int LA36_10 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s10 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 10, input);
                    
                        throw nvae_d36s10;
                    }
                    }
                    break;
                case UNDEFINED:
                	{
                    int LA36_11 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s11 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 11, input);
                    
                        throw nvae_d36s11;
                    }
                    }
                    break;
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOAT_LITERAL:
                	{
                    int LA36_12 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s12 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 12, input);
                    
                        throw nvae_d36s12;
                    }
                    }
                    break;
                case STRING_LITERAL:
                	{
                    int LA36_13 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s13 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 13, input);
                    
                        throw nvae_d36s13;
                    }
                    }
                    break;
                case TRUE:
                	{
                    int LA36_14 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s14 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 14, input);
                    
                        throw nvae_d36s14;
                    }
                    }
                    break;
                case FALSE:
                	{
                    int LA36_15 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s15 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 15, input);
                    
                        throw nvae_d36s15;
                    }
                    }
                    break;
                case NULL:
                	{
                    int LA36_16 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s16 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 16, input);
                    
                        throw nvae_d36s16;
                    }
                    }
                    break;
                case LBRACK:
                	{
                    int LA36_17 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s17 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 17, input);
                    
                        throw nvae_d36s17;
                    }
                    }
                    break;
                case LCURLY:
                	{
                    int LA36_18 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s18 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 18, input);
                    
                        throw nvae_d36s18;
                    }
                    }
                    break;
                case FUNCTION:
                	{
                    int LA36_19 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s19 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 19, input);
                    
                        throw nvae_d36s19;
                    }
                    }
                    break;
                case NEW:
                	{
                    int LA36_20 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s20 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 20, input);
                    
                        throw nvae_d36s20;
                    }
                    }
                    break;
                case LPAREN:
                	{
                    int LA36_21 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s21 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 21, input);
                    
                        throw nvae_d36s21;
                    }
                    }
                    break;
                case IDENT:
                	{
                    int LA36_22 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s22 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 22, input);
                    
                        throw nvae_d36s22;
                    }
                    }
                    break;
                case USE:
                	{
                    int LA36_23 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s23 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 23, input);
                    
                        throw nvae_d36s23;
                    }
                    }
                    break;
                case XML:
                	{
                    int LA36_24 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s24 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 24, input);
                    
                        throw nvae_d36s24;
                    }
                    }
                    break;
                case DYNAMIC:
                	{
                    int LA36_25 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s25 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 25, input);
                    
                        throw nvae_d36s25;
                    }
                    }
                    break;
                case IS:
                	{
                    int LA36_26 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s26 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 26, input);
                    
                        throw nvae_d36s26;
                    }
                    }
                    break;
                case AS:
                	{
                    int LA36_27 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s27 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 27, input);
                    
                        throw nvae_d36s27;
                    }
                    }
                    break;
                case GET:
                	{
                    int LA36_28 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s28 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 28, input);
                    
                        throw nvae_d36s28;
                    }
                    }
                    break;
                case SET:
                	{
                    int LA36_29 = input.LA(3);
                    
                    if ( (synpred59()) )
                    {
                        alt36 = 1;
                    }
                    else if ( (true) )
                    {
                        alt36 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d36s29 =
                            new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 29, input);
                    
                        throw nvae_d36s29;
                    }
                    }
                    break;
                case EOF:
                case SEMI:
                case RCURLY:
                case VAR:
                case CONST:
                case IF:
                case ELSE:
                case RETURN:
                case CONTINUE:
                case BREAK:
                case SWITCH:
                case CASE:
                case DEFAULT:
                case FOR:
                case WHILE:
                case DO:
                case WITH:
                case SL_COMMENT:
                case ML_COMMENT:
                case 176:
                case 177:
                	{
                    alt36 = 2;
                    }
                    break;
                	default:
                	    if ( backtracking > 0 ) {failed = true; return retval;}
                	    NoViableAltException nvae_d36s1 =
                	        new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 1, input);
                
                	    throw nvae_d36s1;
                }
            
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d36s0 =
                    new NoViableAltException("811:1: returnStatement : ( RETURN expression semi | RETURN semi );", 36, 0, input);
            
                throw nvae_d36s0;
            }
            switch (alt36) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:812:4: RETURN expression semi
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	RETURN118 = (CommonToken)input.LT(1);
                    	Match(input,RETURN,FOLLOW_RETURN_in_returnStatement2424); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	RETURN118_tree = (CommonTree)adaptor.Create(RETURN118);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(RETURN118_tree, root_0);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("return "); 
                    	}
                    	PushFollow(FOLLOW_expression_in_returnStatement2429);
                    	expression119 = expression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, expression119.Tree);
                    	PushFollow(FOLLOW_semi_in_returnStatement2431);
                    	semi120 = semi();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, semi120.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:813:4: RETURN semi
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	RETURN121 = (CommonToken)input.LT(1);
                    	Match(input,RETURN,FOLLOW_RETURN_in_returnStatement2436); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	RETURN121_tree = (CommonTree)adaptor.Create(RETURN121);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(RETURN121_tree, root_0);
                    	}
                    	PushFollow(FOLLOW_semi_in_returnStatement2439);
                    	semi122 = semi();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, semi122.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("return"); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 45, returnStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end returnStatement

    public class continueStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start continueStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:816:1: continueStatement : CONTINUE semi ;
    public continueStatement_return continueStatement() // throws RecognitionException [1]
    {   
        continueStatement_return retval = new continueStatement_return();
        retval.start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken CONTINUE123 = null;
        semi_return semi124 = null;
        
        
        CommonTree CONTINUE123_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 46) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:817:4: ( CONTINUE semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:817:4: CONTINUE semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CONTINUE123 = (CommonToken)input.LT(1);
            	Match(input,CONTINUE,FOLLOW_CONTINUE_in_continueStatement2454); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CONTINUE123_tree = (CommonTree)adaptor.Create(CONTINUE123);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CONTINUE123_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_continueStatement2457);
            	semi124 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi124.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("continue"); 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 46, continueStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end continueStatement

    public class breakStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start breakStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:820:1: breakStatement : BREAK semi ;
    public breakStatement_return breakStatement() // throws RecognitionException [1]
    {   
        breakStatement_return retval = new breakStatement_return();
        retval.start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken BREAK125 = null;
        semi_return semi126 = null;
        
        
        CommonTree BREAK125_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 47) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:821:4: ( BREAK semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:821:4: BREAK semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	BREAK125 = (CommonToken)input.LT(1);
            	Match(input,BREAK,FOLLOW_BREAK_in_breakStatement2470); if (failed) return retval;
            	if ( backtracking==0 ) {
            	BREAK125_tree = (CommonTree)adaptor.Create(BREAK125);
            	root_0 = (CommonTree)adaptor.BecomeRoot(BREAK125_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_breakStatement2473);
            	semi126 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi126.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("break"); 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 47, breakStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end breakStatement

    public class switchStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:824:1: switchStatement : SWITCH ( condition ) switchBlock ;
    public switchStatement_return switchStatement() // throws RecognitionException [1]
    {   
        switchStatement_return retval = new switchStatement_return();
        retval.start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken SWITCH127 = null;
        condition_return condition128 = null;

        switchBlock_return switchBlock129 = null;
        
        
        CommonTree SWITCH127_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 48) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:825:4: ( SWITCH ( condition ) switchBlock )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:825:4: SWITCH ( condition ) switchBlock
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	SWITCH127 = (CommonToken)input.LT(1);
            	Match(input,SWITCH,FOLLOW_SWITCH_in_switchStatement2487); if (failed) return retval;
            	if ( backtracking==0 ) {
            	SWITCH127_tree = (CommonTree)adaptor.Create(SWITCH127);
            	root_0 = (CommonTree)adaptor.BecomeRoot(SWITCH127_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("switch"); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:826:3: ( condition )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:826:4: condition
            	{
            		PushFollow(FOLLOW_condition_in_switchStatement2496);
            		condition128 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition128.Tree);
            	
            	}

            	PushFollow(FOLLOW_switchBlock_in_switchStatement2501);
            	switchBlock129 = switchBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, switchBlock129.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 48, switchStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatement

    public class switchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:830:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
    public switchBlock_return switchBlock() // throws RecognitionException [1]
    {   
        switchBlock_return retval = new switchBlock_return();
        retval.start = input.LT(1);
        int switchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LCURLY130 = null;
        CommonToken RCURLY133 = null;
        caseStatement_return caseStatement131 = null;

        defaultStatement_return defaultStatement132 = null;
        
        
        CommonTree LCURLY130_tree=null;
        CommonTree RCURLY133_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_caseStatement = new RewriteRuleSubtreeStream(adaptor,"rule caseStatement");
        RewriteRuleSubtreeStream stream_defaultStatement = new RewriteRuleSubtreeStream(adaptor,"rule defaultStatement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 49) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:831:4: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:831:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
            {
            	LCURLY130 = (CommonToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_switchBlock2512); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY130);

            	if ( backtracking == 0 ) 
            	{
            	   
            	  												buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{");
            	  												CurrentTab++;
            	  											
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:835:3: ( caseStatement )*
            	do 
            	{
            	    int alt37 = 2;
            	    int LA37_0 = input.LA(1);
            	    
            	    if ( (LA37_0 == CASE) )
            	    {
            	        alt37 = 1;
            	    }
            	    
            	
            	    switch (alt37) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:835:5: caseStatement
            			    {
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	  buffer.Append(NewLine + tab); 
            			    	}
            			    	PushFollow(FOLLOW_caseStatement_in_switchBlock2529);
            			    	caseStatement131 = caseStatement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_caseStatement.Add(caseStatement131.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop37;
            	    }
            	} while (true);
            	
            	loop37:
            		;	// Stops C# compiler whinging that label 'loop37' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:836:3: ( defaultStatement )?
            	int alt38 = 2;
            	int LA38_0 = input.LA(1);
            	
            	if ( (LA38_0 == DEFAULT) )
            	{
            	    alt38 = 1;
            	}
            	switch (alt38) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:836:5: defaultStatement
            	        {
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	  buffer.Append(NewLine + tab); 
            	        	}
            	        	PushFollow(FOLLOW_defaultStatement_in_switchBlock2539);
            	        	defaultStatement132 = defaultStatement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_defaultStatement.Add(defaultStatement132.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY133 = (CommonToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_switchBlock2545); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY133);

            	if ( backtracking == 0 ) 
            	{
            	  
            	  												CurrentTab--;
            	  												buffer.Append(NewLine + tab);
            	  												buffer.Append("}");
            	  											
            	}
            	
            	// AST REWRITE
            	// elements:          defaultStatement, caseStatement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 842:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:842:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:842:14: ( caseStatement )*
            	    while ( stream_caseStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_caseStatement.Next());
            	    
            	    }
            	    stream_caseStatement.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:842:29: ( defaultStatement )?
            	    if ( stream_defaultStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_defaultStatement.Next());
            	    
            	    }
            	    stream_defaultStatement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 49, switchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchBlock

    public class caseStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start caseStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:845:1: caseStatement : CASE expression COLON l= switchStatementList ;
    public caseStatement_return caseStatement() // throws RecognitionException [1]
    {   
        caseStatement_return retval = new caseStatement_return();
        retval.start = input.LT(1);
        int caseStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken CASE134 = null;
        CommonToken COLON136 = null;
        switchStatementList_return l = null;

        expression_return expression135 = null;
        
        
        CommonTree CASE134_tree=null;
        CommonTree COLON136_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 50) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:846:4: ( CASE expression COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:846:4: CASE expression COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CASE134 = (CommonToken)input.LT(1);
            	Match(input,CASE,FOLLOW_CASE_in_caseStatement2579); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CASE134_tree = (CommonTree)adaptor.Create(CASE134);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CASE134_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("case "); 
            	}
            	PushFollow(FOLLOW_expression_in_caseStatement2588);
            	expression135 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression135.Tree);
            	COLON136 = (CommonToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_caseStatement2593); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   
            	  						buffer.Append(":");  
            	  						CurrentTab++;
            	  					
            	}
            	PushFollow(FOLLOW_switchStatementList_in_caseStatement2603);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   CurrentTab--; 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 50, caseStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end caseStatement

    public class defaultStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start defaultStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:856:1: defaultStatement : DEFAULT COLON l= switchStatementList ;
    public defaultStatement_return defaultStatement() // throws RecognitionException [1]
    {   
        defaultStatement_return retval = new defaultStatement_return();
        retval.start = input.LT(1);
        int defaultStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DEFAULT137 = null;
        CommonToken COLON138 = null;
        switchStatementList_return l = null;
        
        
        CommonTree DEFAULT137_tree=null;
        CommonTree COLON138_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 51) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:857:4: ( DEFAULT COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:857:4: DEFAULT COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DEFAULT137 = (CommonToken)input.LT(1);
            	Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultStatement2622); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DEFAULT137_tree = (CommonTree)adaptor.Create(DEFAULT137);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DEFAULT137_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("default"); 
            	}
            	COLON138 = (CommonToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_defaultStatement2629); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   
            	  						buffer.Append(":"); 
            	  						CurrentTab++;
            	  					
            	}
            	PushFollow(FOLLOW_switchStatementList_in_defaultStatement2639);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   CurrentTab--; 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 51, defaultStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end defaultStatement

    public class switchStatementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:866:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
    public switchStatementList_return switchStatementList() // throws RecognitionException [1]
    {   
        switchStatementList_return retval = new switchStatementList_return();
        retval.start = input.LT(1);
        int switchStatementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement139 = null;
        
        
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 52) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:4: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:4: ( statement )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:4: ( statement )*
            	do 
            	{
            	    int alt39 = 2;
            	    int LA39_0 = input.LA(1);
            	    
            	    if ( (LA39_0 == SEMI || LA39_0 == LCURLY || (LA39_0 >= STRING_LITERAL && LA39_0 <= CONST) || LA39_0 == LPAREN || LA39_0 == IF || (LA39_0 >= RETURN && LA39_0 <= SWITCH) || LA39_0 == FOR || (LA39_0 >= WHILE && LA39_0 <= VOID) || LA39_0 == IDENT || LA39_0 == LBRACK || LA39_0 == DYNAMIC || (LA39_0 >= IS && LA39_0 <= AS) || (LA39_0 >= PLUS && LA39_0 <= MINUS) || (LA39_0 >= INC && LA39_0 <= XML) || (LA39_0 >= 176 && LA39_0 <= 177)) )
            	    {
            	        alt39 = 1;
            	    }
            	    
            	
            	    switch (alt39) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:6: statement
            			    {
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	  buffer.Append(NewLine + tab); 
            			    	}
            			    	PushFollow(FOLLOW_statement_in_switchStatementList2661);
            			    	statement139 = statement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_statement.Add(statement139.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop39;
            	    }
            	} while (true);
            	
            	loop39:
            		;	// Stops C# compiler whinging that label 'loop39' has no statements

            	
            	// AST REWRITE
            	// elements:          statement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 867:51: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:54: ^( SWITCH_STATEMENT_LIST ( statement )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:867:78: ( statement )*
            	    while ( stream_statement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_statement.Next());
            	    
            	    }
            	    stream_statement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 52, switchStatementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatementList

    public class forStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:870:1: forStatement : f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) ;
    public forStatement_return forStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forStatement_return retval = new forStatement_return();
        retval.start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken f = null;
        CommonToken LPAREN140 = null;
        CommonToken RPAREN142 = null;
        CommonToken RPAREN145 = null;
        forInClause_return forInClause141 = null;

        statement_return statement143 = null;

        traditionalForClause_return traditionalForClause144 = null;

        statement_return statement146 = null;
        
        
        CommonTree f_tree=null;
        CommonTree LPAREN140_tree=null;
        CommonTree RPAREN142_tree=null;
        CommonTree RPAREN145_tree=null;
        RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        RewriteRuleSubtreeStream stream_traditionalForClause = new RewriteRuleSubtreeStream(adaptor,"rule traditionalForClause");
        RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
        	int next_node = -1;
        	int next_node_2 = -1;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 53) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:877:4: (f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:877:4: f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            {
            	f = (CommonToken)input.LT(1);
            	Match(input,FOR,FOLLOW_FOR_in_forStatement2695); if (failed) return retval;
            	if ( backtracking==0 ) stream_FOR.Add(f);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("for"); 
            	}
            	LPAREN140 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_forStatement2703); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN140);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBeforeMethodDef ? " (" : "(");   
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            	int alt40 = 2;
            	switch ( input.LA(1) ) 
            	{
            	case VAR:
            	case CONST:
            		{
            	    switch ( input.LA(2) ) 
            	    {
            	    case IDENT:
            	    	{
            	        int LA40_31 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s31 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 31, input);
            	        
            	            throw nvae_d40s31;
            	        }
            	        }
            	        break;
            	    case USE:
            	    	{
            	        int LA40_32 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s32 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 32, input);
            	        
            	            throw nvae_d40s32;
            	        }
            	        }
            	        break;
            	    case XML:
            	    	{
            	        int LA40_33 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s33 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 33, input);
            	        
            	            throw nvae_d40s33;
            	        }
            	        }
            	        break;
            	    case DYNAMIC:
            	    	{
            	        int LA40_34 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s34 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 34, input);
            	        
            	            throw nvae_d40s34;
            	        }
            	        }
            	        break;
            	    case IS:
            	    	{
            	        int LA40_35 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s35 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 35, input);
            	        
            	            throw nvae_d40s35;
            	        }
            	        }
            	        break;
            	    case AS:
            	    	{
            	        int LA40_36 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s36 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 36, input);
            	        
            	            throw nvae_d40s36;
            	        }
            	        }
            	        break;
            	    case GET:
            	    	{
            	        int LA40_37 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s37 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 37, input);
            	        
            	            throw nvae_d40s37;
            	        }
            	        }
            	        break;
            	    case SET:
            	    	{
            	        int LA40_38 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s38 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 38, input);
            	        
            	            throw nvae_d40s38;
            	        }
            	        }
            	        break;
            	    	default:
            	    	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    	    NoViableAltException nvae_d40s1 =
            	    	        new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 1, input);
            	    
            	    	    throw nvae_d40s1;
            	    }
            	
            	    }
            	    break;
            	case IDENT:
            		{
            	    int LA40_2 = input.LA(2);
            	    
            	    if ( (LA40_2 == SEMI || LA40_2 == COMMA || (LA40_2 >= ASSIGN && LA40_2 <= LPAREN) || (LA40_2 >= STAR && LA40_2 <= DOT) || LA40_2 == LBRACK || (LA40_2 >= STAR_ASSIGN && LA40_2 <= DEC) || (LA40_2 >= 185 && LA40_2 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_2 == IN) )
            	    {
            	        int LA40_47 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s47 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 47, input);
            	        
            	            throw nvae_d40s47;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s2 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 2, input);
            	    
            	        throw nvae_d40s2;
            	    }
            	    }
            	    break;
            	case USE:
            		{
            	    int LA40_3 = input.LA(2);
            	    
            	    if ( (LA40_3 == SEMI || LA40_3 == COMMA || (LA40_3 >= ASSIGN && LA40_3 <= LPAREN) || (LA40_3 >= STAR && LA40_3 <= DOT) || LA40_3 == LBRACK || (LA40_3 >= STAR_ASSIGN && LA40_3 <= DEC) || (LA40_3 >= 185 && LA40_3 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_3 == IN) )
            	    {
            	        int LA40_73 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s73 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 73, input);
            	        
            	            throw nvae_d40s73;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s3 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 3, input);
            	    
            	        throw nvae_d40s3;
            	    }
            	    }
            	    break;
            	case XML:
            		{
            	    int LA40_4 = input.LA(2);
            	    
            	    if ( (LA40_4 == IN) )
            	    {
            	        int LA40_91 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s91 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 91, input);
            	        
            	            throw nvae_d40s91;
            	        }
            	    }
            	    else if ( (LA40_4 == SEMI || LA40_4 == COMMA || (LA40_4 >= ASSIGN && LA40_4 <= LPAREN) || (LA40_4 >= STAR && LA40_4 <= DOT) || LA40_4 == LBRACK || (LA40_4 >= STAR_ASSIGN && LA40_4 <= DEC) || (LA40_4 >= 185 && LA40_4 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s4 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 4, input);
            	    
            	        throw nvae_d40s4;
            	    }
            	    }
            	    break;
            	case DYNAMIC:
            		{
            	    int LA40_5 = input.LA(2);
            	    
            	    if ( (LA40_5 == SEMI || LA40_5 == COMMA || (LA40_5 >= ASSIGN && LA40_5 <= LPAREN) || (LA40_5 >= STAR && LA40_5 <= DOT) || LA40_5 == LBRACK || (LA40_5 >= STAR_ASSIGN && LA40_5 <= DEC) || (LA40_5 >= 185 && LA40_5 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_5 == IN) )
            	    {
            	        int LA40_125 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s125 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 125, input);
            	        
            	            throw nvae_d40s125;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s5 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 5, input);
            	    
            	        throw nvae_d40s5;
            	    }
            	    }
            	    break;
            	case IS:
            		{
            	    int LA40_6 = input.LA(2);
            	    
            	    if ( (LA40_6 == SEMI || LA40_6 == COMMA || (LA40_6 >= ASSIGN && LA40_6 <= LPAREN) || (LA40_6 >= STAR && LA40_6 <= DOT) || LA40_6 == LBRACK || (LA40_6 >= STAR_ASSIGN && LA40_6 <= DEC) || (LA40_6 >= 185 && LA40_6 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_6 == IN) )
            	    {
            	        int LA40_151 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s151 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 151, input);
            	        
            	            throw nvae_d40s151;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s6 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 6, input);
            	    
            	        throw nvae_d40s6;
            	    }
            	    }
            	    break;
            	case AS:
            		{
            	    int LA40_7 = input.LA(2);
            	    
            	    if ( (LA40_7 == IN) )
            	    {
            	        int LA40_169 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s169 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 169, input);
            	        
            	            throw nvae_d40s169;
            	        }
            	    }
            	    else if ( (LA40_7 == SEMI || LA40_7 == COMMA || (LA40_7 >= ASSIGN && LA40_7 <= LPAREN) || (LA40_7 >= STAR && LA40_7 <= DOT) || LA40_7 == LBRACK || (LA40_7 >= STAR_ASSIGN && LA40_7 <= DEC) || (LA40_7 >= 185 && LA40_7 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s7 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 7, input);
            	    
            	        throw nvae_d40s7;
            	    }
            	    }
            	    break;
            	case GET:
            		{
            	    int LA40_8 = input.LA(2);
            	    
            	    if ( (LA40_8 == SEMI || LA40_8 == COMMA || (LA40_8 >= ASSIGN && LA40_8 <= LPAREN) || (LA40_8 >= STAR && LA40_8 <= DOT) || LA40_8 == LBRACK || (LA40_8 >= STAR_ASSIGN && LA40_8 <= DEC) || (LA40_8 >= 185 && LA40_8 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_8 == IN) )
            	    {
            	        int LA40_203 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s203 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 203, input);
            	        
            	            throw nvae_d40s203;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s8 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 8, input);
            	    
            	        throw nvae_d40s8;
            	    }
            	    }
            	    break;
            	case SET:
            		{
            	    int LA40_9 = input.LA(2);
            	    
            	    if ( (LA40_9 == SEMI || LA40_9 == COMMA || (LA40_9 >= ASSIGN && LA40_9 <= LPAREN) || (LA40_9 >= STAR && LA40_9 <= DOT) || LA40_9 == LBRACK || (LA40_9 >= STAR_ASSIGN && LA40_9 <= DEC) || (LA40_9 >= 185 && LA40_9 <= 186)) )
            	    {
            	        alt40 = 2;
            	    }
            	    else if ( (LA40_9 == IN) )
            	    {
            	        int LA40_229 = input.LA(3);
            	        
            	        if ( (synpred63()) )
            	        {
            	            alt40 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt40 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d40s229 =
            	                new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 229, input);
            	        
            	            throw nvae_d40s229;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d40s9 =
            	            new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 9, input);
            	    
            	        throw nvae_d40s9;
            	    }
            	    }
            	    break;
            	case SEMI:
            	case LCURLY:
            	case STRING_LITERAL:
            	case FUNCTION:
            	case LPAREN:
            	case VOID:
            	case LBRACK:
            	case PLUS:
            	case MINUS:
            	case INC:
            	case DEC:
            	case DELETE:
            	case TYPEOF:
            	case LNOT:
            	case BNOT:
            	case UNDEFINED:
            	case TRUE:
            	case FALSE:
            	case NULL:
            	case HEX_LITERAL:
            	case DECIMAL_LITERAL:
            	case OCTAL_LITERAL:
            	case FLOAT_LITERAL:
            	case NEW:
            		{
            	    alt40 = 2;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d40s0 =
            		        new NoViableAltException("879:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 40, 0, input);
            	
            		    throw nvae_d40s0;
            	}
            	
            	switch (alt40) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:880:4: ( forInClauseDecl IN )=> forInClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_forInClause_in_forStatement2723);
            	        	forInClause141 = forInClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_forInClause.Add(forInClause141.Tree);
            	        	RPAREN142 = (CommonToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2729); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN142);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   
            	        	  												buffer.Append(")"); 
            	        	  												buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	        	  												CurrentTab++;
            	        	  												int next_test = input.LA(1);
            	        	  												if(next_test != ASLexer.LCURLY)	buffer.Append(NewLine + tab);												
            	        	  											
            	        	}
            	        	PushFollow(FOLLOW_statement_in_forStatement2742);
            	        	statement143 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement143.Tree);
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	  
            	        	  												CurrentTab--;
            	        	  												buffer.Append(NewLine + tab);
            	        	  												buffer.Append("}");
            	        	  											
            	        	}
            	        	
            	        	// AST REWRITE
            	        	// elements:          statement, forInClause
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 893:4: -> ^( FOR_IN[$f] forInClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:893:7: ^( FOR_IN[$f] forInClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_IN, f), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_forInClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:895:6: traditionalForClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_traditionalForClause_in_forStatement2771);
            	        	traditionalForClause144 = traditionalForClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_traditionalForClause.Add(traditionalForClause144.Tree);
            	        	RPAREN145 = (CommonToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2773); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN145);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   
            	        	  												buffer.Append(")"); 
            	        	  												buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	        	  												CurrentTab++;
            	        	  												int next_test_2 = input.LA(1);
            	        	  												if(next_test_2 != ASLexer.LCURLY)	buffer.Append(NewLine + tab);												
            	        	  											
            	        	}
            	        	PushFollow(FOLLOW_statement_in_forStatement2782);
            	        	statement146 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement146.Tree);
            	        	if ( backtracking == 0 ) 
            	        	{
            	        	  
            	        	  												CurrentTab--;
            	        	  												buffer.Append(NewLine + tab);
            	        	  												buffer.Append("}");
            	        	  											
            	        	}
            	        	
            	        	// AST REWRITE
            	        	// elements:          traditionalForClause, f, statement
            	        	// token labels:      f
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleTokenStream stream_f = new RewriteRuleTokenStream(adaptor, "token f", f);
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 907:4: -> ^( $f traditionalForClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:907:7: ^( $f traditionalForClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_f.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_traditionalForClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 53, forStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forStatement

    public class traditionalForClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start traditionalForClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:911:1: traditionalForClause : a= forInit SEMI b= forCond SEMI c= forIter ;
    public traditionalForClause_return traditionalForClause() // throws RecognitionException [1]
    {   
        traditionalForClause_return retval = new traditionalForClause_return();
        retval.start = input.LT(1);
        int traditionalForClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken SEMI147 = null;
        CommonToken SEMI148 = null;
        forInit_return a = null;

        forCond_return b = null;

        forIter_return c = null;
        
        
        CommonTree SEMI147_tree=null;
        CommonTree SEMI148_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 54) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:912:4: (a= forInit SEMI b= forCond SEMI c= forIter )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:912:4: a= forInit SEMI b= forCond SEMI c= forIter
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInit_in_traditionalForClause2819);
            	a = forInit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, a.Tree);
            	SEMI147 = (CommonToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2821); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBetweenArguments ? "; " : ";"); 
            	}
            	PushFollow(FOLLOW_forCond_in_traditionalForClause2831);
            	b = forCond();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, b.Tree);
            	SEMI148 = (CommonToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2833); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBetweenArguments ? "; " : ";"); 
            	}
            	PushFollow(FOLLOW_forIter_in_traditionalForClause2843);
            	c = forIter();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 54, traditionalForClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end traditionalForClause

    public class forInClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:917:1: forInClause : forInClauseDecl IN forInClauseTail ;
    public forInClause_return forInClause() // throws RecognitionException [1]
    {   
        forInClause_return retval = new forInClause_return();
        retval.start = input.LT(1);
        int forInClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IN150 = null;
        forInClauseDecl_return forInClauseDecl149 = null;

        forInClauseTail_return forInClauseTail151 = null;
        
        
        CommonTree IN150_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 55) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:918:4: ( forInClauseDecl IN forInClauseTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:918:4: forInClauseDecl IN forInClauseTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInClauseDecl_in_forInClause2855);
            	forInClauseDecl149 = forInClauseDecl();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseDecl149.Tree);
            	IN150 = (CommonToken)input.LT(1);
            	Match(input,IN,FOLLOW_IN_in_forInClause2857); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(" in "); 
            	}
            	PushFollow(FOLLOW_forInClauseTail_in_forInClause2862);
            	forInClauseTail151 = forInClauseTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseTail151.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 55, forInClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end forInClause

    public class forInClauseDecl_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseDecl
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:921:1: forInClauseDecl : ( declaration | ide= ident );
    public forInClauseDecl_return forInClauseDecl() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseDecl_return retval = new forInClauseDecl_return();
        retval.start = input.LT(1);
        int forInClauseDecl_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ide = null;

        declaration_return declaration152 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 56) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:926:4: ( declaration | ide= ident )
            int alt41 = 2;
            int LA41_0 = input.LA(1);
            
            if ( ((LA41_0 >= VAR && LA41_0 <= CONST)) )
            {
                alt41 = 1;
            }
            else if ( ((LA41_0 >= GET && LA41_0 <= SET) || LA41_0 == IDENT || LA41_0 == DYNAMIC || (LA41_0 >= IS && LA41_0 <= AS) || (LA41_0 >= USE && LA41_0 <= XML)) )
            {
                alt41 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d41s0 =
                    new NoViableAltException("921:1: forInClauseDecl : ( declaration | ide= ident );", 41, 0, input);
            
                throw nvae_d41s0;
            }
            switch (alt41) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:926:4: declaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declaration_in_forInClauseDecl2883);
                    	declaration152 = declaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration152.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:927:4: ide= ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_forInClauseDecl2891);
                    	ide = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append( ((CommonTree)ide.Tree).Text ); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 56, forInClauseDecl_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseDecl

    public class forInClauseTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:931:1: forInClauseTail : expressionList ;
    public forInClauseTail_return forInClauseTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseTail_return retval = new forInClauseTail_return();
        retval.start = input.LT(1);
        int forInClauseTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList153 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 57) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:936:4: ( expressionList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:936:4: expressionList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_expressionList_in_forInClauseTail2917);
            	expressionList153 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList153.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 57, forInClauseTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseTail

    public class forInit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:940:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
    public forInit_return forInit() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInit_return retval = new forInit_return();
        retval.start = input.LT(1);
        int forInit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration154 = null;

        expressionList_return expressionList155 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        RewriteRuleSubtreeStream stream_declaration = new RewriteRuleSubtreeStream(adaptor,"rule declaration");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 58) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:945:4: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:945:4: ( declaration | expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:945:4: ( declaration | expressionList )?
            	int alt42 = 3;
            	int LA42_0 = input.LA(1);
            	
            	if ( ((LA42_0 >= VAR && LA42_0 <= CONST)) )
            	{
            	    alt42 = 1;
            	}
            	else if ( (LA42_0 == LCURLY || (LA42_0 >= STRING_LITERAL && LA42_0 <= SET) || LA42_0 == LPAREN || LA42_0 == VOID || LA42_0 == IDENT || LA42_0 == LBRACK || LA42_0 == DYNAMIC || (LA42_0 >= IS && LA42_0 <= AS) || (LA42_0 >= PLUS && LA42_0 <= MINUS) || (LA42_0 >= INC && LA42_0 <= NEW) || (LA42_0 >= USE && LA42_0 <= XML)) )
            	{
            	    alt42 = 2;
            	}
            	switch (alt42) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:945:5: declaration
            	        {
            	        	PushFollow(FOLLOW_declaration_in_forInit2941);
            	        	declaration154 = declaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_declaration.Add(declaration154.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:945:19: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forInit2945);
            	        	expressionList155 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList155.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          declaration, expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 946:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:946:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:946:17: ( declaration )?
            	    if ( stream_declaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_declaration.Next());
            	    
            	    }
            	    stream_declaration.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:946:30: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 58, forInit_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInit

    public class forCond_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forCond
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:949:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
    public forCond_return forCond() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forCond_return retval = new forCond_return();
        retval.start = input.LT(1);
        int forCond_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList156 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 59) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:954:4: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:954:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:954:4: ( expressionList )?
            	int alt43 = 2;
            	int LA43_0 = input.LA(1);
            	
            	if ( (LA43_0 == LCURLY || (LA43_0 >= STRING_LITERAL && LA43_0 <= SET) || LA43_0 == LPAREN || LA43_0 == VOID || LA43_0 == IDENT || LA43_0 == LBRACK || LA43_0 == DYNAMIC || (LA43_0 >= IS && LA43_0 <= AS) || (LA43_0 >= PLUS && LA43_0 <= MINUS) || (LA43_0 >= INC && LA43_0 <= NEW) || (LA43_0 >= USE && LA43_0 <= XML)) )
            	{
            	    alt43 = 1;
            	}
            	switch (alt43) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forCond2983);
            	        	expressionList156 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList156.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 955:3: -> ^( FOR_CONDITION ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:955:6: ^( FOR_CONDITION ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:955:22: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 59, forCond_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forCond

    public class forIter_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forIter
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:958:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
    public forIter_return forIter() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forIter_return retval = new forIter_return();
        retval.start = input.LT(1);
        int forIter_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList157 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 60) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:963:4: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:963:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:963:4: ( expressionList )?
            	int alt44 = 2;
            	int LA44_0 = input.LA(1);
            	
            	if ( (LA44_0 == LCURLY || (LA44_0 >= STRING_LITERAL && LA44_0 <= SET) || LA44_0 == LPAREN || LA44_0 == VOID || LA44_0 == IDENT || LA44_0 == LBRACK || LA44_0 == DYNAMIC || (LA44_0 >= IS && LA44_0 <= AS) || (LA44_0 >= PLUS && LA44_0 <= MINUS) || (LA44_0 >= INC && LA44_0 <= NEW) || (LA44_0 >= USE && LA44_0 <= XML)) )
            	{
            	    alt44 = 1;
            	}
            	switch (alt44) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forIter3016);
            	        	expressionList157 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList157.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 964:3: -> ^( FOR_ITERATOR ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:964:6: ^( FOR_ITERATOR ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:964:21: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 60, forIter_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forIter

    public class whileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start whileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:967:1: whileStatement : WHILE condition ( statement ) ;
    public whileStatement_return whileStatement() // throws RecognitionException [1]
    {   
        whileStatement_return retval = new whileStatement_return();
        retval.start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken WHILE158 = null;
        condition_return condition159 = null;

        statement_return statement160 = null;
        
        
        CommonTree WHILE158_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 61) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:968:4: ( WHILE condition ( statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:968:4: WHILE condition ( statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WHILE158 = (CommonToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_whileStatement3039); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WHILE158_tree = (CommonTree)adaptor.Create(WHILE158);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WHILE158_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("while"); 
            	}
            	PushFollow(FOLLOW_condition_in_whileStatement3048);
            	condition159 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition159.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  							buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  							CurrentTab++;
            	  							int next_test = input.LA(1);
            	  							if(next_test != ASLexer.LCURLY)	buffer.Append(NewLine + tab);
            	  						
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:975:3: ( statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:975:4: statement
            	{
            		PushFollow(FOLLOW_statement_in_whileStatement3056);
            		statement160 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement160.Tree);
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  							CurrentTab--;
            	  							buffer.Append(NewLine + tab);
            	  							buffer.Append("}");
            	  						
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 61, whileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end whileStatement

    public class doWhileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start doWhileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:982:1: doWhileStatement : DO statement WHILE ( condition ) semi ;
    public doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {   
        doWhileStatement_return retval = new doWhileStatement_return();
        retval.start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DO161 = null;
        CommonToken WHILE163 = null;
        statement_return statement162 = null;

        condition_return condition164 = null;

        semi_return semi165 = null;
        
        
        CommonTree DO161_tree=null;
        CommonTree WHILE163_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 62) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:983:4: ( DO statement WHILE ( condition ) semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:983:4: DO statement WHILE ( condition ) semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DO161 = (CommonToken)input.LT(1);
            	Match(input,DO,FOLLOW_DO_in_doWhileStatement3071); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DO161_tree = (CommonTree)adaptor.Create(DO161);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DO161_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	  
            	  							buffer.Append("do");
            	  							buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  							CurrentTab++;
            	  							int next_test = input.LA(1);
            	  							if(next_test != ASLexer.LCURLY)	buffer.Append(NewLine + tab);							
            	  						
            	}
            	PushFollow(FOLLOW_statement_in_doWhileStatement3081);
            	statement162 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement162.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  							CurrentTab--;
            	  							buffer.Append(NewLine + tab);
            	  							buffer.Append("}");
            	  						
            	}
            	WHILE163 = (CommonToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_doWhileStatement3088); if (failed) return retval;
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(" while"); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:996:3: ( condition )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:996:4: condition
            	{
            		PushFollow(FOLLOW_condition_in_doWhileStatement3098);
            		condition164 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition164.Tree);
            	
            	}

            	PushFollow(FOLLOW_semi_in_doWhileStatement3104);
            	semi165 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi165.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 62, doWhileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end doWhileStatement

    public class withStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start withStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1000:1: withStatement : WITH condition ( statement ) ;
    public withStatement_return withStatement() // throws RecognitionException [1]
    {   
        withStatement_return retval = new withStatement_return();
        retval.start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken WITH166 = null;
        condition_return condition167 = null;

        statement_return statement168 = null;
        
        
        CommonTree WITH166_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 63) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1001:4: ( WITH condition ( statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1001:4: WITH condition ( statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WITH166 = (CommonToken)input.LT(1);
            	Match(input,WITH,FOLLOW_WITH_in_withStatement3115); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WITH166_tree = (CommonTree)adaptor.Create(WITH166);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WITH166_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("with"); 
            	}
            	PushFollow(FOLLOW_condition_in_withStatement3124);
            	condition167 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition167.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  							buffer.Append((options.NewlineAfterCondition ? NewLine + tab : "") + "{"); 
            	  							CurrentTab++;
            	  							int next_test = input.LA(1);
            	  							if(next_test != ASLexer.LCURLY)	buffer.Append(NewLine + tab);
            	  						
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1008:3: ( statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1008:4: statement
            	{
            		PushFollow(FOLLOW_statement_in_withStatement3132);
            		statement168 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement168.Tree);
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  							CurrentTab--;
            	  							buffer.Append(NewLine + tab);
            	  							buffer.Append("}");
            	  						
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 63, withStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end withStatement

    public class typeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1015:1: typeExpression : c= COLON ( identifier | VOID | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( VOID )? ( STAR )? ) ;
    public typeExpression_return typeExpression() // throws RecognitionException [1]
    {   
        typeExpression_return retval = new typeExpression_return();
        retval.start = input.LT(1);
        int typeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken c = null;
        CommonToken VOID170 = null;
        CommonToken STAR171 = null;
        identifier_return identifier169 = null;
        
        
        CommonTree c_tree=null;
        CommonTree VOID170_tree=null;
        CommonTree STAR171_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_VOID = new RewriteRuleTokenStream(adaptor,"token VOID");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 64) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1017:3: (c= COLON ( identifier | VOID | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( VOID )? ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1017:3: c= COLON ( identifier | VOID | STAR )
            {
            	c = (CommonToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_typeExpression3152); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(c);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBetweenType ? " : " : ":"); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1018:3: ( identifier | VOID | STAR )
            	int alt45 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case GET:
            	case SET:
            	case IDENT:
            	case DYNAMIC:
            	case IS:
            	case AS:
            	case USE:
            	case XML:
            		{
            	    alt45 = 1;
            	    }
            	    break;
            	case VOID:
            		{
            	    alt45 = 2;
            	    }
            	    break;
            	case STAR:
            		{
            	    alt45 = 3;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d45s0 =
            		        new NoViableAltException("1018:3: ( identifier | VOID | STAR )", 45, 0, input);
            	
            		    throw nvae_d45s0;
            	}
            	
            	switch (alt45) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1019:4: identifier
            	        {
            	        	PushFollow(FOLLOW_identifier_in_typeExpression3165);
            	        	identifier169 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_identifier.Add(identifier169.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1020:6: VOID
            	        {
            	        	VOID170 = (CommonToken)input.LT(1);
            	        	Match(input,VOID,FOLLOW_VOID_in_typeExpression3173); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_VOID.Add(VOID170);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append("Void"); 
            	        	}
            	        
            	        }
            	        break;
            	    case 3 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1021:6: STAR
            	        {
            	        	STAR171 = (CommonToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_typeExpression3183); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR171);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append("*");	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          STAR, VOID, identifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1023:3: -> ^( TYPE_SPEC[$c] ( identifier )? ( VOID )? ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1023:6: ^( TYPE_SPEC[$c] ( identifier )? ( VOID )? ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_SPEC, c), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1023:22: ( identifier )?
            	    if ( stream_identifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_identifier.Next());
            	    
            	    }
            	    stream_identifier.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1023:34: ( VOID )?
            	    if ( stream_VOID.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_VOID.Next());
            	    
            	    }
            	    stream_VOID.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1023:40: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 64, typeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeExpression

    public class identifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1026:1: identifier : qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) ;
    public identifier_return identifier() // throws RecognitionException [1]
    {   
        identifier_return retval = new identifier_return();
        retval.start = input.LT(1);
        int identifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DOT173 = null;
        qualifiedIdent_return qualifiedIdent172 = null;

        qualifiedIdent_return qualifiedIdent174 = null;
        
        
        CommonTree DOT173_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 65) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1027:4: ( qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1027:4: qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )*
            {
            	PushFollow(FOLLOW_qualifiedIdent_in_identifier3221);
            	qualifiedIdent172 = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent172.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1028:3: ( options {greedy=true; } : DOT qualifiedIdent )*
            	do 
            	{
            	    int alt46 = 2;
            	    int LA46_0 = input.LA(1);
            	    
            	    if ( (LA46_0 == DOT) )
            	    {
            	        alt46 = 1;
            	    }
            	    
            	
            	    switch (alt46) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1029:6: DOT qualifiedIdent
            			    {
            			    	DOT173 = (CommonToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifier3245); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT173);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append("."); 
            			    	}
            			    	PushFollow(FOLLOW_qualifiedIdent_in_identifier3249);
            			    	qualifiedIdent174 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent174.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop46;
            	    }
            	} while (true);
            	
            	loop46:
            		;	// Stops C# compiler whinging that label 'loop46' has no statements

            	
            	// AST REWRITE
            	// elements:          qualifiedIdent
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1031:3: -> ^( IDENTIFIER ( qualifiedIdent )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1031:6: ^( IDENTIFIER ( qualifiedIdent )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_qualifiedIdent.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_qualifiedIdent.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            	    
            	    }
            	    stream_qualifiedIdent.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 65, identifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifier

    public class qualifiedIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start qualifiedIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1034:1: qualifiedIdent : ide= ident ;
    public qualifiedIdent_return qualifiedIdent() // throws RecognitionException [1]
    {   
        qualifiedIdent_return retval = new qualifiedIdent_return();
        retval.start = input.LT(1);
        int qualifiedIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ide = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 66) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1035:4: (ide= ident )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1035:4: ide= ident
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_ident_in_qualifiedIdent3278);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append( ((CommonTree)ide.Tree).Text ); 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 66, qualifiedIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end qualifiedIdent

    public class namespaceName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start namespaceName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1038:1: namespaceName : ( IDENT | reservedNamespace );
    public namespaceName_return namespaceName() // throws RecognitionException [1]
    {   
        namespaceName_return retval = new namespaceName_return();
        retval.start = input.LT(1);
        int namespaceName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IDENT175 = null;
        reservedNamespace_return reservedNamespace176 = null;
        
        
        CommonTree IDENT175_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 67) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1039:4: ( IDENT | reservedNamespace )
            int alt47 = 2;
            int LA47_0 = input.LA(1);
            
            if ( (LA47_0 == IDENT) )
            {
                alt47 = 1;
            }
            else if ( ((LA47_0 >= PUBLIC && LA47_0 <= INTERNAL)) )
            {
                alt47 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d47s0 =
                    new NoViableAltException("1038:1: namespaceName : ( IDENT | reservedNamespace );", 47, 0, input);
            
                throw nvae_d47s0;
            }
            switch (alt47) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1039:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT175 = (CommonToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_namespaceName3292); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT175_tree = (CommonTree)adaptor.Create(IDENT175);
                    	adaptor.AddChild(root_0, IDENT175_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1039:12: reservedNamespace
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_reservedNamespace_in_namespaceName3296);
                    	reservedNamespace176 = reservedNamespace();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, reservedNamespace176.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 67, namespaceName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end namespaceName

    public class reservedNamespace_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start reservedNamespace
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1042:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
    public reservedNamespace_return reservedNamespace() // throws RecognitionException [1]
    {   
        reservedNamespace_return retval = new reservedNamespace_return();
        retval.start = input.LT(1);
        int reservedNamespace_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set177 = null;
        
        CommonTree set177_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 68) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1043:4: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set177 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= PUBLIC && input.LA(1) <= INTERNAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set177));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_reservedNamespace0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 68, reservedNamespace_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end reservedNamespace

    public class identifierStar_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifierStar
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1049:1: identifierStar : ide= ident ( options {greedy=true; } : DOT ide2= ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) ;
    public identifierStar_return identifierStar() // throws RecognitionException [1]
    {   
        identifierStar_return retval = new identifierStar_return();
        retval.start = input.LT(1);
        int identifierStar_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DOT178 = null;
        CommonToken DOT179 = null;
        CommonToken STAR180 = null;
        ident_return ide = null;

        ident_return ide2 = null;
        
        
        CommonTree DOT178_tree=null;
        CommonTree DOT179_tree=null;
        CommonTree STAR180_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 69) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1050:4: (ide= ident ( options {greedy=true; } : DOT ide2= ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1050:4: ide= ident ( options {greedy=true; } : DOT ide2= ident )* ( DOT STAR )?
            {
            	PushFollow(FOLLOW_ident_in_identifierStar3335);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1051:3: ( options {greedy=true; } : DOT ide2= ident )*
            	do 
            	{
            	    int alt48 = 2;
            	    int LA48_0 = input.LA(1);
            	    
            	    if ( (LA48_0 == DOT) )
            	    {
            	        int LA48_1 = input.LA(2);
            	        
            	        if ( ((LA48_1 >= GET && LA48_1 <= SET) || LA48_1 == IDENT || LA48_1 == DYNAMIC || (LA48_1 >= IS && LA48_1 <= AS) || (LA48_1 >= USE && LA48_1 <= XML)) )
            	        {
            	            alt48 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt48) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1052:5: DOT ide2= ident
            			    {
            			    	DOT178 = (CommonToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifierStar3357); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT178);

            			    	PushFollow(FOLLOW_ident_in_identifierStar3361);
            			    	ide2 = ident();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_ident.Add(ide2.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop48;
            	    }
            	} while (true);
            	
            	loop48:
            		;	// Stops C# compiler whinging that label 'loop48' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1054:3: ( DOT STAR )?
            	int alt49 = 2;
            	int LA49_0 = input.LA(1);
            	
            	if ( (LA49_0 == DOT) )
            	{
            	    alt49 = 1;
            	}
            	switch (alt49) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1054:5: DOT STAR
            	        {
            	        	DOT179 = (CommonToken)input.LT(1);
            	        	Match(input,DOT,FOLLOW_DOT_in_identifierStar3376); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DOT.Add(DOT179);

            	        	STAR180 = (CommonToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_identifierStar3378); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR180);

            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          STAR, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1056:3: -> ^( IDENTIFIER ( ident )+ ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1056:6: ^( IDENTIFIER ( ident )+ ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_ident.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1056:26: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 69, identifierStar_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifierStar

    public class annotations_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotations
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1059:1: annotations : ( ( annotation ) | ( includeDirective ) )+ -> ^( ANNOTATIONS ( annotation )+ ) ;
    public annotations_return annotations() // throws RecognitionException [1]
    {   
        annotations_return retval = new annotations_return();
        retval.start = input.LT(1);
        int annotations_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        annotation_return annotation181 = null;

        includeDirective_return includeDirective182 = null;
        
        
        RewriteRuleSubtreeStream stream_includeDirective = new RewriteRuleSubtreeStream(adaptor,"rule includeDirective");
        RewriteRuleSubtreeStream stream_annotation = new RewriteRuleSubtreeStream(adaptor,"rule annotation");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 70) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1060:4: ( ( ( annotation ) | ( includeDirective ) )+ -> ^( ANNOTATIONS ( annotation )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1060:4: ( ( annotation ) | ( includeDirective ) )+
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1060:4: ( ( annotation ) | ( includeDirective ) )+
            	int cnt50 = 0;
            	do 
            	{
            	    int alt50 = 3;
            	    int LA50_0 = input.LA(1);
            	    
            	    if ( (LA50_0 == LBRACK) )
            	    {
            	        int LA50_13 = input.LA(2);
            	        
            	        if ( (synpred78()) )
            	        {
            	            alt50 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA50_0 == 175) )
            	    {
            	        int LA50_14 = input.LA(2);
            	        
            	        if ( (synpred79()) )
            	        {
            	            alt50 = 2;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt50) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:5: ( annotation )
            			    {
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:5: ( annotation )
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:7: annotation
            			    	{
            			    		if ( backtracking == 0 ) 
            			    		{
            			    		   buffer.Append(NewLine + tab); 
            			    		}
            			    		PushFollow(FOLLOW_annotation_in_annotations3424);
            			    		annotation181 = annotation();
            			    		followingStackPointer_--;
            			    		if (failed) return retval;
            			    		if ( backtracking==0 ) stream_annotation.Add(annotation181.Tree);
            			    	
            			    	}

            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:6: ( includeDirective )
            			    {
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:6: ( includeDirective )
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:8: includeDirective
            			    	{
            			    		if ( backtracking == 0 ) 
            			    		{
            			    		   buffer.Append(NewLine + tab); 
            			    		}
            			    		PushFollow(FOLLOW_includeDirective_in_annotations3437);
            			    		includeDirective182 = includeDirective();
            			    		followingStackPointer_--;
            			    		if (failed) return retval;
            			    		if ( backtracking==0 ) stream_includeDirective.Add(includeDirective182.Tree);
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt50 >= 1 ) goto loop50;
            			    if ( backtracking > 0 ) {failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(50, input);
            		            throw eee;
            	    }
            	    cnt50++;
            	} while (true);
            	
            	loop50:
            		;	// Stops C# compiler whinging that label 'loop50' has no statements

            	
            	// AST REWRITE
            	// elements:          annotation
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1064:3: -> ^( ANNOTATIONS ( annotation )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1064:6: ^( ANNOTATIONS ( annotation )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATIONS, "ANNOTATIONS"), root_1);
            	    
            	    if ( !(stream_annotation.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_annotation.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotation.Next());
            	    
            	    }
            	    stream_annotation.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 70, annotations_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotations

    public class annotation_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotation
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1067:1: annotation : LBRACK ide= ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
    public annotation_return annotation() // throws RecognitionException [1]
    {   
        annotation_return retval = new annotation_return();
        retval.start = input.LT(1);
        int annotation_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LBRACK183 = null;
        CommonToken RBRACK185 = null;
        ident_return ide = null;

        annotationParamList_return annotationParamList184 = null;
        
        
        CommonTree LBRACK183_tree=null;
        CommonTree RBRACK185_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_annotationParamList = new RewriteRuleSubtreeStream(adaptor,"rule annotationParamList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 71) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1068:4: ( LBRACK ide= ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1068:4: LBRACK ide= ident ( annotationParamList )? RBRACK
            {
            	LBRACK183 = (CommonToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_annotation3466); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK183);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("["); 
            	}
            	PushFollow(FOLLOW_ident_in_annotation3478);
            	ide = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ide.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(((CommonTree)ide.Tree).Text); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1070:3: ( annotationParamList )?
            	int alt51 = 2;
            	int LA51_0 = input.LA(1);
            	
            	if ( (LA51_0 == LPAREN) )
            	{
            	    alt51 = 1;
            	}
            	switch (alt51) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: annotationParamList
            	        {
            	        	PushFollow(FOLLOW_annotationParamList_in_annotation3487);
            	        	annotationParamList184 = annotationParamList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParamList.Add(annotationParamList184.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK185 = (CommonToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_annotation3492); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK185);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("]"); 
            	}
            	
            	// AST REWRITE
            	// elements:          ident, annotationParamList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1072:3: -> ^( ANNOTATION ident ( annotationParamList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1072:6: ^( ANNOTATION ident ( annotationParamList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1072:25: ( annotationParamList )?
            	    if ( stream_annotationParamList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParamList.Next());
            	    
            	    }
            	    stream_annotationParamList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 71, annotation_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotation

    public class annotationParamList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParamList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1075:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
    public annotationParamList_return annotationParamList() // throws RecognitionException [1]
    {   
        annotationParamList_return retval = new annotationParamList_return();
        retval.start = input.LT(1);
        int annotationParamList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LPAREN186 = null;
        CommonToken COMMA188 = null;
        CommonToken RPAREN190 = null;
        annotationParam_return annotationParam187 = null;

        annotationParam_return annotationParam189 = null;
        
        
        CommonTree LPAREN186_tree=null;
        CommonTree COMMA188_tree=null;
        CommonTree RPAREN190_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_annotationParam = new RewriteRuleSubtreeStream(adaptor,"rule annotationParam");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 72) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1077:3: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1077:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
            {
            	LPAREN186 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_annotationParamList3524); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN186);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("("); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1078:3: ( annotationParam ( COMMA annotationParam )* )?
            	int alt53 = 2;
            	int LA53_0 = input.LA(1);
            	
            	if ( (LA53_0 == STRING_LITERAL || (LA53_0 >= GET && LA53_0 <= SET) || LA53_0 == IDENT || LA53_0 == DYNAMIC || (LA53_0 >= IS && LA53_0 <= AS) || (LA53_0 >= TRUE && LA53_0 <= FLOAT_LITERAL) || (LA53_0 >= USE && LA53_0 <= XML)) )
            	{
            	    alt53 = 1;
            	}
            	switch (alt53) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1078:5: annotationParam ( COMMA annotationParam )*
            	        {
            	        	PushFollow(FOLLOW_annotationParam_in_annotationParamList3537);
            	        	annotationParam187 = annotationParam();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam187.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1079:4: ( COMMA annotationParam )*
            	        	do 
            	        	{
            	        	    int alt52 = 2;
            	        	    int LA52_0 = input.LA(1);
            	        	    
            	        	    if ( (LA52_0 == COMMA) )
            	        	    {
            	        	        alt52 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt52) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1080:5: COMMA annotationParam
            	        			    {
            	        			    	COMMA188 = (CommonToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_annotationParamList3548); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA188);

            	        			    	if ( backtracking == 0 ) 
            	        			    	{
            	        			    	   buffer.Append(","); 
            	        			    	}
            	        			    	PushFollow(FOLLOW_annotationParam_in_annotationParamList3559);
            	        			    	annotationParam189 = annotationParam();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam189.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop52;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop52:
            	        		;	// Stops C# compiler whinging that label 'loop52' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN190 = (CommonToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_annotationParamList3574); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN190);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(")"); 
            	}
            	
            	// AST REWRITE
            	// elements:          annotationParam
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1085:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1085:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1085:26: ( annotationParam )*
            	    while ( stream_annotationParam.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParam.Next());
            	    
            	    }
            	    stream_annotationParam.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 72, annotationParamList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParamList

    public class annotationParam_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParam
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );
    public annotationParam_return annotationParam() // throws RecognitionException [1]
    {   
        annotationParam_return retval = new annotationParam_return();
        retval.start = input.LT(1);
        int annotationParam_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken ASSIGN191 = null;
        CommonToken ASSIGN192 = null;
        ident_return ide1 = null;

        constant_return cn1 = null;

        ident_return ide2 = null;

        ident_return ide3 = null;

        constant_return cn2 = null;

        ident_return ide4 = null;
        
        
        CommonTree ASSIGN191_tree=null;
        CommonTree ASSIGN192_tree=null;
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleSubtreeStream stream_constant = new RewriteRuleSubtreeStream(adaptor,"rule constant");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 73) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1090:3: (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident )
            int alt54 = 4;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                int LA54_1 = input.LA(2);
                
                if ( (LA54_1 == EOF || LA54_1 == COMMA || LA54_1 == RPAREN) )
                {
                    alt54 = 4;
                }
                else if ( (LA54_1 == ASSIGN) )
                {
                    int LA54_17 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s17 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 17, input);
                    
                        throw nvae_d54s17;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s1 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 1, input);
                
                    throw nvae_d54s1;
                }
                }
                break;
            case USE:
            	{
                int LA54_2 = input.LA(2);
                
                if ( (LA54_2 == ASSIGN) )
                {
                    int LA54_18 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s18 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 18, input);
                    
                        throw nvae_d54s18;
                    }
                }
                else if ( (LA54_2 == EOF || LA54_2 == COMMA || LA54_2 == RPAREN) )
                {
                    alt54 = 4;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s2 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 2, input);
                
                    throw nvae_d54s2;
                }
                }
                break;
            case XML:
            	{
                int LA54_3 = input.LA(2);
                
                if ( (LA54_3 == ASSIGN) )
                {
                    int LA54_22 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s22 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 22, input);
                    
                        throw nvae_d54s22;
                    }
                }
                else if ( (LA54_3 == EOF || LA54_3 == COMMA || LA54_3 == RPAREN) )
                {
                    alt54 = 4;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s3 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 3, input);
                
                    throw nvae_d54s3;
                }
                }
                break;
            case DYNAMIC:
            	{
                int LA54_4 = input.LA(2);
                
                if ( (LA54_4 == EOF || LA54_4 == COMMA || LA54_4 == RPAREN) )
                {
                    alt54 = 4;
                }
                else if ( (LA54_4 == ASSIGN) )
                {
                    int LA54_29 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s29 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 29, input);
                    
                        throw nvae_d54s29;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s4 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 4, input);
                
                    throw nvae_d54s4;
                }
                }
                break;
            case IS:
            	{
                int LA54_5 = input.LA(2);
                
                if ( (LA54_5 == ASSIGN) )
                {
                    int LA54_30 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s30 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 30, input);
                    
                        throw nvae_d54s30;
                    }
                }
                else if ( (LA54_5 == EOF || LA54_5 == COMMA || LA54_5 == RPAREN) )
                {
                    alt54 = 4;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s5 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 5, input);
                
                    throw nvae_d54s5;
                }
                }
                break;
            case AS:
            	{
                int LA54_6 = input.LA(2);
                
                if ( (LA54_6 == EOF || LA54_6 == COMMA || LA54_6 == RPAREN) )
                {
                    alt54 = 4;
                }
                else if ( (LA54_6 == ASSIGN) )
                {
                    int LA54_37 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s37 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 37, input);
                    
                        throw nvae_d54s37;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s6 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 6, input);
                
                    throw nvae_d54s6;
                }
                }
                break;
            case GET:
            	{
                int LA54_7 = input.LA(2);
                
                if ( (LA54_7 == EOF || LA54_7 == COMMA || LA54_7 == RPAREN) )
                {
                    alt54 = 4;
                }
                else if ( (LA54_7 == ASSIGN) )
                {
                    int LA54_41 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s41 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 41, input);
                    
                        throw nvae_d54s41;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s7 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 7, input);
                
                    throw nvae_d54s7;
                }
                }
                break;
            case SET:
            	{
                int LA54_8 = input.LA(2);
                
                if ( (LA54_8 == ASSIGN) )
                {
                    int LA54_42 = input.LA(3);
                    
                    if ( (synpred83()) )
                    {
                        alt54 = 1;
                    }
                    else if ( (synpred84()) )
                    {
                        alt54 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d54s42 =
                            new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 42, input);
                    
                        throw nvae_d54s42;
                    }
                }
                else if ( (LA54_8 == EOF || LA54_8 == COMMA || LA54_8 == RPAREN) )
                {
                    alt54 = 4;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d54s8 =
                        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 8, input);
                
                    throw nvae_d54s8;
                }
                }
                break;
            case STRING_LITERAL:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt54 = 3;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d54s0 =
            	        new NoViableAltException("1088:1: annotationParam : (ide1= ident ASSIGN cn1= constant -> ^( ASSIGN ident constant ) | ide2= ident ASSIGN ide3= ident -> ^( ASSIGN ident ident ) | cn2= constant -> constant | ide4= ident -> ident );", 54, 0, input);
            
            	    throw nvae_d54s0;
            }
            
            switch (alt54) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1090:3: ide1= ident ASSIGN cn1= constant
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam3607);
                    	ide1 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ide1.Tree);
                    	ASSIGN191 = (CommonToken)input.LT(1);
                    	Match(input,ASSIGN,FOLLOW_ASSIGN_in_annotationParam3609); if (failed) return retval;
                    	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN191);

                    	PushFollow(FOLLOW_constant_in_annotationParam3613);
                    	cn1 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(cn1.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)ide1.Tree).Text + "=" + ((CommonTree)cn1.Tree).Text); 
                    	}
                    	
                    	// AST REWRITE
                    	// elements:          ASSIGN, ident, constant
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1090:119: -> ^( ASSIGN ident constant )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1090:122: ^( ASSIGN ident constant )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_ident.Next());
                    	    adaptor.AddChild(root_1, stream_constant.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1091:4: ide2= ident ASSIGN ide3= ident
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam3632);
                    	ide2 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ide2.Tree);
                    	ASSIGN192 = (CommonToken)input.LT(1);
                    	Match(input,ASSIGN,FOLLOW_ASSIGN_in_annotationParam3634); if (failed) return retval;
                    	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN192);

                    	PushFollow(FOLLOW_ident_in_annotationParam3638);
                    	ide3 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ide3.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)ide2.Tree).Text + "=" + ((CommonTree)ide3.Tree).Text); 
                    	}
                    	
                    	// AST REWRITE
                    	// elements:          ASSIGN, ident, ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1091:119: -> ^( ASSIGN ident ident )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1091:122: ^( ASSIGN ident ident )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_ident.Next());
                    	    adaptor.AddChild(root_1, stream_ident.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1092:4: cn2= constant
                    {
                    	PushFollow(FOLLOW_constant_in_annotationParam3657);
                    	cn2 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(cn2.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)cn2.Tree).Text); 
                    	}
                    	
                    	// AST REWRITE
                    	// elements:          constant
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1092:65: -> constant
                    	{
                    	    adaptor.AddChild(root_0, stream_constant.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1093:4: ide4= ident
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam3670);
                    	ide4 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ide4.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)ide4.Tree).Text); 
                    	}
                    	
                    	// AST REWRITE
                    	// elements:          ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1093:65: -> ident
                    	{
                    	    adaptor.AddChild(root_0, stream_ident.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 73, annotationParam_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParam

    public class modifiers_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifiers
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1097:1: modifiers : ( modifier )* -> ^( MODIFIERS ( modifier )* ) ;
    public modifiers_return modifiers() // throws RecognitionException [1]
    {   
        modifiers_return retval = new modifiers_return();
        retval.start = input.LT(1);
        int modifiers_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifier_return modifier193 = null;
        
        
        RewriteRuleSubtreeStream stream_modifier = new RewriteRuleSubtreeStream(adaptor,"rule modifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 74) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1098:4: ( ( modifier )* -> ^( MODIFIERS ( modifier )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1098:4: ( modifier )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1098:4: ( modifier )*
            	do 
            	{
            	    int alt55 = 2;
            	    int LA55_0 = input.LA(1);
            	    
            	    if ( ((LA55_0 >= IDENT && LA55_0 <= INTERNAL) || (LA55_0 >= STATIC && LA55_0 <= DYNAMIC) || (LA55_0 >= 180 && LA55_0 <= 184)) )
            	    {
            	        alt55 = 1;
            	    }
            	    
            	
            	    switch (alt55) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: modifier
            			    {
            			    	PushFollow(FOLLOW_modifier_in_modifiers3690);
            			    	modifier193 = modifier();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_modifier.Add(modifier193.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop55;
            	    }
            	} while (true);
            	
            	loop55:
            		;	// Stops C# compiler whinging that label 'loop55' has no statements

            	
            	// AST REWRITE
            	// elements:          modifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1099:3: -> ^( MODIFIERS ( modifier )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1099:6: ^( MODIFIERS ( modifier )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MODIFIERS, "MODIFIERS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1099:18: ( modifier )*
            	    while ( stream_modifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_modifier.Next());
            	    
            	    }
            	    stream_modifier.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 74, modifiers_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifiers

    public class modifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1102:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
    public modifier_return modifier() // throws RecognitionException [1]
    {   
        modifier_return retval = new modifier_return();
        retval.start = input.LT(1);
        int modifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken STATIC195 = null;
        CommonToken string_literal196 = null;
        CommonToken string_literal197 = null;
        CommonToken string_literal198 = null;
        CommonToken string_literal199 = null;
        CommonToken DYNAMIC200 = null;
        CommonToken string_literal201 = null;
        namespaceName_return namespaceName194 = null;
        
        
        CommonTree STATIC195_tree=null;
        CommonTree string_literal196_tree=null;
        CommonTree string_literal197_tree=null;
        CommonTree string_literal198_tree=null;
        CommonTree string_literal199_tree=null;
        CommonTree DYNAMIC200_tree=null;
        CommonTree string_literal201_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 75) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1103:4: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
            int alt56 = 8;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            	{
                alt56 = 1;
                }
                break;
            case STATIC:
            	{
                alt56 = 2;
                }
                break;
            case 180:
            	{
                alt56 = 3;
                }
                break;
            case 181:
            	{
                alt56 = 4;
                }
                break;
            case 182:
            	{
                alt56 = 5;
                }
                break;
            case 183:
            	{
                alt56 = 6;
                }
                break;
            case DYNAMIC:
            	{
                alt56 = 7;
                }
                break;
            case 184:
            	{
                alt56 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d56s0 =
            	        new NoViableAltException("1102:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );", 56, 0, input);
            
            	    throw nvae_d56s0;
            }
            
            switch (alt56) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1103:4: namespaceName
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_namespaceName_in_modifier3713);
                    	namespaceName194 = namespaceName();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceName194.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1104:4: STATIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STATIC195 = (CommonToken)input.LT(1);
                    	Match(input,STATIC,FOLLOW_STATIC_in_modifier3718); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STATIC195_tree = (CommonTree)adaptor.Create(STATIC195);
                    	adaptor.AddChild(root_0, STATIC195_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1105:4: 'final'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal196 = (CommonToken)input.LT(1);
                    	Match(input,180,FOLLOW_180_in_modifier3723); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal196_tree = (CommonTree)adaptor.Create(string_literal196);
                    	adaptor.AddChild(root_0, string_literal196_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1106:4: 'enumerable'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal197 = (CommonToken)input.LT(1);
                    	Match(input,181,FOLLOW_181_in_modifier3728); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal197_tree = (CommonTree)adaptor.Create(string_literal197);
                    	adaptor.AddChild(root_0, string_literal197_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1107:4: 'explicit'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal198 = (CommonToken)input.LT(1);
                    	Match(input,182,FOLLOW_182_in_modifier3733); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal198_tree = (CommonTree)adaptor.Create(string_literal198);
                    	adaptor.AddChild(root_0, string_literal198_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1108:4: 'override'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal199 = (CommonToken)input.LT(1);
                    	Match(input,183,FOLLOW_183_in_modifier3738); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal199_tree = (CommonTree)adaptor.Create(string_literal199);
                    	adaptor.AddChild(root_0, string_literal199_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1109:4: DYNAMIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	DYNAMIC200 = (CommonToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_modifier3743); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	DYNAMIC200_tree = (CommonTree)adaptor.Create(DYNAMIC200);
                    	adaptor.AddChild(root_0, DYNAMIC200_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1110:4: 'intrinsic'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal201 = (CommonToken)input.LT(1);
                    	Match(input,184,FOLLOW_184_in_modifier3748); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal201_tree = (CommonTree)adaptor.Create(string_literal201);
                    	adaptor.AddChild(root_0, string_literal201_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 75, modifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifier

    public class arguments_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arguments
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1113:1: arguments : ( LPAREN expressionList RPAREN | LPAREN RPAREN );
    public arguments_return arguments() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        arguments_return retval = new arguments_return();
        retval.start = input.LT(1);
        int arguments_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LPAREN202 = null;
        CommonToken RPAREN204 = null;
        CommonToken LPAREN205 = null;
        CommonToken RPAREN206 = null;
        expressionList_return expressionList203 = null;
        
        
        CommonTree LPAREN202_tree=null;
        CommonTree RPAREN204_tree=null;
        CommonTree LPAREN205_tree=null;
        CommonTree RPAREN206_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 76) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1118:4: ( LPAREN expressionList RPAREN | LPAREN RPAREN )
            int alt57 = 2;
            int LA57_0 = input.LA(1);
            
            if ( (LA57_0 == LPAREN) )
            {
                int LA57_1 = input.LA(2);
                
                if ( (LA57_1 == RPAREN) )
                {
                    alt57 = 2;
                }
                else if ( (LA57_1 == LCURLY || (LA57_1 >= STRING_LITERAL && LA57_1 <= SET) || LA57_1 == LPAREN || LA57_1 == VOID || LA57_1 == IDENT || LA57_1 == LBRACK || LA57_1 == DYNAMIC || (LA57_1 >= IS && LA57_1 <= AS) || (LA57_1 >= PLUS && LA57_1 <= MINUS) || (LA57_1 >= INC && LA57_1 <= NEW) || (LA57_1 >= USE && LA57_1 <= XML)) )
                {
                    alt57 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d57s1 =
                        new NoViableAltException("1113:1: arguments : ( LPAREN expressionList RPAREN | LPAREN RPAREN );", 57, 1, input);
                
                    throw nvae_d57s1;
                }
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d57s0 =
                    new NoViableAltException("1113:1: arguments : ( LPAREN expressionList RPAREN | LPAREN RPAREN );", 57, 0, input);
            
                throw nvae_d57s0;
            }
            switch (alt57) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1118:4: LPAREN expressionList RPAREN
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LPAREN202 = (CommonToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3769); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LPAREN202_tree = (CommonTree)adaptor.Create(LPAREN202);
                    	adaptor.AddChild(root_0, LPAREN202_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("("); 
                    	}
                    	PushFollow(FOLLOW_expressionList_in_arguments3773);
                    	expressionList203 = expressionList();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList203.Tree);
                    	RPAREN204 = (CommonToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3775); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	RPAREN204_tree = (CommonTree)adaptor.Create(RPAREN204);
                    	adaptor.AddChild(root_0, RPAREN204_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(")");  
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1119:4: LPAREN RPAREN
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LPAREN205 = (CommonToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3782); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LPAREN205_tree = (CommonTree)adaptor.Create(LPAREN205);
                    	adaptor.AddChild(root_0, LPAREN205_tree);
                    	}
                    	RPAREN206 = (CommonToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3784); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	RPAREN206_tree = (CommonTree)adaptor.Create(RPAREN206);
                    	adaptor.AddChild(root_0, RPAREN206_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append("()"); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 76, arguments_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end arguments

    public class element_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start element
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1123:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
    public element_return element() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        element_return retval = new element_return();
        retval.start = input.LT(1);
        int element_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression207 = null;
        
        
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 77) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1128:4: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1128:4: assignmentExpression
            {
            	PushFollow(FOLLOW_assignmentExpression_in_element3810);
            	assignmentExpression207 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression207.Tree);
            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1129:3: -> ^( ELEMENT assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1129:6: ^( ELEMENT assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELEMENT, "ELEMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 77, element_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end element

    public class arrayLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arrayLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1133:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) ;
    public arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {   
        arrayLiteral_return retval = new arrayLiteral_return();
        retval.start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LBRACK208 = null;
        CommonToken RBRACK210 = null;
        elementList_return elementList209 = null;
        
        
        CommonTree LBRACK208_tree=null;
        CommonTree RBRACK210_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_elementList = new RewriteRuleSubtreeStream(adaptor,"rule elementList");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 78) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1134:4: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1134:4: LBRACK ( elementList )? RBRACK
            {
            	LBRACK208 = (CommonToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_arrayLiteral3832); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK208);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("["); 
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1134:35: ( elementList )?
            	int alt58 = 2;
            	int LA58_0 = input.LA(1);
            	
            	if ( (LA58_0 == LCURLY || (LA58_0 >= STRING_LITERAL && LA58_0 <= SET) || LA58_0 == LPAREN || LA58_0 == VOID || LA58_0 == IDENT || LA58_0 == LBRACK || LA58_0 == DYNAMIC || (LA58_0 >= IS && LA58_0 <= AS) || (LA58_0 >= PLUS && LA58_0 <= MINUS) || (LA58_0 >= INC && LA58_0 <= NEW) || (LA58_0 >= USE && LA58_0 <= XML)) )
            	{
            	    alt58 = 1;
            	}
            	switch (alt58) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: elementList
            	        {
            	        	PushFollow(FOLLOW_elementList_in_arrayLiteral3836);
            	        	elementList209 = elementList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_elementList.Add(elementList209.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK210 = (CommonToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_arrayLiteral3839); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK210);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("]"); 
            	}
            	
            	// AST REWRITE
            	// elements:          elementList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1135:3: -> ^( ARRAY_LITERAL ( elementList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1135:6: ^( ARRAY_LITERAL ( elementList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1135:22: ( elementList )?
            	    if ( stream_elementList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_elementList.Next());
            	    
            	    }
            	    stream_elementList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 78, arrayLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end arrayLiteral

    public class elementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1138:1: elementList : nonemptyElementList ( COMMA ( nonemptyElementList )? )* ;
    public elementList_return elementList() // throws RecognitionException [1]
    {   
        elementList_return retval = new elementList_return();
        retval.start = input.LT(1);
        int elementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA212 = null;
        nonemptyElementList_return nonemptyElementList211 = null;

        nonemptyElementList_return nonemptyElementList213 = null;
        
        
        CommonTree COMMA212_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 79) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1139:4: ( nonemptyElementList ( COMMA ( nonemptyElementList )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1139:4: nonemptyElementList ( COMMA ( nonemptyElementList )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_nonemptyElementList_in_elementList3863);
            	nonemptyElementList211 = nonemptyElementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList211.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1140:3: ( COMMA ( nonemptyElementList )? )*
            	do 
            	{
            	    int alt60 = 2;
            	    int LA60_0 = input.LA(1);
            	    
            	    if ( (LA60_0 == COMMA) )
            	    {
            	        alt60 = 1;
            	    }
            	    
            	
            	    switch (alt60) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1141:4: COMMA ( nonemptyElementList )?
            			    {
            			    	COMMA212 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_elementList3873); if (failed) return retval;
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            			    	}
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1142:4: ( nonemptyElementList )?
            			    	int alt59 = 2;
            			    	int LA59_0 = input.LA(1);
            			    	
            			    	if ( (LA59_0 == LCURLY || (LA59_0 >= STRING_LITERAL && LA59_0 <= SET) || LA59_0 == LPAREN || LA59_0 == VOID || LA59_0 == IDENT || LA59_0 == LBRACK || LA59_0 == DYNAMIC || (LA59_0 >= IS && LA59_0 <= AS) || (LA59_0 >= PLUS && LA59_0 <= MINUS) || (LA59_0 >= INC && LA59_0 <= NEW) || (LA59_0 >= USE && LA59_0 <= XML)) )
            			    	{
            			    	    alt59 = 1;
            			    	}
            			    	switch (alt59) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: nonemptyElementList
            			    	        {
            			    	        	PushFollow(FOLLOW_nonemptyElementList_in_elementList3886);
            			    	        	nonemptyElementList213 = nonemptyElementList();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList213.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop60;
            	    }
            	} while (true);
            	
            	loop60:
            		;	// Stops C# compiler whinging that label 'loop60' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 79, elementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elementList

    public class nonemptyElementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start nonemptyElementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1146:1: nonemptyElementList : assignmentExpression ( COMMA assignmentExpression )* ;
    public nonemptyElementList_return nonemptyElementList() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        nonemptyElementList_return retval = new nonemptyElementList_return();
        retval.start = input.LT(1);
        int nonemptyElementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA215 = null;
        assignmentExpression_return assignmentExpression214 = null;

        assignmentExpression_return assignmentExpression216 = null;
        
        
        CommonTree COMMA215_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 80) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1151:4: ( assignmentExpression ( COMMA assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1151:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3914);
            	assignmentExpression214 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression214.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1152:3: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt61 = 2;
            	    int LA61_0 = input.LA(1);
            	    
            	    if ( (LA61_0 == COMMA) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA61_4 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA61_5 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA61_6 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA61_7 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA61_8 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA61_9 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA61_10 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA61_11 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA61_12 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA61_13 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA61_14 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA61_15 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA61_16 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA61_17 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA61_18 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA61_19 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA61_20 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA61_21 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA61_22 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA61_23 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA61_24 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA61_25 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA61_26 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA61_27 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA61_28 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA61_29 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA61_30 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA61_31 = input.LA(3);
            	            
            	            if ( (synpred98()) )
            	            {
            	                alt61 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt61) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1153:4: COMMA assignmentExpression
            			    {
            			    	COMMA215 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_nonemptyElementList3924); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	COMMA215_tree = (CommonTree)adaptor.Create(COMMA215);
            			    	adaptor.AddChild(root_0, COMMA215_tree);
            			    	}
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3936);
            			    	assignmentExpression216 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression216.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop61;
            	    }
            	} while (true);
            	
            	loop61:
            		;	// Stops C# compiler whinging that label 'loop61' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 80, nonemptyElementList_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end nonemptyElementList

    public class objectLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start objectLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1159:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
    public objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {   
        objectLiteral_return retval = new objectLiteral_return();
        retval.start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LCURLY217 = null;
        CommonToken RCURLY219 = null;
        fieldList_return fieldList218 = null;
        
        
        CommonTree LCURLY217_tree=null;
        CommonTree RCURLY219_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_fieldList = new RewriteRuleSubtreeStream(adaptor,"rule fieldList");
        
        	int next_token = -1;
        	
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 81) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1163:4: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1163:4: LCURLY ( fieldList )? RCURLY
            {
            	LCURLY217 = (CommonToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_objectLiteral3958); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY217);

            	if ( backtracking == 0 ) 
            	{
            	   
            	  							buffer.Append("{"); 
            	  							next_token = input.LA(1);
            	  							if(next_token != ASLexer.RCURLY && options.NewlineBetweenFields)
            	  							{
            	  								CurrentTab++;
            	  								buffer.Append(NewLine + tab);
            	  							}
            	  						
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1172:3: ( fieldList )?
            	int alt62 = 2;
            	int LA62_0 = input.LA(1);
            	
            	if ( ((LA62_0 >= GET && LA62_0 <= SET) || LA62_0 == IDENT || LA62_0 == DYNAMIC || (LA62_0 >= IS && LA62_0 <= AS) || (LA62_0 >= HEX_LITERAL && LA62_0 <= FLOAT_LITERAL) || (LA62_0 >= USE && LA62_0 <= XML)) )
            	{
            	    alt62 = 1;
            	}
            	switch (alt62) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: fieldList
            	        {
            	        	PushFollow(FOLLOW_fieldList_in_objectLiteral3967);
            	        	fieldList218 = fieldList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_fieldList.Add(fieldList218.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY219 = (CommonToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_objectLiteral3973); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY219);

            	if ( backtracking == 0 ) 
            	{
            	   
            	  							if(next_token != ASLexer.RCURLY && options.NewlineBetweenFields)
            	  							{
            	  								CurrentTab--;
            	  								buffer.Append(NewLine + tab);
            	  							}
            	  							buffer.Append("}"); 
            	  						
            	}
            	
            	// AST REWRITE
            	// elements:          fieldList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1181:3: -> ^( OBJECT_LITERAL ( fieldList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1181:6: ^( OBJECT_LITERAL ( fieldList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1181:23: ( fieldList )?
            	    if ( stream_fieldList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_fieldList.Next());
            	    
            	    }
            	    stream_fieldList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 81, objectLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end objectLiteral

    public class fieldList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1184:1: fieldList : literalField ( COMMA ( literalField )? )* ;
    public fieldList_return fieldList() // throws RecognitionException [1]
    {   
        fieldList_return retval = new fieldList_return();
        retval.start = input.LT(1);
        int fieldList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA221 = null;
        literalField_return literalField220 = null;

        literalField_return literalField222 = null;
        
        
        CommonTree COMMA221_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 82) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1185:4: ( literalField ( COMMA ( literalField )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1185:4: literalField ( COMMA ( literalField )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_literalField_in_fieldList4000);
            	literalField220 = literalField();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField220.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1186:3: ( COMMA ( literalField )? )*
            	do 
            	{
            	    int alt64 = 2;
            	    int LA64_0 = input.LA(1);
            	    
            	    if ( (LA64_0 == COMMA) )
            	    {
            	        alt64 = 1;
            	    }
            	    
            	
            	    switch (alt64) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1187:4: COMMA ( literalField )?
            			    {
            			    	COMMA221 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_fieldList4010); if (failed) return retval;
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	  
            			    	  											if(options.NewlineBetweenFields)
            			    	  											{
            			    	  												buffer.Append("," + NewLine + tab);
            			    	  											} else 
            			    	  											{ 
            			    	  												buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            			    	  											}
            			    	  										
            			    	}
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1196:4: ( literalField )?
            			    	int alt63 = 2;
            			    	int LA63_0 = input.LA(1);
            			    	
            			    	if ( ((LA63_0 >= GET && LA63_0 <= SET) || LA63_0 == IDENT || LA63_0 == DYNAMIC || (LA63_0 >= IS && LA63_0 <= AS) || (LA63_0 >= HEX_LITERAL && LA63_0 <= FLOAT_LITERAL) || (LA63_0 >= USE && LA63_0 <= XML)) )
            			    	{
            			    	    alt63 = 1;
            			    	}
            			    	switch (alt63) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: literalField
            			    	        {
            			    	        	PushFollow(FOLLOW_literalField_in_fieldList4024);
            			    	        	literalField222 = literalField();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField222.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop64;
            	    }
            	} while (true);
            	
            	loop64:
            		;	// Stops C# compiler whinging that label 'loop64' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 82, fieldList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldList

    public class literalField_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start literalField
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1200:1: literalField : field= fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
    public literalField_return literalField() // throws RecognitionException [1]
    {   
        literalField_return retval = new literalField_return();
        retval.start = input.LT(1);
        int literalField_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COLON223 = null;
        fieldName_return field = null;

        element_return element224 = null;
        
        
        CommonTree COLON223_tree=null;
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_element = new RewriteRuleSubtreeStream(adaptor,"rule element");
        RewriteRuleSubtreeStream stream_fieldName = new RewriteRuleSubtreeStream(adaptor,"rule fieldName");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 83) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1201:5: (field= fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1201:5: field= fieldName COLON element
            {
            	PushFollow(FOLLOW_fieldName_in_literalField4046);
            	field = fieldName();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_fieldName.Add(field.Tree);
            	COLON223 = (CommonToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_literalField4051); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(COLON223);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append( options.SpaceBetweenType ? " : " : ":"); 
            	}
            	PushFollow(FOLLOW_element_in_literalField4059);
            	element224 = element();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_element.Add(element224.Tree);
            	
            	// AST REWRITE
            	// elements:          fieldName, element
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1204:3: -> ^( OBJECT_FIELD fieldName element )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1204:6: ^( OBJECT_FIELD fieldName element )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_fieldName.Next());
            	    adaptor.AddChild(root_1, stream_element.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 83, literalField_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end literalField

    public class fieldName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1207:1: fieldName : (ide= ident | num= number );
    public fieldName_return fieldName() // throws RecognitionException [1]
    {   
        fieldName_return retval = new fieldName_return();
        retval.start = input.LT(1);
        int fieldName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ide = null;

        number_return num = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 84) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1208:4: (ide= ident | num= number )
            int alt65 = 2;
            int LA65_0 = input.LA(1);
            
            if ( ((LA65_0 >= GET && LA65_0 <= SET) || LA65_0 == IDENT || LA65_0 == DYNAMIC || (LA65_0 >= IS && LA65_0 <= AS) || (LA65_0 >= USE && LA65_0 <= XML)) )
            {
                alt65 = 1;
            }
            else if ( ((LA65_0 >= HEX_LITERAL && LA65_0 <= FLOAT_LITERAL)) )
            {
                alt65 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d65s0 =
                    new NoViableAltException("1207:1: fieldName : (ide= ident | num= number );", 65, 0, input);
            
                throw nvae_d65s0;
            }
            switch (alt65) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1208:4: ide= ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_fieldName4085);
                    	ide = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ide.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)ide.Tree).Text ); 
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1209:4: num= number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_fieldName4095);
                    	num = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, num.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)num.Tree).Text); 
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 84, fieldName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldName

    public class expression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1213:1: expression : assignmentExpression ;
    public expression_return expression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expression_return retval = new expression_return();
        retval.start = input.LT(1);
        int expression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression225 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 85) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1218:4: ( assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1218:4: assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_expression4120);
            	assignmentExpression225 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression225.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 85, expression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expression

    public class expressionList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1222:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) ;
    public expressionList_return expressionList() // throws RecognitionException [1]
    {   
        expressionList_return retval = new expressionList_return();
        retval.start = input.LT(1);
        int expressionList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COMMA227 = null;
        assignmentExpression_return assignmentExpression226 = null;

        assignmentExpression_return assignmentExpression228 = null;
        
        
        CommonTree COMMA227_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 86) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1223:4: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1223:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	PushFollow(FOLLOW_assignmentExpression_in_expressionList4132);
            	assignmentExpression226 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression226.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1224:3: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt66 = 2;
            	    int LA66_0 = input.LA(1);
            	    
            	    if ( (LA66_0 == COMMA) )
            	    {
            	        alt66 = 1;
            	    }
            	    
            	
            	    switch (alt66) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1225:4: COMMA assignmentExpression
            			    {
            			    	COMMA227 = (CommonToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_expressionList4142); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA227);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	  buffer.Append(options.SpaceBetweenArguments ? ", " : ","); 
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_expressionList4154);
            			    	assignmentExpression228 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression228.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop66;
            	    }
            	} while (true);
            	
            	loop66:
            		;	// Stops C# compiler whinging that label 'loop66' has no statements

            	
            	// AST REWRITE
            	// elements:          assignmentExpression, assignmentExpression, COMMA
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1227:6: -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1227:9: ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELIST, "ELIST"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1227:38: ( COMMA assignmentExpression )*
            	    while ( stream_assignmentExpression.HasNext() || stream_COMMA.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_COMMA.Next());
            	        adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    }
            	    stream_assignmentExpression.Reset();
            	    stream_COMMA.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 86, expressionList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end expressionList

    public class assignmentExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1231:1: assignmentExpression : c= conditionalExpression ( ( assignmentOperator )=>op= assignmentOperator assignmentExpression )* ;
    public assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {   
        assignmentExpression_return retval = new assignmentExpression_return();
        retval.start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        conditionalExpression_return c = null;

        assignmentOperator_return op = null;

        assignmentExpression_return assignmentExpression229 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 87) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1232:4: (c= conditionalExpression ( ( assignmentOperator )=>op= assignmentOperator assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1232:4: c= conditionalExpression ( ( assignmentOperator )=>op= assignmentOperator assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression4188);
            	c = conditionalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1233:2: ( ( assignmentOperator )=>op= assignmentOperator assignmentExpression )*
            	do 
            	{
            	    int alt67 = 2;
            	    int LA67_0 = input.LA(1);
            	    
            	    if ( (LA67_0 == ASSIGN || (LA67_0 >= STAR_ASSIGN && LA67_0 <= LOR_ASSIGN)) )
            	    {
            	        int LA67_64 = input.LA(2);
            	        
            	        if ( (synpred104()) )
            	        {
            	            alt67 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt67) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1233:4: ( assignmentOperator )=>op= assignmentOperator assignmentExpression
            			    {
            			    	PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression4203);
            			    	op = assignmentOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, op.Tree);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  														if(options.SpaceBetweenAssign) buffer.Append(" ");
            			    	  														buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  														if(options.SpaceBetweenAssign) buffer.Append(" "); 
            			    	  													
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression4223);
            			    	assignmentExpression229 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression229.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop67;
            	    }
            	} while (true);
            	
            	loop67:
            		;	// Stops C# compiler whinging that label 'loop67' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 87, assignmentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentExpression

    public class assignmentOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1243:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
    public assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {   
        assignmentOperator_return retval = new assignmentOperator_return();
        retval.start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set230 = null;
        
        CommonTree set230_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 88) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1244:4: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set230 = (CommonToken)input.LT(1);
            	if ( input.LA(1) == ASSIGN || (input.LA(1) >= STAR_ASSIGN && input.LA(1) <= LOR_ASSIGN) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set230));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_assignmentOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 88, assignmentOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentOperator

    public class conditionalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1261:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
    public conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {   
        conditionalExpression_return retval = new conditionalExpression_return();
        retval.start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken QUESTION232 = null;
        logicalOrExpression_return logicalOrExpression231 = null;

        conditionalSubExpression_return conditionalSubExpression233 = null;
        
        
        CommonTree QUESTION232_tree=null;
        RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream(adaptor,"token QUESTION");
        RewriteRuleSubtreeStream stream_logicalOrExpression = new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
        RewriteRuleSubtreeStream stream_conditionalSubExpression = new RewriteRuleSubtreeStream(adaptor,"rule conditionalSubExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 89) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1262:4: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1262:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1262:4: ( logicalOrExpression -> logicalOrExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1262:5: logicalOrExpression
            	{
            		PushFollow(FOLLOW_logicalOrExpression_in_conditionalExpression4317);
            		logicalOrExpression231 = logicalOrExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_logicalOrExpression.Add(logicalOrExpression231.Tree);
            		
            		// AST REWRITE
            		// elements:          logicalOrExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 1262:25: -> logicalOrExpression
            		{
            		    adaptor.AddChild(root_0, stream_logicalOrExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1263:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            	int alt68 = 2;
            	int LA68_0 = input.LA(1);
            	
            	if ( (LA68_0 == QUESTION) )
            	{
            	    alt68 = 1;
            	}
            	switch (alt68) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1264:4: QUESTION conditionalSubExpression
            	        {
            	        	QUESTION232 = (CommonToken)input.LT(1);
            	        	Match(input,QUESTION,FOLLOW_QUESTION_in_conditionalExpression4331); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_QUESTION.Add(QUESTION232);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   
            	        	  							if(options.SpaceBetweenOperators) buffer.Append(" ");
            	        	  							buffer.Append("?"); 
            	        	  							if(options.SpaceBetweenOperators) buffer.Append(" "); 
            	        	  						
            	        	}
            	        	PushFollow(FOLLOW_conditionalSubExpression_in_conditionalExpression4338);
            	        	conditionalSubExpression233 = conditionalSubExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_conditionalSubExpression.Add(conditionalSubExpression233.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          conditionalSubExpression, QUESTION, conditionalExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 1270:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1270:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    adaptor.AddChild(root_1, stream_conditionalSubExpression.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 89, conditionalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalExpression

    public class conditionalSubExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalSubExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1273:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
    public conditionalSubExpression_return conditionalSubExpression() // throws RecognitionException [1]
    {   
        conditionalSubExpression_return retval = new conditionalSubExpression_return();
        retval.start = input.LT(1);
        int conditionalSubExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken COLON235 = null;
        assignmentExpression_return assignmentExpression234 = null;

        assignmentExpression_return assignmentExpression236 = null;
        
        
        CommonTree COLON235_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 90) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1274:4: ( assignmentExpression COLON assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1274:4: assignmentExpression COLON assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression4367);
            	assignmentExpression234 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression234.Tree);
            	COLON235 = (CommonToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_conditionalSubExpression4372); if (failed) return retval;
            	if ( backtracking==0 ) {
            	COLON235_tree = (CommonTree)adaptor.Create(COLON235);
            	root_0 = (CommonTree)adaptor.BecomeRoot(COLON235_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(options.SpaceBetweenOperators ? " : " : ":"); 
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression4381);
            	assignmentExpression236 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression236.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 90, conditionalSubExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalSubExpression

    public class logicalOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1282:1: logicalOrExpression : logicalAndExpression (op= logicalOrOperator logicalAndExpression )* ;
    public logicalOrExpression_return logicalOrExpression() // throws RecognitionException [1]
    {   
        logicalOrExpression_return retval = new logicalOrExpression_return();
        retval.start = input.LT(1);
        int logicalOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        logicalOrOperator_return op = null;

        logicalAndExpression_return logicalAndExpression237 = null;

        logicalAndExpression_return logicalAndExpression238 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 91) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1283:4: ( logicalAndExpression (op= logicalOrOperator logicalAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1283:4: logicalAndExpression (op= logicalOrOperator logicalAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression4395);
            	logicalAndExpression237 = logicalAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression237.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1284:3: (op= logicalOrOperator logicalAndExpression )*
            	do 
            	{
            	    int alt69 = 2;
            	    int LA69_0 = input.LA(1);
            	    
            	    if ( (LA69_0 == LOR || LA69_0 == 185) )
            	    {
            	        alt69 = 1;
            	    }
            	    
            	
            	    switch (alt69) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1285:4: op= logicalOrOperator logicalAndExpression
            			    {
            			    	PushFollow(FOLLOW_logicalOrOperator_in_logicalOrExpression4406);
            			    	op = logicalOrOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  														buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  													
            			    	}
            			    	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression4418);
            			    	logicalAndExpression238 = logicalAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression238.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop69;
            	    }
            	} while (true);
            	
            	loop69:
            		;	// Stops C# compiler whinging that label 'loop69' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 91, logicalOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrExpression

    public class logicalOrOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1294:1: logicalOrOperator : ( LOR | 'or' );
    public logicalOrOperator_return logicalOrOperator() // throws RecognitionException [1]
    {   
        logicalOrOperator_return retval = new logicalOrOperator_return();
        retval.start = input.LT(1);
        int logicalOrOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set239 = null;
        
        CommonTree set239_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 92) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1295:4: ( LOR | 'or' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set239 = (CommonToken)input.LT(1);
            	if ( input.LA(1) == LOR || input.LA(1) == 185 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set239));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalOrOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 92, logicalOrOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrOperator

    public class logicalAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1299:1: logicalAndExpression : bitwiseOrExpression (op= logicalAndOperator bitwiseOrExpression )* ;
    public logicalAndExpression_return logicalAndExpression() // throws RecognitionException [1]
    {   
        logicalAndExpression_return retval = new logicalAndExpression_return();
        retval.start = input.LT(1);
        int logicalAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        logicalAndOperator_return op = null;

        bitwiseOrExpression_return bitwiseOrExpression240 = null;

        bitwiseOrExpression_return bitwiseOrExpression241 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 93) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1300:4: ( bitwiseOrExpression (op= logicalAndOperator bitwiseOrExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1300:4: bitwiseOrExpression (op= logicalAndOperator bitwiseOrExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression4450);
            	bitwiseOrExpression240 = bitwiseOrExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression240.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1301:3: (op= logicalAndOperator bitwiseOrExpression )*
            	do 
            	{
            	    int alt70 = 2;
            	    int LA70_0 = input.LA(1);
            	    
            	    if ( (LA70_0 == LAND || LA70_0 == 186) )
            	    {
            	        alt70 = 1;
            	    }
            	    
            	
            	    switch (alt70) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1302:4: op= logicalAndOperator bitwiseOrExpression
            			    {
            			    	PushFollow(FOLLOW_logicalAndOperator_in_logicalAndExpression4461);
            			    	op = logicalAndOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  														buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  													
            			    	}
            			    	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression4473);
            			    	bitwiseOrExpression241 = bitwiseOrExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression241.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop70;
            	    }
            	} while (true);
            	
            	loop70:
            		;	// Stops C# compiler whinging that label 'loop70' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 93, logicalAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndExpression

    public class logicalAndOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1311:1: logicalAndOperator : ( LAND | 'and' );
    public logicalAndOperator_return logicalAndOperator() // throws RecognitionException [1]
    {   
        logicalAndOperator_return retval = new logicalAndOperator_return();
        retval.start = input.LT(1);
        int logicalAndOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set242 = null;
        
        CommonTree set242_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 94) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1312:4: ( LAND | 'and' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set242 = (CommonToken)input.LT(1);
            	if ( input.LA(1) == LAND || input.LA(1) == 186 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set242));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalAndOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 94, logicalAndOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndOperator

    public class bitwiseOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1316:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
    public bitwiseOrExpression_return bitwiseOrExpression() // throws RecognitionException [1]
    {   
        bitwiseOrExpression_return retval = new bitwiseOrExpression_return();
        retval.start = input.LT(1);
        int bitwiseOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken BOR244 = null;
        bitwiseXorExpression_return bitwiseXorExpression243 = null;

        bitwiseXorExpression_return bitwiseXorExpression245 = null;
        
        
        CommonTree BOR244_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 95) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1317:4: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1317:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression4505);
            	bitwiseXorExpression243 = bitwiseXorExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression243.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1318:3: ( BOR bitwiseXorExpression )*
            	do 
            	{
            	    int alt71 = 2;
            	    int LA71_0 = input.LA(1);
            	    
            	    if ( (LA71_0 == BOR) )
            	    {
            	        alt71 = 1;
            	    }
            	    
            	
            	    switch (alt71) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1318:4: BOR bitwiseXorExpression
            			    {
            			    	BOR244 = (CommonToken)input.LT(1);
            			    	Match(input,BOR,FOLLOW_BOR_in_bitwiseOrExpression4510); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BOR244_tree = (CommonTree)adaptor.Create(BOR244);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BOR244_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression4513);
            			    	bitwiseXorExpression245 = bitwiseXorExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression245.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop71;
            	    }
            	} while (true);
            	
            	loop71:
            		;	// Stops C# compiler whinging that label 'loop71' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 95, bitwiseOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseOrExpression

    public class bitwiseXorExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseXorExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1322:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
    public bitwiseXorExpression_return bitwiseXorExpression() // throws RecognitionException [1]
    {   
        bitwiseXorExpression_return retval = new bitwiseXorExpression_return();
        retval.start = input.LT(1);
        int bitwiseXorExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken BXOR247 = null;
        bitwiseAndExpression_return bitwiseAndExpression246 = null;

        bitwiseAndExpression_return bitwiseAndExpression248 = null;
        
        
        CommonTree BXOR247_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 96) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1323:4: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1323:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression4527);
            	bitwiseAndExpression246 = bitwiseAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression246.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1324:3: ( BXOR bitwiseAndExpression )*
            	do 
            	{
            	    int alt72 = 2;
            	    int LA72_0 = input.LA(1);
            	    
            	    if ( (LA72_0 == BXOR) )
            	    {
            	        alt72 = 1;
            	    }
            	    
            	
            	    switch (alt72) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1324:4: BXOR bitwiseAndExpression
            			    {
            			    	BXOR247 = (CommonToken)input.LT(1);
            			    	Match(input,BXOR,FOLLOW_BXOR_in_bitwiseXorExpression4532); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BXOR247_tree = (CommonTree)adaptor.Create(BXOR247);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BXOR247_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression4535);
            			    	bitwiseAndExpression248 = bitwiseAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression248.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop72;
            	    }
            	} while (true);
            	
            	loop72:
            		;	// Stops C# compiler whinging that label 'loop72' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 96, bitwiseXorExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseXorExpression

    public class bitwiseAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1328:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
    public bitwiseAndExpression_return bitwiseAndExpression() // throws RecognitionException [1]
    {   
        bitwiseAndExpression_return retval = new bitwiseAndExpression_return();
        retval.start = input.LT(1);
        int bitwiseAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken BAND250 = null;
        equalityExpression_return equalityExpression249 = null;

        equalityExpression_return equalityExpression251 = null;
        
        
        CommonTree BAND250_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 97) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1329:4: ( equalityExpression ( BAND equalityExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1329:4: equalityExpression ( BAND equalityExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression4549);
            	equalityExpression249 = equalityExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression249.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1330:3: ( BAND equalityExpression )*
            	do 
            	{
            	    int alt73 = 2;
            	    int LA73_0 = input.LA(1);
            	    
            	    if ( (LA73_0 == BAND) )
            	    {
            	        alt73 = 1;
            	    }
            	    
            	
            	    switch (alt73) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1330:4: BAND equalityExpression
            			    {
            			    	BAND250 = (CommonToken)input.LT(1);
            			    	Match(input,BAND,FOLLOW_BAND_in_bitwiseAndExpression4554); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BAND250_tree = (CommonTree)adaptor.Create(BAND250);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BAND250_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression4557);
            			    	equalityExpression251 = equalityExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression251.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop73;
            	    }
            	} while (true);
            	
            	loop73:
            		;	// Stops C# compiler whinging that label 'loop73' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 97, bitwiseAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseAndExpression

    public class equalityExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1334:1: equalityExpression : relationalExpression (op= equalityOperator relationalExpression )* ;
    public equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {   
        equalityExpression_return retval = new equalityExpression_return();
        retval.start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        equalityOperator_return op = null;

        relationalExpression_return relationalExpression252 = null;

        relationalExpression_return relationalExpression253 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 98) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1335:4: ( relationalExpression (op= equalityOperator relationalExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1335:4: relationalExpression (op= equalityOperator relationalExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_relationalExpression_in_equalityExpression4571);
            	relationalExpression252 = relationalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression252.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1336:2: (op= equalityOperator relationalExpression )*
            	do 
            	{
            	    int alt74 = 2;
            	    int LA74_0 = input.LA(1);
            	    
            	    if ( ((LA74_0 >= STRICT_EQUAL && LA74_0 <= EQUAL)) )
            	    {
            	        alt74 = 1;
            	    }
            	    
            	
            	    switch (alt74) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1337:3: op= equalityOperator relationalExpression
            			    {
            			    	PushFollow(FOLLOW_equalityOperator_in_equalityExpression4581);
            			    	op = equalityOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  														buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  														if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  													
            			    	}
            			    	PushFollow(FOLLOW_relationalExpression_in_equalityExpression4593);
            			    	relationalExpression253 = relationalExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression253.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop74;
            	    }
            	} while (true);
            	
            	loop74:
            		;	// Stops C# compiler whinging that label 'loop74' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 98, equalityExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityExpression

    public class equalityOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1346:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
    public equalityOperator_return equalityOperator() // throws RecognitionException [1]
    {   
        equalityOperator_return retval = new equalityOperator_return();
        retval.start = input.LT(1);
        int equalityOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set254 = null;
        
        CommonTree set254_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 99) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1347:4: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set254 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= STRICT_EQUAL && input.LA(1) <= EQUAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set254));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_equalityOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 99, equalityOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityOperator

    public class relationalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1351:1: relationalExpression : shiftExpression ( ( relationalOperator )=>op= relationalOperator shiftExpression )* ;
    public relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {   
        relationalExpression_return retval = new relationalExpression_return();
        retval.start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        relationalOperator_return op = null;

        shiftExpression_return shiftExpression255 = null;

        shiftExpression_return shiftExpression256 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 100) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1352:4: ( shiftExpression ( ( relationalOperator )=>op= relationalOperator shiftExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1352:4: shiftExpression ( ( relationalOperator )=>op= relationalOperator shiftExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_shiftExpression_in_relationalExpression4633);
            	shiftExpression255 = shiftExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression255.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1353:3: ( ( relationalOperator )=>op= relationalOperator shiftExpression )*
            	do 
            	{
            	    int alt75 = 2;
            	    int LA75_0 = input.LA(1);
            	    
            	    if ( (LA75_0 == IS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA75_78 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA75_79 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA75_80 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA75_81 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA75_83 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA75_90 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA75_91 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA75_107 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA75_109 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA75_110 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA75_111 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA75_112 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA75_113 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA75_114 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA75_115 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA75_116 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA75_117 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA75_118 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA75_119 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA75_120 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA75_121 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA75_122 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA75_123 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA75_124 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA75_125 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA75_126 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA75_127 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA75_128 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA75_0 == AS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA75_143 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA75_144 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA75_145 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA75_146 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA75_148 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA75_155 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA75_156 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA75_169 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA75_171 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA75_172 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA75_173 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA75_174 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA75_175 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA75_176 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA75_177 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA75_178 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA75_179 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA75_180 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA75_181 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA75_182 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA75_183 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA75_184 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA75_185 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA75_186 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA75_187 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA75_188 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA75_189 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA75_190 = input.LA(3);
            	            
            	            if ( (synpred130()) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA75_0 == IN) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA75_207 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA75_208 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA75_209 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA75_210 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA75_211 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA75_212 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA75_213 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA75_214 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA75_215 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA75_216 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA75_217 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA75_218 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA75_219 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA75_220 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA75_221 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA75_222 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA75_223 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA75_224 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA75_225 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA75_226 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA75_227 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA75_228 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA75_229 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA75_230 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA75_231 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA75_232 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA75_233 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA75_234 = input.LA(3);
            	            
            	            if ( ((synpred130() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt75 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA75_0 == LT) && (synpred130()) )
            	    {
            	        alt75 = 1;
            	    }
            	    else if ( (LA75_0 == GT) && (synpred130()) )
            	    {
            	        alt75 = 1;
            	    }
            	    else if ( (LA75_0 == LE) && (synpred130()) )
            	    {
            	        alt75 = 1;
            	    }
            	    else if ( (LA75_0 == GE) && (synpred130()) )
            	    {
            	        alt75 = 1;
            	    }
            	    else if ( (LA75_0 == INSTANCEOF) && (synpred130()) )
            	    {
            	        alt75 = 1;
            	    }
            	    
            	
            	    switch (alt75) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1354:4: ( relationalOperator )=>op= relationalOperator shiftExpression
            			    {
            			    	PushFollow(FOLLOW_relationalOperator_in_relationalExpression4649);
            			    	op = relationalOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  																buffer.Append(" ");
            			    	  																buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  																buffer.Append(" "); 
            			    	  															
            			    	}
            			    	PushFollow(FOLLOW_shiftExpression_in_relationalExpression4657);
            			    	shiftExpression256 = shiftExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression256.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop75;
            	    }
            	} while (true);
            	
            	loop75:
            		;	// Stops C# compiler whinging that label 'loop75' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 100, relationalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalExpression

    public class relationalOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1363:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );
    public relationalOperator_return relationalOperator() // throws RecognitionException [1]
    {   
        relationalOperator_return retval = new relationalOperator_return();
        retval.start = input.LT(1);
        int relationalOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken IN257 = null;
        CommonToken LT258 = null;
        CommonToken GT259 = null;
        CommonToken LE260 = null;
        CommonToken GE261 = null;
        CommonToken IS262 = null;
        CommonToken AS263 = null;
        CommonToken INSTANCEOF264 = null;
        
        CommonTree IN257_tree=null;
        CommonTree LT258_tree=null;
        CommonTree GT259_tree=null;
        CommonTree LE260_tree=null;
        CommonTree GE261_tree=null;
        CommonTree IS262_tree=null;
        CommonTree AS263_tree=null;
        CommonTree INSTANCEOF264_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 101) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1364:4: ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF )
            int alt76 = 8;
            switch ( input.LA(1) ) 
            {
            case IN:
            	{
                alt76 = 1;
                }
                break;
            case LT:
            	{
                alt76 = 2;
                }
                break;
            case GT:
            	{
                alt76 = 3;
                }
                break;
            case LE:
            	{
                alt76 = 4;
                }
                break;
            case GE:
            	{
                alt76 = 5;
                }
                break;
            case IS:
            	{
                alt76 = 6;
                }
                break;
            case AS:
            	{
                alt76 = 7;
                }
                break;
            case INSTANCEOF:
            	{
                alt76 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d76s0 =
            	        new NoViableAltException("1363:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );", 76, 0, input);
            
            	    throw nvae_d76s0;
            }
            
            switch (alt76) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1364:4: {...}? IN
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( !(((InOperator_scope)InOperator_stack.Peek()).allowed) ) 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    throw new FailedPredicateException(input, "relationalOperator", "$InOperator::allowed");
                    	}
                    	IN257 = (CommonToken)input.LT(1);
                    	Match(input,IN,FOLLOW_IN_in_relationalOperator4675); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IN257_tree = (CommonTree)adaptor.Create(IN257);
                    	adaptor.AddChild(root_0, IN257_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:4: LT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LT258 = (CommonToken)input.LT(1);
                    	Match(input,LT,FOLLOW_LT_in_relationalOperator4680); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LT258_tree = (CommonTree)adaptor.Create(LT258);
                    	adaptor.AddChild(root_0, LT258_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:9: GT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GT259 = (CommonToken)input.LT(1);
                    	Match(input,GT,FOLLOW_GT_in_relationalOperator4684); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GT259_tree = (CommonTree)adaptor.Create(GT259);
                    	adaptor.AddChild(root_0, GT259_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:14: LE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LE260 = (CommonToken)input.LT(1);
                    	Match(input,LE,FOLLOW_LE_in_relationalOperator4688); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LE260_tree = (CommonTree)adaptor.Create(LE260);
                    	adaptor.AddChild(root_0, LE260_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:19: GE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GE261 = (CommonToken)input.LT(1);
                    	Match(input,GE,FOLLOW_GE_in_relationalOperator4692); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GE261_tree = (CommonTree)adaptor.Create(GE261);
                    	adaptor.AddChild(root_0, GE261_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:24: IS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IS262 = (CommonToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_relationalOperator4696); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IS262_tree = (CommonTree)adaptor.Create(IS262);
                    	adaptor.AddChild(root_0, IS262_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:29: AS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	AS263 = (CommonToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_relationalOperator4700); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	AS263_tree = (CommonTree)adaptor.Create(AS263);
                    	adaptor.AddChild(root_0, AS263_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1365:34: INSTANCEOF
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	INSTANCEOF264 = (CommonToken)input.LT(1);
                    	Match(input,INSTANCEOF,FOLLOW_INSTANCEOF_in_relationalOperator4704); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	INSTANCEOF264_tree = (CommonTree)adaptor.Create(INSTANCEOF264);
                    	adaptor.AddChild(root_0, INSTANCEOF264_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 101, relationalOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalOperator

    public class shiftExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1369:1: shiftExpression : additiveExpression (op= shiftOperator additiveExpression )* ;
    public shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {   
        shiftExpression_return retval = new shiftExpression_return();
        retval.start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        shiftOperator_return op = null;

        additiveExpression_return additiveExpression265 = null;

        additiveExpression_return additiveExpression266 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 102) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1370:4: ( additiveExpression (op= shiftOperator additiveExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1370:4: additiveExpression (op= shiftOperator additiveExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_additiveExpression_in_shiftExpression4716);
            	additiveExpression265 = additiveExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression265.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1371:3: (op= shiftOperator additiveExpression )*
            	do 
            	{
            	    int alt77 = 2;
            	    int LA77_0 = input.LA(1);
            	    
            	    if ( ((LA77_0 >= SL && LA77_0 <= BSR)) )
            	    {
            	        alt77 = 1;
            	    }
            	    
            	
            	    switch (alt77) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1372:4: op= shiftOperator additiveExpression
            			    {
            			    	PushFollow(FOLLOW_shiftOperator_in_shiftExpression4727);
            			    	op = shiftOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  											buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  										
            			    	}
            			    	PushFollow(FOLLOW_additiveExpression_in_shiftExpression4737);
            			    	additiveExpression266 = additiveExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression266.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop77;
            	    }
            	} while (true);
            	
            	loop77:
            		;	// Stops C# compiler whinging that label 'loop77' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 102, shiftExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftExpression

    public class shiftOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1381:1: shiftOperator : ( SL | SR | BSR );
    public shiftOperator_return shiftOperator() // throws RecognitionException [1]
    {   
        shiftOperator_return retval = new shiftOperator_return();
        retval.start = input.LT(1);
        int shiftOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set267 = null;
        
        CommonTree set267_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 103) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1382:4: ( SL | SR | BSR )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set267 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= SL && input.LA(1) <= BSR) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set267));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_shiftOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 103, shiftOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftOperator

    public class additiveExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1386:1: additiveExpression : multiplicativeExpression (op= additiveOperator multiplicativeExpression )* ;
    public additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {   
        additiveExpression_return retval = new additiveExpression_return();
        retval.start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        additiveOperator_return op = null;

        multiplicativeExpression_return multiplicativeExpression268 = null;

        multiplicativeExpression_return multiplicativeExpression269 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 104) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1387:4: ( multiplicativeExpression (op= additiveOperator multiplicativeExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1387:4: multiplicativeExpression (op= additiveOperator multiplicativeExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression4773);
            	multiplicativeExpression268 = multiplicativeExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression268.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1388:3: (op= additiveOperator multiplicativeExpression )*
            	do 
            	{
            	    int alt78 = 2;
            	    int LA78_0 = input.LA(1);
            	    
            	    if ( (LA78_0 == MINUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA78_78 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA78_79 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA78_80 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA78_81 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA78_82 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA78_83 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA78_84 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA78_85 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA78_86 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA78_87 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA78_88 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA78_89 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA78_90 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA78_91 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA78_92 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA78_93 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA78_94 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA78_95 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA78_96 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA78_97 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA78_98 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA78_99 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA78_100 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA78_101 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA78_102 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA78_103 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA78_104 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA78_105 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA78_0 == PLUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA78_106 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA78_107 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA78_108 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA78_109 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA78_110 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA78_111 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA78_112 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA78_113 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA78_114 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA78_115 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA78_116 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA78_117 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA78_118 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA78_119 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA78_120 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA78_121 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA78_122 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA78_123 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA78_124 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA78_125 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA78_126 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA78_127 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA78_128 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA78_129 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA78_130 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA78_131 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA78_132 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA78_133 = input.LA(3);
            	            
            	            if ( (synpred141()) )
            	            {
            	                alt78 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt78) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1389:4: op= additiveOperator multiplicativeExpression
            			    {
            			    	PushFollow(FOLLOW_additiveOperator_in_additiveExpression4784);
            			    	op = additiveOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  											buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  										
            			    	}
            			    	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression4794);
            			    	multiplicativeExpression269 = multiplicativeExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression269.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop78;
            	    }
            	} while (true);
            	
            	loop78:
            		;	// Stops C# compiler whinging that label 'loop78' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 104, additiveExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveExpression

    public class additiveOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1398:1: additiveOperator : ( PLUS | MINUS );
    public additiveOperator_return additiveOperator() // throws RecognitionException [1]
    {   
        additiveOperator_return retval = new additiveOperator_return();
        retval.start = input.LT(1);
        int additiveOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set270 = null;
        
        CommonTree set270_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 105) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1399:4: ( PLUS | MINUS )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set270 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= PLUS && input.LA(1) <= MINUS) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set270));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_additiveOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 105, additiveOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveOperator

    public class multiplicativeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1403:1: multiplicativeExpression : unaryExpression (op= multiplicativeOperator unaryExpression )* ;
    public multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {   
        multiplicativeExpression_return retval = new multiplicativeExpression_return();
        retval.start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        multiplicativeOperator_return op = null;

        unaryExpression_return unaryExpression271 = null;

        unaryExpression_return unaryExpression272 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 106) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1404:4: ( unaryExpression (op= multiplicativeOperator unaryExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1404:4: unaryExpression (op= multiplicativeOperator unaryExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression4826);
            	unaryExpression271 = unaryExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression271.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1405:3: (op= multiplicativeOperator unaryExpression )*
            	do 
            	{
            	    int alt79 = 2;
            	    int LA79_0 = input.LA(1);
            	    
            	    if ( (LA79_0 == STAR || (LA79_0 >= DIV && LA79_0 <= MOD)) )
            	    {
            	        alt79 = 1;
            	    }
            	    
            	
            	    switch (alt79) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1406:4: op= multiplicativeOperator unaryExpression
            			    {
            			    	PushFollow(FOLLOW_multiplicativeOperator_in_multiplicativeExpression4838);
            			    	op = multiplicativeOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(op.Tree, root_0);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" ");
            			    	  											buffer.Append(((CommonTree)op.Tree).Text ); 
            			    	  											if(options.SpaceBetweenOperators) buffer.Append(" "); 
            			    	  										
            			    	}
            			    	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression4846);
            			    	unaryExpression272 = unaryExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression272.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop79;
            	    }
            	} while (true);
            	
            	loop79:
            		;	// Stops C# compiler whinging that label 'loop79' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 106, multiplicativeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeExpression

    public class multiplicativeOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1415:1: multiplicativeOperator : ( STAR | DIV | MOD );
    public multiplicativeOperator_return multiplicativeOperator() // throws RecognitionException [1]
    {   
        multiplicativeOperator_return retval = new multiplicativeOperator_return();
        retval.start = input.LT(1);
        int multiplicativeOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set273 = null;
        
        CommonTree set273_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 107) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1416:4: ( STAR | DIV | MOD )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set273 = (CommonToken)input.LT(1);
            	if ( input.LA(1) == STAR || (input.LA(1) >= DIV && input.LA(1) <= MOD) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set273));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_multiplicativeOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 107, multiplicativeOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeOperator

    public class unaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1420:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | tmin= MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | tplus= PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );
    public unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {   
        unaryExpression_return retval = new unaryExpression_return();
        retval.start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken iin = null;
        CommonToken dde = null;
        CommonToken tmin = null;
        CommonToken tplus = null;
        unaryExpression_return unaryExpression274 = null;

        unaryExpression_return unaryExpression275 = null;

        unaryExpression_return unaryExpression276 = null;

        unaryExpression_return unaryExpression277 = null;

        unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus278 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree tmin_tree=null;
        CommonTree tplus_tree=null;
        RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream(adaptor,"token PLUS");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_MINUS = new RewriteRuleTokenStream(adaptor,"token MINUS");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 108) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1421:4: (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | tmin= MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | tplus= PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus )
            int alt80 = 5;
            switch ( input.LA(1) ) 
            {
            case INC:
            	{
                alt80 = 1;
                }
                break;
            case DEC:
            	{
                alt80 = 2;
                }
                break;
            case MINUS:
            	{
                alt80 = 3;
                }
                break;
            case PLUS:
            	{
                alt80 = 4;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case LPAREN:
            case VOID:
            case IDENT:
            case LBRACK:
            case DYNAMIC:
            case IS:
            case AS:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case USE:
            case XML:
            	{
                alt80 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d80s0 =
            	        new NoViableAltException("1420:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | tmin= MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | tplus= PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );", 80, 0, input);
            
            	    throw nvae_d80s0;
            }
            
            switch (alt80) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1421:4: iin= INC unaryExpression
                    {
                    	iin = (CommonToken)input.LT(1);
                    	Match(input,INC,FOLLOW_INC_in_unaryExpression4884); if (failed) return retval;
                    	if ( backtracking==0 ) stream_INC.Add(iin);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(iin.Text); 
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4889);
                    	unaryExpression274 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression274.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1421:59: -> ^( PRE_INC[$iin] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1421:62: ^( PRE_INC[$iin] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_INC, iin), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1422:4: dde= DEC unaryExpression
                    {
                    	dde = (CommonToken)input.LT(1);
                    	Match(input,DEC,FOLLOW_DEC_in_unaryExpression4906); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DEC.Add(dde);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(dde.Text); 
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4911);
                    	unaryExpression275 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression275.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1422:59: -> ^( PRE_DEC[$dde] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1422:62: ^( PRE_DEC[$dde] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_DEC, dde), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1423:4: tmin= MINUS unaryExpression
                    {
                    	tmin = (CommonToken)input.LT(1);
                    	Match(input,MINUS,FOLLOW_MINUS_in_unaryExpression4928); if (failed) return retval;
                    	if ( backtracking==0 ) stream_MINUS.Add(tmin);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tmin.Text);  
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4932);
                    	unaryExpression276 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression276.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1423:63: -> ^( UNARY_MINUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1423:66: ^( UNARY_MINUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1424:4: tplus= PLUS unaryExpression
                    {
                    	tplus = (CommonToken)input.LT(1);
                    	Match(input,PLUS,FOLLOW_PLUS_in_unaryExpression4948); if (failed) return retval;
                    	if ( backtracking==0 ) stream_PLUS.Add(tplus);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tplus.Text); 
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression4952);
                    	unaryExpression277 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression277.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1424:63: -> ^( UNARY_PLUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1424:66: ^( UNARY_PLUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_PLUS, "UNARY_PLUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1425:4: unaryExpressionNotPlusMinus
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression4966);
                    	unaryExpressionNotPlusMinus278 = unaryExpressionNotPlusMinus();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus278.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 108, unaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpression

    public class unaryExpressionNotPlusMinus_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpressionNotPlusMinus
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1428:1: unaryExpressionNotPlusMinus : (tk1= DELETE postfixExpression -> ^( DELETE postfixExpression ) | tk2= VOID unaryExpression -> ^( VOID unaryExpression ) | tk3= TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | tk4= LNOT unaryExpression -> ^( LNOT unaryExpression ) | tk5= BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
    public unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus() // throws RecognitionException [1]
    {   
        unaryExpressionNotPlusMinus_return retval = new unaryExpressionNotPlusMinus_return();
        retval.start = input.LT(1);
        int unaryExpressionNotPlusMinus_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken tk1 = null;
        CommonToken tk2 = null;
        CommonToken tk3 = null;
        CommonToken tk4 = null;
        CommonToken tk5 = null;
        postfixExpression_return postfixExpression279 = null;

        unaryExpression_return unaryExpression280 = null;

        unaryExpression_return unaryExpression281 = null;

        unaryExpression_return unaryExpression282 = null;

        unaryExpression_return unaryExpression283 = null;

        postfixExpression_return postfixExpression284 = null;
        
        
        CommonTree tk1_tree=null;
        CommonTree tk2_tree=null;
        CommonTree tk3_tree=null;
        CommonTree tk4_tree=null;
        CommonTree tk5_tree=null;
        RewriteRuleTokenStream stream_BNOT = new RewriteRuleTokenStream(adaptor,"token BNOT");
        RewriteRuleTokenStream stream_LNOT = new RewriteRuleTokenStream(adaptor,"token LNOT");
        RewriteRuleTokenStream stream_TYPEOF = new RewriteRuleTokenStream(adaptor,"token TYPEOF");
        RewriteRuleTokenStream stream_DELETE = new RewriteRuleTokenStream(adaptor,"token DELETE");
        RewriteRuleTokenStream stream_VOID = new RewriteRuleTokenStream(adaptor,"token VOID");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        RewriteRuleSubtreeStream stream_postfixExpression = new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 109) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1429:4: (tk1= DELETE postfixExpression -> ^( DELETE postfixExpression ) | tk2= VOID unaryExpression -> ^( VOID unaryExpression ) | tk3= TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | tk4= LNOT unaryExpression -> ^( LNOT unaryExpression ) | tk5= BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
            int alt81 = 6;
            switch ( input.LA(1) ) 
            {
            case DELETE:
            	{
                alt81 = 1;
                }
                break;
            case VOID:
            	{
                alt81 = 2;
                }
                break;
            case TYPEOF:
            	{
                alt81 = 3;
                }
                break;
            case LNOT:
            	{
                alt81 = 4;
                }
                break;
            case BNOT:
            	{
                alt81 = 5;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case LPAREN:
            case IDENT:
            case LBRACK:
            case DYNAMIC:
            case IS:
            case AS:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case USE:
            case XML:
            	{
                alt81 = 6;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d81s0 =
            	        new NoViableAltException("1428:1: unaryExpressionNotPlusMinus : (tk1= DELETE postfixExpression -> ^( DELETE postfixExpression ) | tk2= VOID unaryExpression -> ^( VOID unaryExpression ) | tk3= TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | tk4= LNOT unaryExpression -> ^( LNOT unaryExpression ) | tk5= BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );", 81, 0, input);
            
            	    throw nvae_d81s0;
            }
            
            switch (alt81) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1429:4: tk1= DELETE postfixExpression
                    {
                    	tk1 = (CommonToken)input.LT(1);
                    	Match(input,DELETE,FOLLOW_DELETE_in_unaryExpressionNotPlusMinus4979); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DELETE.Add(tk1);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tk1.Text + " ");  
                    	}
                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4984);
                    	postfixExpression279 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_postfixExpression.Add(postfixExpression279.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          DELETE, postfixExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1429:70: -> ^( DELETE postfixExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1429:73: ^( DELETE postfixExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DELETE.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_postfixExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1430:4: tk2= VOID unaryExpression
                    {
                    	tk2 = (CommonToken)input.LT(1);
                    	Match(input,VOID,FOLLOW_VOID_in_unaryExpressionNotPlusMinus4999); if (failed) return retval;
                    	if ( backtracking==0 ) stream_VOID.Add(tk2);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tk2.Text + " ");  
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5003);
                    	unaryExpression280 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression280.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          VOID, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1430:65: -> ^( VOID unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1430:68: ^( VOID unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_VOID.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1431:4: tk3= TYPEOF unaryExpression
                    {
                    	tk3 = (CommonToken)input.LT(1);
                    	Match(input,TYPEOF,FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus5018); if (failed) return retval;
                    	if ( backtracking==0 ) stream_TYPEOF.Add(tk3);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tk3.Text + " ");  
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5022);
                    	unaryExpression281 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression281.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          TYPEOF, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1431:67: -> ^( TYPEOF unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1431:70: ^( TYPEOF unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_TYPEOF.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1432:4: tk4= LNOT unaryExpression
                    {
                    	tk4 = (CommonToken)input.LT(1);
                    	Match(input,LNOT,FOLLOW_LNOT_in_unaryExpressionNotPlusMinus5037); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LNOT.Add(tk4);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tk4.Text + " ");  
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5041);
                    	unaryExpression282 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression282.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, LNOT
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1432:65: -> ^( LNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1432:68: ^( LNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1433:4: tk5= BNOT unaryExpression
                    {
                    	tk5 = (CommonToken)input.LT(1);
                    	Match(input,BNOT,FOLLOW_BNOT_in_unaryExpressionNotPlusMinus5056); if (failed) return retval;
                    	if ( backtracking==0 ) stream_BNOT.Add(tk5);

                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(tk5.Text + " ");  
                    	}
                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5060);
                    	unaryExpression283 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression283.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          BNOT, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1433:65: -> ^( BNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1433:68: ^( BNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1434:4: postfixExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus5073);
                    	postfixExpression284 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, postfixExpression284.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 109, unaryExpressionNotPlusMinus_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpressionNotPlusMinus

    public class postfixExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start postfixExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1438:1: postfixExpression : ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? ;
    public postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {   
        postfixExpression_return retval = new postfixExpression_return();
        retval.start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken iin = null;
        CommonToken dde = null;
        CommonToken LBRACK286 = null;
        CommonToken RBRACK288 = null;
        propOrIdent_return poi = null;

        primaryExpression_return primaryExpression285 = null;

        expression_return expression287 = null;

        arguments_return arguments289 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree LBRACK286_tree=null;
        CommonTree RBRACK288_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleSubtreeStream stream_arguments = new RewriteRuleSubtreeStream(adaptor,"rule arguments");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_propOrIdent = new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 110) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1439:4: ( ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1439:4: ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1439:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1439:5: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_postfixExpression5086);
            		primaryExpression285 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression285.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 1439:23: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1440:3: (poi= propOrIdent[root_0, retval.start] -> $poi | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )*
            	do 
            	{
            	    int alt82 = 4;
            	    switch ( input.LA(1) ) 
            	    {
            	    case LBRACK:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA82_80 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA82_81 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA82_82 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA82_83 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA82_84 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA82_85 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA82_86 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA82_87 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA82_88 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA82_89 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA82_90 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA82_91 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA82_92 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA82_93 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA82_94 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA82_95 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA82_96 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA82_97 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA82_98 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA82_99 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA82_100 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA82_101 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA82_102 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA82_103 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA82_104 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA82_105 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA82_106 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA82_107 = input.LA(3);
            	            
            	            if ( (synpred156()) )
            	            {
            	                alt82 = 2;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case LPAREN:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case RPAREN:
            	        	{
            	            alt82 = 3;
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA82_110 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA82_111 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA82_112 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA82_113 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA82_114 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA82_115 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA82_116 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA82_117 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA82_118 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA82_119 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA82_120 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA82_121 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA82_122 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA82_123 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA82_124 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA82_125 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA82_126 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA82_127 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA82_128 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA82_129 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA82_130 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA82_131 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA82_132 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA82_133 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA82_134 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA82_135 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA82_136 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA82_137 = input.LA(3);
            	            
            	            if ( (synpred157()) )
            	            {
            	                alt82 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case DOT:
            	    	{
            	        alt82 = 1;
            	        }
            	        break;
            	    
            	    }
            	
            	    switch (alt82) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1440:5: poi= propOrIdent[root_0, retval.start]
            			    {
            			    	PushFollow(FOLLOW_propOrIdent_in_postfixExpression5099);
            			    	poi = propOrIdent(root_0,  retval.start);
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_propOrIdent.Add(poi.Tree);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	}
            			    	
            			    	// AST REWRITE
            			    	// elements:          poi
            			    	// token labels:      
            			    	// rule labels:       retval, poi
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	RewriteRuleSubtreeStream stream_poi = new RewriteRuleSubtreeStream(adaptor, "token poi", (poi!=null ? poi.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1440:47: -> $poi
            			    	{
            			    	    adaptor.AddChild(root_0, stream_poi.Next());
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1441:5: LBRACK expression RBRACK
            			    {
            			    	LBRACK286 = (CommonToken)input.LT(1);
            			    	Match(input,LBRACK,FOLLOW_LBRACK_in_postfixExpression5113); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK286);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append("["); 
            			    	}
            			    	PushFollow(FOLLOW_expression_in_postfixExpression5117);
            			    	expression287 = expression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_expression.Add(expression287.Tree);
            			    	RBRACK288 = (CommonToken)input.LT(1);
            			    	Match(input,RBRACK,FOLLOW_RBRACK_in_postfixExpression5119); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK288);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append("]"); 
            			    	}
            			    	
            			    	// AST REWRITE
            			    	// elements:          postfixExpression, expression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1441:78: -> ^( ARRAY_ACC $postfixExpression expression )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1441:81: ^( ARRAY_ACC $postfixExpression expression )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_expression.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 3 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1442:5: arguments
            			    {
            			    	PushFollow(FOLLOW_arguments_in_postfixExpression5138);
            			    	arguments289 = arguments();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_arguments.Add(arguments289.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          arguments, postfixExpression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1442:15: -> ^( METHOD_CALL $postfixExpression arguments )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1442:18: ^( METHOD_CALL $postfixExpression arguments )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_CALL, "METHOD_CALL"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_arguments.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop82;
            	    }
            	} while (true);
            	
            	loop82:
            		;	// Stops C# compiler whinging that label 'loop82' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1445:3: (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            	int alt83 = 3;
            	int LA83_0 = input.LA(1);
            	
            	if ( (LA83_0 == INC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA83_79 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA83_80 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA83_81 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA83_82 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA83_83 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA83_84 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA83_85 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA83_86 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA83_87 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA83_88 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA83_89 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA83_90 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA83_91 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA83_92 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA83_93 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA83_94 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA83_95 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA83_96 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA83_97 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA83_98 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA83_99 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA83_100 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA83_101 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA83_102 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA83_103 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA83_104 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA83_105 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA83_106 = input.LA(3);
            	            
            	            if ( (synpred158()) )
            	            {
            	                alt83 = 1;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case IMPORT:
            	        case SEMI:
            	        case COMMA:
            	        case RCURLY:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case LT:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case DIV:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 175:
            	        case 176:
            	        case 177:
            	        case 180:
            	        case 181:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        	{
            	            alt83 = 1;
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA83_0 == DEC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA83_157 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA83_158 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA83_159 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA83_160 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA83_161 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case VOID:
            	        	{
            	            int LA83_162 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA83_163 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA83_164 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA83_165 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA83_166 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA83_167 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA83_168 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA83_169 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA83_170 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA83_171 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA83_172 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA83_173 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA83_174 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA83_175 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA83_176 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA83_177 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA83_178 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA83_179 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA83_180 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA83_181 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA83_182 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA83_183 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA83_184 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt83 = 2;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case IMPORT:
            	        case SEMI:
            	        case COMMA:
            	        case RCURLY:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case LT:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case DIV:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 175:
            	        case 176:
            	        case 177:
            	        case 180:
            	        case 181:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        	{
            	            alt83 = 2;
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt83) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1445:6: iin= INC
            	        {
            	        	iin = (CommonToken)input.LT(1);
            	        	Match(input,INC,FOLLOW_INC_in_postfixExpression5164); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_INC.Add(iin);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(iin.Text); 
            	        	}
            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 1445:43: -> ^( POST_INC[$iin] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1445:46: ^( POST_INC[$iin] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_INC, iin), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1446:6: dde= DEC
            	        {
            	        	dde = (CommonToken)input.LT(1);
            	        	Match(input,DEC,FOLLOW_DEC_in_postfixExpression5185); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DEC.Add(dde);

            	        	if ( backtracking == 0 ) 
            	        	{
            	        	   buffer.Append(dde.Text); 
            	        	}
            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 1446:43: -> ^( POST_DEC[$dde] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1446:46: ^( POST_DEC[$dde] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_DEC, dde), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 110, postfixExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end postfixExpression

    public class primaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start primaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1450:1: primaryExpression : (und= UNDEFINED | c= constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | encapsulatedExpression | qualifiedIdent );
    public primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {   
        primaryExpression_return retval = new primaryExpression_return();
        retval.start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken und = null;
        constant_return c = null;

        arrayLiteral_return arrayLiteral290 = null;

        objectLiteral_return objectLiteral291 = null;

        functionDefinition_return functionDefinition292 = null;

        newFullExpression_return newFullExpression293 = null;

        encapsulatedExpression_return encapsulatedExpression294 = null;

        qualifiedIdent_return qualifiedIdent295 = null;
        
        
        CommonTree und_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 111) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1451:4: (und= UNDEFINED | c= constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | encapsulatedExpression | qualifiedIdent )
            int alt84 = 8;
            switch ( input.LA(1) ) 
            {
            case UNDEFINED:
            	{
                alt84 = 1;
                }
                break;
            case STRING_LITERAL:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt84 = 2;
                }
                break;
            case LBRACK:
            	{
                alt84 = 3;
                }
                break;
            case LCURLY:
            	{
                alt84 = 4;
                }
                break;
            case FUNCTION:
            	{
                alt84 = 5;
                }
                break;
            case NEW:
            	{
                alt84 = 6;
                }
                break;
            case LPAREN:
            	{
                alt84 = 7;
                }
                break;
            case GET:
            case SET:
            case IDENT:
            case DYNAMIC:
            case IS:
            case AS:
            case USE:
            case XML:
            	{
                alt84 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d84s0 =
            	        new NoViableAltException("1450:1: primaryExpression : (und= UNDEFINED | c= constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | encapsulatedExpression | qualifiedIdent );", 84, 0, input);
            
            	    throw nvae_d84s0;
            }
            
            switch (alt84) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1451:4: und= UNDEFINED
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	und = (CommonToken)input.LT(1);
                    	Match(input,UNDEFINED,FOLLOW_UNDEFINED_in_primaryExpression5216); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	und_tree = (CommonTree)adaptor.Create(und);
                    	adaptor.AddChild(root_0, und_tree);
                    	}
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(und.Text); 
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1452:4: c= constant
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_constant_in_primaryExpression5228);
                    	c = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
                    	if ( backtracking == 0 ) 
                    	{
                    	   buffer.Append(((CommonTree)c.Tree).Text); 
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1453:4: arrayLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_arrayLiteral_in_primaryExpression5239);
                    	arrayLiteral290 = arrayLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, arrayLiteral290.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1454:4: objectLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_objectLiteral_in_primaryExpression5244);
                    	objectLiteral291 = objectLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, objectLiteral291.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1455:4: functionDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_functionDefinition_in_primaryExpression5249);
                    	functionDefinition292 = functionDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, functionDefinition292.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1456:4: newFullExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newFullExpression_in_primaryExpression5254);
                    	newFullExpression293 = newFullExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newFullExpression293.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1457:4: encapsulatedExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_encapsulatedExpression_in_primaryExpression5259);
                    	encapsulatedExpression294 = encapsulatedExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, encapsulatedExpression294.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1458:4: qualifiedIdent
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_qualifiedIdent_in_primaryExpression5264);
                    	qualifiedIdent295 = qualifiedIdent();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent295.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 111, primaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end primaryExpression

    public class propOrIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start propOrIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1462:1: propOrIdent[CommonTree identPrimary, IToken startToken] : DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) ;
    public propOrIdent_return propOrIdent(CommonTree identPrimary, IToken startToken) // throws RecognitionException [1]
    {   
        propOrIdent_return retval = new propOrIdent_return();
        retval.start = input.LT(1);
        int propOrIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DOT296 = null;
        qualifiedIdent_return propId = null;
        
        
        CommonTree DOT296_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 112) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1464:9: ( DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1464:9: DOT propId= qualifiedIdent
            {
            	if ( backtracking == 0 ) 
            	{
            	   retval.start = startToken; 
            	}
            	DOT296 = (CommonToken)input.LT(1);
            	Match(input,DOT,FOLLOW_DOT_in_propOrIdent5290); if (failed) return retval;
            	if ( backtracking==0 ) stream_DOT.Add(DOT296);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("."); 
            	}
            	PushFollow(FOLLOW_qualifiedIdent_in_propOrIdent5303);
            	propId = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(propId.Tree);
            	
            	// AST REWRITE
            	// elements:          propId
            	// token labels:      
            	// rule labels:       propId, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_propId = new RewriteRuleSubtreeStream(adaptor, "token propId", (propId!=null ? propId.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1467:3: -> ^( PROPERTY_OR_IDENTIFIER $propId)
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1467:6: ^( PROPERTY_OR_IDENTIFIER $propId)
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PROPERTY_OR_IDENTIFIER, "PROPERTY_OR_IDENTIFIER"), root_1);
            	    
            	    adaptor.AddChild(root_1, identPrimary);
            	    adaptor.AddChild(root_1, stream_propId.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 112, propOrIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end propOrIdent

    public class constant_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start constant
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1470:1: constant : ( number | STRING_LITERAL | TRUE | FALSE | NULL );
    public constant_return constant() // throws RecognitionException [1]
    {   
        constant_return retval = new constant_return();
        retval.start = input.LT(1);
        int constant_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken STRING_LITERAL298 = null;
        CommonToken TRUE299 = null;
        CommonToken FALSE300 = null;
        CommonToken NULL301 = null;
        number_return number297 = null;
        
        
        CommonTree STRING_LITERAL298_tree=null;
        CommonTree TRUE299_tree=null;
        CommonTree FALSE300_tree=null;
        CommonTree NULL301_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 113) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1471:4: ( number | STRING_LITERAL | TRUE | FALSE | NULL )
            int alt85 = 5;
            switch ( input.LA(1) ) 
            {
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt85 = 1;
                }
                break;
            case STRING_LITERAL:
            	{
                alt85 = 2;
                }
                break;
            case TRUE:
            	{
                alt85 = 3;
                }
                break;
            case FALSE:
            	{
                alt85 = 4;
                }
                break;
            case NULL:
            	{
                alt85 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d85s0 =
            	        new NoViableAltException("1470:1: constant : ( number | STRING_LITERAL | TRUE | FALSE | NULL );", 85, 0, input);
            
            	    throw nvae_d85s0;
            }
            
            switch (alt85) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1471:4: number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_constant5327);
                    	number297 = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, number297.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1472:4: STRING_LITERAL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STRING_LITERAL298 = (CommonToken)input.LT(1);
                    	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_constant5332); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STRING_LITERAL298_tree = (CommonTree)adaptor.Create(STRING_LITERAL298);
                    	adaptor.AddChild(root_0, STRING_LITERAL298_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1473:4: TRUE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	TRUE299 = (CommonToken)input.LT(1);
                    	Match(input,TRUE,FOLLOW_TRUE_in_constant5337); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	TRUE299_tree = (CommonTree)adaptor.Create(TRUE299);
                    	adaptor.AddChild(root_0, TRUE299_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1474:4: FALSE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	FALSE300 = (CommonToken)input.LT(1);
                    	Match(input,FALSE,FOLLOW_FALSE_in_constant5342); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	FALSE300_tree = (CommonTree)adaptor.Create(FALSE300);
                    	adaptor.AddChild(root_0, FALSE300_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1475:4: NULL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	NULL301 = (CommonToken)input.LT(1);
                    	Match(input,NULL,FOLLOW_NULL_in_constant5347); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	NULL301_tree = (CommonTree)adaptor.Create(NULL301);
                    	adaptor.AddChild(root_0, NULL301_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 113, constant_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end constant

    public class number_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start number
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1478:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
    public number_return number() // throws RecognitionException [1]
    {   
        number_return retval = new number_return();
        retval.start = input.LT(1);
        int number_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken set302 = null;
        
        CommonTree set302_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 114) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1479:4: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set302 = (CommonToken)input.LT(1);
            	if ( (input.LA(1) >= HEX_LITERAL && input.LA(1) <= FLOAT_LITERAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set302));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_number0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 114, number_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end number

    public class newFullExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start newFullExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1486:1: newFullExpression : n= NEW fullNewSubexpression arguments ;
    public newFullExpression_return newFullExpression() // throws RecognitionException [1]
    {   
        newFullExpression_return retval = new newFullExpression_return();
        retval.start = input.LT(1);
        int newFullExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken n = null;
        fullNewSubexpression_return fullNewSubexpression303 = null;

        arguments_return arguments304 = null;
        
        
        CommonTree n_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 115) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1487:4: (n= NEW fullNewSubexpression arguments )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1487:4: n= NEW fullNewSubexpression arguments
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	n = (CommonToken)input.LT(1);
            	Match(input,NEW,FOLLOW_NEW_in_newFullExpression5389); if (failed) return retval;
            	if ( backtracking==0 ) {
            	n_tree = (CommonTree)adaptor.Create(n);
            	root_0 = (CommonTree)adaptor.BecomeRoot(n_tree, root_0);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(n.Text + " "); 
            	}
            	PushFollow(FOLLOW_fullNewSubexpression_in_newFullExpression5400);
            	fullNewSubexpression303 = fullNewSubexpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, fullNewSubexpression303.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	}
            	PushFollow(FOLLOW_arguments_in_newFullExpression5406);
            	arguments304 = arguments();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, arguments304.Tree);
            	if ( backtracking == 0 ) 
            	{
            	   
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 115, newFullExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end newFullExpression

    public class fullNewSubexpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fullNewSubexpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1492:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
    public fullNewSubexpression_return fullNewSubexpression() // throws RecognitionException [1]
    {   
        fullNewSubexpression_return retval = new fullNewSubexpression_return();
        retval.start = input.LT(1);
        int fullNewSubexpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken DOT306 = null;
        primaryExpression_return primaryExpression305 = null;

        qualifiedIdent_return qualifiedIdent307 = null;

        brackets_return brackets308 = null;
        
        
        CommonTree DOT306_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_brackets = new RewriteRuleSubtreeStream(adaptor,"rule brackets");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 116) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1493:4: ( ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1493:4: ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1493:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1493:6: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_fullNewSubexpression5424);
            		primaryExpression305 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression305.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 1493:24: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1495:3: ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            	do 
            	{
            	    int alt86 = 3;
            	    int LA86_0 = input.LA(1);
            	    
            	    if ( (LA86_0 == DOT) )
            	    {
            	        alt86 = 1;
            	    }
            	    else if ( (LA86_0 == LBRACK) )
            	    {
            	        alt86 = 2;
            	    }
            	    
            	
            	    switch (alt86) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1495:5: DOT qualifiedIdent
            			    {
            			    	DOT306 = (CommonToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_fullNewSubexpression5438); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT306);

            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   buffer.Append("."); 
            			    	}
            			    	PushFollow(FOLLOW_qualifiedIdent_in_fullNewSubexpression5443);
            			    	qualifiedIdent307 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent307.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          fullNewSubexpression, DOT, qualifiedIdent
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1495:49: -> ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1495:52: ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DOT.Next(), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1496:5: brackets
            			    {
            			    	PushFollow(FOLLOW_brackets_in_fullNewSubexpression5460);
            			    	brackets308 = brackets();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_brackets.Add(brackets308.Tree);
            			    	if ( backtracking == 0 ) 
            			    	{
            			    	   
            			    	}
            			    	
            			    	// AST REWRITE
            			    	// elements:          fullNewSubexpression, brackets
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1496:21: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1496:24: ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_brackets.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop86;
            	    }
            	} while (true);
            	
            	loop86:
            		;	// Stops C# compiler whinging that label 'loop86' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 116, fullNewSubexpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fullNewSubexpression

    public class comments_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start comments
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1501:1: comments : ( comment )+ -> ^( COMMENT_LIST ( comment )+ ) ;
    public comments_return comments() // throws RecognitionException [1]
    {   
        comments_return retval = new comments_return();
        retval.start = input.LT(1);
        int comments_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        comment_return comment309 = null;
        
        
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 117) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:4: ( ( comment )+ -> ^( COMMENT_LIST ( comment )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:4: ( comment )+
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:4: ( comment )+
            	int cnt87 = 0;
            	do 
            	{
            	    int alt87 = 2;
            	    int LA87_0 = input.LA(1);
            	    
            	    if ( (LA87_0 == SL_COMMENT) )
            	    {
            	        int LA87_15 = input.LA(2);
            	        
            	        if ( (synpred176()) )
            	        {
            	            alt87 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA87_0 == ML_COMMENT) )
            	    {
            	        int LA87_16 = input.LA(2);
            	        
            	        if ( (synpred176()) )
            	        {
            	            alt87 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt87) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: comment
            			    {
            			    	PushFollow(FOLLOW_comment_in_comments5502);
            			    	comment309 = comment();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_comment.Add(comment309.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt87 >= 1 ) goto loop87;
            			    if ( backtracking > 0 ) {failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(87, input);
            		            throw eee;
            	    }
            	    cnt87++;
            	} while (true);
            	
            	loop87:
            		;	// Stops C# compiler whinging that label 'loop87' has no statements

            	
            	// AST REWRITE
            	// elements:          comment
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1509:13: -> ^( COMMENT_LIST ( comment )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:16: ^( COMMENT_LIST ( comment )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_LIST, "COMMENT_LIST"), root_1);
            	    
            	    if ( !(stream_comment.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_comment.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_comment.Next());
            	    
            	    }
            	    stream_comment.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 117, comments_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end comments

    public class comment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start comment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1512:1: comment : ( singleCommentStatement ( comment )* -> ^( COMMENT_ENTRY singleCommentStatement ) ( comment )* | multiCommentStatement ( comment )* -> ^( COMMENT_ENTRY multiCommentStatement ) ( comment )* );
    public comment_return comment() // throws RecognitionException [1]
    {   
        comment_return retval = new comment_return();
        retval.start = input.LT(1);
        int comment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        singleCommentStatement_return singleCommentStatement310 = null;

        comment_return comment311 = null;

        multiCommentStatement_return multiCommentStatement312 = null;

        comment_return comment313 = null;
        
        
        RewriteRuleSubtreeStream stream_multiCommentStatement = new RewriteRuleSubtreeStream(adaptor,"rule multiCommentStatement");
        RewriteRuleSubtreeStream stream_singleCommentStatement = new RewriteRuleSubtreeStream(adaptor,"rule singleCommentStatement");
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 118) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:4: ( singleCommentStatement ( comment )* -> ^( COMMENT_ENTRY singleCommentStatement ) ( comment )* | multiCommentStatement ( comment )* -> ^( COMMENT_ENTRY multiCommentStatement ) ( comment )* )
            int alt90 = 2;
            int LA90_0 = input.LA(1);
            
            if ( (LA90_0 == SL_COMMENT) )
            {
                alt90 = 1;
            }
            else if ( (LA90_0 == ML_COMMENT) )
            {
                alt90 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d90s0 =
                    new NoViableAltException("1512:1: comment : ( singleCommentStatement ( comment )* -> ^( COMMENT_ENTRY singleCommentStatement ) ( comment )* | multiCommentStatement ( comment )* -> ^( COMMENT_ENTRY multiCommentStatement ) ( comment )* );", 90, 0, input);
            
                throw nvae_d90s0;
            }
            switch (alt90) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:4: singleCommentStatement ( comment )*
                    {
                    	PushFollow(FOLLOW_singleCommentStatement_in_comment5523);
                    	singleCommentStatement310 = singleCommentStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_singleCommentStatement.Add(singleCommentStatement310.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:27: ( comment )*
                    	do 
                    	{
                    	    int alt88 = 2;
                    	    int LA88_0 = input.LA(1);
                    	    
                    	    if ( (LA88_0 == SL_COMMENT) )
                    	    {
                    	        int LA88_15 = input.LA(2);
                    	        
                    	        if ( (synpred177()) )
                    	        {
                    	            alt88 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA88_0 == ML_COMMENT) )
                    	    {
                    	        int LA88_16 = input.LA(2);
                    	        
                    	        if ( (synpred177()) )
                    	        {
                    	            alt88 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt88) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment5525);
                    			    	comment311 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment311.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop88;
                    	    }
                    	} while (true);
                    	
                    	loop88:
                    		;	// Stops C# compiler whinging that label 'loop88' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          singleCommentStatement, comment
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1513:36: -> ^( COMMENT_ENTRY singleCommentStatement ) ( comment )*
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:39: ^( COMMENT_ENTRY singleCommentStatement )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_singleCommentStatement.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:79: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_0, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:4: multiCommentStatement ( comment )*
                    {
                    	PushFollow(FOLLOW_multiCommentStatement_in_comment5542);
                    	multiCommentStatement312 = multiCommentStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_multiCommentStatement.Add(multiCommentStatement312.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:27: ( comment )*
                    	do 
                    	{
                    	    int alt89 = 2;
                    	    int LA89_0 = input.LA(1);
                    	    
                    	    if ( (LA89_0 == SL_COMMENT) )
                    	    {
                    	        int LA89_15 = input.LA(2);
                    	        
                    	        if ( (synpred179()) )
                    	        {
                    	            alt89 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA89_0 == ML_COMMENT) )
                    	    {
                    	        int LA89_16 = input.LA(2);
                    	        
                    	        if ( (synpred179()) )
                    	        {
                    	            alt89 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt89) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment5545);
                    			    	comment313 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment313.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop89;
                    	    }
                    	} while (true);
                    	
                    	loop89:
                    		;	// Stops C# compiler whinging that label 'loop89' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          comment, multiCommentStatement
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1514:36: -> ^( COMMENT_ENTRY multiCommentStatement ) ( comment )*
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:39: ^( COMMENT_ENTRY multiCommentStatement )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_multiCommentStatement.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:78: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_0, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 118, comment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end comment

    public class singleCommentStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start singleCommentStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1517:1: singleCommentStatement : SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) ;
    public singleCommentStatement_return singleCommentStatement() // throws RecognitionException [1]
    {   
        singleCommentStatement_return retval = new singleCommentStatement_return();
        retval.start = input.LT(1);
        int singleCommentStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken SL_COMMENT314 = null;
        
        CommonTree SL_COMMENT314_tree=null;
        RewriteRuleTokenStream stream_SL_COMMENT = new RewriteRuleTokenStream(adaptor,"token SL_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 119) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1518:4: ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1518:4: SL_COMMENT
            {
            	SL_COMMENT314 = (CommonToken)input.LT(1);
            	Match(input,SL_COMMENT,FOLLOW_SL_COMMENT_in_singleCommentStatement5568); if (failed) return retval;
            	if ( backtracking==0 ) stream_SL_COMMENT.Add(SL_COMMENT314);

            	
            	// AST REWRITE
            	// elements:          SL_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1518:15: -> ^( SINGLELINE_COMMENT SL_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1518:18: ^( SINGLELINE_COMMENT SL_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SINGLELINE_COMMENT, "SINGLELINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_SL_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 119, singleCommentStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end singleCommentStatement

    public class multiCommentStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiCommentStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1521:1: multiCommentStatement : ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) ;
    public multiCommentStatement_return multiCommentStatement() // throws RecognitionException [1]
    {   
        multiCommentStatement_return retval = new multiCommentStatement_return();
        retval.start = input.LT(1);
        int multiCommentStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken ML_COMMENT315 = null;
        
        CommonTree ML_COMMENT315_tree=null;
        RewriteRuleTokenStream stream_ML_COMMENT = new RewriteRuleTokenStream(adaptor,"token ML_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 120) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1522:4: ( ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1522:4: ML_COMMENT
            {
            	ML_COMMENT315 = (CommonToken)input.LT(1);
            	Match(input,ML_COMMENT,FOLLOW_ML_COMMENT_in_multiCommentStatement5588); if (failed) return retval;
            	if ( backtracking==0 ) stream_ML_COMMENT.Add(ML_COMMENT315);

            	
            	// AST REWRITE
            	// elements:          ML_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1522:15: -> ^( MULTILINE_COMMENT ML_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1522:18: ^( MULTILINE_COMMENT ML_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MULTILINE_COMMENT, "MULTILINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ML_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 120, multiCommentStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiCommentStatement

    public class brackets_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start brackets
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1525:1: brackets : LBRACK expressionList RBRACK ;
    public brackets_return brackets() // throws RecognitionException [1]
    {   
        brackets_return retval = new brackets_return();
        retval.start = input.LT(1);
        int brackets_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LBRACK316 = null;
        CommonToken RBRACK318 = null;
        expressionList_return expressionList317 = null;
        
        
        CommonTree LBRACK316_tree=null;
        CommonTree RBRACK318_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 121) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1532:4: ( LBRACK expressionList RBRACK )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1532:4: LBRACK expressionList RBRACK
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	LBRACK316 = (CommonToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_brackets5616); if (failed) return retval;
            	if ( backtracking==0 ) {
            	LBRACK316_tree = (CommonTree)adaptor.Create(LBRACK316);
            	adaptor.AddChild(root_0, LBRACK316_tree);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("["); 
            	}
            	PushFollow(FOLLOW_expressionList_in_brackets5624);
            	expressionList317 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList317.Tree);
            	RBRACK318 = (CommonToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_brackets5629); if (failed) return retval;
            	if ( backtracking==0 ) {
            	RBRACK318_tree = (CommonTree)adaptor.Create(RBRACK318);
            	adaptor.AddChild(root_0, RBRACK318_tree);
            	}
            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("]"); 
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 121, brackets_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end brackets

    public class encapsulatedExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start encapsulatedExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1537:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
    public encapsulatedExpression_return encapsulatedExpression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        encapsulatedExpression_return retval = new encapsulatedExpression_return();
        retval.start = input.LT(1);
        int encapsulatedExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken LPAREN319 = null;
        CommonToken RPAREN321 = null;
        assignmentExpression_return assignmentExpression320 = null;
        
        
        CommonTree LPAREN319_tree=null;
        CommonTree RPAREN321_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 122) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1542:4: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1542:4: LPAREN assignmentExpression RPAREN
            {
            	LPAREN319 = (CommonToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_encapsulatedExpression5654); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN319);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append("("); 
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_encapsulatedExpression5664);
            	assignmentExpression320 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression320.Tree);
            	RPAREN321 = (CommonToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_encapsulatedExpression5669); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN321);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(")"); 
            	}
            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1545:3: -> ^( ENCPS_EXPR assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1545:6: ^( ENCPS_EXPR assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 122, encapsulatedExpression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end encapsulatedExpression

    public class functionDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start functionDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1549:1: functionDefinition : f= FUNCTION parameterDeclarationList (type_exp= typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
    public functionDefinition_return functionDefinition() // throws RecognitionException [1]
    {   
        functionDefinition_return retval = new functionDefinition_return();
        retval.start = input.LT(1);
        int functionDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken f = null;
        typeExpression_return type_exp = null;

        parameterDeclarationList_return parameterDeclarationList322 = null;

        block_return block323 = null;
        
        
        CommonTree f_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 123) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1550:4: (f= FUNCTION parameterDeclarationList (type_exp= typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1550:4: f= FUNCTION parameterDeclarationList (type_exp= typeExpression )? block
            {
            	f = (CommonToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionDefinition5699); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(f);

            	if ( backtracking == 0 ) 
            	{
            	   buffer.Append(f.Text + (options.SpaceBeforeMethodDef ? " " : "")); 
            	}
            	PushFollow(FOLLOW_parameterDeclarationList_in_functionDefinition5706);
            	parameterDeclarationList322 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList322.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1552:11: (type_exp= typeExpression )?
            	int alt91 = 2;
            	int LA91_0 = input.LA(1);
            	
            	if ( (LA91_0 == COLON) )
            	{
            	    alt91 = 1;
            	}
            	switch (alt91) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: type_exp= typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_functionDefinition5713);
            	        	type_exp = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(type_exp.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	if ( backtracking == 0 ) 
            	{
            	  
            	  										if(options.NewlineAfterMethod) buffer.Append(NewLine + tab);
            	  										buffer.Append("{");
            	  										CurrentTab++;
            	  									
            	}
            	PushFollow(FOLLOW_block_in_functionDefinition5729);
            	block323 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_block.Add(block323.Tree);
            	if ( backtracking == 0 ) 
            	{
            	  
            	  										CurrentTab--;
            	  										buffer.Append(NewLine + tab);
            	  										buffer.Append("}");
            	  										//buffer.Append(NewLine + tab);
            	  									
            	}
            	
            	// AST REWRITE
            	// elements:          block, parameterDeclarationList, typeExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1565:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1565:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1565:42: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 123, functionDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end functionDefinition

    public class ident_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ident
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1569:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );
    public ident_return ident() // throws RecognitionException [1]
    {   
        ident_return retval = new ident_return();
        retval.start = input.LT(1);
        int ident_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        CommonToken i = null;
        CommonToken IDENT324 = null;
        
        CommonTree i_tree=null;
        CommonTree IDENT324_tree=null;
        RewriteRuleTokenStream stream_GET = new RewriteRuleTokenStream(adaptor,"token GET");
        RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor,"token XML");
        RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor,"token AS");
        RewriteRuleTokenStream stream_DYNAMIC = new RewriteRuleTokenStream(adaptor,"token DYNAMIC");
        RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor,"token SET");
        RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor,"token IS");
        RewriteRuleTokenStream stream_USE = new RewriteRuleTokenStream(adaptor,"token USE");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 124) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1570:4: ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] )
            int alt92 = 8;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                alt92 = 1;
                }
                break;
            case USE:
            	{
                alt92 = 2;
                }
                break;
            case XML:
            	{
                alt92 = 3;
                }
                break;
            case DYNAMIC:
            	{
                alt92 = 4;
                }
                break;
            case IS:
            	{
                alt92 = 5;
                }
                break;
            case AS:
            	{
                alt92 = 6;
                }
                break;
            case GET:
            	{
                alt92 = 7;
                }
                break;
            case SET:
            	{
                alt92 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d92s0 =
            	        new NoViableAltException("1569:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );", 92, 0, input);
            
            	    throw nvae_d92s0;
            }
            
            switch (alt92) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1570:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT324 = (CommonToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_ident5767); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT324_tree = (CommonTree)adaptor.Create(IDENT324);
                    	adaptor.AddChild(root_0, IDENT324_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1571:4: i= USE
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,USE,FOLLOW_USE_in_ident5774); if (failed) return retval;
                    	if ( backtracking==0 ) stream_USE.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1571:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1572:4: i= XML
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,XML,FOLLOW_XML_in_ident5786); if (failed) return retval;
                    	if ( backtracking==0 ) stream_XML.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1572:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1573:4: i= DYNAMIC
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_ident5798); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DYNAMIC.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1573:14: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1574:4: i= IS
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_ident5810); if (failed) return retval;
                    	if ( backtracking==0 ) stream_IS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1574:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1575:4: i= AS
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_ident5822); if (failed) return retval;
                    	if ( backtracking==0 ) stream_AS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1575:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1576:4: i= GET
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,GET,FOLLOW_GET_in_ident5834); if (failed) return retval;
                    	if ( backtracking==0 ) stream_GET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1576:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1577:4: i= SET
                    {
                    	i = (CommonToken)input.LT(1);
                    	Match(input,SET,FOLLOW_SET_in_ident5846); if (failed) return retval;
                    	if ( backtracking==0 ) stream_SET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1577:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
         
        	catch (NoViableAltException e)
        	{
        		Debug.WriteLine("NoValiable alt: token=" + e.Token + " (decision=" + e.decisionNumber + " state " + e.stateNumber + ")" + " decision=<<" + e.grammarDecisionDescription + ">>");
        		throw e;
        	}
        	catch (MismatchedTokenException e)
        	{
                Debug.WriteLine("[" + e.Line + ":" + e.Index + "]: " + e.Message + ". Unexpected " + e.UnexpectedType.ToString() +  "( expecting: "+ e.expecting + " )");
                throw e;
        	}
        	catch(RecognitionException e)
        	{
        		Debug.WriteLine("RecognitionException: " + e);
        		throw e;
        	}
        finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 124, ident_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ident

    // $ANTLR start synpred5
    public void synpred5_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:371:4: ( SEMI )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:371:4: SEMI
        {
        	Match(input,SEMI,FOLLOW_SEMI_in_synpred5575); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred5

    // $ANTLR start synpred37
    public void synpred37_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:673:4: ( LCURLY )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:673:5: LCURLY
        {
        	Match(input,LCURLY,FOLLOW_LCURLY_in_synpred371978); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred37

    // $ANTLR start synpred39
    public void synpred39_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:675:4: ( expressionStatement )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:675:4: expressionStatement
        {
        	PushFollow(FOLLOW_expressionStatement_in_synpred391996);
        	expressionStatement();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred39

    // $ANTLR start synpred52
    public void synpred52_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:718:6: ( comments )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:718:6: comments
        {
        	PushFollow(FOLLOW_comments_in_synpred522198);
        	comments();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred52

    // $ANTLR start synpred54
    public void synpred54_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:727:4: ( ELSE )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:727:5: ELSE
        {
        	Match(input,ELSE,FOLLOW_ELSE_in_synpred542239); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred54

    // $ANTLR start synpred55
    public void synpred55_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:726:4: ( ( comments )? ( ELSE )=> elseClause )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:726:4: ( comments )? ( ELSE )=> elseClause
        {
        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:726:6: ( comments )?
        	int alt97 = 2;
        	int LA97_0 = input.LA(1);
        	
        	if ( ((LA97_0 >= SL_COMMENT && LA97_0 <= ML_COMMENT)) )
        	{
        	    alt97 = 1;
        	}
        	switch (alt97) 
        	{
        	    case 1 :
        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:0:0: comments
        	        {
        	        	PushFollow(FOLLOW_comments_in_synpred552229);
        	        	comments();
        	        	followingStackPointer_--;
        	        	if (failed) return ;
        	        
        	        }
        	        break;
        	
        	}

        	PushFollow(FOLLOW_elseClause_in_synpred552242);
        	elseClause();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred55

    // $ANTLR start synpred59
    public void synpred59_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:812:4: ( RETURN expression semi )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:812:4: RETURN expression semi
        {
        	Match(input,RETURN,FOLLOW_RETURN_in_synpred592424); if (failed) return ;
        	PushFollow(FOLLOW_expression_in_synpred592429);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_semi_in_synpred592431);
        	semi();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred59

    // $ANTLR start synpred63
    public void synpred63_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:880:4: ( forInClauseDecl IN )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:880:5: forInClauseDecl IN
        {
        	PushFollow(FOLLOW_forInClauseDecl_in_synpred632718);
        	forInClauseDecl();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,IN,FOLLOW_IN_in_synpred632720); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred63

    // $ANTLR start synpred78
    public void synpred78_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:5: ( ( annotation ) )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:5: ( annotation )
        {
        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:5: ( annotation )
        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1061:7: annotation
        	{
        		if ( backtracking == 0 ) 
        		{
        		   buffer.Append(NewLine + tab); 
        		}
        		PushFollow(FOLLOW_annotation_in_synpred783424);
        		annotation();
        		followingStackPointer_--;
        		if (failed) return ;
        	
        	}

        
        }
    }
    // $ANTLR end synpred78

    // $ANTLR start synpred79
    public void synpred79_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:6: ( ( includeDirective ) )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:6: ( includeDirective )
        {
        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:6: ( includeDirective )
        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1062:8: includeDirective
        	{
        		if ( backtracking == 0 ) 
        		{
        		   buffer.Append(NewLine + tab); 
        		}
        		PushFollow(FOLLOW_includeDirective_in_synpred793437);
        		includeDirective();
        		followingStackPointer_--;
        		if (failed) return ;
        	
        	}

        
        }
    }
    // $ANTLR end synpred79

    // $ANTLR start synpred83
    public void synpred83_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1090:3: ( ident ASSIGN constant )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1090:3: ident ASSIGN constant
        {
        	PushFollow(FOLLOW_ident_in_synpred833607);
        	ident();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred833609); if (failed) return ;
        	PushFollow(FOLLOW_constant_in_synpred833613);
        	constant();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred83

    // $ANTLR start synpred84
    public void synpred84_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1091:4: ( ident ASSIGN ident )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1091:4: ident ASSIGN ident
        {
        	PushFollow(FOLLOW_ident_in_synpred843632);
        	ident();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred843634); if (failed) return ;
        	PushFollow(FOLLOW_ident_in_synpred843638);
        	ident();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred84

    // $ANTLR start synpred98
    public void synpred98_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1153:4: ( COMMA assignmentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1153:4: COMMA assignmentExpression
        {
        	Match(input,COMMA,FOLLOW_COMMA_in_synpred983924); if (failed) return ;
        	PushFollow(FOLLOW_assignmentExpression_in_synpred983936);
        	assignmentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred98

    // $ANTLR start synpred104
    public void synpred104_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1233:4: ( assignmentOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1233:5: assignmentOperator
        {
        	PushFollow(FOLLOW_assignmentOperator_in_synpred1044197);
        	assignmentOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred104

    // $ANTLR start synpred130
    public void synpred130_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1354:4: ( relationalOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1354:5: relationalOperator
        {
        	PushFollow(FOLLOW_relationalOperator_in_synpred1304643);
        	relationalOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred130

    // $ANTLR start synpred141
    public void synpred141_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1389:4: ( additiveOperator multiplicativeExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1389:4: additiveOperator multiplicativeExpression
        {
        	PushFollow(FOLLOW_additiveOperator_in_synpred1414784);
        	additiveOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_multiplicativeExpression_in_synpred1414794);
        	multiplicativeExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred141

    // $ANTLR start synpred156
    public void synpred156_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1441:5: ( LBRACK expression RBRACK )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1441:5: LBRACK expression RBRACK
        {
        	Match(input,LBRACK,FOLLOW_LBRACK_in_synpred1565113); if (failed) return ;
        	PushFollow(FOLLOW_expression_in_synpred1565117);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,RBRACK,FOLLOW_RBRACK_in_synpred1565119); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred156

    // $ANTLR start synpred157
    public void synpred157_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1442:5: ( arguments )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1442:5: arguments
        {
        	PushFollow(FOLLOW_arguments_in_synpred1575138);
        	arguments();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred157

    // $ANTLR start synpred158
    public void synpred158_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1445:6: ( INC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1445:6: INC
        {
        	Match(input,INC,FOLLOW_INC_in_synpred1585164); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred158

    // $ANTLR start synpred159
    public void synpred159_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1446:6: ( DEC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1446:6: DEC
        {
        	Match(input,DEC,FOLLOW_DEC_in_synpred1595185); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred159

    // $ANTLR start synpred176
    public void synpred176_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:4: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1509:4: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred1765502);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred176

    // $ANTLR start synpred177
    public void synpred177_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:27: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1513:27: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred1775525);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred177

    // $ANTLR start synpred179
    public void synpred179_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:27: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\CodeReformatter\\CodeReformatter\\AS.g:1514:27: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred1795545);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred179

   	public bool synpred79() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred79_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred159() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred159_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred78() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred78_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred158() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred158_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred157() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred157_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred156() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred156_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred59() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred59_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred55() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred55_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred54() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred54_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred104() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred104_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred84() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred84_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred52() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred52_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred83() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred83_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred130() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred130_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred39() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred39_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred37() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred37_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred179() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred179_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred98() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred98_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred177() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred177_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred176() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred176_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred63() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred63_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred141() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred141_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred5() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred5_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}


	private void InitializeCyclicDFAs()
	{
	}

 

    public static readonly BitSet FOLLOW_as2CompilationUnit_in_compilationUnit437 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_as2CompilationUnit468 = new BitSet(new ulong[]{0x3400000000000000UL,0x0000006FC0000000UL,0x01F0800018000000UL});
    public static readonly BitSet FOLLOW_annotations_in_as2CompilationUnit474 = new BitSet(new ulong[]{0x3400000000000000UL,0x0000006FC0000000UL,0x01F0800018000000UL});
    public static readonly BitSet FOLLOW_comments_in_as2CompilationUnit484 = new BitSet(new ulong[]{0x3400000000000000UL,0x0000006FC0000000UL,0x01F0800018000000UL});
    public static readonly BitSet FOLLOW_as2Type_in_as2CompilationUnit495 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_as2Type508 = new BitSet(new ulong[]{0x3000000000000000UL});
    public static readonly BitSet FOLLOW_as2ClassDefinition_in_as2Type514 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2InterfaceDefinition_in_as2Type520 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EOF_in_endOfFile537 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IMPORT_in_importDefinition549 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifierStar_in_importDefinition556 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_importDefinition564 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_semi575 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_as2ClassDefinition594 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_as2ClassDefinition606 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_classExtendsClause_in_as2ClassDefinition612 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_implementsClause_in_as2ClassDefinition619 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_typeBlock_in_as2ClassDefinition625 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDefinition672 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_interfaceDefinition683 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_interfaceDefinition687 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlock_in_interfaceDefinition693 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_as2InterfaceDefinition729 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_as2InterfaceDefinition731 = new BitSet(new ulong[]{0x4000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition735 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlock_in_as2InterfaceDefinition739 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_classExtendsClause773 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_classExtendsClause785 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceExtendsClause808 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause820 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_interfaceExtendsClause834 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause848 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_implementsClause875 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause886 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_implementsClause900 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause913 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceTypeBlock939 = new BitSet(new ulong[]{0x0400000000000000UL,0x0000006FC000002CUL,0x01F0800000000000UL});
    public static readonly BitSet FOLLOW_interfaceTypeBlockEntry_in_interfaceTypeBlock944 = new BitSet(new ulong[]{0x0400000000000000UL,0x0000006FC000002CUL,0x01F0800000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceTypeBlock950 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_typeBlock973 = new BitSet(new ulong[]{0x0400000000000000UL,0x0000006FC000032CUL,0x01F0800018000000UL});
    public static readonly BitSet FOLLOW_typeBlockEntry_in_typeBlock978 = new BitSet(new ulong[]{0x0400000000000000UL,0x0000006FC000032CUL,0x01F0800018000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_typeBlock984 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_interfaceTypeBlockEntry1012 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000020UL});
    public static readonly BitSet FOLLOW_interfaceMethodDefinition_in_interfaceTypeBlockEntry1023 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_interfaceTypeBlockEntry1033 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2IncludeDirective_in_interfaceTypeBlockEntry1040 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_interfaceTypeBlockEntry1047 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_typeBlockEntry1064 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000320UL});
    public static readonly BitSet FOLLOW_variableDefinition_in_typeBlockEntry1071 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_methodDefinition_in_typeBlockEntry1081 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_typeBlockEntry1091 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2IncludeDirective_in_typeBlockEntry1098 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_typeBlockEntry1105 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comments_in_typeBlockEntry1114 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1127 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_as2IncludeDirective1131 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_175_in_includeDirective1154 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_includeDirective1156 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_includeDirective1158 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_interfaceMethodDefinition1170 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_optionalAccessorRole_in_interfaceMethodDefinition1182 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_interfaceMethodDefinition1188 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_interfaceMethodDefinition1198 = new BitSet(new ulong[]{0x0800000000000002UL,0x0000000000100000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_interfaceMethodDefinition1204 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_interfaceMethodDefinition1212 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_methodDefinition1283 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_optionalAccessorRole_in_methodDefinition1295 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_methodDefinition1301 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_methodDefinition1319 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100002UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_methodDefinition1325 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_comments_in_methodDefinition1348 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_methodDefinition1358 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_methodDefinition1360 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_accessorRole_in_optionalAccessorRole1447 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GET_in_accessorRole1470 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SET_in_accessorRole1478 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_variableDefinition1509 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1518 = new BitSet(new ulong[]{0x8800000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDefinition1538 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1549 = new BitSet(new ulong[]{0x8800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_variableDefinition1558 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_varOrConst0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_variableDeclarator1602 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000100400UL});
    public static readonly BitSet FOLLOW_typeExpression_in_variableDeclarator1615 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_variableInitializer_in_variableDeclarator1622 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_declaration1637 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declaration1647 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_declarationTail_in_declaration1651 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_declarationTail1677 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declarationTail1685 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableInitializer1701 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableInitializer1711 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_parameterDeclarationList1724 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400012C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1734 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_COMMA_in_parameterDeclarationList1745 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400002C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1754 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_parameterDeclarationList1769 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_basicParameterDeclaration_in_parameterDeclaration1796 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONST_in_basicParameterDeclaration1807 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_basicParameterDeclaration1815 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000100400UL});
    public static readonly BitSet FOLLOW_typeExpression_in_basicParameterDeclaration1827 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_parameterDefault_in_basicParameterDeclaration1834 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_parameterDefault1878 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_parameterDefault1881 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_block1892 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF6UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_blockEntry_in_block1896 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF6UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_RCURLY_in_block1902 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_blockEntry1926 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_condition1937 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_condition1945 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_condition1950 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_statement1982 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declarationStatement_in_statement1987 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_statement1996 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_statement2006 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_statement2011 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_statement2016 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement2021 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_statement2026 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_statement2031 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_statement2036 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_statement2046 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_statement2055 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_statement2065 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_statement2075 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_statement2080 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comments_in_statement2088 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_declarationStatement2115 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_declarationStatement2120 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_expressionStatement2141 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_expressionStatement2143 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IF_in_ifStatement2165 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_condition_in_ifStatement2177 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_comments_in_ifStatement2198 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement2208 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000004000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_comments_in_ifStatement2229 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_elseClause_in_ifStatement2242 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_elseClause2264 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_elseClause2275 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_176_in_throwStatement2291 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_throwStatement2296 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_throwStatement2298 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_177_in_tryStatement2309 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_tryStatement2317 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000C000000000000UL});
    public static readonly BitSet FOLLOW_catchBlock_in_tryStatement2330 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000C000000000000UL});
    public static readonly BitSet FOLLOW_finallyBlock_in_tryStatement2340 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_178_in_catchBlock2353 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_LPAREN_in_catchBlock2360 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_catchBlock2370 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000101000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_catchBlock2376 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_catchBlock2382 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_catchBlock2390 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_179_in_finallyBlock2404 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_finallyBlock2410 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement2424 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_returnStatement2429 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_returnStatement2431 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement2436 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_returnStatement2439 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement2454 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_continueStatement2457 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement2470 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_breakStatement2473 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement2487 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_condition_in_switchStatement2496 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchBlock_in_switchStatement2501 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_switchBlock2512 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000280004UL});
    public static readonly BitSet FOLLOW_caseStatement_in_switchBlock2529 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000280004UL});
    public static readonly BitSet FOLLOW_defaultStatement_in_switchBlock2539 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RCURLY_in_switchBlock2545 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CASE_in_caseStatement2579 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_caseStatement2588 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100000UL});
    public static readonly BitSet FOLLOW_COLON_in_caseStatement2593 = new BitSet(new ulong[]{0x0800000000000002UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_switchStatementList_in_caseStatement2603 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultStatement2622 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100000UL});
    public static readonly BitSet FOLLOW_COLON_in_defaultStatement2629 = new BitSet(new ulong[]{0x0800000000000002UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_switchStatementList_in_defaultStatement2639 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_switchStatementList2661 = new BitSet(new ulong[]{0x0800000000000002UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_FOR_in_forStatement2695 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement2703 = new BitSet(new ulong[]{0x0800000000000000UL,0x0000004848000BF2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_forInClause_in_forStatement2723 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2729 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2742 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_traditionalForClause_in_forStatement2771 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2773 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2782 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInit_in_traditionalForClause2819 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2821 = new BitSet(new ulong[]{0x0800000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_forCond_in_traditionalForClause2831 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2833 = new BitSet(new ulong[]{0x0000000000000002UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_forIter_in_traditionalForClause2843 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_forInClause2855 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_IN_in_forInClause2857 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_forInClauseTail_in_forInClause2862 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInClauseDecl2883 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_forInClauseDecl2891 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInClauseTail2917 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInit2941 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInit2945 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forCond2983 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forIter3016 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement3039 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_condition_in_whileStatement3048 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_whileStatement3056 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement3071 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement3081 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000001000000UL});
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement3088 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_condition_in_doWhileStatement3098 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_doWhileStatement3104 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WITH_in_withStatement3115 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_condition_in_withStatement3124 = new BitSet(new ulong[]{0x0800000000000000UL,0x000000484F47ABF2UL,0x000300007FFFF30CUL});
    public static readonly BitSet FOLLOW_statement_in_withStatement3132 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COLON_in_typeExpression3152 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040580000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_identifier_in_typeExpression3165 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VOID_in_typeExpression3173 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_typeExpression3183 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier3221 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifier3245 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier3249 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_ident_in_qualifiedIdent3278 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_namespaceName3292 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_reservedNamespace_in_namespaceName3296 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_reservedNamespace0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar3335 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar3357 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar3361 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar3376 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_STAR_in_identifierStar3378 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_annotations3424 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_includeDirective_in_annotations3437 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL,0x0000800000000000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_annotation3466 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_annotation3478 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000800UL});
    public static readonly BitSet FOLLOW_annotationParamList_in_annotation3487 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_annotation3492 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_annotationParamList3524 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400010D0UL,0x0000000063F8000CUL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList3537 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_COMMA_in_annotationParamList3548 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000D0UL,0x0000000063F8000CUL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList3559 = new BitSet(new ulong[]{0x8000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_annotationParamList3574 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3607 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam3609 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL,0x0000000003F80000UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam3613 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3632 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam3634 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3638 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam3657 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam3670 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifier_in_modifiers3690 = new BitSet(new ulong[]{0x0000000000000002UL,0x00000067C0000000UL,0x01F0000000000000UL});
    public static readonly BitSet FOLLOW_namespaceName_in_modifier3713 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STATIC_in_modifier3718 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_180_in_modifier3723 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_181_in_modifier3728 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_182_in_modifier3733 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_183_in_modifier3738 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_modifier3743 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_184_in_modifier3748 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3769 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expressionList_in_arguments3773 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3775 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3782 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3784 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_element3810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral3832 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000058480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral3836 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral3839 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3863 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList3873 = new BitSet(new ulong[]{0x0000000000000002UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3886 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3914 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_nonemptyElementList3924 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3936 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral3958 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C4UL,0x0000000063C0000CUL});
    public static readonly BitSet FOLLOW_fieldList_in_objectLiteral3967 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral3973 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList4000 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_fieldList4010 = new BitSet(new ulong[]{0x0000000000000002UL,0x00000040400000C0UL,0x0000000063C0000CUL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList4024 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_fieldName_in_literalField4046 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100000UL});
    public static readonly BitSet FOLLOW_COLON_in_literalField4051 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_element_in_literalField4059 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_fieldName4085 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_fieldName4095 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression4120 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList4132 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_expressionList4142 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList4154 = new BitSet(new ulong[]{0x8000000000000002UL});
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression4188 = new BitSet(new ulong[]{0x0000000000000002UL,0x000FFF8000000400UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression4203 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression4223 = new BitSet(new ulong[]{0x0000000000000002UL,0x000FFF8000000400UL});
    public static readonly BitSet FOLLOW_set_in_assignmentOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalOrExpression_in_conditionalExpression4317 = new BitSet(new ulong[]{0x0000000000000002UL,0x0010000000000000UL});
    public static readonly BitSet FOLLOW_QUESTION_in_conditionalExpression4331 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_conditionalSubExpression_in_conditionalExpression4338 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression4367 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalSubExpression4372 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression4381 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression4395 = new BitSet(new ulong[]{0x0000000000000002UL,0x0020000000000000UL,0x0200000000000000UL});
    public static readonly BitSet FOLLOW_logicalOrOperator_in_logicalOrExpression4406 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression4418 = new BitSet(new ulong[]{0x0000000000000002UL,0x0020000000000000UL,0x0200000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalOrOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression4450 = new BitSet(new ulong[]{0x0000000000000002UL,0x0040000000000000UL,0x0400000000000000UL});
    public static readonly BitSet FOLLOW_logicalAndOperator_in_logicalAndExpression4461 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression4473 = new BitSet(new ulong[]{0x0000000000000002UL,0x0040000000000000UL,0x0400000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalAndOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression4505 = new BitSet(new ulong[]{0x0000000000000002UL,0x0080000000000000UL});
    public static readonly BitSet FOLLOW_BOR_in_bitwiseOrExpression4510 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression4513 = new BitSet(new ulong[]{0x0000000000000002UL,0x0080000000000000UL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression4527 = new BitSet(new ulong[]{0x0000000000000002UL,0x0100000000000000UL});
    public static readonly BitSet FOLLOW_BXOR_in_bitwiseXorExpression4532 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression4535 = new BitSet(new ulong[]{0x0000000000000002UL,0x0100000000000000UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression4549 = new BitSet(new ulong[]{0x0000000000000002UL,0x0200000000000000UL});
    public static readonly BitSet FOLLOW_BAND_in_bitwiseAndExpression4554 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression4557 = new BitSet(new ulong[]{0x0000000000000002UL,0x0200000000000000UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression4571 = new BitSet(new ulong[]{0x0000000000000002UL,0x3C00000000000000UL});
    public static readonly BitSet FOLLOW_equalityOperator_in_equalityExpression4581 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression4593 = new BitSet(new ulong[]{0x0000000000000002UL,0x3C00000000000000UL});
    public static readonly BitSet FOLLOW_set_in_equalityOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression4633 = new BitSet(new ulong[]{0x0000000000000002UL,0xC000000000800000UL,0x000000000000001FUL});
    public static readonly BitSet FOLLOW_relationalOperator_in_relationalExpression4649 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression4657 = new BitSet(new ulong[]{0x0000000000000002UL,0xC000000000800000UL,0x000000000000001FUL});
    public static readonly BitSet FOLLOW_IN_in_relationalOperator4675 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_relationalOperator4680 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_relationalOperator4684 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LE_in_relationalOperator4688 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GE_in_relationalOperator4692 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_relationalOperator4696 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_relationalOperator4700 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INSTANCEOF_in_relationalOperator4704 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression4716 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x00000000000000E0UL});
    public static readonly BitSet FOLLOW_shiftOperator_in_shiftExpression4727 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression4737 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x00000000000000E0UL});
    public static readonly BitSet FOLLOW_set_in_shiftOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression4773 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_additiveExpression4784 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression4794 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000000300UL});
    public static readonly BitSet FOLLOW_set_in_additiveOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression4826 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL,0x0000000000000C00UL});
    public static readonly BitSet FOLLOW_multiplicativeOperator_in_multiplicativeExpression4838 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression4846 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000010000000UL,0x0000000000000C00UL});
    public static readonly BitSet FOLLOW_set_in_multiplicativeOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_unaryExpression4884 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4889 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_unaryExpression4906 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4911 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_MINUS_in_unaryExpression4928 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4932 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PLUS_in_unaryExpression4948 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression4952 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression4966 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DELETE_in_unaryExpressionNotPlusMinus4979 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048400008F2UL,0x0000000067FC000CUL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4984 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_VOID_in_unaryExpressionNotPlusMinus4999 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5003 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus5018 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5022 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LNOT_in_unaryExpressionNotPlusMinus5037 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5041 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BNOT_in_unaryExpressionNotPlusMinus5056 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus5060 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus5073 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_postfixExpression5086 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000800UL,0x0000000000003000UL});
    public static readonly BitSet FOLLOW_propOrIdent_in_postfixExpression5099 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000800UL,0x0000000000003000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_postfixExpression5113 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_postfixExpression5117 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_postfixExpression5119 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000800UL,0x0000000000003000UL});
    public static readonly BitSet FOLLOW_arguments_in_postfixExpression5138 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000800UL,0x0000000000003000UL});
    public static readonly BitSet FOLLOW_INC_in_postfixExpression5164 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_postfixExpression5185 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_UNDEFINED_in_primaryExpression5216 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_primaryExpression5228 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpression5239 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpression5244 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDefinition_in_primaryExpression5249 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newFullExpression_in_primaryExpression5254 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_encapsulatedExpression_in_primaryExpression5259 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_primaryExpression5264 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propOrIdent5290 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_propOrIdent5303 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_constant5327 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_constant5332 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TRUE_in_constant5337 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FALSE_in_constant5342 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NULL_in_constant5347 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_number0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NEW_in_newFullExpression5389 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048400008F2UL,0x0000000067FC000CUL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_newFullExpression5400 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_arguments_in_newFullExpression5406 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_fullNewSubexpression5424 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000000UL});
    public static readonly BitSet FOLLOW_DOT_in_fullNewSubexpression5438 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_fullNewSubexpression5443 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000000UL});
    public static readonly BitSet FOLLOW_brackets_in_fullNewSubexpression5460 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000820000000UL});
    public static readonly BitSet FOLLOW_comment_in_comments5502 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_singleCommentStatement_in_comment5523 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment5525 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_multiCommentStatement_in_comment5542 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment5545 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000018000000UL});
    public static readonly BitSet FOLLOW_SL_COMMENT_in_singleCommentStatement5568 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ML_COMMENT_in_multiCommentStatement5588 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_brackets5616 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expressionList_in_brackets5624 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_brackets5629 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_encapsulatedExpression5654 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_encapsulatedExpression5664 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000001000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_encapsulatedExpression5669 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDefinition5699 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000800UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_functionDefinition5706 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000100002UL});
    public static readonly BitSet FOLLOW_typeExpression_in_functionDefinition5713 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_functionDefinition5729 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_ident5767 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_ident5774 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_in_ident5786 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_ident5798 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_ident5810 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_ident5822 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GET_in_ident5834 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SET_in_ident5846 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred5575 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred371978 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_synpred391996 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comments_in_synpred522198 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_synpred542239 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comments_in_synpred552229 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_elseClause_in_synpred552242 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_synpred592424 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_synpred592429 = new BitSet(new ulong[]{0x0800000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_synpred592431 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_synpred632718 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000800000UL});
    public static readonly BitSet FOLLOW_IN_in_synpred632720 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_synpred783424 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_includeDirective_in_synpred793437 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_synpred833607 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred833609 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000010UL,0x0000000003F80000UL});
    public static readonly BitSet FOLLOW_constant_in_synpred833613 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_synpred843632 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred843634 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000040400000C0UL,0x000000006000000CUL});
    public static readonly BitSet FOLLOW_ident_in_synpred843638 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_synpred983924 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred983936 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred1044197 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_relationalOperator_in_synpred1304643 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_synpred1414784 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred1414794 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_synpred1565113 = new BitSet(new ulong[]{0x0000000000000000UL,0x00000048480008F2UL,0x0000000067FFF30CUL});
    public static readonly BitSet FOLLOW_expression_in_synpred1565117 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_synpred1565119 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_synpred1575138 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_synpred1585164 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_synpred1595185 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred1765502 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred1775525 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred1795545 = new BitSet(new ulong[]{0x0000000000000002UL});

}
}