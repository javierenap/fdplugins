// $ANTLR 3.0 C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g 2007-08-23 01:12:06
namespace 
CodeReformatter.Generators.Core

{

using System.IO;
using System.Diagnostics;


using System;
using Antlr.Runtime;
using IList 		= System.Collections.IList;
using ArrayList 	= System.Collections.ArrayList;
using Stack 		= Antlr.Runtime.Collections.StackList;

using IDictionary	= System.Collections.IDictionary;
using Hashtable 	= System.Collections.Hashtable;



using Antlr.Runtime.Tree;

public class ASParser : Parser 
{
    public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"COMPILATION_UNIT", 
		"TYPE_BLOCK", 
		"METHOD_DEF", 
		"VAR_DEF", 
		"ANNOTATIONS", 
		"ANNOTATION", 
		"ANNOTATION_PARAMS", 
		"MODIFIERS", 
		"NAMESPACE_DEF", 
		"ACCESSOR_ROLE", 
		"CLASS_DEF", 
		"INTERFACE_DEF", 
		"PARAMS", 
		"PARAM", 
		"TYPE_SPEC", 
		"BLOCK", 
		"ELIST", 
		"CONDITION", 
		"ARGUMENTS", 
		"EXPR_STMNT", 
		"ENCPS_EXPR", 
		"VAR_INIT", 
		"METHOD_CALL", 
		"PROPERTY_OR_IDENTIFIER", 
		"PROPERTY_ACCESS", 
		"TYPE_NAME", 
		"ARRAY_ACC", 
		"UNARY_PLUS", 
		"UNARY_MINUS", 
		"POST_INC", 
		"POST_DEC", 
		"PRE_INC", 
		"PRE_DEC", 
		"ARRAY_LITERAL", 
		"ELEMENT", 
		"OBJECT_LITERAL", 
		"OBJECT_FIELD", 
		"FUNC_DEF", 
		"FOR_INIT", 
		"FOR_CONDITION", 
		"FOR_ITERATOR", 
		"FOR_EACH", 
		"FOR_IN", 
		"SWITCH_STATEMENT_LIST", 
		"IDENTIFIER", 
		"DEFAULT_XML_NAMESPACE", 
		"SINGLELINE_COMMENT", 
		"MULTILINE_COMMENT", 
		"COMMENT_LIST", 
		"COMMENT_ENTRY", 
		"VIRTUAL_PLACEHOLDER", 
		"ANNOTATION_ASSIGN", 
		"AS2_COMPILATION_UNIT", 
		"HIDDEN", 
		"HIDDEN_CHANNEL", 
		"PACKAGE", 
		"LCURLY", 
		"RCURLY", 
		"SEMI", 
		"IMPORT", 
		"CLASS", 
		"INTERFACE", 
		"EXTENDS", 
		"COMMA", 
		"IMPLEMENTS", 
		"INCLUDE_DIRECTIVE", 
		"STRING_LITERAL", 
		"FUNCTION", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"USE", 
		"VAR", 
		"CONST", 
		"ASSIGN", 
		"LPAREN", 
		"RPAREN", 
		"REST", 
		"IF", 
		"ELSE", 
		"RETURN", 
		"CONTINUE", 
		"BREAK", 
		"SWITCH", 
		"CASE", 
		"COLON", 
		"DEFAULT", 
		"FOR", 
		"EACH", 
		"IN", 
		"WHILE", 
		"DO", 
		"WITH", 
		"XML", 
		"STAR", 
		"DOT", 
		"DBL_COLON", 
		"IDENT", 
		"PUBLIC", 
		"PRIVATE", 
		"PROTECTED", 
		"INTERNAL", 
		"LBRACK", 
		"RBRACK", 
		"STATIC", 
		"DYNAMIC", 
		"STAR_ASSIGN", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"PLUS_ASSIGN", 
		"MINUS_ASSIGN", 
		"SL_ASSIGN", 
		"SR_ASSIGN", 
		"BSR_ASSIGN", 
		"BAND_ASSIGN", 
		"BXOR_ASSIGN", 
		"BOR_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"QUESTION", 
		"LOR", 
		"LAND", 
		"BOR", 
		"BXOR", 
		"BAND", 
		"STRICT_EQUAL", 
		"STRICT_NOT_EQUAL", 
		"NOT_EQUAL", 
		"EQUAL", 
		"LT", 
		"GT", 
		"LE", 
		"GE", 
		"IS", 
		"AS", 
		"INSTANCEOF", 
		"SL", 
		"SR", 
		"BSR", 
		"PLUS", 
		"MINUS", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"DELETE", 
		"TYPEOF", 
		"LNOT", 
		"BNOT", 
		"E4X_DESC", 
		"E4X_ATTRI", 
		"UNDEFINED", 
		"TRUE", 
		"FALSE", 
		"NULL", 
		"HEX_LITERAL", 
		"DECIMAL_LITERAL", 
		"OCTAL_LITERAL", 
		"FLOAT_LITERAL", 
		"NEW", 
		"SL_COMMENT", 
		"ML_COMMENT", 
		"ESC", 
		"HEX_DIGIT", 
		"EXPONENT", 
		"WS", 
		"NL", 
		"BOM", 
		"OCT_DIGIT", 
		"CTRLCHAR_ESC", 
		"UNICODE_ESC", 
		"OCTAL_ESC", 
		"'include'", 
		"'throw'", 
		"'try'", 
		"'catch'", 
		"'finally'", 
		"'void'", 
		"'final'", 
		"'enumerable'", 
		"'explicit'", 
		"'override'", 
		"'intrinsic'", 
		"'or'", 
		"'and'"
    };

    public const int INTERNAL = 105;
    public const int BLOCK = 19;
    public const int BOR_ASSIGN = 120;
    public const int STRING_LITERAL = 70;
    public const int GT = 134;
    public const int HEX_DIGIT = 167;
    public const int GET = 72;
    public const int UNDEFINED = 155;
    public const int SL_ASSIGN = 115;
    public const int PRE_DEC = 36;
    public const int SR = 141;
    public const int LOR_ASSIGN = 122;
    public const int IMPLEMENTS = 68;
    public const int GE = 136;
    public const int LBRACK = 106;
    public const int OCTAL_LITERAL = 161;
    public const int SL = 140;
    public const int PROPERTY_OR_IDENTIFIER = 27;
    public const int SINGLELINE_COMMENT = 50;
    public const int UNICODE_ESC = 174;
    public const int EXTENDS = 66;
    public const int NAMESPACE_DEF = 12;
    public const int FOR_IN = 46;
    public const int NOT_EQUAL = 131;
    public const int MOD_ASSIGN = 112;
    public const int LCURLY = 60;
    public const int UNARY_MINUS = 32;
    public const int LNOT = 151;
    public const int ANNOTATION_ASSIGN = 55;
    public const int ACCESSOR_ROLE = 13;
    public const int E4X_ATTRI = 154;
    public const int MULTILINE_COMMENT = 51;
    public const int DEFAULT = 90;
    public const int STATIC = 108;
    public const int ML_COMMENT = 165;
    public const int OCTAL_ESC = 175;
    public const int STRICT_NOT_EQUAL = 130;
    public const int OCT_DIGIT = 172;
    public const int ANNOTATIONS = 8;
    public const int E4X_DESC = 153;
    public const int POST_DEC = 34;
    public const int DECIMAL_LITERAL = 160;
    public const int MOD = 146;
    public const int INTERFACE_DEF = 15;
    public const int MODIFIERS = 11;
    public const int TYPE_SPEC = 18;
    public const int DIV = 145;
    public const int UNARY_PLUS = 31;
    public const int EACH = 92;
    public const int DEFAULT_XML_NAMESPACE = 49;
    public const int LAND_ASSIGN = 121;
    public const int CONDITION = 21;
    public const int ASSIGN = 78;
    public const int NULL = 158;
    public const int PRIVATE = 103;
    public const int DO = 95;
    public const int EOF = -1;
    public const int MINUS = 144;
    public const int SWITCH_STATEMENT_LIST = 47;
    public const int PARAM = 17;
    public const int TYPE_BLOCK = 5;
    public const int VIRTUAL_PLACEHOLDER = 54;
    public const int VAR_INIT = 25;
    public const int INSTANCEOF = 139;
    public const int FUNCTION = 71;
    public const int PROPERTY_ACCESS = 28;
    public const int TYPE_NAME = 29;
    public const int INC = 147;
    public const int RETURN = 84;
    public const int HIDDEN = 57;
    public const int ELSE = 83;
    public const int EQUAL = 132;
    public const int HIDDEN_CHANNEL = 58;
    public const int BXOR_ASSIGN = 119;
    public const int CTRLCHAR_ESC = 173;
    public const int BSR_ASSIGN = 117;
    public const int TRUE = 156;
    public const int DBL_COLON = 100;
    public const int IDENTIFIER = 48;
    public const int COMMENT_ENTRY = 53;
    public const int COMMENT_LIST = 52;
    public const int SEMI = 62;
    public const int STRICT_EQUAL = 129;
    public const int PLUS_ASSIGN = 113;
    public const int BSR = 142;
    public const int OBJECT_FIELD = 40;
    public const int ELEMENT = 38;
    public const int NEW = 163;
    public const int DIV_ASSIGN = 111;
    public const int DELETE = 149;
    public const int NL = 170;
    public const int IDENT = 101;
    public const int BAND_ASSIGN = 118;
    public const int AS = 138;
    public const int AS2_COMPILATION_UNIT = 56;
    public const int CASE = 88;
    public const int OBJECT_LITERAL = 39;
    public const int RBRACK = 107;
    public const int LPAREN = 79;
    public const int PLUS = 143;
    public const int CLASS = 64;
    public const int FUNC_DEF = 41;
    public const int ARRAY_ACC = 30;
    public const int BREAK = 86;
    public const int WHILE = 94;
    public const int CONST = 77;
    public const int RCURLY = 61;
    public const int INTERFACE = 65;
    public const int PARAMS = 16;
    public const int FOR_INIT = 42;
    public const int DEC = 148;
    public const int COMMA = 67;
    public const int COMPILATION_UNIT = 4;
    public const int LT = 133;
    public const int FOR_ITERATOR = 44;
    public const int ARGUMENTS = 22;
    public const int LE = 135;
    public const int FOR_CONDITION = 43;
    public const int CLASS_DEF = 14;
    public const int MINUS_ASSIGN = 114;
    public const int ENCPS_EXPR = 24;
    public const int LOR = 124;
    public const int WITH = 96;
    public const int REST = 81;
    public const int INCLUDE_DIRECTIVE = 69;
    public const int BAND = 128;
    public const int STAR_ASSIGN = 110;
    public const int EXPONENT = 168;
    public const int SL_COMMENT = 164;
    public const int VAR = 76;
    public const int WS = 169;
    public const int PACKAGE = 59;
    public const int STAR = 98;
    public const int FOR = 91;
    public const int FALSE = 157;
    public const int IMPORT = 63;
    public const int DOT = 99;
    public const int XML = 97;
    public const int ANNOTATION = 9;
    public const int QUESTION = 123;
    public const int EXPR_STMNT = 23;
    public const int PRE_INC = 35;
    public const int BOR = 126;
    public const int NAMESPACE = 74;
    public const int BOM = 171;
    public const int SWITCH = 87;
    public const int CONTINUE = 85;
    public const int ARRAY_LITERAL = 37;
    public const int USE = 75;
    public const int SR_ASSIGN = 116;
    public const int ANNOTATION_PARAMS = 10;
    public const int HEX_LITERAL = 159;
    public const int IS = 137;
    public const int METHOD_CALL = 26;
    public const int FOR_EACH = 45;
    public const int LAND = 125;
    public const int DYNAMIC = 109;
    public const int IN = 93;
    public const int BXOR = 127;
    public const int METHOD_DEF = 6;
    public const int VAR_DEF = 7;
    public const int IF = 82;
    public const int ELIST = 20;
    public const int TYPEOF = 150;
    public const int FLOAT_LITERAL = 162;
    public const int COLON = 89;
    public const int SET = 73;
    public const int PUBLIC = 102;
    public const int POST_INC = 33;
    public const int ESC = 166;
    public const int BNOT = 152;
    public const int RPAREN = 80;
    public const int PROTECTED = 104;
    protected class InOperator_scope 
    {
        protected internal Boolean allowed;
    }
    protected Stack InOperator_stack = new Stack();

    
    
        public ASParser(ITokenStream input) 
    		: base(input)
    	{
    		InitializeCyclicDFAs();
            ruleMemo = new IDictionary[357+1];
         }
        
    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();
    
    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set { this.adaptor = value; }
    }

    override public string[] TokenNames
	{
		get { return tokenNames; }
	}

    override public string GrammarFileName
	{
		get { return "C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g"; }
	}

    
    
    	#region Members
    	
    	private ASLexer lexer;
    	private ICharStream cs;
    	public static int CHANNEL_PLACEHOLDER = 999;
    
    	public void SetInput(ASLexer lexer, ICharStream cs) 
    	{
    		this.lexer = lexer;
    		this.cs = cs;
    	}
    
    	/*
    	protected void mismatch(IIntStream input, int ttype, BitSet follow)
    	{
    		MismatchedTokenException mte = new MismatchedTokenException(ttype, input);
    		RecoverFromMismatchedToken(input, mte, ttype, follow);
    	}
    	*/
    	
    	#endregion


    public class as2Program_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2Program
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:99:1: as2Program : as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) ;
    public as2Program_return as2Program() // throws RecognitionException [1]
    {   
        as2Program_return retval = new as2Program_return();
        retval.start = input.LT(1);
        int as2Program_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        as2CompilationUnit_return as2CompilationUnit1 = null;
        
        
        RewriteRuleSubtreeStream stream_as2CompilationUnit = new RewriteRuleSubtreeStream(adaptor,"rule as2CompilationUnit");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 1) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:4: ( as2CompilationUnit -> ^( COMPILATION_UNIT as2CompilationUnit ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:4: as2CompilationUnit
            {
            	PushFollow(FOLLOW_as2CompilationUnit_in_as2Program355);
            	as2CompilationUnit1 = as2CompilationUnit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);
            	
            	// AST REWRITE
            	// elements:          as2CompilationUnit
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 100:23: -> ^( COMPILATION_UNIT as2CompilationUnit )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:100:26: ^( COMPILATION_UNIT as2CompilationUnit )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_as2CompilationUnit.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 1, as2Program_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2Program

    public class as3Program_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as3Program
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:103:1: as3Program : as3CompilationUnit -> ^( COMPILATION_UNIT as3CompilationUnit ) ;
    public as3Program_return as3Program() // throws RecognitionException [1]
    {   
        as3Program_return retval = new as3Program_return();
        retval.start = input.LT(1);
        int as3Program_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        as3CompilationUnit_return as3CompilationUnit2 = null;
        
        
        RewriteRuleSubtreeStream stream_as3CompilationUnit = new RewriteRuleSubtreeStream(adaptor,"rule as3CompilationUnit");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 2) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:4: ( as3CompilationUnit -> ^( COMPILATION_UNIT as3CompilationUnit ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:4: as3CompilationUnit
            {
            	PushFollow(FOLLOW_as3CompilationUnit_in_as3Program375);
            	as3CompilationUnit2 = as3CompilationUnit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);
            	
            	// AST REWRITE
            	// elements:          as3CompilationUnit
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 104:23: -> ^( COMPILATION_UNIT as3CompilationUnit )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:104:26: ^( COMPILATION_UNIT as3CompilationUnit )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_as3CompilationUnit.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 2, as3Program_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as3Program

    public class as2CompilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2CompilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:108:1: as2CompilationUnit : ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type ;
    public as2CompilationUnit_return as2CompilationUnit() // throws RecognitionException [1]
    {   
        as2CompilationUnit_return retval = new as2CompilationUnit_return();
        retval.start = input.LT(1);
        int as2CompilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        commentExpression_return commentExpression3 = null;

        importDefinition_return importDefinition4 = null;

        annotations_return annotations5 = null;

        commentExpression_return commentExpression6 = null;

        as2Type_return as2Type7 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 3) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: ( ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: ( commentExpression )? ( importDefinition )* ( annotations | commentExpression )* as2Type
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: ( commentExpression )?
            	int alt1 = 2;
            	int LA1_0 = input.LA(1);
            	
            	if ( (LA1_0 == SL_COMMENT) )
            	{
            	    int LA1_1 = input.LA(2);
            	    
            	    if ( (synpred1()) )
            	    {
            	        alt1 = 1;
            	    }
            	}
            	else if ( (LA1_0 == ML_COMMENT) )
            	{
            	    int LA1_2 = input.LA(2);
            	    
            	    if ( (synpred1()) )
            	    {
            	        alt1 = 1;
            	    }
            	}
            	switch (alt1) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_as2CompilationUnit397);
            	        	commentExpression3 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression3.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:110:3: ( importDefinition )*
            	do 
            	{
            	    int alt2 = 2;
            	    int LA2_0 = input.LA(1);
            	    
            	    if ( (LA2_0 == IMPORT) )
            	    {
            	        alt2 = 1;
            	    }
            	    
            	
            	    switch (alt2) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: importDefinition
            			    {
            			    	PushFollow(FOLLOW_importDefinition_in_as2CompilationUnit403);
            			    	importDefinition4 = importDefinition();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition4.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop2;
            	    }
            	} while (true);
            	
            	loop2:
            		;	// Stops C# compiler whinging that label 'loop2' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:3: ( annotations | commentExpression )*
            	do 
            	{
            	    int alt3 = 3;
            	    int LA3_0 = input.LA(1);
            	    
            	    if ( (LA3_0 == LBRACK || LA3_0 == 176) )
            	    {
            	        alt3 = 1;
            	    }
            	    else if ( ((LA3_0 >= SL_COMMENT && LA3_0 <= ML_COMMENT)) )
            	    {
            	        alt3 = 2;
            	    }
            	    
            	
            	    switch (alt3) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:4: annotations
            			    {
            			    	PushFollow(FOLLOW_annotations_in_as2CompilationUnit409);
            			    	annotations5 = annotations();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations5.Tree);
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:111:18: commentExpression
            			    {
            			    	PushFollow(FOLLOW_commentExpression_in_as2CompilationUnit413);
            			    	commentExpression6 = commentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression6.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop3;
            	    }
            	} while (true);
            	
            	loop3:
            		;	// Stops C# compiler whinging that label 'loop3' has no statements

            	PushFollow(FOLLOW_as2Type_in_as2CompilationUnit419);
            	as2Type7 = as2Type();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, as2Type7.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 3, as2CompilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2CompilationUnit

    public class as2Type_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2Type
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:115:1: as2Type : mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) ;
    public as2Type_return as2Type() // throws RecognitionException [1]
    {   
        as2Type_return retval = new as2Type_return();
        retval.start = input.LT(1);
        int as2Type_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return mods = null;

        as2ClassDefinition_return as2ClassDefinition8 = null;

        as2InterfaceDefinition_return as2InterfaceDefinition9 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 4) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:4: (mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:116:4: mods= modifiers ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_modifiers_in_as2Type432);
            	mods = modifiers();
            	followingStackPointer_--;
            	if (failed) return retval;
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )
            	int alt4 = 2;
            	int LA4_0 = input.LA(1);
            	
            	if ( (LA4_0 == CLASS) )
            	{
            	    alt4 = 1;
            	}
            	else if ( (LA4_0 == INTERFACE) )
            	{
            	    alt4 = 2;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d4s0 =
            	        new NoViableAltException("117:2: ( as2ClassDefinition[$mods.tree] | as2InterfaceDefinition[$mods.tree] )", 4, 0, input);
            	
            	    throw nvae_d4s0;
            	}
            	switch (alt4) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:117:4: as2ClassDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2ClassDefinition_in_as2Type438);
            	        	as2ClassDefinition8 = as2ClassDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2ClassDefinition8.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:118:4: as2InterfaceDefinition[$mods.tree]
            	        {
            	        	PushFollow(FOLLOW_as2InterfaceDefinition_in_as2Type444);
            	        	as2InterfaceDefinition9 = as2InterfaceDefinition(((CommonTree)mods.tree));
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, as2InterfaceDefinition9.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 4, as2Type_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2Type

    public class as3CompilationUnit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as3CompilationUnit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:122:1: as3CompilationUnit : ( commentExpression )? packageDecl ( packageBlockEntry )* EOF ;
    public as3CompilationUnit_return as3CompilationUnit() // throws RecognitionException [1]
    {   
        as3CompilationUnit_return retval = new as3CompilationUnit_return();
        retval.start = input.LT(1);
        int as3CompilationUnit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EOF13 = null;
        commentExpression_return commentExpression10 = null;

        packageDecl_return packageDecl11 = null;

        packageBlockEntry_return packageBlockEntry12 = null;
        
        
        CommonTree EOF13_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 5) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( ( commentExpression )? packageDecl ( packageBlockEntry )* EOF )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( commentExpression )? packageDecl ( packageBlockEntry )* EOF
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:123:6: ( commentExpression )?
            	int alt5 = 2;
            	int LA5_0 = input.LA(1);
            	
            	if ( ((LA5_0 >= SL_COMMENT && LA5_0 <= ML_COMMENT)) )
            	{
            	    alt5 = 1;
            	}
            	switch (alt5) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_as3CompilationUnit462);
            	        	commentExpression10 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression10.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_packageDecl_in_as3CompilationUnit467);
            	packageDecl11 = packageDecl();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, packageDecl11.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:125:3: ( packageBlockEntry )*
            	do 
            	{
            	    int alt6 = 2;
            	    int LA6_0 = input.LA(1);
            	    
            	    if ( ((LA6_0 >= SEMI && LA6_0 <= INTERFACE) || LA6_0 == FUNCTION || (LA6_0 >= NAMESPACE && LA6_0 <= CONST) || (LA6_0 >= IDENT && LA6_0 <= LBRACK) || (LA6_0 >= STATIC && LA6_0 <= DYNAMIC) || (LA6_0 >= SL_COMMENT && LA6_0 <= ML_COMMENT) || LA6_0 == 176 || (LA6_0 >= 182 && LA6_0 <= 186)) )
            	    {
            	        alt6 = 1;
            	    }
            	    
            	
            	    switch (alt6) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
            			    {
            			    	PushFollow(FOLLOW_packageBlockEntry_in_as3CompilationUnit471);
            			    	packageBlockEntry12 = packageBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, packageBlockEntry12.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop6;
            	    }
            	} while (true);
            	
            	loop6:
            		;	// Stops C# compiler whinging that label 'loop6' has no statements

            	EOF13 = (IToken)input.LT(1);
            	Match(input,EOF,FOLLOW_EOF_in_as3CompilationUnit476); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 5, as3CompilationUnit_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as3CompilationUnit

    public class packageDecl_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageDecl
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:129:1: packageDecl : PACKAGE ( identifier )? packageBlock ;
    public packageDecl_return packageDecl() // throws RecognitionException [1]
    {   
        packageDecl_return retval = new packageDecl_return();
        retval.start = input.LT(1);
        int packageDecl_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken PACKAGE14 = null;
        identifier_return identifier15 = null;

        packageBlock_return packageBlock16 = null;
        
        
        CommonTree PACKAGE14_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 6) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:4: ( PACKAGE ( identifier )? packageBlock )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:4: PACKAGE ( identifier )? packageBlock
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PACKAGE14 = (IToken)input.LT(1);
            	Match(input,PACKAGE,FOLLOW_PACKAGE_in_packageDecl488); if (failed) return retval;
            	if ( backtracking==0 ) {
            	PACKAGE14_tree = (CommonTree)adaptor.Create(PACKAGE14);
            	root_0 = (CommonTree)adaptor.BecomeRoot(PACKAGE14_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:130:13: ( identifier )?
            	int alt7 = 2;
            	int LA7_0 = input.LA(1);
            	
            	if ( ((LA7_0 >= GET && LA7_0 <= USE) || LA7_0 == XML || (LA7_0 >= IDENT && LA7_0 <= INTERNAL) || LA7_0 == DYNAMIC || (LA7_0 >= IS && LA7_0 <= AS)) )
            	{
            	    alt7 = 1;
            	}
            	switch (alt7) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: identifier
            	        {
            	        	PushFollow(FOLLOW_identifier_in_packageDecl491);
            	        	identifier15 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier15.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_packageBlock_in_packageDecl496);
            	packageBlock16 = packageBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, packageBlock16.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 6, packageDecl_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageDecl

    public class packageBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:134:1: packageBlock : LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) ;
    public packageBlock_return packageBlock() // throws RecognitionException [1]
    {   
        packageBlock_return retval = new packageBlock_return();
        retval.start = input.LT(1);
        int packageBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY17 = null;
        IToken RCURLY19 = null;
        packageBlockEntry_return packageBlockEntry18 = null;
        
        
        CommonTree LCURLY17_tree=null;
        CommonTree RCURLY19_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_packageBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule packageBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 7) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: ( LCURLY ( packageBlockEntry )* RCURLY -> ^( BLOCK ( packageBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:135:4: LCURLY ( packageBlockEntry )* RCURLY
            {
            	LCURLY17 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_packageBlock507); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY17);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:136:3: ( packageBlockEntry )*
            	do 
            	{
            	    int alt8 = 2;
            	    int LA8_0 = input.LA(1);
            	    
            	    if ( ((LA8_0 >= SEMI && LA8_0 <= INTERFACE) || LA8_0 == FUNCTION || (LA8_0 >= NAMESPACE && LA8_0 <= CONST) || (LA8_0 >= IDENT && LA8_0 <= LBRACK) || (LA8_0 >= STATIC && LA8_0 <= DYNAMIC) || (LA8_0 >= SL_COMMENT && LA8_0 <= ML_COMMENT) || LA8_0 == 176 || (LA8_0 >= 182 && LA8_0 <= 186)) )
            	    {
            	        alt8 = 1;
            	    }
            	    
            	
            	    switch (alt8) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: packageBlockEntry
            			    {
            			    	PushFollow(FOLLOW_packageBlockEntry_in_packageBlock511);
            			    	packageBlockEntry18 = packageBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_packageBlockEntry.Add(packageBlockEntry18.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop8;
            	    }
            	} while (true);
            	
            	loop8:
            		;	// Stops C# compiler whinging that label 'loop8' has no statements

            	RCURLY19 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_packageBlock516); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY19);

            	
            	// AST REWRITE
            	// elements:          packageBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 138:3: -> ^( BLOCK ( packageBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:6: ^( BLOCK ( packageBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:138:14: ( packageBlockEntry )*
            	    while ( stream_packageBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_packageBlockEntry.Next());
            	    
            	    }
            	    stream_packageBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 7, packageBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageBlock

    public class packageBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start packageBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:141:1: packageBlockEntry : ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression );
    public packageBlockEntry_return packageBlockEntry() // throws RecognitionException [1]
    {   
        packageBlockEntry_return retval = new packageBlockEntry_return();
        retval.start = input.LT(1);
        int packageBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI28 = null;
        modifiers_return mods = null;

        importDefinition_return importDefinition20 = null;

        annotations_return annotations21 = null;

        classDefinition_return classDefinition22 = null;

        interfaceDefinition_return interfaceDefinition23 = null;

        variableDefinition_return variableDefinition24 = null;

        methodDefinition_return methodDefinition25 = null;

        namespaceDefinition_return namespaceDefinition26 = null;

        useNamespaceDirective_return useNamespaceDirective27 = null;

        commentExpression_return commentExpression29 = null;
        
        
        CommonTree SEMI28_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 8) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression )
            int alt12 = 2;
            int LA12_0 = input.LA(1);
            
            if ( ((LA12_0 >= SEMI && LA12_0 <= INTERFACE) || LA12_0 == FUNCTION || (LA12_0 >= NAMESPACE && LA12_0 <= CONST) || (LA12_0 >= IDENT && LA12_0 <= LBRACK) || (LA12_0 >= STATIC && LA12_0 <= DYNAMIC) || LA12_0 == 176 || (LA12_0 >= 182 && LA12_0 <= 186)) )
            {
                alt12 = 1;
            }
            else if ( ((LA12_0 >= SL_COMMENT && LA12_0 <= ML_COMMENT)) )
            {
                alt12 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d12s0 =
                    new NoViableAltException("141:1: packageBlockEntry : ( ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI ) | commentExpression );", 12, 0, input);
            
                throw nvae_d12s0;
            }
            switch (alt12) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )
                    	int alt11 = 3;
                    	switch ( input.LA(1) ) 
                    	{
                    	case IMPORT:
                    		{
                    	    alt11 = 1;
                    	    }
                    	    break;
                    	case CLASS:
                    	case INTERFACE:
                    	case FUNCTION:
                    	case NAMESPACE:
                    	case USE:
                    	case VAR:
                    	case CONST:
                    	case IDENT:
                    	case PUBLIC:
                    	case PRIVATE:
                    	case PROTECTED:
                    	case INTERNAL:
                    	case LBRACK:
                    	case STATIC:
                    	case DYNAMIC:
                    	case 176:
                    	case 182:
                    	case 183:
                    	case 184:
                    	case 185:
                    	case 186:
                    		{
                    	    alt11 = 2;
                    	    }
                    	    break;
                    	case SEMI:
                    		{
                    	    alt11 = 3;
                    	    }
                    	    break;
                    		default:
                    		    if ( backtracking > 0 ) {failed = true; return retval;}
                    		    NoViableAltException nvae_d11s0 =
                    		        new NoViableAltException("142:4: ( importDefinition | ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective ) | SEMI )", 11, 0, input);
                    	
                    		    throw nvae_d11s0;
                    	}
                    	
                    	switch (alt11) 
                    	{
                    	    case 1 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:142:6: importDefinition
                    	        {
                    	        	PushFollow(FOLLOW_importDefinition_in_packageBlockEntry540);
                    	        	importDefinition20 = importDefinition();
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition20.Tree);
                    	        
                    	        }
                    	        break;
                    	    case 2 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:5: ( annotations )? mods= modifiers ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )
                    	        {
                    	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:143:5: ( annotations )?
                    	        	int alt9 = 2;
                    	        	int LA9_0 = input.LA(1);
                    	        	
                    	        	if ( (LA9_0 == LBRACK || LA9_0 == 176) )
                    	        	{
                    	        	    alt9 = 1;
                    	        	}
                    	        	switch (alt9) 
                    	        	{
                    	        	    case 1 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotations
                    	        	        {
                    	        	        	PushFollow(FOLLOW_annotations_in_packageBlockEntry546);
                    	        	        	annotations21 = annotations();
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations21.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	
                    	        	}

                    	        	PushFollow(FOLLOW_modifiers_in_packageBlockEntry554);
                    	        	mods = modifiers();
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:145:4: ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )
                    	        	int alt10 = 6;
                    	        	switch ( input.LA(1) ) 
                    	        	{
                    	        	case CLASS:
                    	        		{
                    	        	    alt10 = 1;
                    	        	    }
                    	        	    break;
                    	        	case INTERFACE:
                    	        		{
                    	        	    alt10 = 2;
                    	        	    }
                    	        	    break;
                    	        	case VAR:
                    	        	case CONST:
                    	        		{
                    	        	    alt10 = 3;
                    	        	    }
                    	        	    break;
                    	        	case FUNCTION:
                    	        		{
                    	        	    alt10 = 4;
                    	        	    }
                    	        	    break;
                    	        	case NAMESPACE:
                    	        		{
                    	        	    alt10 = 5;
                    	        	    }
                    	        	    break;
                    	        	case USE:
                    	        		{
                    	        	    alt10 = 6;
                    	        	    }
                    	        	    break;
                    	        		default:
                    	        		    if ( backtracking > 0 ) {failed = true; return retval;}
                    	        		    NoViableAltException nvae_d10s0 =
                    	        		        new NoViableAltException("145:4: ( classDefinition[$mods.tree] | interfaceDefinition[$mods.tree] | variableDefinition[$mods.tree] | methodDefinition[$mods.tree] | namespaceDefinition[$mods.tree] | useNamespaceDirective )", 10, 0, input);
                    	        	
                    	        		    throw nvae_d10s0;
                    	        	}
                    	        	
                    	        	switch (alt10) 
                    	        	{
                    	        	    case 1 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:145:6: classDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_classDefinition_in_packageBlockEntry562);
                    	        	        	classDefinition22 = classDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, classDefinition22.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 2 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:146:6: interfaceDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_interfaceDefinition_in_packageBlockEntry570);
                    	        	        	interfaceDefinition23 = interfaceDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, interfaceDefinition23.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 3 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:147:6: variableDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_variableDefinition_in_packageBlockEntry578);
                    	        	        	variableDefinition24 = variableDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDefinition24.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 4 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:148:6: methodDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_methodDefinition_in_packageBlockEntry586);
                    	        	        	methodDefinition25 = methodDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, methodDefinition25.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 5 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:149:6: namespaceDefinition[$mods.tree]
                    	        	        {
                    	        	        	PushFollow(FOLLOW_namespaceDefinition_in_packageBlockEntry594);
                    	        	        	namespaceDefinition26 = namespaceDefinition(((CommonTree)mods.tree));
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceDefinition26.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	    case 6 :
                    	        	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:150:6: useNamespaceDirective
                    	        	        {
                    	        	        	PushFollow(FOLLOW_useNamespaceDirective_in_packageBlockEntry602);
                    	        	        	useNamespaceDirective27 = useNamespaceDirective();
                    	        	        	followingStackPointer_--;
                    	        	        	if (failed) return retval;
                    	        	        	if ( backtracking==0 ) adaptor.AddChild(root_0, useNamespaceDirective27.Tree);
                    	        	        
                    	        	        }
                    	        	        break;
                    	        	
                    	        	}

                    	        
                    	        }
                    	        break;
                    	    case 3 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:152:5: SEMI
                    	        {
                    	        	SEMI28 = (IToken)input.LT(1);
                    	        	Match(input,SEMI,FOLLOW_SEMI_in_packageBlockEntry613); if (failed) return retval;
                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:154:5: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_packageBlockEntry624);
                    	commentExpression29 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression29.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 8, packageBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end packageBlockEntry

    public class endOfFile_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start endOfFile
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:157:1: endOfFile : EOF ;
    public endOfFile_return endOfFile() // throws RecognitionException [1]
    {   
        endOfFile_return retval = new endOfFile_return();
        retval.start = input.LT(1);
        int endOfFile_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EOF30 = null;
        
        CommonTree EOF30_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 9) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:158:4: ( EOF )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:158:4: EOF
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	EOF30 = (IToken)input.LT(1);
            	Match(input,EOF,FOLLOW_EOF_in_endOfFile635); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 9, endOfFile_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end endOfFile

    public class importDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start importDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:161:1: importDefinition : IMPORT identifierStar semi ;
    public importDefinition_return importDefinition() // throws RecognitionException [1]
    {   
        importDefinition_return retval = new importDefinition_return();
        retval.start = input.LT(1);
        int importDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IMPORT31 = null;
        identifierStar_return identifierStar32 = null;

        semi_return semi33 = null;
        
        
        CommonTree IMPORT31_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 10) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:162:4: ( IMPORT identifierStar semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:162:4: IMPORT identifierStar semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IMPORT31 = (IToken)input.LT(1);
            	Match(input,IMPORT,FOLLOW_IMPORT_in_importDefinition647); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IMPORT31_tree = (CommonTree)adaptor.Create(IMPORT31);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IMPORT31_tree, root_0);
            	}
            	PushFollow(FOLLOW_identifierStar_in_importDefinition650);
            	identifierStar32 = identifierStar();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, identifierStar32.Tree);
            	PushFollow(FOLLOW_semi_in_importDefinition652);
            	semi33 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi33.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 10, importDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end importDefinition

    public class semi_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start semi
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:165:1: semi : ( SEMI | );
    public semi_return semi() // throws RecognitionException [1]
    {   
        semi_return retval = new semi_return();
        retval.start = input.LT(1);
        int semi_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI34 = null;
        
        CommonTree SEMI34_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 11) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: ( SEMI | )
            int alt13 = 2;
            int LA13_0 = input.LA(1);
            
            if ( (LA13_0 == SEMI) )
            {
                int LA13_1 = input.LA(2);
                
                if ( (synpred19()) )
                {
                    alt13 = 1;
                }
                else if ( (true) )
                {
                    alt13 = 2;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d13s1 =
                        new NoViableAltException("165:1: semi : ( SEMI | );", 13, 1, input);
                
                    throw nvae_d13s1;
                }
            }
            else if ( (LA13_0 == EOF || (LA13_0 >= LCURLY && LA13_0 <= RCURLY) || (LA13_0 >= IMPORT && LA13_0 <= INTERFACE) || (LA13_0 >= INCLUDE_DIRECTIVE && LA13_0 <= CONST) || LA13_0 == LPAREN || (LA13_0 >= IF && LA13_0 <= CASE) || (LA13_0 >= DEFAULT && LA13_0 <= FOR) || (LA13_0 >= WHILE && LA13_0 <= XML) || (LA13_0 >= IDENT && LA13_0 <= LBRACK) || (LA13_0 >= STATIC && LA13_0 <= DYNAMIC) || LA13_0 == LT || (LA13_0 >= IS && LA13_0 <= AS) || (LA13_0 >= PLUS && LA13_0 <= DIV) || (LA13_0 >= INC && LA13_0 <= BNOT) || (LA13_0 >= E4X_ATTRI && LA13_0 <= ML_COMMENT) || (LA13_0 >= 176 && LA13_0 <= 178) || (LA13_0 >= 181 && LA13_0 <= 186)) )
            {
                alt13 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d13s0 =
                    new NoViableAltException("165:1: semi : ( SEMI | );", 13, 0, input);
            
                throw nvae_d13s0;
            }
            switch (alt13) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI34 = (IToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_semi663); if (failed) return retval;
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:168:2: 
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 11, semi_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end semi

    public class classDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start classDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:170:1: classDefinition[CommonTree mods] : CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) ;
    public classDefinition_return classDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        classDefinition_return retval = new classDefinition_return();
        retval.start = input.LT(1);
        int classDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CLASS35 = null;
        ident_return ident36 = null;

        classExtendsClause_return classExtendsClause37 = null;

        implementsClause_return implementsClause38 = null;

        typeBlock_return typeBlock39 = null;
        
        
        CommonTree CLASS35_tree=null;
        RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor,"token CLASS");
        RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
        RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 12) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: ( CLASS ident classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:171:4: CLASS ident classExtendsClause implementsClause typeBlock
            {
            	CLASS35 = (IToken)input.LT(1);
            	Match(input,CLASS,FOLLOW_CLASS_in_classDefinition680); if (failed) return retval;
            	if ( backtracking==0 ) stream_CLASS.Add(CLASS35);

            	PushFollow(FOLLOW_ident_in_classDefinition682);
            	ident36 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident36.Tree);
            	PushFollow(FOLLOW_classExtendsClause_in_classDefinition686);
            	classExtendsClause37 = classExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_classExtendsClause.Add(classExtendsClause37.Tree);
            	PushFollow(FOLLOW_implementsClause_in_classDefinition690);
            	implementsClause38 = implementsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_implementsClause.Add(implementsClause38.Tree);
            	PushFollow(FOLLOW_typeBlock_in_classDefinition694);
            	typeBlock39 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock39.Tree);
            	
            	// AST REWRITE
            	// elements:          ident, typeBlock, classExtendsClause, implementsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 175:3: -> ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:175:6: ^( CLASS_DEF ident classExtendsClause implementsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_classExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_implementsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 12, classDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end classDefinition

    public class as2ClassDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2ClassDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:178:1: as2ClassDefinition[CommonTree mods] : CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) ;
    public as2ClassDefinition_return as2ClassDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2ClassDefinition_return retval = new as2ClassDefinition_return();
        retval.start = input.LT(1);
        int as2ClassDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CLASS40 = null;
        identifier_return identifier41 = null;

        classExtendsClause_return classExtendsClause42 = null;

        implementsClause_return implementsClause43 = null;

        typeBlock_return typeBlock44 = null;
        
        
        CommonTree CLASS40_tree=null;
        RewriteRuleTokenStream stream_CLASS = new RewriteRuleTokenStream(adaptor,"token CLASS");
        RewriteRuleSubtreeStream stream_classExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
        RewriteRuleSubtreeStream stream_implementsClause = new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 13) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: ( CLASS identifier classExtendsClause implementsClause typeBlock -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:179:4: CLASS identifier classExtendsClause implementsClause typeBlock
            {
            	CLASS40 = (IToken)input.LT(1);
            	Match(input,CLASS,FOLLOW_CLASS_in_as2ClassDefinition724); if (failed) return retval;
            	if ( backtracking==0 ) stream_CLASS.Add(CLASS40);

            	PushFollow(FOLLOW_identifier_in_as2ClassDefinition726);
            	identifier41 = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(identifier41.Tree);
            	PushFollow(FOLLOW_classExtendsClause_in_as2ClassDefinition730);
            	classExtendsClause42 = classExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_classExtendsClause.Add(classExtendsClause42.Tree);
            	PushFollow(FOLLOW_implementsClause_in_as2ClassDefinition734);
            	implementsClause43 = implementsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_implementsClause.Add(implementsClause43.Tree);
            	PushFollow(FOLLOW_typeBlock_in_as2ClassDefinition738);
            	typeBlock44 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock44.Tree);
            	
            	// AST REWRITE
            	// elements:          identifier, classExtendsClause, typeBlock, implementsClause
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 183:3: -> ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:183:6: ^( CLASS_DEF identifier classExtendsClause implementsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_classExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_implementsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 13, as2ClassDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2ClassDefinition

    public class interfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:186:1: interfaceDefinition[CommonTree mods] : INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) ;
    public interfaceDefinition_return interfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        interfaceDefinition_return retval = new interfaceDefinition_return();
        retval.start = input.LT(1);
        int interfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INTERFACE45 = null;
        ident_return ident46 = null;

        interfaceExtendsClause_return interfaceExtendsClause47 = null;

        typeBlock_return typeBlock48 = null;
        
        
        CommonTree INTERFACE45_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 14) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:188:4: ( INTERFACE ident interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:188:4: INTERFACE ident interfaceExtendsClause typeBlock
            {
            	INTERFACE45 = (IToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_interfaceDefinition773); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(INTERFACE45);

            	PushFollow(FOLLOW_ident_in_interfaceDefinition775);
            	ident46 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident46.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_interfaceDefinition779);
            	interfaceExtendsClause47 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause47.Tree);
            	PushFollow(FOLLOW_typeBlock_in_interfaceDefinition783);
            	typeBlock48 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock48.Tree);
            	
            	// AST REWRITE
            	// elements:          typeBlock, interfaceExtendsClause, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 191:3: -> ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:191:6: ^( INTERFACE_DEF ident interfaceExtendsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 14, interfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceDefinition

    public class as2InterfaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2InterfaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:194:1: as2InterfaceDefinition[CommonTree mods] : INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) ;
    public as2InterfaceDefinition_return as2InterfaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        as2InterfaceDefinition_return retval = new as2InterfaceDefinition_return();
        retval.start = input.LT(1);
        int as2InterfaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INTERFACE49 = null;
        identifier_return identifier50 = null;

        interfaceExtendsClause_return interfaceExtendsClause51 = null;

        typeBlock_return typeBlock52 = null;
        
        
        CommonTree INTERFACE49_tree=null;
        RewriteRuleTokenStream stream_INTERFACE = new RewriteRuleTokenStream(adaptor,"token INTERFACE");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        RewriteRuleSubtreeStream stream_interfaceExtendsClause = new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
        RewriteRuleSubtreeStream stream_typeBlock = new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
         CommonTree annos = null; 
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 15) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: ( INTERFACE identifier interfaceExtendsClause typeBlock -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:196:4: INTERFACE identifier interfaceExtendsClause typeBlock
            {
            	INTERFACE49 = (IToken)input.LT(1);
            	Match(input,INTERFACE,FOLLOW_INTERFACE_in_as2InterfaceDefinition816); if (failed) return retval;
            	if ( backtracking==0 ) stream_INTERFACE.Add(INTERFACE49);

            	PushFollow(FOLLOW_identifier_in_as2InterfaceDefinition818);
            	identifier50 = identifier();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_identifier.Add(identifier50.Tree);
            	PushFollow(FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition822);
            	interfaceExtendsClause51 = interfaceExtendsClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_interfaceExtendsClause.Add(interfaceExtendsClause51.Tree);
            	PushFollow(FOLLOW_typeBlock_in_as2InterfaceDefinition826);
            	typeBlock52 = typeBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_typeBlock.Add(typeBlock52.Tree);
            	
            	// AST REWRITE
            	// elements:          interfaceExtendsClause, typeBlock, identifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 199:3: -> ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:199:6: ^( INTERFACE_DEF identifier interfaceExtendsClause typeBlock )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_identifier.Next());
            	    adaptor.AddChild(root_1, stream_interfaceExtendsClause.Next());
            	    adaptor.AddChild(root_1, stream_typeBlock.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 15, as2InterfaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2InterfaceDefinition

    public class classExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start classExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:202:1: classExtendsClause : ( EXTENDS identifier )? ;
    public classExtendsClause_return classExtendsClause() // throws RecognitionException [1]
    {   
        classExtendsClause_return retval = new classExtendsClause_return();
        retval.start = input.LT(1);
        int classExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EXTENDS53 = null;
        identifier_return identifier54 = null;
        
        
        CommonTree EXTENDS53_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 16) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( ( EXTENDS identifier )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( EXTENDS identifier )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:4: ( EXTENDS identifier )?
            	int alt14 = 2;
            	int LA14_0 = input.LA(1);
            	
            	if ( (LA14_0 == EXTENDS) )
            	{
            	    alt14 = 1;
            	}
            	switch (alt14) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:203:5: EXTENDS identifier
            	        {
            	        	EXTENDS53 = (IToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_classExtendsClause854); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	EXTENDS53_tree = (CommonTree)adaptor.Create(EXTENDS53);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS53_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_classExtendsClause857);
            	        	identifier54 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier54.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 16, classExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end classExtendsClause

    public class interfaceExtendsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start interfaceExtendsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:205:1: interfaceExtendsClause : ( EXTENDS identifier ( COMMA identifier )* )? ;
    public interfaceExtendsClause_return interfaceExtendsClause() // throws RecognitionException [1]
    {   
        interfaceExtendsClause_return retval = new interfaceExtendsClause_return();
        retval.start = input.LT(1);
        int interfaceExtendsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken EXTENDS55 = null;
        IToken COMMA57 = null;
        identifier_return identifier56 = null;

        identifier_return identifier58 = null;
        
        
        CommonTree EXTENDS55_tree=null;
        CommonTree COMMA57_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 17) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( ( EXTENDS identifier ( COMMA identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( EXTENDS identifier ( COMMA identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:4: ( EXTENDS identifier ( COMMA identifier )* )?
            	int alt16 = 2;
            	int LA16_0 = input.LA(1);
            	
            	if ( (LA16_0 == EXTENDS) )
            	{
            	    alt16 = 1;
            	}
            	switch (alt16) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:5: EXTENDS identifier ( COMMA identifier )*
            	        {
            	        	EXTENDS55 = (IToken)input.LT(1);
            	        	Match(input,EXTENDS,FOLLOW_EXTENDS_in_interfaceExtendsClause870); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	EXTENDS55_tree = (CommonTree)adaptor.Create(EXTENDS55);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(EXTENDS55_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause873);
            	        	identifier56 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier56.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:25: ( COMMA identifier )*
            	        	do 
            	        	{
            	        	    int alt15 = 2;
            	        	    int LA15_0 = input.LA(1);
            	        	    
            	        	    if ( (LA15_0 == COMMA) )
            	        	    {
            	        	        alt15 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt15) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:206:27: COMMA identifier
            	        			    {
            	        			    	COMMA57 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_interfaceExtendsClause877); if (failed) return retval;
            	        			    	PushFollow(FOLLOW_identifier_in_interfaceExtendsClause880);
            	        			    	identifier58 = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier58.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop15;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop15:
            	        		;	// Stops C# compiler whinging that label 'loop15' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 17, interfaceExtendsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end interfaceExtendsClause

    public class implementsClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start implementsClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:208:1: implementsClause : ( IMPLEMENTS identifier ( COMMA identifier )* )? ;
    public implementsClause_return implementsClause() // throws RecognitionException [1]
    {   
        implementsClause_return retval = new implementsClause_return();
        retval.start = input.LT(1);
        int implementsClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IMPLEMENTS59 = null;
        IToken COMMA61 = null;
        identifier_return identifier60 = null;

        identifier_return identifier62 = null;
        
        
        CommonTree IMPLEMENTS59_tree=null;
        CommonTree COMMA61_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 18) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( ( IMPLEMENTS identifier ( COMMA identifier )* )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:4: ( IMPLEMENTS identifier ( COMMA identifier )* )?
            	int alt18 = 2;
            	int LA18_0 = input.LA(1);
            	
            	if ( (LA18_0 == IMPLEMENTS) )
            	{
            	    alt18 = 1;
            	}
            	switch (alt18) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:5: IMPLEMENTS identifier ( COMMA identifier )*
            	        {
            	        	IMPLEMENTS59 = (IToken)input.LT(1);
            	        	Match(input,IMPLEMENTS,FOLLOW_IMPLEMENTS_in_implementsClause895); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	IMPLEMENTS59_tree = (CommonTree)adaptor.Create(IMPLEMENTS59);
            	        	root_0 = (CommonTree)adaptor.BecomeRoot(IMPLEMENTS59_tree, root_0);
            	        	}
            	        	PushFollow(FOLLOW_identifier_in_implementsClause898);
            	        	identifier60 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier60.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:28: ( COMMA identifier )*
            	        	do 
            	        	{
            	        	    int alt17 = 2;
            	        	    int LA17_0 = input.LA(1);
            	        	    
            	        	    if ( (LA17_0 == COMMA) )
            	        	    {
            	        	        alt17 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt17) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:209:30: COMMA identifier
            	        			    {
            	        			    	COMMA61 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_implementsClause902); if (failed) return retval;
            	        			    	PushFollow(FOLLOW_identifier_in_implementsClause905);
            	        			    	identifier62 = identifier();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) adaptor.AddChild(root_0, identifier62.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop17;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop17:
            	        		;	// Stops C# compiler whinging that label 'loop17' has no statements

            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 18, implementsClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end implementsClause

    public class typeBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:211:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) ;
    public typeBlock_return typeBlock() // throws RecognitionException [1]
    {   
        typeBlock_return retval = new typeBlock_return();
        retval.start = input.LT(1);
        int typeBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY63 = null;
        IToken RCURLY65 = null;
        typeBlockEntry_return typeBlockEntry64 = null;
        
        
        CommonTree LCURLY63_tree=null;
        CommonTree RCURLY65_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_typeBlockEntry = new RewriteRuleSubtreeStream(adaptor,"rule typeBlockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 19) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:212:4: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK ( typeBlockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:212:4: LCURLY ( typeBlockEntry )* RCURLY
            {
            	LCURLY63 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_typeBlock919); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY63);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:213:3: ( typeBlockEntry )*
            	do 
            	{
            	    int alt19 = 2;
            	    int LA19_0 = input.LA(1);
            	    
            	    if ( (LA19_0 == IMPORT || LA19_0 == INCLUDE_DIRECTIVE || LA19_0 == FUNCTION || (LA19_0 >= VAR && LA19_0 <= CONST) || (LA19_0 >= IDENT && LA19_0 <= LBRACK) || (LA19_0 >= STATIC && LA19_0 <= DYNAMIC) || (LA19_0 >= SL_COMMENT && LA19_0 <= ML_COMMENT) || LA19_0 == 176 || (LA19_0 >= 182 && LA19_0 <= 186)) )
            	    {
            	        alt19 = 1;
            	    }
            	    
            	
            	    switch (alt19) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeBlockEntry
            			    {
            			    	PushFollow(FOLLOW_typeBlockEntry_in_typeBlock923);
            			    	typeBlockEntry64 = typeBlockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_typeBlockEntry.Add(typeBlockEntry64.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop19;
            	    }
            	} while (true);
            	
            	loop19:
            		;	// Stops C# compiler whinging that label 'loop19' has no statements

            	RCURLY65 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_typeBlock928); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY65);

            	
            	// AST REWRITE
            	// elements:          typeBlockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 215:3: -> ^( TYPE_BLOCK ( typeBlockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:215:6: ^( TYPE_BLOCK ( typeBlockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:215:19: ( typeBlockEntry )*
            	    while ( stream_typeBlockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeBlockEntry.Next());
            	    
            	    }
            	    stream_typeBlockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 19, typeBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlock

    public class typeBlockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeBlockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:218:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );
    public typeBlockEntry_return typeBlockEntry() // throws RecognitionException [1]
    {   
        typeBlockEntry_return retval = new typeBlockEntry_return();
        retval.start = input.LT(1);
        int typeBlockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifiers_return m = null;

        variableDefinition_return variableDefinition66 = null;

        methodDefinition_return methodDefinition67 = null;

        importDefinition_return importDefinition68 = null;

        as2IncludeDirective_return as2IncludeDirective69 = null;

        commentExpression_return commentExpression70 = null;

        annotations_return annotations71 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 20) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:219:4: (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations )
            int alt21 = 5;
            switch ( input.LA(1) ) 
            {
            case FUNCTION:
            case VAR:
            case CONST:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case STATIC:
            case DYNAMIC:
            case 182:
            case 183:
            case 184:
            case 185:
            case 186:
            	{
                alt21 = 1;
                }
                break;
            case IMPORT:
            	{
                alt21 = 2;
                }
                break;
            case INCLUDE_DIRECTIVE:
            	{
                alt21 = 3;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt21 = 4;
                }
                break;
            case LBRACK:
            case 176:
            	{
                alt21 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d21s0 =
            	        new NoViableAltException("218:1: typeBlockEntry : (m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] ) | importDefinition | as2IncludeDirective | commentExpression | annotations );", 21, 0, input);
            
            	    throw nvae_d21s0;
            }
            
            switch (alt21) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:219:4: m= modifiers ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_modifiers_in_typeBlockEntry952);
                    	m = modifiers();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )
                    	int alt20 = 2;
                    	int LA20_0 = input.LA(1);
                    	
                    	if ( ((LA20_0 >= VAR && LA20_0 <= CONST)) )
                    	{
                    	    alt20 = 1;
                    	}
                    	else if ( (LA20_0 == FUNCTION) )
                    	{
                    	    alt20 = 2;
                    	}
                    	else 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    NoViableAltException nvae_d20s0 =
                    	        new NoViableAltException("220:3: ( variableDefinition[$m.tree] | methodDefinition[$m.tree] )", 20, 0, input);
                    	
                    	    throw nvae_d20s0;
                    	}
                    	switch (alt20) 
                    	{
                    	    case 1 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:220:5: variableDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_variableDefinition_in_typeBlockEntry959);
                    	        	variableDefinition66 = variableDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDefinition66.Tree);
                    	        
                    	        }
                    	        break;
                    	    case 2 :
                    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:221:5: methodDefinition[$m.tree]
                    	        {
                    	        	PushFollow(FOLLOW_methodDefinition_in_typeBlockEntry966);
                    	        	methodDefinition67 = methodDefinition(((CommonTree)m.tree));
                    	        	followingStackPointer_--;
                    	        	if (failed) return retval;
                    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, methodDefinition67.Tree);
                    	        
                    	        }
                    	        break;
                    	
                    	}

                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:223:4: importDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_importDefinition_in_typeBlockEntry976);
                    	importDefinition68 = importDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, importDefinition68.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:224:4: as2IncludeDirective
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_as2IncludeDirective_in_typeBlockEntry981);
                    	as2IncludeDirective69 = as2IncludeDirective();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, as2IncludeDirective69.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:225:4: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_typeBlockEntry986);
                    	commentExpression70 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression70.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:226:4: annotations
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_annotations_in_typeBlockEntry991);
                    	annotations71 = annotations();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, annotations71.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 20, typeBlockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeBlockEntry

    public class as2IncludeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start as2IncludeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:229:1: as2IncludeDirective : INCLUDE_DIRECTIVE STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) ;
    public as2IncludeDirective_return as2IncludeDirective() // throws RecognitionException [1]
    {   
        as2IncludeDirective_return retval = new as2IncludeDirective_return();
        retval.start = input.LT(1);
        int as2IncludeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken INCLUDE_DIRECTIVE72 = null;
        IToken STRING_LITERAL73 = null;
        
        CommonTree INCLUDE_DIRECTIVE72_tree=null;
        CommonTree STRING_LITERAL73_tree=null;
        RewriteRuleTokenStream stream_INCLUDE_DIRECTIVE = new RewriteRuleTokenStream(adaptor,"token INCLUDE_DIRECTIVE");
        RewriteRuleTokenStream stream_STRING_LITERAL = new RewriteRuleTokenStream(adaptor,"token STRING_LITERAL");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 21) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:230:4: ( INCLUDE_DIRECTIVE STRING_LITERAL -> ^( INCLUDE_DIRECTIVE STRING_LITERAL ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:230:4: INCLUDE_DIRECTIVE STRING_LITERAL
            {
            	INCLUDE_DIRECTIVE72 = (IToken)input.LT(1);
            	Match(input,INCLUDE_DIRECTIVE,FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1002); if (failed) return retval;
            	if ( backtracking==0 ) stream_INCLUDE_DIRECTIVE.Add(INCLUDE_DIRECTIVE72);

            	STRING_LITERAL73 = (IToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_as2IncludeDirective1004); if (failed) return retval;
            	if ( backtracking==0 ) stream_STRING_LITERAL.Add(STRING_LITERAL73);

            	
            	// AST REWRITE
            	// elements:          STRING_LITERAL, INCLUDE_DIRECTIVE
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 230:37: -> ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:230:40: ^( INCLUDE_DIRECTIVE STRING_LITERAL )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_INCLUDE_DIRECTIVE.Next(), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_STRING_LITERAL.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 21, as2IncludeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end as2IncludeDirective

    public class includeDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start includeDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:233:1: includeDirective : 'include' STRING_LITERAL semi ;
    public includeDirective_return includeDirective() // throws RecognitionException [1]
    {   
        includeDirective_return retval = new includeDirective_return();
        retval.start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal74 = null;
        IToken STRING_LITERAL75 = null;
        semi_return semi76 = null;
        
        
        CommonTree string_literal74_tree=null;
        CommonTree STRING_LITERAL75_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 22) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:234:4: ( 'include' STRING_LITERAL semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:234:4: 'include' STRING_LITERAL semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal74 = (IToken)input.LT(1);
            	Match(input,176,FOLLOW_176_in_includeDirective1023); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal74_tree = (CommonTree)adaptor.Create(string_literal74);
            	adaptor.AddChild(root_0, string_literal74_tree);
            	}
            	STRING_LITERAL75 = (IToken)input.LT(1);
            	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_includeDirective1027); if (failed) return retval;
            	if ( backtracking==0 ) {
            	STRING_LITERAL75_tree = (CommonTree)adaptor.Create(STRING_LITERAL75);
            	adaptor.AddChild(root_0, STRING_LITERAL75_tree);
            	}
            	PushFollow(FOLLOW_semi_in_includeDirective1031);
            	semi76 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi76.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 22, includeDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end includeDirective

    public class methodDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start methodDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:240:1: methodDefinition[CommonTree mods] : FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) ;
    public methodDefinition_return methodDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        methodDefinition_return retval = new methodDefinition_return();
        retval.start = input.LT(1);
        int methodDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken FUNCTION77 = null;
        optionalAccessorRole_return r = null;

        ident_return ident78 = null;

        parameterDeclarationList_return parameterDeclarationList79 = null;

        typeExpression_return typeExpression80 = null;

        block_return block81 = null;

        semi_return semi82 = null;
        
        
        CommonTree FUNCTION77_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_optionalAccessorRole = new RewriteRuleSubtreeStream(adaptor,"rule optionalAccessorRole");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 23) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:241:4: ( FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi ) -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:241:4: FUNCTION r= optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block | semi )
            {
            	FUNCTION77 = (IToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_methodDefinition1044); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION77);

            	PushFollow(FOLLOW_optionalAccessorRole_in_methodDefinition1050);
            	r = optionalAccessorRole();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_optionalAccessorRole.Add(r.Tree);
            	PushFollow(FOLLOW_ident_in_methodDefinition1054);
            	ident78 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident78.Tree);
            	PushFollow(FOLLOW_parameterDeclarationList_in_methodDefinition1058);
            	parameterDeclarationList79 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList79.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:245:3: ( typeExpression )?
            	int alt22 = 2;
            	int LA22_0 = input.LA(1);
            	
            	if ( (LA22_0 == COLON) )
            	{
            	    alt22 = 1;
            	}
            	switch (alt22) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_methodDefinition1062);
            	        	typeExpression80 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression80.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:3: ( block | semi )
            	int alt23 = 2;
            	int LA23_0 = input.LA(1);
            	
            	if ( (LA23_0 == LCURLY) )
            	{
            	    alt23 = 1;
            	}
            	else if ( (LA23_0 == EOF || (LA23_0 >= RCURLY && LA23_0 <= INTERFACE) || LA23_0 == INCLUDE_DIRECTIVE || LA23_0 == FUNCTION || (LA23_0 >= NAMESPACE && LA23_0 <= CONST) || (LA23_0 >= IDENT && LA23_0 <= LBRACK) || (LA23_0 >= STATIC && LA23_0 <= DYNAMIC) || (LA23_0 >= SL_COMMENT && LA23_0 <= ML_COMMENT) || LA23_0 == 176 || (LA23_0 >= 182 && LA23_0 <= 186)) )
            	{
            	    alt23 = 2;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d23s0 =
            	        new NoViableAltException("246:3: ( block | semi )", 23, 0, input);
            	
            	    throw nvae_d23s0;
            	}
            	switch (alt23) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:4: block
            	        {
            	        	PushFollow(FOLLOW_block_in_methodDefinition1068);
            	        	block81 = block();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_block.Add(block81.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:246:10: semi
            	        {
            	        	PushFollow(FOLLOW_semi_in_methodDefinition1070);
            	        	semi82 = semi();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_semi.Add(semi82.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, block, optionalAccessorRole, typeExpression, parameterDeclarationList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 247:3: -> ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:247:6: ^( METHOD_DEF optionalAccessorRole ident parameterDeclarationList ( typeExpression )? ( block )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_optionalAccessorRole.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:250:5: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:251:5: ( block )?
            	    if ( stream_block.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    }
            	    stream_block.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 23, methodDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end methodDefinition

    public class optionalAccessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start optionalAccessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:254:1: optionalAccessorRole : ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) ;
    public optionalAccessorRole_return optionalAccessorRole() // throws RecognitionException [1]
    {   
        optionalAccessorRole_return retval = new optionalAccessorRole_return();
        retval.start = input.LT(1);
        int optionalAccessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        accessorRole_return accessorRole83 = null;
        
        
        RewriteRuleSubtreeStream stream_accessorRole = new RewriteRuleSubtreeStream(adaptor,"rule accessorRole");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 24) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:255:4: ( ( accessorRole )? -> ^( ACCESSOR_ROLE ( accessorRole )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:255:4: ( accessorRole )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:255:4: ( accessorRole )?
            	int alt24 = 2;
            	int LA24_0 = input.LA(1);
            	
            	if ( (LA24_0 == GET) )
            	{
            	    int LA24_1 = input.LA(2);
            	    
            	    if ( ((LA24_1 >= GET && LA24_1 <= USE) || LA24_1 == XML || LA24_1 == IDENT || LA24_1 == DYNAMIC || (LA24_1 >= IS && LA24_1 <= AS)) )
            	    {
            	        alt24 = 1;
            	    }
            	}
            	else if ( (LA24_0 == SET) )
            	{
            	    int LA24_9 = input.LA(2);
            	    
            	    if ( ((LA24_9 >= GET && LA24_9 <= USE) || LA24_9 == XML || LA24_9 == IDENT || LA24_9 == DYNAMIC || (LA24_9 >= IS && LA24_9 <= AS)) )
            	    {
            	        alt24 = 1;
            	    }
            	}
            	switch (alt24) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: accessorRole
            	        {
            	        	PushFollow(FOLLOW_accessorRole_in_optionalAccessorRole1134);
            	        	accessorRole83 = accessorRole();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_accessorRole.Add(accessorRole83.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          accessorRole
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 256:3: -> ^( ACCESSOR_ROLE ( accessorRole )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:256:6: ^( ACCESSOR_ROLE ( accessorRole )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ACCESSOR_ROLE, "ACCESSOR_ROLE"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:256:22: ( accessorRole )?
            	    if ( stream_accessorRole.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_accessorRole.Next());
            	    
            	    }
            	    stream_accessorRole.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 24, optionalAccessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end optionalAccessorRole

    public class accessorRole_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start accessorRole
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:259:1: accessorRole : ( GET | SET );
    public accessorRole_return accessorRole() // throws RecognitionException [1]
    {   
        accessorRole_return retval = new accessorRole_return();
        retval.start = input.LT(1);
        int accessorRole_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set84 = null;
        
        CommonTree set84_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 25) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:260:4: ( GET | SET )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set84 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= GET && input.LA(1) <= SET) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set84));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_accessorRole0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 25, accessorRole_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end accessorRole

    public class namespaceDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start namespaceDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:263:1: namespaceDefinition[CommonTree mods] : NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) ;
    public namespaceDefinition_return namespaceDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        namespaceDefinition_return retval = new namespaceDefinition_return();
        retval.start = input.LT(1);
        int namespaceDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NAMESPACE85 = null;
        ident_return ident86 = null;
        
        
        CommonTree NAMESPACE85_tree=null;
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 26) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:264:4: ( NAMESPACE ident -> ^( NAMESPACE_DEF NAMESPACE ident ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:264:4: NAMESPACE ident
            {
            	NAMESPACE85 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_namespaceDefinition1173); if (failed) return retval;
            	if ( backtracking==0 ) stream_NAMESPACE.Add(NAMESPACE85);

            	PushFollow(FOLLOW_ident_in_namespaceDefinition1175);
            	ident86 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident86.Tree);
            	
            	// AST REWRITE
            	// elements:          NAMESPACE, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 265:3: -> ^( NAMESPACE_DEF NAMESPACE ident )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:265:6: ^( NAMESPACE_DEF NAMESPACE ident )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_NAMESPACE.Next());
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 26, namespaceDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end namespaceDefinition

    public class useNamespaceDirective_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start useNamespaceDirective
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:268:1: useNamespaceDirective : USE NAMESPACE ident semi ;
    public useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
    {   
        useNamespaceDirective_return retval = new useNamespaceDirective_return();
        retval.start = input.LT(1);
        int useNamespaceDirective_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken USE87 = null;
        IToken NAMESPACE88 = null;
        ident_return ident89 = null;

        semi_return semi90 = null;
        
        
        CommonTree USE87_tree=null;
        CommonTree NAMESPACE88_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 27) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:269:4: ( USE NAMESPACE ident semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:269:4: USE NAMESPACE ident semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	USE87 = (IToken)input.LT(1);
            	Match(input,USE,FOLLOW_USE_in_useNamespaceDirective1200); if (failed) return retval;
            	if ( backtracking==0 ) {
            	USE87_tree = (CommonTree)adaptor.Create(USE87);
            	adaptor.AddChild(root_0, USE87_tree);
            	}
            	NAMESPACE88 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_useNamespaceDirective1202); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NAMESPACE88_tree = (CommonTree)adaptor.Create(NAMESPACE88);
            	adaptor.AddChild(root_0, NAMESPACE88_tree);
            	}
            	PushFollow(FOLLOW_ident_in_useNamespaceDirective1204);
            	ident89 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident89.Tree);
            	PushFollow(FOLLOW_semi_in_useNamespaceDirective1206);
            	semi90 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi90.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 27, useNamespaceDirective_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end useNamespaceDirective

    public class variableDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:272:1: variableDefinition[CommonTree mods] : decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) ;
    public variableDefinition_return variableDefinition(CommonTree mods) // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        variableDefinition_return retval = new variableDefinition_return();
        retval.start = input.LT(1);
        int variableDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA92 = null;
        varOrConst_return decl = null;

        variableDeclarator_return variableDeclarator91 = null;

        variableDeclarator_return variableDeclarator93 = null;

        semi_return semi94 = null;
        
        
        CommonTree COMMA92_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_varOrConst = new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
        RewriteRuleSubtreeStream stream_variableDeclarator = new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 28) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:277:4: (decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi -> ^( VAR_DEF $decl ( variableDeclarator )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:277:4: decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* semi
            {
            	PushFollow(FOLLOW_varOrConst_in_variableDefinition1230);
            	decl = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_varOrConst.Add(decl.Tree);
            	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1232);
            	variableDeclarator91 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator91.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:278:3: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt25 = 2;
            	    int LA25_0 = input.LA(1);
            	    
            	    if ( (LA25_0 == COMMA) )
            	    {
            	        alt25 = 1;
            	    }
            	    
            	
            	    switch (alt25) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:278:4: COMMA variableDeclarator
            			    {
            			    	COMMA92 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_variableDefinition1237); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA92);

            			    	PushFollow(FOLLOW_variableDeclarator_in_variableDefinition1239);
            			    	variableDeclarator93 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_variableDeclarator.Add(variableDeclarator93.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop25;
            	    }
            	} while (true);
            	
            	loop25:
            		;	// Stops C# compiler whinging that label 'loop25' has no statements

            	PushFollow(FOLLOW_semi_in_variableDefinition1245);
            	semi94 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi94.Tree);
            	
            	// AST REWRITE
            	// elements:          decl, variableDeclarator
            	// token labels:      
            	// rule labels:       decl, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_decl = new RewriteRuleSubtreeStream(adaptor, "token decl", (decl!=null ? decl.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 280:3: -> ^( VAR_DEF $decl ( variableDeclarator )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:280:6: ^( VAR_DEF $decl ( variableDeclarator )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(VAR_DEF, "VAR_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, mods);
            	    adaptor.AddChild(root_1, stream_decl.Next());
            	    if ( !(stream_variableDeclarator.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_variableDeclarator.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_variableDeclarator.Next());
            	    
            	    }
            	    stream_variableDeclarator.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 28, variableDefinition_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end variableDefinition

    public class varOrConst_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start varOrConst
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:283:1: varOrConst : ( VAR | CONST );
    public varOrConst_return varOrConst() // throws RecognitionException [1]
    {   
        varOrConst_return retval = new varOrConst_return();
        retval.start = input.LT(1);
        int varOrConst_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set95 = null;
        
        CommonTree set95_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 29) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:284:4: ( VAR | CONST )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set95 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= VAR && input.LA(1) <= CONST) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set95));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_varOrConst0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 29, varOrConst_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end varOrConst

    public class variableDeclarator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableDeclarator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:287:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? ;
    public variableDeclarator_return variableDeclarator() // throws RecognitionException [1]
    {   
        variableDeclarator_return retval = new variableDeclarator_return();
        retval.start = input.LT(1);
        int variableDeclarator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ident96 = null;

        typeExpression_return typeExpression97 = null;

        variableInitializer_return variableInitializer98 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 30) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:288:4: ( ident ( typeExpression )? ( variableInitializer )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:288:4: ident ( typeExpression )? ( variableInitializer )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_ident_in_variableDeclarator1287);
            	ident96 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(ident96.Tree, root_0);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:288:11: ( typeExpression )?
            	int alt26 = 2;
            	int LA26_0 = input.LA(1);
            	
            	if ( (LA26_0 == COLON) )
            	{
            	    alt26 = 1;
            	}
            	switch (alt26) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_variableDeclarator1290);
            	        	typeExpression97 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, typeExpression97.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:288:27: ( variableInitializer )?
            	int alt27 = 2;
            	int LA27_0 = input.LA(1);
            	
            	if ( (LA27_0 == ASSIGN) )
            	{
            	    alt27 = 1;
            	}
            	switch (alt27) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: variableInitializer
            	        {
            	        	PushFollow(FOLLOW_variableInitializer_in_variableDeclarator1293);
            	        	variableInitializer98 = variableInitializer();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, variableInitializer98.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 30, variableDeclarator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableDeclarator

    public class declaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:290:1: declaration : varOrConst variableDeclarator declarationTail ;
    public declaration_return declaration() // throws RecognitionException [1]
    {   
        declaration_return retval = new declaration_return();
        retval.start = input.LT(1);
        int declaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        varOrConst_return varOrConst99 = null;

        variableDeclarator_return variableDeclarator100 = null;

        declarationTail_return declarationTail101 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 31) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:4: ( varOrConst variableDeclarator declarationTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:291:4: varOrConst variableDeclarator declarationTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_varOrConst_in_declaration1304);
            	varOrConst99 = varOrConst();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(varOrConst99.Tree, root_0);
            	PushFollow(FOLLOW_variableDeclarator_in_declaration1307);
            	variableDeclarator100 = variableDeclarator();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator100.Tree);
            	PushFollow(FOLLOW_declarationTail_in_declaration1311);
            	declarationTail101 = declarationTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationTail101.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 31, declaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end declaration

    public class declarationTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:295:1: declarationTail : ( COMMA variableDeclarator )* ;
    public declarationTail_return declarationTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationTail_return retval = new declarationTail_return();
        retval.start = input.LT(1);
        int declarationTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA102 = null;
        variableDeclarator_return variableDeclarator103 = null;
        
        
        CommonTree COMMA102_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 32) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:4: ( ( COMMA variableDeclarator )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:4: ( COMMA variableDeclarator )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:4: ( COMMA variableDeclarator )*
            	do 
            	{
            	    int alt28 = 2;
            	    int LA28_0 = input.LA(1);
            	    
            	    if ( (LA28_0 == COMMA) )
            	    {
            	        alt28 = 1;
            	    }
            	    
            	
            	    switch (alt28) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:300:5: COMMA variableDeclarator
            			    {
            			    	COMMA102 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_declarationTail1333); if (failed) return retval;
            			    	PushFollow(FOLLOW_variableDeclarator_in_declarationTail1336);
            			    	variableDeclarator103 = variableDeclarator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, variableDeclarator103.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop28;
            	    }
            	} while (true);
            	
            	loop28:
            		;	// Stops C# compiler whinging that label 'loop28' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 32, declarationTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationTail

    public class variableInitializer_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start variableInitializer
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:303:1: variableInitializer : ASSIGN assignmentExpression ;
    public variableInitializer_return variableInitializer() // throws RecognitionException [1]
    {   
        variableInitializer_return retval = new variableInitializer_return();
        retval.start = input.LT(1);
        int variableInitializer_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN104 = null;
        assignmentExpression_return assignmentExpression105 = null;
        
        
        CommonTree ASSIGN104_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 33) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:304:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:304:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN104 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_variableInitializer1349); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN104_tree = (CommonTree)adaptor.Create(ASSIGN104);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN104_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_variableInitializer1352);
            	assignmentExpression105 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression105.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 33, variableInitializer_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end variableInitializer

    public class parameterDeclarationList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclarationList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:309:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) ;
    public parameterDeclarationList_return parameterDeclarationList() // throws RecognitionException [1]
    {   
        parameterDeclarationList_return retval = new parameterDeclarationList_return();
        retval.start = input.LT(1);
        int parameterDeclarationList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN106 = null;
        IToken COMMA108 = null;
        IToken RPAREN110 = null;
        parameterDeclaration_return parameterDeclaration107 = null;

        parameterDeclaration_return parameterDeclaration109 = null;
        
        
        CommonTree LPAREN106_tree=null;
        CommonTree COMMA108_tree=null;
        CommonTree RPAREN110_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_parameterDeclaration = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclaration");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 34) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:310:4: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS ( parameterDeclaration )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:310:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
            {
            	LPAREN106 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_parameterDeclarationList1365); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN106);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:311:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
            	int alt30 = 2;
            	int LA30_0 = input.LA(1);
            	
            	if ( ((LA30_0 >= GET && LA30_0 <= USE) || LA30_0 == CONST || LA30_0 == REST || LA30_0 == XML || LA30_0 == IDENT || LA30_0 == DYNAMIC || (LA30_0 >= IS && LA30_0 <= AS)) )
            	{
            	    alt30 = 1;
            	}
            	switch (alt30) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:311:5: parameterDeclaration ( COMMA parameterDeclaration )*
            	        {
            	        	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1371);
            	        	parameterDeclaration107 = parameterDeclaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration107.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:312:4: ( COMMA parameterDeclaration )*
            	        	do 
            	        	{
            	        	    int alt29 = 2;
            	        	    int LA29_0 = input.LA(1);
            	        	    
            	        	    if ( (LA29_0 == COMMA) )
            	        	    {
            	        	        alt29 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt29) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:312:5: COMMA parameterDeclaration
            	        			    {
            	        			    	COMMA108 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_parameterDeclarationList1377); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA108);

            	        			    	PushFollow(FOLLOW_parameterDeclaration_in_parameterDeclarationList1379);
            	        			    	parameterDeclaration109 = parameterDeclaration();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_parameterDeclaration.Add(parameterDeclaration109.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop29;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop29:
            	        		;	// Stops C# compiler whinging that label 'loop29' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN110 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_parameterDeclarationList1390); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN110);

            	
            	// AST REWRITE
            	// elements:          parameterDeclaration
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 315:3: -> ^( PARAMS ( parameterDeclaration )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:6: ^( PARAMS ( parameterDeclaration )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAMS, "PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:315:15: ( parameterDeclaration )*
            	    while ( stream_parameterDeclaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDeclaration.Next());
            	    
            	    }
            	    stream_parameterDeclaration.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 34, parameterDeclarationList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclarationList

    public class parameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:319:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
    public parameterDeclaration_return parameterDeclaration() // throws RecognitionException [1]
    {   
        parameterDeclaration_return retval = new parameterDeclaration_return();
        retval.start = input.LT(1);
        int parameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        basicParameterDeclaration_return basicParameterDeclaration111 = null;

        parameterRestDeclaration_return parameterRestDeclaration112 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 35) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:320:4: ( basicParameterDeclaration | parameterRestDeclaration )
            int alt31 = 2;
            int LA31_0 = input.LA(1);
            
            if ( ((LA31_0 >= GET && LA31_0 <= USE) || LA31_0 == CONST || LA31_0 == XML || LA31_0 == IDENT || LA31_0 == DYNAMIC || (LA31_0 >= IS && LA31_0 <= AS)) )
            {
                alt31 = 1;
            }
            else if ( (LA31_0 == REST) )
            {
                alt31 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d31s0 =
                    new NoViableAltException("319:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );", 31, 0, input);
            
                throw nvae_d31s0;
            }
            switch (alt31) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:320:4: basicParameterDeclaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_basicParameterDeclaration_in_parameterDeclaration1413);
                    	basicParameterDeclaration111 = basicParameterDeclaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, basicParameterDeclaration111.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:320:32: parameterRestDeclaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_parameterRestDeclaration_in_parameterDeclaration1417);
                    	parameterRestDeclaration112 = parameterRestDeclaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, parameterRestDeclaration112.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 35, parameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterDeclaration

    public class basicParameterDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start basicParameterDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:323:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
    public basicParameterDeclaration_return basicParameterDeclaration() // throws RecognitionException [1]
    {   
        basicParameterDeclaration_return retval = new basicParameterDeclaration_return();
        retval.start = input.LT(1);
        int basicParameterDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CONST113 = null;
        ident_return ident114 = null;

        typeExpression_return typeExpression115 = null;

        parameterDefault_return parameterDefault116 = null;
        
        
        CommonTree CONST113_tree=null;
        RewriteRuleTokenStream stream_CONST = new RewriteRuleTokenStream(adaptor,"token CONST");
        RewriteRuleSubtreeStream stream_parameterDefault = new RewriteRuleSubtreeStream(adaptor,"rule parameterDefault");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 36) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:4: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:4: ( CONST )?
            	int alt32 = 2;
            	int LA32_0 = input.LA(1);
            	
            	if ( (LA32_0 == CONST) )
            	{
            	    alt32 = 1;
            	}
            	switch (alt32) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: CONST
            	        {
            	        	CONST113 = (IToken)input.LT(1);
            	        	Match(input,CONST,FOLLOW_CONST_in_basicParameterDeclaration1428); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_CONST.Add(CONST113);

            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_ident_in_basicParameterDeclaration1431);
            	ident114 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident114.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:17: ( typeExpression )?
            	int alt33 = 2;
            	int LA33_0 = input.LA(1);
            	
            	if ( (LA33_0 == COLON) )
            	{
            	    alt33 = 1;
            	}
            	switch (alt33) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_basicParameterDeclaration1433);
            	        	typeExpression115 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression115.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:324:33: ( parameterDefault )?
            	int alt34 = 2;
            	int LA34_0 = input.LA(1);
            	
            	if ( (LA34_0 == ASSIGN) )
            	{
            	    alt34 = 1;
            	}
            	switch (alt34) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: parameterDefault
            	        {
            	        	PushFollow(FOLLOW_parameterDefault_in_basicParameterDeclaration1436);
            	        	parameterDefault116 = parameterDefault();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_parameterDefault.Add(parameterDefault116.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, parameterDefault, CONST, typeExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 325:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:14: ( CONST )?
            	    if ( stream_CONST.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_CONST.Next());
            	    
            	    }
            	    stream_CONST.Reset();
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:27: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:325:43: ( parameterDefault )?
            	    if ( stream_parameterDefault.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_parameterDefault.Next());
            	    
            	    }
            	    stream_parameterDefault.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 36, basicParameterDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end basicParameterDeclaration

    public class parameterDefault_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterDefault
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:328:1: parameterDefault : ASSIGN assignmentExpression ;
    public parameterDefault_return parameterDefault() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        parameterDefault_return retval = new parameterDefault_return();
        retval.start = input.LT(1);
        int parameterDefault_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN117 = null;
        assignmentExpression_return assignmentExpression118 = null;
        
        
        CommonTree ASSIGN117_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 37) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:334:4: ( ASSIGN assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:334:4: ASSIGN assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ASSIGN117 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_parameterDefault1480); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ASSIGN117_tree = (CommonTree)adaptor.Create(ASSIGN117);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN117_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_parameterDefault1483);
            	assignmentExpression118 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression118.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 37, parameterDefault_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end parameterDefault

    public class parameterRestDeclaration_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start parameterRestDeclaration
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:337:1: parameterRestDeclaration : REST ( ident )? -> ^( PARAM REST ( ident )? ) ;
    public parameterRestDeclaration_return parameterRestDeclaration() // throws RecognitionException [1]
    {   
        parameterRestDeclaration_return retval = new parameterRestDeclaration_return();
        retval.start = input.LT(1);
        int parameterRestDeclaration_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken REST119 = null;
        ident_return ident120 = null;
        
        
        CommonTree REST119_tree=null;
        RewriteRuleTokenStream stream_REST = new RewriteRuleTokenStream(adaptor,"token REST");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 38) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:338:4: ( REST ( ident )? -> ^( PARAM REST ( ident )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:338:4: REST ( ident )?
            {
            	REST119 = (IToken)input.LT(1);
            	Match(input,REST,FOLLOW_REST_in_parameterRestDeclaration1494); if (failed) return retval;
            	if ( backtracking==0 ) stream_REST.Add(REST119);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:338:9: ( ident )?
            	int alt35 = 2;
            	int LA35_0 = input.LA(1);
            	
            	if ( ((LA35_0 >= GET && LA35_0 <= USE) || LA35_0 == XML || LA35_0 == IDENT || LA35_0 == DYNAMIC || (LA35_0 >= IS && LA35_0 <= AS)) )
            	{
            	    alt35 = 1;
            	}
            	switch (alt35) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: ident
            	        {
            	        	PushFollow(FOLLOW_ident_in_parameterRestDeclaration1496);
            	        	ident120 = ident();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_ident.Add(ident120.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          ident, REST
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 339:3: -> ^( PARAM REST ( ident )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:339:6: ^( PARAM REST ( ident )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PARAM, "PARAM"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_REST.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:339:19: ( ident )?
            	    if ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 38, parameterRestDeclaration_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end parameterRestDeclaration

    public class block_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start block
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:341:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) ;
    public block_return block() // throws RecognitionException [1]
    {   
        block_return retval = new block_return();
        retval.start = input.LT(1);
        int block_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY121 = null;
        IToken RCURLY123 = null;
        blockEntry_return blockEntry122 = null;
        
        
        CommonTree LCURLY121_tree=null;
        CommonTree RCURLY123_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_blockEntry = new RewriteRuleSubtreeStream(adaptor,"rule blockEntry");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 39) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:342:4: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK ( blockEntry )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:342:4: LCURLY ( blockEntry )* RCURLY
            {
            	LCURLY121 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_block1520); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY121);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:342:11: ( blockEntry )*
            	do 
            	{
            	    int alt36 = 2;
            	    int LA36_0 = input.LA(1);
            	    
            	    if ( (LA36_0 == LCURLY || LA36_0 == SEMI || (LA36_0 >= STRING_LITERAL && LA36_0 <= CONST) || LA36_0 == LPAREN || LA36_0 == IF || (LA36_0 >= RETURN && LA36_0 <= SWITCH) || (LA36_0 >= DEFAULT && LA36_0 <= FOR) || (LA36_0 >= WHILE && LA36_0 <= XML) || (LA36_0 >= IDENT && LA36_0 <= LBRACK) || LA36_0 == DYNAMIC || LA36_0 == LT || (LA36_0 >= IS && LA36_0 <= AS) || (LA36_0 >= PLUS && LA36_0 <= DIV) || (LA36_0 >= INC && LA36_0 <= BNOT) || (LA36_0 >= E4X_ATTRI && LA36_0 <= ML_COMMENT) || (LA36_0 >= 177 && LA36_0 <= 178) || LA36_0 == 181) )
            	    {
            	        alt36 = 1;
            	    }
            	    
            	
            	    switch (alt36) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: blockEntry
            			    {
            			    	PushFollow(FOLLOW_blockEntry_in_block1522);
            			    	blockEntry122 = blockEntry();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_blockEntry.Add(blockEntry122.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop36;
            	    }
            	} while (true);
            	
            	loop36:
            		;	// Stops C# compiler whinging that label 'loop36' has no statements

            	RCURLY123 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_block1525); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY123);

            	
            	// AST REWRITE
            	// elements:          blockEntry
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 343:3: -> ^( BLOCK ( blockEntry )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:343:6: ^( BLOCK ( blockEntry )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:343:14: ( blockEntry )*
            	    while ( stream_blockEntry.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_blockEntry.Next());
            	    
            	    }
            	    stream_blockEntry.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 39, block_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end block

    public class blockEntry_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start blockEntry
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:346:1: blockEntry : statement ;
    public blockEntry_return blockEntry() // throws RecognitionException [1]
    {   
        blockEntry_return retval = new blockEntry_return();
        retval.start = input.LT(1);
        int blockEntry_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement124 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 40) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: ( statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:347:4: statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_statement_in_blockEntry1547);
            	statement124 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement124.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 40, blockEntry_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end blockEntry

    public class condition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start condition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:350:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
    public condition_return condition() // throws RecognitionException [1]
    {   
        condition_return retval = new condition_return();
        retval.start = input.LT(1);
        int condition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN125 = null;
        IToken RPAREN127 = null;
        expression_return expression126 = null;
        
        
        CommonTree LPAREN125_tree=null;
        CommonTree RPAREN127_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 41) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:351:4: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:351:4: LPAREN expression RPAREN
            {
            	LPAREN125 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_condition1558); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN125);

            	PushFollow(FOLLOW_expression_in_condition1560);
            	expression126 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expression.Add(expression126.Tree);
            	RPAREN127 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_condition1562); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN127);

            	
            	// AST REWRITE
            	// elements:          expression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 352:3: -> ^( CONDITION expression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:352:6: ^( CONDITION expression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(CONDITION, "CONDITION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 41, condition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end condition

    public class statement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start statement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );
    public statement_return statement() // throws RecognitionException [1]
    {   
        statement_return retval = new statement_return();
        retval.start = input.LT(1);
        int statement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI145 = null;
        block_return block128 = null;

        declarationStatement_return declarationStatement129 = null;

        expressionStatement_return expressionStatement130 = null;

        ifStatement_return ifStatement131 = null;

        forEachStatement_return forEachStatement132 = null;

        forStatement_return forStatement133 = null;

        whileStatement_return whileStatement134 = null;

        doWhileStatement_return doWhileStatement135 = null;

        withStatement_return withStatement136 = null;

        switchStatement_return switchStatement137 = null;

        breakStatement_return breakStatement138 = null;

        continueStatement_return continueStatement139 = null;

        returnStatement_return returnStatement140 = null;

        throwStatement_return throwStatement141 = null;

        tryStatement_return tryStatement142 = null;

        defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement143 = null;

        commentExpression_return commentExpression144 = null;
        
        
        CommonTree SEMI145_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 42) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI )
            int alt37 = 18;
            switch ( input.LA(1) ) 
            {
            case LCURLY:
            	{
                int LA37_1 = input.LA(2);
                
                if ( (LA37_1 == LCURLY) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( ((LA37_1 >= VAR && LA37_1 <= CONST)) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == INC) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == DEC) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == MINUS) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == PLUS) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == DELETE) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == 181) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == TYPEOF) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == LNOT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == BNOT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == UNDEFINED) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == LT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == DIV) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( ((LA37_1 >= HEX_LITERAL && LA37_1 <= FLOAT_LITERAL)) )
                {
                    int LA37_64 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s64 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 64, input);
                    
                        throw nvae_d37s64;
                    }
                }
                else if ( (LA37_1 == STRING_LITERAL) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == TRUE) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == FALSE) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == NULL) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == LBRACK) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == FUNCTION) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == NEW) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == LPAREN) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == E4X_ATTRI) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == IDENT) )
                {
                    int LA37_74 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s74 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 74, input);
                    
                        throw nvae_d37s74;
                    }
                }
                else if ( ((LA37_1 >= PUBLIC && LA37_1 <= INTERNAL)) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == USE) )
                {
                    int LA37_76 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s76 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 76, input);
                    
                        throw nvae_d37s76;
                    }
                }
                else if ( (LA37_1 == XML) )
                {
                    int LA37_77 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s77 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 77, input);
                    
                        throw nvae_d37s77;
                    }
                }
                else if ( (LA37_1 == DYNAMIC) )
                {
                    int LA37_78 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s78 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 78, input);
                    
                        throw nvae_d37s78;
                    }
                }
                else if ( (LA37_1 == NAMESPACE) )
                {
                    int LA37_79 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s79 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 79, input);
                    
                        throw nvae_d37s79;
                    }
                }
                else if ( (LA37_1 == IS) )
                {
                    int LA37_80 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s80 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 80, input);
                    
                        throw nvae_d37s80;
                    }
                }
                else if ( (LA37_1 == AS) )
                {
                    int LA37_81 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s81 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 81, input);
                    
                        throw nvae_d37s81;
                    }
                }
                else if ( (LA37_1 == GET) )
                {
                    int LA37_82 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s82 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 82, input);
                    
                        throw nvae_d37s82;
                    }
                }
                else if ( (LA37_1 == SET) )
                {
                    int LA37_83 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s83 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 83, input);
                    
                        throw nvae_d37s83;
                    }
                }
                else if ( (LA37_1 == IF) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == FOR) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == WHILE) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == DO) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == WITH) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == SWITCH) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == BREAK) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == CONTINUE) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == RETURN) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == 177) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == 178) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == DEFAULT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == SL_COMMENT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == ML_COMMENT) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == SEMI) && (synpred48()) )
                {
                    alt37 = 1;
                }
                else if ( (LA37_1 == RCURLY) )
                {
                    int LA37_99 = input.LA(3);
                    
                    if ( (synpred48()) )
                    {
                        alt37 = 1;
                    }
                    else if ( (synpred50()) )
                    {
                        alt37 = 3;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d37s99 =
                            new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 99, input);
                    
                        throw nvae_d37s99;
                    }
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d37s1 =
                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 1, input);
                
                    throw nvae_d37s1;
                }
                }
                break;
            case VAR:
            case CONST:
            	{
                alt37 = 2;
                }
                break;
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case PLUS:
            case MINUS:
            case DIV:
            case INC:
            case DEC:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case 181:
            	{
                alt37 = 3;
                }
                break;
            case IF:
            	{
                alt37 = 4;
                }
                break;
            case FOR:
            	{
                int LA37_36 = input.LA(2);
                
                if ( (LA37_36 == LPAREN) )
                {
                    alt37 = 6;
                }
                else if ( (LA37_36 == EACH) )
                {
                    alt37 = 5;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d37s36 =
                        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 36, input);
                
                    throw nvae_d37s36;
                }
                }
                break;
            case WHILE:
            	{
                alt37 = 7;
                }
                break;
            case DO:
            	{
                alt37 = 8;
                }
                break;
            case WITH:
            	{
                alt37 = 9;
                }
                break;
            case SWITCH:
            	{
                alt37 = 10;
                }
                break;
            case BREAK:
            	{
                alt37 = 11;
                }
                break;
            case CONTINUE:
            	{
                alt37 = 12;
                }
                break;
            case RETURN:
            	{
                alt37 = 13;
                }
                break;
            case 177:
            	{
                alt37 = 14;
                }
                break;
            case 178:
            	{
                alt37 = 15;
                }
                break;
            case DEFAULT:
            	{
                alt37 = 16;
                }
                break;
            case SL_COMMENT:
            case ML_COMMENT:
            	{
                alt37 = 17;
                }
                break;
            case SEMI:
            	{
                alt37 = 18;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d37s0 =
            	        new NoViableAltException("355:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | forStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | commentExpression | SEMI );", 37, 0, input);
            
            	    throw nvae_d37s0;
            }
            
            switch (alt37) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( LCURLY )=> block
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_block_in_statement1588);
                    	block128 = block();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, block128.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:357:4: declarationStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declarationStatement_in_statement1593);
                    	declarationStatement129 = declarationStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declarationStatement129.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: expressionStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_expressionStatement_in_statement1598);
                    	expressionStatement130 = expressionStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionStatement130.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:359:4: ifStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ifStatement_in_statement1603);
                    	ifStatement131 = ifStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ifStatement131.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:361:4: forEachStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_forEachStatement_in_statement1610);
                    	forEachStatement132 = forEachStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, forEachStatement132.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:362:4: forStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_forStatement_in_statement1615);
                    	forStatement133 = forStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, forStatement133.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:365:4: whileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_whileStatement_in_statement1623);
                    	whileStatement134 = whileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, whileStatement134.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:368:4: doWhileStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_doWhileStatement_in_statement1631);
                    	doWhileStatement135 = doWhileStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, doWhileStatement135.Tree);
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:371:4: withStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_withStatement_in_statement1640);
                    	withStatement136 = withStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, withStatement136.Tree);
                    
                    }
                    break;
                case 10 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:374:4: switchStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_switchStatement_in_statement1649);
                    	switchStatement137 = switchStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, switchStatement137.Tree);
                    
                    }
                    break;
                case 11 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:377:4: breakStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_breakStatement_in_statement1658);
                    	breakStatement138 = breakStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, breakStatement138.Tree);
                    
                    }
                    break;
                case 12 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:380:4: continueStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_continueStatement_in_statement1666);
                    	continueStatement139 = continueStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, continueStatement139.Tree);
                    
                    }
                    break;
                case 13 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:383:4: returnStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_returnStatement_in_statement1674);
                    	returnStatement140 = returnStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, returnStatement140.Tree);
                    
                    }
                    break;
                case 14 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:386:4: throwStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_throwStatement_in_statement1682);
                    	throwStatement141 = throwStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, throwStatement141.Tree);
                    
                    }
                    break;
                case 15 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:389:4: tryStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_tryStatement_in_statement1691);
                    	tryStatement142 = tryStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, tryStatement142.Tree);
                    
                    }
                    break;
                case 16 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:392:4: defaultXMLNamespaceStatement
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_defaultXMLNamespaceStatement_in_statement1700);
                    	defaultXMLNamespaceStatement143 = defaultXMLNamespaceStatement();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, defaultXMLNamespaceStatement143.Tree);
                    
                    }
                    break;
                case 17 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:395:4: commentExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_commentExpression_in_statement1709);
                    	commentExpression144 = commentExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression144.Tree);
                    
                    }
                    break;
                case 18 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:398:4: SEMI
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	SEMI145 = (IToken)input.LT(1);
                    	Match(input,SEMI,FOLLOW_SEMI_in_statement1717); if (failed) return retval;
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 42, statement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end statement

    public class declarationStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start declarationStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:401:1: declarationStatement : declaration semi ;
    public declarationStatement_return declarationStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        declarationStatement_return retval = new declarationStatement_return();
        retval.start = input.LT(1);
        int declarationStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration146 = null;

        semi_return semi147 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 43) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:406:4: ( declaration semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:406:4: declaration semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_declaration_in_declarationStatement1739);
            	declaration146 = declaration();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration146.Tree);
            	PushFollow(FOLLOW_semi_in_declarationStatement1741);
            	semi147 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi147.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 43, declarationStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end declarationStatement

    public class expressionStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:409:1: expressionStatement : expressionList semi -> ^( EXPR_STMNT expressionList ) ;
    public expressionStatement_return expressionStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expressionStatement_return retval = new expressionStatement_return();
        retval.start = input.LT(1);
        int expressionStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList148 = null;

        semi_return semi149 = null;
        
        
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 44) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:414:4: ( expressionList semi -> ^( EXPR_STMNT expressionList ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:414:4: expressionList semi
            {
            	PushFollow(FOLLOW_expressionList_in_expressionStatement1762);
            	expressionList148 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expressionList.Add(expressionList148.Tree);
            	PushFollow(FOLLOW_semi_in_expressionStatement1764);
            	semi149 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi149.Tree);
            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 415:3: -> ^( EXPR_STMNT expressionList )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:415:6: ^( EXPR_STMNT expressionList )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 44, expressionStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expressionStatement

    public class ifStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ifStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:418:1: ifStatement : IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )? ;
    public ifStatement_return ifStatement() // throws RecognitionException [1]
    {   
        ifStatement_return retval = new ifStatement_return();
        retval.start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IF150 = null;
        condition_return condition151 = null;

        commentExpression_return commentExpression152 = null;

        statement_return statement153 = null;

        commentExpression_return commentExpression154 = null;

        elseClause_return elseClause155 = null;
        
        
        CommonTree IF150_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 45) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:4: ( IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:4: IF condition ( commentExpression )? statement ( commentExpression )? ( ( ELSE )=> elseClause )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	IF150 = (IToken)input.LT(1);
            	Match(input,IF,FOLLOW_IF_in_ifStatement1786); if (failed) return retval;
            	if ( backtracking==0 ) {
            	IF150_tree = (CommonTree)adaptor.Create(IF150);
            	root_0 = (CommonTree)adaptor.BecomeRoot(IF150_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_ifStatement1789);
            	condition151 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition151.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:18: ( commentExpression )?
            	int alt38 = 2;
            	int LA38_0 = input.LA(1);
            	
            	if ( (LA38_0 == SL_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA38_50 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA38_51 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA38_54 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA38_55 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA38_56 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA38_57 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA38_58 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA38_59 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA38_60 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA38_61 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA38_62 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA38_63 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA38_64 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA38_65 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA38_66 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA38_67 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA38_68 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA38_69 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA38_70 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA38_71 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA38_72 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA38_73 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA38_74 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA38_75 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA38_76 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA38_77 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA38_78 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA38_79 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA38_80 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA38_81 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA38_82 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA38_83 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA38_84 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA38_85 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA38_86 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA38_87 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA38_88 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA38_89 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA38_90 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA38_91 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA38_92 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA38_93 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA38_94 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA38_95 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA38_96 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA38_97 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 178:
            	        	{
            	            int LA38_98 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA38_99 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA38_100 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA38_0 == ML_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA38_103 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA38_104 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA38_107 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA38_108 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA38_109 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA38_110 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA38_111 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA38_112 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA38_113 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA38_114 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA38_115 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA38_116 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA38_117 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA38_118 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA38_119 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA38_120 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA38_121 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA38_122 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA38_123 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA38_124 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA38_125 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA38_126 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA38_127 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA38_128 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA38_129 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA38_130 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA38_131 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA38_132 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA38_133 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA38_134 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA38_135 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA38_136 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA38_137 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA38_138 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA38_139 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA38_140 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA38_141 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA38_142 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA38_143 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA38_144 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA38_145 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA38_146 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA38_147 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA38_148 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA38_149 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA38_150 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case 178:
            	        	{
            	            int LA38_151 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA38_152 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA38_153 = input.LA(3);
            	            
            	            if ( (synpred65()) )
            	            {
            	                alt38 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt38) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_ifStatement1791);
            	        	commentExpression152 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression152.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_statement_in_ifStatement1794);
            	statement153 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement153.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:47: ( commentExpression )?
            	int alt39 = 2;
            	int LA39_0 = input.LA(1);
            	
            	if ( (LA39_0 == SL_COMMENT) )
            	{
            	    int LA39_1 = input.LA(2);
            	    
            	    if ( (synpred66()) )
            	    {
            	        alt39 = 1;
            	    }
            	}
            	else if ( (LA39_0 == ML_COMMENT) )
            	{
            	    int LA39_2 = input.LA(2);
            	    
            	    if ( (synpred66()) )
            	    {
            	        alt39 = 1;
            	    }
            	}
            	switch (alt39) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_ifStatement1796);
            	        	commentExpression154 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression154.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:3: ( ( ELSE )=> elseClause )?
            	int alt40 = 2;
            	int LA40_0 = input.LA(1);
            	
            	if ( (LA40_0 == ELSE) )
            	{
            	    int LA40_1 = input.LA(2);
            	    
            	    if ( (synpred67()) )
            	    {
            	        alt40 = 1;
            	    }
            	}
            	switch (alt40) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:4: ( ELSE )=> elseClause
            	        {
            	        	PushFollow(FOLLOW_elseClause_in_ifStatement1806);
            	        	elseClause155 = elseClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, elseClause155.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 45, ifStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ifStatement

    public class elseClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elseClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:423:1: elseClause : ELSE ( commentExpression )? statement ;
    public elseClause_return elseClause() // throws RecognitionException [1]
    {   
        elseClause_return retval = new elseClause_return();
        retval.start = input.LT(1);
        int elseClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ELSE156 = null;
        commentExpression_return commentExpression157 = null;

        statement_return statement158 = null;
        
        
        CommonTree ELSE156_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 46) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:4: ( ELSE ( commentExpression )? statement )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:4: ELSE ( commentExpression )? statement
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	ELSE156 = (IToken)input.LT(1);
            	Match(input,ELSE,FOLLOW_ELSE_in_elseClause1819); if (failed) return retval;
            	if ( backtracking==0 ) {
            	ELSE156_tree = (CommonTree)adaptor.Create(ELSE156);
            	root_0 = (CommonTree)adaptor.BecomeRoot(ELSE156_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:10: ( commentExpression )?
            	int alt41 = 2;
            	int LA41_0 = input.LA(1);
            	
            	if ( (LA41_0 == SL_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA41_50 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA41_51 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA41_53 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA41_54 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA41_55 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA41_56 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA41_57 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA41_58 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA41_59 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA41_60 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA41_61 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA41_62 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA41_63 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA41_64 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA41_65 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA41_66 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA41_67 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA41_68 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA41_69 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA41_70 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA41_71 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA41_72 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA41_73 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA41_74 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA41_75 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA41_76 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA41_77 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA41_78 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA41_79 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA41_80 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA41_81 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA41_82 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA41_83 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA41_84 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA41_85 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA41_86 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA41_87 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA41_88 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA41_89 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA41_90 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA41_91 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA41_92 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA41_93 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA41_94 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA41_95 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA41_96 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 178:
            	        	{
            	            int LA41_97 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA41_98 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA41_99 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA41_0 == ML_COMMENT) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case SL_COMMENT:
            	        	{
            	            int LA41_103 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA41_104 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA41_106 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case VAR:
            	        case CONST:
            	        	{
            	            int LA41_107 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA41_108 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA41_109 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA41_110 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA41_111 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA41_112 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA41_113 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA41_114 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA41_115 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA41_116 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA41_117 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA41_118 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA41_119 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA41_120 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA41_121 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA41_122 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA41_123 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA41_124 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA41_125 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA41_126 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA41_127 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA41_128 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA41_129 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA41_130 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA41_131 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA41_132 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA41_133 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA41_134 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA41_135 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA41_136 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA41_137 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA41_138 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA41_139 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case IF:
            	        	{
            	            int LA41_140 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case FOR:
            	        	{
            	            int LA41_141 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA41_142 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DO:
            	        	{
            	            int LA41_143 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case WITH:
            	        	{
            	            int LA41_144 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SWITCH:
            	        	{
            	            int LA41_145 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case BREAK:
            	        	{
            	            int LA41_146 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case CONTINUE:
            	        	{
            	            int LA41_147 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case RETURN:
            	        	{
            	            int LA41_148 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 177:
            	        	{
            	            int LA41_149 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case 178:
            	        	{
            	            int LA41_150 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case DEFAULT:
            	        	{
            	            int LA41_151 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	        case SEMI:
            	        	{
            	            int LA41_152 = input.LA(3);
            	            
            	            if ( (synpred68()) )
            	            {
            	                alt41 = 1;
            	            }
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt41) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            	        {
            	        	PushFollow(FOLLOW_commentExpression_in_elseClause1822);
            	        	commentExpression157 = commentExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression157.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_statement_in_elseClause1825);
            	statement158 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement158.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 46, elseClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elseClause

    public class throwStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start throwStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:427:1: throwStatement : 'throw' expression semi ;
    public throwStatement_return throwStatement() // throws RecognitionException [1]
    {   
        throwStatement_return retval = new throwStatement_return();
        retval.start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal159 = null;
        expression_return expression160 = null;

        semi_return semi161 = null;
        
        
        CommonTree string_literal159_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 47) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:428:4: ( 'throw' expression semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:428:4: 'throw' expression semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal159 = (IToken)input.LT(1);
            	Match(input,177,FOLLOW_177_in_throwStatement1836); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal159_tree = (CommonTree)adaptor.Create(string_literal159);
            	root_0 = (CommonTree)adaptor.BecomeRoot(string_literal159_tree, root_0);
            	}
            	PushFollow(FOLLOW_expression_in_throwStatement1839);
            	expression160 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression160.Tree);
            	PushFollow(FOLLOW_semi_in_throwStatement1841);
            	semi161 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi161.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 47, throwStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end throwStatement

    public class tryStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start tryStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:431:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? ;
    public tryStatement_return tryStatement() // throws RecognitionException [1]
    {   
        tryStatement_return retval = new tryStatement_return();
        retval.start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal162 = null;
        block_return block163 = null;

        catchBlock_return catchBlock164 = null;

        finallyBlock_return finallyBlock165 = null;
        
        
        CommonTree string_literal162_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 48) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:432:4: ( 'try' block ( catchBlock )* ( finallyBlock )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:432:4: 'try' block ( catchBlock )* ( finallyBlock )?
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal162 = (IToken)input.LT(1);
            	Match(input,178,FOLLOW_178_in_tryStatement1852); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal162_tree = (CommonTree)adaptor.Create(string_literal162);
            	adaptor.AddChild(root_0, string_literal162_tree);
            	}
            	PushFollow(FOLLOW_block_in_tryStatement1856);
            	block163 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block163.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:434:3: ( catchBlock )*
            	do 
            	{
            	    int alt42 = 2;
            	    int LA42_0 = input.LA(1);
            	    
            	    if ( (LA42_0 == 179) )
            	    {
            	        alt42 = 1;
            	    }
            	    
            	
            	    switch (alt42) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: catchBlock
            			    {
            			    	PushFollow(FOLLOW_catchBlock_in_tryStatement1860);
            			    	catchBlock164 = catchBlock();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, catchBlock164.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop42;
            	    }
            	} while (true);
            	
            	loop42:
            		;	// Stops C# compiler whinging that label 'loop42' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:435:3: ( finallyBlock )?
            	int alt43 = 2;
            	int LA43_0 = input.LA(1);
            	
            	if ( (LA43_0 == 180) )
            	{
            	    alt43 = 1;
            	}
            	switch (alt43) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: finallyBlock
            	        {
            	        	PushFollow(FOLLOW_finallyBlock_in_tryStatement1865);
            	        	finallyBlock165 = finallyBlock();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, finallyBlock165.Tree);
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 48, tryStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end tryStatement

    public class catchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start catchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:438:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
    public catchBlock_return catchBlock() // throws RecognitionException [1]
    {   
        catchBlock_return retval = new catchBlock_return();
        retval.start = input.LT(1);
        int catchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal166 = null;
        IToken LPAREN167 = null;
        IToken RPAREN170 = null;
        ident_return ident168 = null;

        typeExpression_return typeExpression169 = null;

        block_return block171 = null;
        
        
        CommonTree string_literal166_tree=null;
        CommonTree LPAREN167_tree=null;
        CommonTree RPAREN170_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 49) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:4: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal166 = (IToken)input.LT(1);
            	Match(input,179,FOLLOW_179_in_catchBlock1877); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal166_tree = (CommonTree)adaptor.Create(string_literal166);
            	adaptor.AddChild(root_0, string_literal166_tree);
            	}
            	LPAREN167 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_catchBlock1879); if (failed) return retval;
            	PushFollow(FOLLOW_ident_in_catchBlock1882);
            	ident168 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident168.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:439:26: ( typeExpression )?
            	int alt44 = 2;
            	int LA44_0 = input.LA(1);
            	
            	if ( (LA44_0 == COLON) )
            	{
            	    alt44 = 1;
            	}
            	switch (alt44) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_catchBlock1884);
            	        	typeExpression169 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, typeExpression169.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RPAREN170 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_catchBlock1887); if (failed) return retval;
            	PushFollow(FOLLOW_block_in_catchBlock1892);
            	block171 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block171.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 49, catchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end catchBlock

    public class finallyBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start finallyBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:443:1: finallyBlock : 'finally' block ;
    public finallyBlock_return finallyBlock() // throws RecognitionException [1]
    {   
        finallyBlock_return retval = new finallyBlock_return();
        retval.start = input.LT(1);
        int finallyBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken string_literal172 = null;
        block_return block173 = null;
        
        
        CommonTree string_literal172_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 50) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:444:4: ( 'finally' block )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:444:4: 'finally' block
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	string_literal172 = (IToken)input.LT(1);
            	Match(input,180,FOLLOW_180_in_finallyBlock1903); if (failed) return retval;
            	if ( backtracking==0 ) {
            	string_literal172_tree = (CommonTree)adaptor.Create(string_literal172);
            	adaptor.AddChild(root_0, string_literal172_tree);
            	}
            	PushFollow(FOLLOW_block_in_finallyBlock1905);
            	block173 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, block173.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 50, finallyBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end finallyBlock

    public class returnStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start returnStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:447:1: returnStatement : RETURN ( expression )? semi ;
    public returnStatement_return returnStatement() // throws RecognitionException [1]
    {   
        returnStatement_return retval = new returnStatement_return();
        retval.start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken RETURN174 = null;
        expression_return expression175 = null;

        semi_return semi176 = null;
        
        
        CommonTree RETURN174_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 51) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:4: ( RETURN ( expression )? semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:4: RETURN ( expression )? semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	RETURN174 = (IToken)input.LT(1);
            	Match(input,RETURN,FOLLOW_RETURN_in_returnStatement1916); if (failed) return retval;
            	if ( backtracking==0 ) {
            	RETURN174_tree = (CommonTree)adaptor.Create(RETURN174);
            	root_0 = (CommonTree)adaptor.BecomeRoot(RETURN174_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:12: ( expression )?
            	int alt45 = 2;
            	switch ( input.LA(1) ) 
            	{
            	    case INC:
            	    	{
            	        int LA45_1 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case DEC:
            	    	{
            	        int LA45_2 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case MINUS:
            	    	{
            	        int LA45_3 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case PLUS:
            	    	{
            	        int LA45_4 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case DELETE:
            	    	{
            	        int LA45_5 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case 181:
            	    	{
            	        int LA45_6 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case TYPEOF:
            	    	{
            	        int LA45_7 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case LNOT:
            	    	{
            	        int LA45_8 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case BNOT:
            	    	{
            	        int LA45_9 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case UNDEFINED:
            	    	{
            	        int LA45_10 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case LT:
            	    	{
            	        int LA45_11 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case DIV:
            	    	{
            	        int LA45_12 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case HEX_LITERAL:
            	    case DECIMAL_LITERAL:
            	    case OCTAL_LITERAL:
            	    case FLOAT_LITERAL:
            	    	{
            	        int LA45_13 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case STRING_LITERAL:
            	    	{
            	        int LA45_14 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case TRUE:
            	    	{
            	        int LA45_15 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case FALSE:
            	    	{
            	        int LA45_16 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case NULL:
            	    	{
            	        int LA45_17 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case LBRACK:
            	    	{
            	        int LA45_18 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case LCURLY:
            	    	{
            	        int LA45_19 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case FUNCTION:
            	    	{
            	        int LA45_20 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case NEW:
            	    	{
            	        int LA45_21 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case LPAREN:
            	    	{
            	        int LA45_22 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case E4X_ATTRI:
            	    	{
            	        int LA45_23 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case IDENT:
            	    	{
            	        int LA45_24 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case PUBLIC:
            	    case PRIVATE:
            	    case PROTECTED:
            	    case INTERNAL:
            	    	{
            	        int LA45_25 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case USE:
            	    	{
            	        int LA45_26 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case XML:
            	    	{
            	        int LA45_27 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case DYNAMIC:
            	    	{
            	        int LA45_28 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case NAMESPACE:
            	    	{
            	        int LA45_29 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case IS:
            	    	{
            	        int LA45_30 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case AS:
            	    	{
            	        int LA45_31 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case GET:
            	    	{
            	        int LA45_32 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	    case SET:
            	    	{
            	        int LA45_33 = input.LA(2);
            	        
            	        if ( (synpred72()) )
            	        {
            	            alt45 = 1;
            	        }
            	        }
            	        break;
            	}
            	
            	switch (alt45) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expression
            	        {
            	        	PushFollow(FOLLOW_expression_in_returnStatement1919);
            	        	expression175 = expression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, expression175.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_semi_in_returnStatement1922);
            	semi176 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi176.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 51, returnStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end returnStatement

    public class continueStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start continueStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:451:1: continueStatement : CONTINUE semi ;
    public continueStatement_return continueStatement() // throws RecognitionException [1]
    {   
        continueStatement_return retval = new continueStatement_return();
        retval.start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CONTINUE177 = null;
        semi_return semi178 = null;
        
        
        CommonTree CONTINUE177_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 52) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:452:4: ( CONTINUE semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:452:4: CONTINUE semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CONTINUE177 = (IToken)input.LT(1);
            	Match(input,CONTINUE,FOLLOW_CONTINUE_in_continueStatement1935); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CONTINUE177_tree = (CommonTree)adaptor.Create(CONTINUE177);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CONTINUE177_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_continueStatement1938);
            	semi178 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi178.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 52, continueStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end continueStatement

    public class breakStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start breakStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:455:1: breakStatement : BREAK semi ;
    public breakStatement_return breakStatement() // throws RecognitionException [1]
    {   
        breakStatement_return retval = new breakStatement_return();
        retval.start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BREAK179 = null;
        semi_return semi180 = null;
        
        
        CommonTree BREAK179_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 53) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: ( BREAK semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:456:4: BREAK semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	BREAK179 = (IToken)input.LT(1);
            	Match(input,BREAK,FOLLOW_BREAK_in_breakStatement1949); if (failed) return retval;
            	if ( backtracking==0 ) {
            	BREAK179_tree = (CommonTree)adaptor.Create(BREAK179);
            	root_0 = (CommonTree)adaptor.BecomeRoot(BREAK179_tree, root_0);
            	}
            	PushFollow(FOLLOW_semi_in_breakStatement1952);
            	semi180 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi180.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 53, breakStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end breakStatement

    public class switchStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:459:1: switchStatement : SWITCH ( condition ( commentExpression )* ) switchBlock ;
    public switchStatement_return switchStatement() // throws RecognitionException [1]
    {   
        switchStatement_return retval = new switchStatement_return();
        retval.start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SWITCH181 = null;
        condition_return condition182 = null;

        commentExpression_return commentExpression183 = null;

        switchBlock_return switchBlock184 = null;
        
        
        CommonTree SWITCH181_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 54) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:4: ( SWITCH ( condition ( commentExpression )* ) switchBlock )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:4: SWITCH ( condition ( commentExpression )* ) switchBlock
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	SWITCH181 = (IToken)input.LT(1);
            	Match(input,SWITCH,FOLLOW_SWITCH_in_switchStatement1963); if (failed) return retval;
            	if ( backtracking==0 ) {
            	SWITCH181_tree = (CommonTree)adaptor.Create(SWITCH181);
            	root_0 = (CommonTree)adaptor.BecomeRoot(SWITCH181_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:12: ( condition ( commentExpression )* )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:13: condition ( commentExpression )*
            	{
            		PushFollow(FOLLOW_condition_in_switchStatement1967);
            		condition182 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition182.Tree);
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:460:23: ( commentExpression )*
            		do 
            		{
            		    int alt46 = 2;
            		    int LA46_0 = input.LA(1);
            		    
            		    if ( ((LA46_0 >= SL_COMMENT && LA46_0 <= ML_COMMENT)) )
            		    {
            		        alt46 = 1;
            		    }
            		    
            		
            		    switch (alt46) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_switchStatement1969);
            				    	commentExpression183 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression183.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop46;
            		    }
            		} while (true);
            		
            		loop46:
            			;	// Stops C# compiler whinging that label 'loop46' has no statements

            	
            	}

            	PushFollow(FOLLOW_switchBlock_in_switchStatement1975);
            	switchBlock184 = switchBlock();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, switchBlock184.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 54, switchStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatement

    public class switchBlock_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchBlock
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:464:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
    public switchBlock_return switchBlock() // throws RecognitionException [1]
    {   
        switchBlock_return retval = new switchBlock_return();
        retval.start = input.LT(1);
        int switchBlock_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY185 = null;
        IToken RCURLY188 = null;
        caseStatement_return caseStatement186 = null;

        defaultStatement_return defaultStatement187 = null;
        
        
        CommonTree LCURLY185_tree=null;
        CommonTree RCURLY188_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_caseStatement = new RewriteRuleSubtreeStream(adaptor,"rule caseStatement");
        RewriteRuleSubtreeStream stream_defaultStatement = new RewriteRuleSubtreeStream(adaptor,"rule defaultStatement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 55) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:465:4: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:465:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
            {
            	LCURLY185 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_switchBlock1986); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY185);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:466:3: ( caseStatement )*
            	do 
            	{
            	    int alt47 = 2;
            	    int LA47_0 = input.LA(1);
            	    
            	    if ( (LA47_0 == CASE) )
            	    {
            	        alt47 = 1;
            	    }
            	    
            	
            	    switch (alt47) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:466:4: caseStatement
            			    {
            			    	PushFollow(FOLLOW_caseStatement_in_switchBlock1991);
            			    	caseStatement186 = caseStatement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_caseStatement.Add(caseStatement186.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop47;
            	    }
            	} while (true);
            	
            	loop47:
            		;	// Stops C# compiler whinging that label 'loop47' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:467:3: ( defaultStatement )?
            	int alt48 = 2;
            	int LA48_0 = input.LA(1);
            	
            	if ( (LA48_0 == DEFAULT) )
            	{
            	    alt48 = 1;
            	}
            	switch (alt48) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:467:4: defaultStatement
            	        {
            	        	PushFollow(FOLLOW_defaultStatement_in_switchBlock1998);
            	        	defaultStatement187 = defaultStatement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_defaultStatement.Add(defaultStatement187.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY188 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_switchBlock2004); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY188);

            	
            	// AST REWRITE
            	// elements:          caseStatement, defaultStatement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 469:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(BLOCK, "BLOCK"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:14: ( caseStatement )*
            	    while ( stream_caseStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_caseStatement.Next());
            	    
            	    }
            	    stream_caseStatement.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:469:29: ( defaultStatement )?
            	    if ( stream_defaultStatement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_defaultStatement.Next());
            	    
            	    }
            	    stream_defaultStatement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 55, switchBlock_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchBlock

    public class caseStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start caseStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:472:1: caseStatement : CASE expression COLON l= switchStatementList ;
    public caseStatement_return caseStatement() // throws RecognitionException [1]
    {   
        caseStatement_return retval = new caseStatement_return();
        retval.start = input.LT(1);
        int caseStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken CASE189 = null;
        IToken COLON191 = null;
        switchStatementList_return l = null;

        expression_return expression190 = null;
        
        
        CommonTree CASE189_tree=null;
        CommonTree COLON191_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 56) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:473:4: ( CASE expression COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:473:4: CASE expression COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	CASE189 = (IToken)input.LT(1);
            	Match(input,CASE,FOLLOW_CASE_in_caseStatement2029); if (failed) return retval;
            	if ( backtracking==0 ) {
            	CASE189_tree = (CommonTree)adaptor.Create(CASE189);
            	root_0 = (CommonTree)adaptor.BecomeRoot(CASE189_tree, root_0);
            	}
            	PushFollow(FOLLOW_expression_in_caseStatement2032);
            	expression190 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression190.Tree);
            	COLON191 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_caseStatement2034); if (failed) return retval;
            	PushFollow(FOLLOW_switchStatementList_in_caseStatement2039);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 56, caseStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end caseStatement

    public class defaultStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start defaultStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:476:1: defaultStatement : DEFAULT COLON l= switchStatementList ;
    public defaultStatement_return defaultStatement() // throws RecognitionException [1]
    {   
        defaultStatement_return retval = new defaultStatement_return();
        retval.start = input.LT(1);
        int defaultStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DEFAULT192 = null;
        IToken COLON193 = null;
        switchStatementList_return l = null;
        
        
        CommonTree DEFAULT192_tree=null;
        CommonTree COLON193_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 57) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:477:4: ( DEFAULT COLON l= switchStatementList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:477:4: DEFAULT COLON l= switchStatementList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DEFAULT192 = (IToken)input.LT(1);
            	Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultStatement2051); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DEFAULT192_tree = (CommonTree)adaptor.Create(DEFAULT192);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DEFAULT192_tree, root_0);
            	}
            	COLON193 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_defaultStatement2054); if (failed) return retval;
            	PushFollow(FOLLOW_switchStatementList_in_defaultStatement2059);
            	l = switchStatementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, l.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 57, defaultStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end defaultStatement

    public class switchStatementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start switchStatementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:480:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
    public switchStatementList_return switchStatementList() // throws RecognitionException [1]
    {   
        switchStatementList_return retval = new switchStatementList_return();
        retval.start = input.LT(1);
        int switchStatementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        statement_return statement194 = null;
        
        
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 58) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:4: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:4: ( statement )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:4: ( statement )*
            	do 
            	{
            	    int alt49 = 2;
            	    int LA49_0 = input.LA(1);
            	    
            	    if ( (LA49_0 == DEFAULT) )
            	    {
            	        int LA49_1 = input.LA(2);
            	        
            	        if ( (LA49_1 == XML) )
            	        {
            	            alt49 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA49_0 == LCURLY || LA49_0 == SEMI || (LA49_0 >= STRING_LITERAL && LA49_0 <= CONST) || LA49_0 == LPAREN || LA49_0 == IF || (LA49_0 >= RETURN && LA49_0 <= SWITCH) || LA49_0 == FOR || (LA49_0 >= WHILE && LA49_0 <= XML) || (LA49_0 >= IDENT && LA49_0 <= LBRACK) || LA49_0 == DYNAMIC || LA49_0 == LT || (LA49_0 >= IS && LA49_0 <= AS) || (LA49_0 >= PLUS && LA49_0 <= DIV) || (LA49_0 >= INC && LA49_0 <= BNOT) || (LA49_0 >= E4X_ATTRI && LA49_0 <= ML_COMMENT) || (LA49_0 >= 177 && LA49_0 <= 178) || LA49_0 == 181) )
            	    {
            	        alt49 = 1;
            	    }
            	    
            	
            	    switch (alt49) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: statement
            			    {
            			    	PushFollow(FOLLOW_statement_in_switchStatementList2070);
            			    	statement194 = statement();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_statement.Add(statement194.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop49;
            	    }
            	} while (true);
            	
            	loop49:
            		;	// Stops C# compiler whinging that label 'loop49' has no statements

            	
            	// AST REWRITE
            	// elements:          statement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 481:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:481:42: ( statement )*
            	    while ( stream_statement.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_statement.Next());
            	    
            	    }
            	    stream_statement.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 58, switchStatementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end switchStatementList

    public class forEachStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forEachStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:484:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) ;
    public forEachStatement_return forEachStatement() // throws RecognitionException [1]
    {   
        forEachStatement_return retval = new forEachStatement_return();
        retval.start = input.LT(1);
        int forEachStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken f = null;
        IToken EACH195 = null;
        IToken LPAREN196 = null;
        IToken RPAREN198 = null;
        forInClause_return forInClause197 = null;

        statement_return statement199 = null;
        
        
        CommonTree f_tree=null;
        CommonTree EACH195_tree=null;
        CommonTree LPAREN196_tree=null;
        CommonTree RPAREN198_tree=null;
        RewriteRuleTokenStream stream_EACH = new RewriteRuleTokenStream(adaptor,"token EACH");
        RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 59) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:4: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH[$f] forInClause statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:485:4: f= FOR EACH LPAREN forInClause RPAREN statement
            {
            	f = (IToken)input.LT(1);
            	Match(input,FOR,FOLLOW_FOR_in_forEachStatement2093); if (failed) return retval;
            	if ( backtracking==0 ) stream_FOR.Add(f);

            	EACH195 = (IToken)input.LT(1);
            	Match(input,EACH,FOLLOW_EACH_in_forEachStatement2095); if (failed) return retval;
            	if ( backtracking==0 ) stream_EACH.Add(EACH195);

            	LPAREN196 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_forEachStatement2099); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN196);

            	PushFollow(FOLLOW_forInClause_in_forEachStatement2103);
            	forInClause197 = forInClause();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_forInClause.Add(forInClause197.Tree);
            	RPAREN198 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_forEachStatement2107); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN198);

            	PushFollow(FOLLOW_statement_in_forEachStatement2111);
            	statement199 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_statement.Add(statement199.Tree);
            	
            	// AST REWRITE
            	// elements:          forInClause, statement
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 490:3: -> ^( FOR_EACH[$f] forInClause statement )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:490:6: ^( FOR_EACH[$f] forInClause statement )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_EACH, f), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_forInClause.Next());
            	    adaptor.AddChild(root_1, stream_statement.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 59, forEachStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end forEachStatement

    public class forStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:493:1: forStatement : f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) ;
    public forStatement_return forStatement() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forStatement_return retval = new forStatement_return();
        retval.start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken f = null;
        IToken LPAREN200 = null;
        IToken RPAREN202 = null;
        IToken RPAREN205 = null;
        forInClause_return forInClause201 = null;

        statement_return statement203 = null;

        traditionalForClause_return traditionalForClause204 = null;

        statement_return statement206 = null;
        
        
        CommonTree f_tree=null;
        CommonTree LPAREN200_tree=null;
        CommonTree RPAREN202_tree=null;
        CommonTree RPAREN205_tree=null;
        RewriteRuleTokenStream stream_FOR = new RewriteRuleTokenStream(adaptor,"token FOR");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_statement = new RewriteRuleSubtreeStream(adaptor,"rule statement");
        RewriteRuleSubtreeStream stream_traditionalForClause = new RewriteRuleSubtreeStream(adaptor,"rule traditionalForClause");
        RewriteRuleSubtreeStream stream_forInClause = new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 60) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:498:4: (f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:498:4: f= FOR LPAREN ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            {
            	f = (IToken)input.LT(1);
            	Match(input,FOR,FOLLOW_FOR_in_forStatement2147); if (failed) return retval;
            	if ( backtracking==0 ) stream_FOR.Add(f);

            	LPAREN200 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_forStatement2151); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN200);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )
            	int alt50 = 2;
            	switch ( input.LA(1) ) 
            	{
            	case VAR:
            	case CONST:
            		{
            	    switch ( input.LA(2) ) 
            	    {
            	    case IDENT:
            	    	{
            	        int LA50_36 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s36 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 36, input);
            	        
            	            throw nvae_d50s36;
            	        }
            	        }
            	        break;
            	    case USE:
            	    	{
            	        int LA50_37 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s37 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 37, input);
            	        
            	            throw nvae_d50s37;
            	        }
            	        }
            	        break;
            	    case XML:
            	    	{
            	        int LA50_38 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s38 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 38, input);
            	        
            	            throw nvae_d50s38;
            	        }
            	        }
            	        break;
            	    case DYNAMIC:
            	    	{
            	        int LA50_39 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s39 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 39, input);
            	        
            	            throw nvae_d50s39;
            	        }
            	        }
            	        break;
            	    case NAMESPACE:
            	    	{
            	        int LA50_40 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s40 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 40, input);
            	        
            	            throw nvae_d50s40;
            	        }
            	        }
            	        break;
            	    case IS:
            	    	{
            	        int LA50_41 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s41 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 41, input);
            	        
            	            throw nvae_d50s41;
            	        }
            	        }
            	        break;
            	    case AS:
            	    	{
            	        int LA50_42 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s42 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 42, input);
            	        
            	            throw nvae_d50s42;
            	        }
            	        }
            	        break;
            	    case GET:
            	    	{
            	        int LA50_43 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s43 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 43, input);
            	        
            	            throw nvae_d50s43;
            	        }
            	        }
            	        break;
            	    case SET:
            	    	{
            	        int LA50_44 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s44 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 44, input);
            	        
            	            throw nvae_d50s44;
            	        }
            	        }
            	        break;
            	    	default:
            	    	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    	    NoViableAltException nvae_d50s1 =
            	    	        new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 1, input);
            	    
            	    	    throw nvae_d50s1;
            	    }
            	
            	    }
            	    break;
            	case IDENT:
            		{
            	    int LA50_2 = input.LA(2);
            	    
            	    if ( (LA50_2 == SEMI || LA50_2 == COMMA || (LA50_2 >= ASSIGN && LA50_2 <= LPAREN) || (LA50_2 >= STAR && LA50_2 <= DBL_COLON) || LA50_2 == LBRACK || (LA50_2 >= STAR_ASSIGN && LA50_2 <= DEC) || LA50_2 == E4X_DESC || (LA50_2 >= 187 && LA50_2 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else if ( (LA50_2 == IN) )
            	    {
            	        int LA50_54 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s54 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 54, input);
            	        
            	            throw nvae_d50s54;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s2 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 2, input);
            	    
            	        throw nvae_d50s2;
            	    }
            	    }
            	    break;
            	case USE:
            		{
            	    int LA50_3 = input.LA(2);
            	    
            	    if ( (LA50_3 == IN) )
            	    {
            	        int LA50_73 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s73 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 73, input);
            	        
            	            throw nvae_d50s73;
            	        }
            	    }
            	    else if ( (LA50_3 == SEMI || LA50_3 == COMMA || (LA50_3 >= ASSIGN && LA50_3 <= LPAREN) || (LA50_3 >= STAR && LA50_3 <= DOT) || LA50_3 == LBRACK || (LA50_3 >= STAR_ASSIGN && LA50_3 <= DEC) || LA50_3 == E4X_DESC || (LA50_3 >= 187 && LA50_3 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s3 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 3, input);
            	    
            	        throw nvae_d50s3;
            	    }
            	    }
            	    break;
            	case XML:
            		{
            	    int LA50_4 = input.LA(2);
            	    
            	    if ( (LA50_4 == IN) )
            	    {
            	        int LA50_100 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s100 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 100, input);
            	        
            	            throw nvae_d50s100;
            	        }
            	    }
            	    else if ( (LA50_4 == SEMI || LA50_4 == COMMA || (LA50_4 >= ASSIGN && LA50_4 <= LPAREN) || (LA50_4 >= STAR && LA50_4 <= DOT) || LA50_4 == LBRACK || (LA50_4 >= STAR_ASSIGN && LA50_4 <= DEC) || LA50_4 == E4X_DESC || (LA50_4 >= 187 && LA50_4 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s4 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 4, input);
            	    
            	        throw nvae_d50s4;
            	    }
            	    }
            	    break;
            	case DYNAMIC:
            		{
            	    int LA50_5 = input.LA(2);
            	    
            	    if ( (LA50_5 == SEMI || LA50_5 == COMMA || (LA50_5 >= ASSIGN && LA50_5 <= LPAREN) || (LA50_5 >= STAR && LA50_5 <= DOT) || LA50_5 == LBRACK || (LA50_5 >= STAR_ASSIGN && LA50_5 <= DEC) || LA50_5 == E4X_DESC || (LA50_5 >= 187 && LA50_5 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else if ( (LA50_5 == IN) )
            	    {
            	        int LA50_136 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s136 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 136, input);
            	        
            	            throw nvae_d50s136;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s5 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 5, input);
            	    
            	        throw nvae_d50s5;
            	    }
            	    }
            	    break;
            	case NAMESPACE:
            		{
            	    int LA50_6 = input.LA(2);
            	    
            	    if ( (LA50_6 == IN) )
            	    {
            	        int LA50_154 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s154 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 154, input);
            	        
            	            throw nvae_d50s154;
            	        }
            	    }
            	    else if ( (LA50_6 == SEMI || LA50_6 == COMMA || (LA50_6 >= ASSIGN && LA50_6 <= LPAREN) || (LA50_6 >= STAR && LA50_6 <= DOT) || LA50_6 == LBRACK || (LA50_6 >= STAR_ASSIGN && LA50_6 <= DEC) || LA50_6 == E4X_DESC || (LA50_6 >= 187 && LA50_6 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s6 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 6, input);
            	    
            	        throw nvae_d50s6;
            	    }
            	    }
            	    break;
            	case IS:
            		{
            	    int LA50_7 = input.LA(2);
            	    
            	    if ( (LA50_7 == IN) )
            	    {
            	        int LA50_181 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s181 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 181, input);
            	        
            	            throw nvae_d50s181;
            	        }
            	    }
            	    else if ( (LA50_7 == SEMI || LA50_7 == COMMA || (LA50_7 >= ASSIGN && LA50_7 <= LPAREN) || (LA50_7 >= STAR && LA50_7 <= DOT) || LA50_7 == LBRACK || (LA50_7 >= STAR_ASSIGN && LA50_7 <= DEC) || LA50_7 == E4X_DESC || (LA50_7 >= 187 && LA50_7 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s7 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 7, input);
            	    
            	        throw nvae_d50s7;
            	    }
            	    }
            	    break;
            	case AS:
            		{
            	    int LA50_8 = input.LA(2);
            	    
            	    if ( (LA50_8 == SEMI || LA50_8 == COMMA || (LA50_8 >= ASSIGN && LA50_8 <= LPAREN) || (LA50_8 >= STAR && LA50_8 <= DOT) || LA50_8 == LBRACK || (LA50_8 >= STAR_ASSIGN && LA50_8 <= DEC) || LA50_8 == E4X_DESC || (LA50_8 >= 187 && LA50_8 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else if ( (LA50_8 == IN) )
            	    {
            	        int LA50_217 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s217 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 217, input);
            	        
            	            throw nvae_d50s217;
            	        }
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s8 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 8, input);
            	    
            	        throw nvae_d50s8;
            	    }
            	    }
            	    break;
            	case GET:
            		{
            	    int LA50_9 = input.LA(2);
            	    
            	    if ( (LA50_9 == IN) )
            	    {
            	        int LA50_235 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s235 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 235, input);
            	        
            	            throw nvae_d50s235;
            	        }
            	    }
            	    else if ( (LA50_9 == SEMI || LA50_9 == COMMA || (LA50_9 >= ASSIGN && LA50_9 <= LPAREN) || (LA50_9 >= STAR && LA50_9 <= DOT) || LA50_9 == LBRACK || (LA50_9 >= STAR_ASSIGN && LA50_9 <= DEC) || LA50_9 == E4X_DESC || (LA50_9 >= 187 && LA50_9 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s9 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 9, input);
            	    
            	        throw nvae_d50s9;
            	    }
            	    }
            	    break;
            	case SET:
            		{
            	    int LA50_10 = input.LA(2);
            	    
            	    if ( (LA50_10 == IN) )
            	    {
            	        int LA50_262 = input.LA(3);
            	        
            	        if ( (synpred77()) )
            	        {
            	            alt50 = 1;
            	        }
            	        else if ( (true) )
            	        {
            	            alt50 = 2;
            	        }
            	        else 
            	        {
            	            if ( backtracking > 0 ) {failed = true; return retval;}
            	            NoViableAltException nvae_d50s262 =
            	                new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 262, input);
            	        
            	            throw nvae_d50s262;
            	        }
            	    }
            	    else if ( (LA50_10 == SEMI || LA50_10 == COMMA || (LA50_10 >= ASSIGN && LA50_10 <= LPAREN) || (LA50_10 >= STAR && LA50_10 <= DOT) || LA50_10 == LBRACK || (LA50_10 >= STAR_ASSIGN && LA50_10 <= DEC) || LA50_10 == E4X_DESC || (LA50_10 >= 187 && LA50_10 <= 188)) )
            	    {
            	        alt50 = 2;
            	    }
            	    else 
            	    {
            	        if ( backtracking > 0 ) {failed = true; return retval;}
            	        NoViableAltException nvae_d50s10 =
            	            new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 10, input);
            	    
            	        throw nvae_d50s10;
            	    }
            	    }
            	    break;
            	case LCURLY:
            	case SEMI:
            	case STRING_LITERAL:
            	case FUNCTION:
            	case LPAREN:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case LBRACK:
            	case LT:
            	case PLUS:
            	case MINUS:
            	case DIV:
            	case INC:
            	case DEC:
            	case DELETE:
            	case TYPEOF:
            	case LNOT:
            	case BNOT:
            	case E4X_ATTRI:
            	case UNDEFINED:
            	case TRUE:
            	case FALSE:
            	case NULL:
            	case HEX_LITERAL:
            	case DECIMAL_LITERAL:
            	case OCTAL_LITERAL:
            	case FLOAT_LITERAL:
            	case NEW:
            	case 181:
            		{
            	    alt50 = 2;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d50s0 =
            		        new NoViableAltException("500:3: ( ( forInClauseDecl IN )=> forInClause RPAREN statement -> ^( FOR_IN[$f] forInClause statement ) | traditionalForClause RPAREN statement -> ^( $f traditionalForClause statement ) )", 50, 0, input);
            	
            		    throw nvae_d50s0;
            	}
            	
            	switch (alt50) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:5: ( forInClauseDecl IN )=> forInClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_forInClause_in_forStatement2163);
            	        	forInClause201 = forInClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_forInClause.Add(forInClause201.Tree);
            	        	RPAREN202 = (IToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2165); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN202);

            	        	PushFollow(FOLLOW_statement_in_forStatement2167);
            	        	statement203 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement203.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          statement, forInClause
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 501:4: -> ^( FOR_IN[$f] forInClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:501:7: ^( FOR_IN[$f] forInClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_IN, f), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_forInClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:503:5: traditionalForClause RPAREN statement
            	        {
            	        	PushFollow(FOLLOW_traditionalForClause_in_forStatement2188);
            	        	traditionalForClause204 = traditionalForClause();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_traditionalForClause.Add(traditionalForClause204.Tree);
            	        	RPAREN205 = (IToken)input.LT(1);
            	        	Match(input,RPAREN,FOLLOW_RPAREN_in_forStatement2190); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN205);

            	        	PushFollow(FOLLOW_statement_in_forStatement2192);
            	        	statement206 = statement();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_statement.Add(statement206.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          traditionalForClause, statement, f
            	        	// token labels:      f
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleTokenStream stream_f = new RewriteRuleTokenStream(adaptor, "token f", f);
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 504:4: -> ^( $f traditionalForClause statement )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:504:7: ^( $f traditionalForClause statement )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_f.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_traditionalForClause.Next());
            	        	    adaptor.AddChild(root_1, stream_statement.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 60, forStatement_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forStatement

    public class traditionalForClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start traditionalForClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:508:1: traditionalForClause : a= forInit SEMI b= forCond SEMI c= forIter ;
    public traditionalForClause_return traditionalForClause() // throws RecognitionException [1]
    {   
        traditionalForClause_return retval = new traditionalForClause_return();
        retval.start = input.LT(1);
        int traditionalForClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SEMI207 = null;
        IToken SEMI208 = null;
        forInit_return a = null;

        forCond_return b = null;

        forIter_return c = null;
        
        
        CommonTree SEMI207_tree=null;
        CommonTree SEMI208_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 61) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:509:4: (a= forInit SEMI b= forCond SEMI c= forIter )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:509:4: a= forInit SEMI b= forCond SEMI c= forIter
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInit_in_traditionalForClause2223);
            	a = forInit();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, a.Tree);
            	SEMI207 = (IToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2225); if (failed) return retval;
            	PushFollow(FOLLOW_forCond_in_traditionalForClause2233);
            	b = forCond();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, b.Tree);
            	SEMI208 = (IToken)input.LT(1);
            	Match(input,SEMI,FOLLOW_SEMI_in_traditionalForClause2235); if (failed) return retval;
            	PushFollow(FOLLOW_forIter_in_traditionalForClause2243);
            	c = forIter();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, c.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 61, traditionalForClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end traditionalForClause

    public class forInClause_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClause
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:514:1: forInClause : forInClauseDecl IN forInClauseTail ;
    public forInClause_return forInClause() // throws RecognitionException [1]
    {   
        forInClause_return retval = new forInClause_return();
        retval.start = input.LT(1);
        int forInClause_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IN210 = null;
        forInClauseDecl_return forInClauseDecl209 = null;

        forInClauseTail_return forInClauseTail211 = null;
        
        
        CommonTree IN210_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 62) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:515:4: ( forInClauseDecl IN forInClauseTail )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:515:4: forInClauseDecl IN forInClauseTail
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_forInClauseDecl_in_forInClause2255);
            	forInClauseDecl209 = forInClauseDecl();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseDecl209.Tree);
            	IN210 = (IToken)input.LT(1);
            	Match(input,IN,FOLLOW_IN_in_forInClause2257); if (failed) return retval;
            	PushFollow(FOLLOW_forInClauseTail_in_forInClause2260);
            	forInClauseTail211 = forInClauseTail();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, forInClauseTail211.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 62, forInClause_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end forInClause

    public class forInClauseDecl_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseDecl
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:518:1: forInClauseDecl : ( declaration | ident );
    public forInClauseDecl_return forInClauseDecl() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseDecl_return retval = new forInClauseDecl_return();
        retval.start = input.LT(1);
        int forInClauseDecl_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration212 = null;

        ident_return ident213 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 63) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:523:4: ( declaration | ident )
            int alt51 = 2;
            int LA51_0 = input.LA(1);
            
            if ( ((LA51_0 >= VAR && LA51_0 <= CONST)) )
            {
                alt51 = 1;
            }
            else if ( ((LA51_0 >= GET && LA51_0 <= USE) || LA51_0 == XML || LA51_0 == IDENT || LA51_0 == DYNAMIC || (LA51_0 >= IS && LA51_0 <= AS)) )
            {
                alt51 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d51s0 =
                    new NoViableAltException("518:1: forInClauseDecl : ( declaration | ident );", 51, 0, input);
            
                throw nvae_d51s0;
            }
            switch (alt51) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:523:4: declaration
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_declaration_in_forInClauseDecl2281);
                    	declaration212 = declaration();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, declaration212.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:523:18: ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_forInClauseDecl2285);
                    	ident213 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ident213.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 63, forInClauseDecl_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseDecl

    public class forInClauseTail_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInClauseTail
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:527:1: forInClauseTail : expressionList ;
    public forInClauseTail_return forInClauseTail() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInClauseTail_return retval = new forInClauseTail_return();
        retval.start = input.LT(1);
        int forInClauseTail_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList214 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 64) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:4: ( expressionList )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:532:4: expressionList
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_expressionList_in_forInClauseTail2307);
            	expressionList214 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList214.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 64, forInClauseTail_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInClauseTail

    public class forInit_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forInit
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:536:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
    public forInit_return forInit() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forInit_return retval = new forInit_return();
        retval.start = input.LT(1);
        int forInit_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        declaration_return declaration215 = null;

        expressionList_return expressionList216 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        RewriteRuleSubtreeStream stream_declaration = new RewriteRuleSubtreeStream(adaptor,"rule declaration");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  false;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 65) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( declaration | expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:4: ( declaration | expressionList )?
            	int alt52 = 3;
            	int LA52_0 = input.LA(1);
            	
            	if ( ((LA52_0 >= VAR && LA52_0 <= CONST)) )
            	{
            	    alt52 = 1;
            	}
            	else if ( (LA52_0 == LCURLY || (LA52_0 >= STRING_LITERAL && LA52_0 <= USE) || LA52_0 == LPAREN || LA52_0 == XML || (LA52_0 >= IDENT && LA52_0 <= LBRACK) || LA52_0 == DYNAMIC || LA52_0 == LT || (LA52_0 >= IS && LA52_0 <= AS) || (LA52_0 >= PLUS && LA52_0 <= DIV) || (LA52_0 >= INC && LA52_0 <= BNOT) || (LA52_0 >= E4X_ATTRI && LA52_0 <= NEW) || LA52_0 == 181) )
            	{
            	    alt52 = 2;
            	}
            	switch (alt52) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:5: declaration
            	        {
            	        	PushFollow(FOLLOW_declaration_in_forInit2331);
            	        	declaration215 = declaration();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_declaration.Add(declaration215.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:541:19: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forInit2335);
            	        	expressionList216 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList216.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList, declaration
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 542:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:17: ( declaration )?
            	    if ( stream_declaration.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_declaration.Next());
            	    
            	    }
            	    stream_declaration.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:542:30: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 65, forInit_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forInit

    public class forCond_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forCond
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:545:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
    public forCond_return forCond() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forCond_return retval = new forCond_return();
        retval.start = input.LT(1);
        int forCond_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList217 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 66) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:550:4: ( expressionList )?
            	int alt53 = 2;
            	int LA53_0 = input.LA(1);
            	
            	if ( (LA53_0 == LCURLY || (LA53_0 >= STRING_LITERAL && LA53_0 <= USE) || LA53_0 == LPAREN || LA53_0 == XML || (LA53_0 >= IDENT && LA53_0 <= LBRACK) || LA53_0 == DYNAMIC || LA53_0 == LT || (LA53_0 >= IS && LA53_0 <= AS) || (LA53_0 >= PLUS && LA53_0 <= DIV) || (LA53_0 >= INC && LA53_0 <= BNOT) || (LA53_0 >= E4X_ATTRI && LA53_0 <= NEW) || LA53_0 == 181) )
            	{
            	    alt53 = 1;
            	}
            	switch (alt53) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forCond2373);
            	        	expressionList217 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList217.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 551:3: -> ^( FOR_CONDITION ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:6: ^( FOR_CONDITION ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:551:22: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 66, forCond_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forCond

    public class forIter_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start forIter
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:554:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
    public forIter_return forIter() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        forIter_return retval = new forIter_return();
        retval.start = input.LT(1);
        int forIter_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        expressionList_return expressionList218 = null;
        
        
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 67) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:559:4: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:559:4: ( expressionList )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:559:4: ( expressionList )?
            	int alt54 = 2;
            	int LA54_0 = input.LA(1);
            	
            	if ( (LA54_0 == LCURLY || (LA54_0 >= STRING_LITERAL && LA54_0 <= USE) || LA54_0 == LPAREN || LA54_0 == XML || (LA54_0 >= IDENT && LA54_0 <= LBRACK) || LA54_0 == DYNAMIC || LA54_0 == LT || (LA54_0 >= IS && LA54_0 <= AS) || (LA54_0 >= PLUS && LA54_0 <= DIV) || (LA54_0 >= INC && LA54_0 <= BNOT) || (LA54_0 >= E4X_ATTRI && LA54_0 <= NEW) || LA54_0 == 181) )
            	{
            	    alt54 = 1;
            	}
            	switch (alt54) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: expressionList
            	        {
            	        	PushFollow(FOLLOW_expressionList_in_forIter2406);
            	        	expressionList218 = expressionList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_expressionList.Add(expressionList218.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          expressionList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 560:3: -> ^( FOR_ITERATOR ( expressionList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:6: ^( FOR_ITERATOR ( expressionList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:560:21: ( expressionList )?
            	    if ( stream_expressionList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_expressionList.Next());
            	    
            	    }
            	    stream_expressionList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 67, forIter_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end forIter

    public class whileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start whileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:563:1: whileStatement : WHILE condition ( ( commentExpression )* statement ) ;
    public whileStatement_return whileStatement() // throws RecognitionException [1]
    {   
        whileStatement_return retval = new whileStatement_return();
        retval.start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken WHILE219 = null;
        condition_return condition220 = null;

        commentExpression_return commentExpression221 = null;

        statement_return statement222 = null;
        
        
        CommonTree WHILE219_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 68) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:4: ( WHILE condition ( ( commentExpression )* statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:4: WHILE condition ( ( commentExpression )* statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WHILE219 = (IToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_whileStatement2429); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WHILE219_tree = (CommonTree)adaptor.Create(WHILE219);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WHILE219_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_whileStatement2432);
            	condition220 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition220.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:21: ( ( commentExpression )* statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:22: ( commentExpression )* statement
            	{
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:22: ( commentExpression )*
            		do 
            		{
            		    int alt55 = 2;
            		    int LA55_0 = input.LA(1);
            		    
            		    if ( (LA55_0 == SL_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA55_50 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA55_51 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA55_53 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA55_54 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA55_55 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA55_56 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA55_57 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA55_58 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA55_59 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 181:
            		        	{
            		            int LA55_60 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA55_61 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA55_62 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA55_63 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA55_64 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA55_65 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA55_66 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA55_67 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA55_68 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA55_69 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA55_70 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA55_71 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA55_72 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA55_73 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA55_74 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA55_75 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA55_76 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA55_77 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA55_78 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA55_79 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA55_80 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA55_81 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA55_82 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA55_83 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA55_84 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA55_85 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA55_86 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA55_87 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA55_88 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA55_89 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA55_90 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA55_91 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA55_92 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA55_93 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA55_94 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA55_95 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA55_96 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 178:
            		        	{
            		            int LA55_97 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA55_98 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA55_99 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    else if ( (LA55_0 == ML_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA55_103 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA55_104 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA55_106 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA55_107 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA55_108 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA55_109 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA55_110 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA55_111 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA55_112 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 181:
            		        	{
            		            int LA55_113 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA55_114 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA55_115 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA55_116 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA55_117 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA55_118 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA55_119 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA55_120 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA55_121 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA55_122 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA55_123 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA55_124 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA55_125 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA55_126 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA55_127 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA55_128 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA55_129 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA55_130 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA55_131 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA55_132 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA55_133 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA55_134 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA55_135 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA55_136 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA55_137 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA55_138 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA55_139 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA55_140 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA55_141 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA55_142 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA55_143 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA55_144 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA55_145 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA55_146 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA55_147 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA55_148 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA55_149 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 178:
            		        	{
            		            int LA55_150 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA55_151 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA55_152 = input.LA(3);
            		            
            		            if ( (synpred83()) )
            		            {
            		                alt55 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    
            		
            		    switch (alt55) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_whileStatement2435);
            				    	commentExpression221 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression221.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop55;
            		    }
            		} while (true);
            		
            		loop55:
            			;	// Stops C# compiler whinging that label 'loop55' has no statements

            		PushFollow(FOLLOW_statement_in_whileStatement2438);
            		statement222 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement222.Tree);
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 68, whileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end whileStatement

    public class doWhileStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start doWhileStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:567:1: doWhileStatement : DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi ;
    public doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {   
        doWhileStatement_return retval = new doWhileStatement_return();
        retval.start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DO223 = null;
        IToken WHILE226 = null;
        commentExpression_return commentExpression224 = null;

        statement_return statement225 = null;

        condition_return condition227 = null;

        commentExpression_return commentExpression228 = null;

        semi_return semi229 = null;
        
        
        CommonTree DO223_tree=null;
        CommonTree WHILE226_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 69) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:4: ( DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:4: DO ( commentExpression )* statement WHILE ( condition ( commentExpression )* ) semi
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	DO223 = (IToken)input.LT(1);
            	Match(input,DO,FOLLOW_DO_in_doWhileStatement2450); if (failed) return retval;
            	if ( backtracking==0 ) {
            	DO223_tree = (CommonTree)adaptor.Create(DO223);
            	root_0 = (CommonTree)adaptor.BecomeRoot(DO223_tree, root_0);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:8: ( commentExpression )*
            	do 
            	{
            	    int alt56 = 2;
            	    int LA56_0 = input.LA(1);
            	    
            	    if ( (LA56_0 == SL_COMMENT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case SL_COMMENT:
            	        	{
            	            int LA56_50 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA56_51 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        case SEMI:
            	        case STRING_LITERAL:
            	        case FUNCTION:
            	        case GET:
            	        case SET:
            	        case NAMESPACE:
            	        case USE:
            	        case VAR:
            	        case CONST:
            	        case LPAREN:
            	        case IF:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case DEFAULT:
            	        case FOR:
            	        case DO:
            	        case WITH:
            	        case XML:
            	        case IDENT:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case LBRACK:
            	        case DYNAMIC:
            	        case LT:
            	        case IS:
            	        case AS:
            	        case PLUS:
            	        case MINUS:
            	        case DIV:
            	        case INC:
            	        case DEC:
            	        case DELETE:
            	        case TYPEOF:
            	        case LNOT:
            	        case BNOT:
            	        case E4X_ATTRI:
            	        case UNDEFINED:
            	        case TRUE:
            	        case FALSE:
            	        case NULL:
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        case NEW:
            	        case 177:
            	        case 178:
            	        case 181:
            	        	{
            	            alt56 = 1;
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA56_88 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA56_0 == ML_COMMENT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case SL_COMMENT:
            	        	{
            	            int LA56_99 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case ML_COMMENT:
            	        	{
            	            int LA56_100 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case WHILE:
            	        	{
            	            int LA56_101 = input.LA(3);
            	            
            	            if ( (synpred84()) )
            	            {
            	                alt56 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        case SEMI:
            	        case STRING_LITERAL:
            	        case FUNCTION:
            	        case GET:
            	        case SET:
            	        case NAMESPACE:
            	        case USE:
            	        case VAR:
            	        case CONST:
            	        case LPAREN:
            	        case IF:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case DEFAULT:
            	        case FOR:
            	        case DO:
            	        case WITH:
            	        case XML:
            	        case IDENT:
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        case LBRACK:
            	        case DYNAMIC:
            	        case LT:
            	        case IS:
            	        case AS:
            	        case PLUS:
            	        case MINUS:
            	        case DIV:
            	        case INC:
            	        case DEC:
            	        case DELETE:
            	        case TYPEOF:
            	        case LNOT:
            	        case BNOT:
            	        case E4X_ATTRI:
            	        case UNDEFINED:
            	        case TRUE:
            	        case FALSE:
            	        case NULL:
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        case NEW:
            	        case 177:
            	        case 178:
            	        case 181:
            	        	{
            	            alt56 = 1;
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt56) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            			    {
            			    	PushFollow(FOLLOW_commentExpression_in_doWhileStatement2453);
            			    	commentExpression224 = commentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression224.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop56;
            	    }
            	} while (true);
            	
            	loop56:
            		;	// Stops C# compiler whinging that label 'loop56' has no statements

            	PushFollow(FOLLOW_statement_in_doWhileStatement2456);
            	statement225 = statement();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, statement225.Tree);
            	WHILE226 = (IToken)input.LT(1);
            	Match(input,WHILE,FOLLOW_WHILE_in_doWhileStatement2458); if (failed) return retval;
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:44: ( condition ( commentExpression )* )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:45: condition ( commentExpression )*
            	{
            		PushFollow(FOLLOW_condition_in_doWhileStatement2462);
            		condition227 = condition();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, condition227.Tree);
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:55: ( commentExpression )*
            		do 
            		{
            		    int alt57 = 2;
            		    int LA57_0 = input.LA(1);
            		    
            		    if ( (LA57_0 == SL_COMMENT) )
            		    {
            		        int LA57_49 = input.LA(2);
            		        
            		        if ( (synpred85()) )
            		        {
            		            alt57 = 1;
            		        }
            		        
            		    
            		    }
            		    else if ( (LA57_0 == ML_COMMENT) )
            		    {
            		        int LA57_50 = input.LA(2);
            		        
            		        if ( (synpred85()) )
            		        {
            		            alt57 = 1;
            		        }
            		        
            		    
            		    }
            		    
            		
            		    switch (alt57) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_doWhileStatement2464);
            				    	commentExpression228 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression228.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop57;
            		    }
            		} while (true);
            		
            		loop57:
            			;	// Stops C# compiler whinging that label 'loop57' has no statements

            	
            	}

            	PushFollow(FOLLOW_semi_in_doWhileStatement2468);
            	semi229 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, semi229.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 69, doWhileStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end doWhileStatement

    public class withStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start withStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:571:1: withStatement : WITH condition ( ( commentExpression )* statement ) ;
    public withStatement_return withStatement() // throws RecognitionException [1]
    {   
        withStatement_return retval = new withStatement_return();
        retval.start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken WITH230 = null;
        condition_return condition231 = null;

        commentExpression_return commentExpression232 = null;

        statement_return statement233 = null;
        
        
        CommonTree WITH230_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 70) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:4: ( WITH condition ( ( commentExpression )* statement ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:4: WITH condition ( ( commentExpression )* statement )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	WITH230 = (IToken)input.LT(1);
            	Match(input,WITH,FOLLOW_WITH_in_withStatement2479); if (failed) return retval;
            	if ( backtracking==0 ) {
            	WITH230_tree = (CommonTree)adaptor.Create(WITH230);
            	root_0 = (CommonTree)adaptor.BecomeRoot(WITH230_tree, root_0);
            	}
            	PushFollow(FOLLOW_condition_in_withStatement2482);
            	condition231 = condition();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, condition231.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:20: ( ( commentExpression )* statement )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:21: ( commentExpression )* statement
            	{
            		// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:21: ( commentExpression )*
            		do 
            		{
            		    int alt58 = 2;
            		    int LA58_0 = input.LA(1);
            		    
            		    if ( (LA58_0 == SL_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA58_50 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA58_51 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA58_53 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA58_54 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA58_55 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA58_56 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA58_57 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA58_58 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA58_59 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 181:
            		        	{
            		            int LA58_60 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA58_61 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA58_62 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA58_63 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA58_64 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA58_65 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA58_66 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA58_67 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA58_68 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA58_69 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA58_70 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA58_71 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA58_72 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA58_73 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA58_74 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA58_75 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA58_76 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA58_77 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA58_78 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA58_79 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA58_80 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA58_81 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA58_82 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA58_83 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA58_84 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA58_85 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA58_86 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA58_87 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA58_88 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA58_89 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA58_90 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA58_91 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA58_92 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA58_93 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA58_94 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA58_95 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA58_96 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 178:
            		        	{
            		            int LA58_97 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA58_98 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA58_99 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    else if ( (LA58_0 == ML_COMMENT) )
            		    {
            		        switch ( input.LA(2) ) 
            		        {
            		        case SL_COMMENT:
            		        	{
            		            int LA58_103 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case ML_COMMENT:
            		        	{
            		            int LA58_104 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LCURLY:
            		        	{
            		            int LA58_106 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case VAR:
            		        case CONST:
            		        	{
            		            int LA58_107 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case INC:
            		        	{
            		            int LA58_108 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEC:
            		        	{
            		            int LA58_109 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case MINUS:
            		        	{
            		            int LA58_110 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PLUS:
            		        	{
            		            int LA58_111 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DELETE:
            		        	{
            		            int LA58_112 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 181:
            		        	{
            		            int LA58_113 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TYPEOF:
            		        	{
            		            int LA58_114 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LNOT:
            		        	{
            		            int LA58_115 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BNOT:
            		        	{
            		            int LA58_116 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case UNDEFINED:
            		        	{
            		            int LA58_117 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LT:
            		        	{
            		            int LA58_118 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DIV:
            		        	{
            		            int LA58_119 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case HEX_LITERAL:
            		        case DECIMAL_LITERAL:
            		        case OCTAL_LITERAL:
            		        case FLOAT_LITERAL:
            		        	{
            		            int LA58_120 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case STRING_LITERAL:
            		        	{
            		            int LA58_121 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case TRUE:
            		        	{
            		            int LA58_122 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FALSE:
            		        	{
            		            int LA58_123 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NULL:
            		        	{
            		            int LA58_124 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LBRACK:
            		        	{
            		            int LA58_125 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FUNCTION:
            		        	{
            		            int LA58_126 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NEW:
            		        	{
            		            int LA58_127 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case LPAREN:
            		        	{
            		            int LA58_128 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case E4X_ATTRI:
            		        	{
            		            int LA58_129 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IDENT:
            		        	{
            		            int LA58_130 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case PUBLIC:
            		        case PRIVATE:
            		        case PROTECTED:
            		        case INTERNAL:
            		        	{
            		            int LA58_131 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case USE:
            		        	{
            		            int LA58_132 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case XML:
            		        	{
            		            int LA58_133 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DYNAMIC:
            		        	{
            		            int LA58_134 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case NAMESPACE:
            		        	{
            		            int LA58_135 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IS:
            		        	{
            		            int LA58_136 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case AS:
            		        	{
            		            int LA58_137 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case GET:
            		        	{
            		            int LA58_138 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SET:
            		        	{
            		            int LA58_139 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case IF:
            		        	{
            		            int LA58_140 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case FOR:
            		        	{
            		            int LA58_141 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WHILE:
            		        	{
            		            int LA58_142 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DO:
            		        	{
            		            int LA58_143 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case WITH:
            		        	{
            		            int LA58_144 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SWITCH:
            		        	{
            		            int LA58_145 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case BREAK:
            		        	{
            		            int LA58_146 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case CONTINUE:
            		        	{
            		            int LA58_147 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case RETURN:
            		        	{
            		            int LA58_148 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 177:
            		        	{
            		            int LA58_149 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case 178:
            		        	{
            		            int LA58_150 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case DEFAULT:
            		        	{
            		            int LA58_151 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        case SEMI:
            		        	{
            		            int LA58_152 = input.LA(3);
            		            
            		            if ( (synpred86()) )
            		            {
            		                alt58 = 1;
            		            }
            		            
            		        
            		            }
            		            break;
            		        
            		        }
            		    
            		    }
            		    
            		
            		    switch (alt58) 
            			{
            				case 1 :
            				    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: commentExpression
            				    {
            				    	PushFollow(FOLLOW_commentExpression_in_withStatement2485);
            				    	commentExpression232 = commentExpression();
            				    	followingStackPointer_--;
            				    	if (failed) return retval;
            				    	if ( backtracking==0 ) adaptor.AddChild(root_0, commentExpression232.Tree);
            				    
            				    }
            				    break;
            		
            				default:
            				    goto loop58;
            		    }
            		} while (true);
            		
            		loop58:
            			;	// Stops C# compiler whinging that label 'loop58' has no statements

            		PushFollow(FOLLOW_statement_in_withStatement2488);
            		statement233 = statement();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) adaptor.AddChild(root_0, statement233.Tree);
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 70, withStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end withStatement

    public class defaultXMLNamespaceStatement_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start defaultXMLNamespaceStatement
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:575:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
    public defaultXMLNamespaceStatement_return defaultXMLNamespaceStatement() // throws RecognitionException [1]
    {   
        defaultXMLNamespaceStatement_return retval = new defaultXMLNamespaceStatement_return();
        retval.start = input.LT(1);
        int defaultXMLNamespaceStatement_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DEFAULT234 = null;
        IToken XML235 = null;
        IToken NAMESPACE236 = null;
        IToken ASSIGN237 = null;
        expression_return expression238 = null;

        semi_return semi239 = null;
        
        
        CommonTree DEFAULT234_tree=null;
        CommonTree XML235_tree=null;
        CommonTree NAMESPACE236_tree=null;
        CommonTree ASSIGN237_tree=null;
        RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor,"token XML");
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleTokenStream stream_DEFAULT = new RewriteRuleTokenStream(adaptor,"token DEFAULT");
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleSubtreeStream stream_semi = new RewriteRuleSubtreeStream(adaptor,"rule semi");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 71) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:576:4: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:576:4: DEFAULT XML NAMESPACE ASSIGN expression semi
            {
            	DEFAULT234 = (IToken)input.LT(1);
            	Match(input,DEFAULT,FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2500); if (failed) return retval;
            	if ( backtracking==0 ) stream_DEFAULT.Add(DEFAULT234);

            	XML235 = (IToken)input.LT(1);
            	Match(input,XML,FOLLOW_XML_in_defaultXMLNamespaceStatement2502); if (failed) return retval;
            	if ( backtracking==0 ) stream_XML.Add(XML235);

            	NAMESPACE236 = (IToken)input.LT(1);
            	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2504); if (failed) return retval;
            	if ( backtracking==0 ) stream_NAMESPACE.Add(NAMESPACE236);

            	ASSIGN237 = (IToken)input.LT(1);
            	Match(input,ASSIGN,FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2506); if (failed) return retval;
            	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN237);

            	PushFollow(FOLLOW_expression_in_defaultXMLNamespaceStatement2508);
            	expression238 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_expression.Add(expression238.Tree);
            	PushFollow(FOLLOW_semi_in_defaultXMLNamespaceStatement2510);
            	semi239 = semi();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_semi.Add(semi239.Tree);
            	
            	// AST REWRITE
            	// elements:          expression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 577:3: -> ^( DEFAULT_XML_NAMESPACE expression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:577:6: ^( DEFAULT_XML_NAMESPACE expression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_expression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 71, defaultXMLNamespaceStatement_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end defaultXMLNamespaceStatement

    public class typeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start typeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:580:1: typeExpression : c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) ;
    public typeExpression_return typeExpression() // throws RecognitionException [1]
    {   
        typeExpression_return retval = new typeExpression_return();
        retval.start = input.LT(1);
        int typeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken c = null;
        IToken string_literal241 = null;
        IToken STAR242 = null;
        identifier_return identifier240 = null;
        
        
        CommonTree c_tree=null;
        CommonTree string_literal241_tree=null;
        CommonTree STAR242_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleTokenStream stream_181 = new RewriteRuleTokenStream(adaptor,"token 181");
        RewriteRuleSubtreeStream stream_identifier = new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 72) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:4: (c= COLON ( identifier | 'void' | STAR ) -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:581:4: c= COLON ( identifier | 'void' | STAR )
            {
            	c = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_typeExpression2533); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(c);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:583:3: ( identifier | 'void' | STAR )
            	int alt59 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case USE:
            	case XML:
            	case IDENT:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case DYNAMIC:
            	case IS:
            	case AS:
            		{
            	    alt59 = 1;
            	    }
            	    break;
            	case 181:
            		{
            	    alt59 = 2;
            	    }
            	    break;
            	case STAR:
            		{
            	    alt59 = 3;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d59s0 =
            		        new NoViableAltException("583:3: ( identifier | 'void' | STAR )", 59, 0, input);
            	
            		    throw nvae_d59s0;
            	}
            	
            	switch (alt59) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:583:4: identifier
            	        {
            	        	PushFollow(FOLLOW_identifier_in_typeExpression2541);
            	        	identifier240 = identifier();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_identifier.Add(identifier240.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:583:17: 'void'
            	        {
            	        	string_literal241 = (IToken)input.LT(1);
            	        	Match(input,181,FOLLOW_181_in_typeExpression2545); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_181.Add(string_literal241);

            	        
            	        }
            	        break;
            	    case 3 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:583:26: STAR
            	        {
            	        	STAR242 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_typeExpression2549); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR242);

            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          STAR, identifier, 181
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 584:3: -> ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:584:6: ^( TYPE_SPEC[$c] ( identifier )? ( 'void' )? ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(TYPE_SPEC, c), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:584:22: ( identifier )?
            	    if ( stream_identifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_identifier.Next());
            	    
            	    }
            	    stream_identifier.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:584:34: ( 'void' )?
            	    if ( stream_181.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_181.Next());
            	    
            	    }
            	    stream_181.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:584:42: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 72, typeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end typeExpression

    public class identifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:587:1: identifier : qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) ;
    public identifier_return identifier() // throws RecognitionException [1]
    {   
        identifier_return retval = new identifier_return();
        retval.start = input.LT(1);
        int identifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT244 = null;
        qualifiedIdent_return qualifiedIdent243 = null;

        qualifiedIdent_return qualifiedIdent245 = null;
        
        
        CommonTree DOT244_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 73) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:588:4: ( qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )* -> ^( IDENTIFIER ( qualifiedIdent )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:588:4: qualifiedIdent ( options {greedy=true; } : DOT qualifiedIdent )*
            {
            	PushFollow(FOLLOW_qualifiedIdent_in_identifier2581);
            	qualifiedIdent243 = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent243.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:589:3: ( options {greedy=true; } : DOT qualifiedIdent )*
            	do 
            	{
            	    int alt60 = 2;
            	    int LA60_0 = input.LA(1);
            	    
            	    if ( (LA60_0 == DOT) )
            	    {
            	        alt60 = 1;
            	    }
            	    
            	
            	    switch (alt60) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:590:6: DOT qualifiedIdent
            			    {
            			    	DOT244 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifier2599); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT244);

            			    	PushFollow(FOLLOW_qualifiedIdent_in_identifier2601);
            			    	qualifiedIdent245 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent245.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop60;
            	    }
            	} while (true);
            	
            	loop60:
            		;	// Stops C# compiler whinging that label 'loop60' has no statements

            	
            	// AST REWRITE
            	// elements:          qualifiedIdent
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 592:3: -> ^( IDENTIFIER ( qualifiedIdent )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:592:6: ^( IDENTIFIER ( qualifiedIdent )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_qualifiedIdent.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_qualifiedIdent.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            	    
            	    }
            	    stream_qualifiedIdent.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 73, identifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifier

    public class qualifiedIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start qualifiedIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:595:1: qualifiedIdent : ( namespaceName DBL_COLON )? ident ;
    public qualifiedIdent_return qualifiedIdent() // throws RecognitionException [1]
    {   
        qualifiedIdent_return retval = new qualifiedIdent_return();
        retval.start = input.LT(1);
        int qualifiedIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DBL_COLON247 = null;
        namespaceName_return namespaceName246 = null;

        ident_return ident248 = null;
        
        
        CommonTree DBL_COLON247_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 74) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( ( namespaceName DBL_COLON )? ident )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( namespaceName DBL_COLON )? ident
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:4: ( namespaceName DBL_COLON )?
            	int alt61 = 2;
            	int LA61_0 = input.LA(1);
            	
            	if ( (LA61_0 == IDENT) )
            	{
            	    int LA61_1 = input.LA(2);
            	    
            	    if ( (LA61_1 == DBL_COLON) )
            	    {
            	        alt61 = 1;
            	    }
            	}
            	else if ( ((LA61_0 >= PUBLIC && LA61_0 <= INTERNAL)) )
            	{
            	    alt61 = 1;
            	}
            	switch (alt61) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:596:5: namespaceName DBL_COLON
            	        {
            	        	PushFollow(FOLLOW_namespaceName_in_qualifiedIdent2629);
            	        	namespaceName246 = namespaceName();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceName246.Tree);
            	        	DBL_COLON247 = (IToken)input.LT(1);
            	        	Match(input,DBL_COLON,FOLLOW_DBL_COLON_in_qualifiedIdent2631); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	DBL_COLON247_tree = (CommonTree)adaptor.Create(DBL_COLON247);
            	        	adaptor.AddChild(root_0, DBL_COLON247_tree);
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_ident_in_qualifiedIdent2635);
            	ident248 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, ident248.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 74, qualifiedIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end qualifiedIdent

    public class namespaceName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start namespaceName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:599:1: namespaceName : ( IDENT | reservedNamespace );
    public namespaceName_return namespaceName() // throws RecognitionException [1]
    {   
        namespaceName_return retval = new namespaceName_return();
        retval.start = input.LT(1);
        int namespaceName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IDENT249 = null;
        reservedNamespace_return reservedNamespace250 = null;
        
        
        CommonTree IDENT249_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 75) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:600:4: ( IDENT | reservedNamespace )
            int alt62 = 2;
            int LA62_0 = input.LA(1);
            
            if ( (LA62_0 == IDENT) )
            {
                alt62 = 1;
            }
            else if ( ((LA62_0 >= PUBLIC && LA62_0 <= INTERNAL)) )
            {
                alt62 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d62s0 =
                    new NoViableAltException("599:1: namespaceName : ( IDENT | reservedNamespace );", 62, 0, input);
            
                throw nvae_d62s0;
            }
            switch (alt62) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:600:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT249 = (IToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_namespaceName2647); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT249_tree = (CommonTree)adaptor.Create(IDENT249);
                    	adaptor.AddChild(root_0, IDENT249_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:600:12: reservedNamespace
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_reservedNamespace_in_namespaceName2651);
                    	reservedNamespace250 = reservedNamespace();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, reservedNamespace250.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 75, namespaceName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end namespaceName

    public class reservedNamespace_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start reservedNamespace
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:603:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
    public reservedNamespace_return reservedNamespace() // throws RecognitionException [1]
    {   
        reservedNamespace_return retval = new reservedNamespace_return();
        retval.start = input.LT(1);
        int reservedNamespace_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set251 = null;
        
        CommonTree set251_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 76) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:604:4: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set251 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= PUBLIC && input.LA(1) <= INTERNAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set251));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_reservedNamespace0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 76, reservedNamespace_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end reservedNamespace

    public class identifierStar_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start identifierStar
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:610:1: identifierStar : ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) ;
    public identifierStar_return identifierStar() // throws RecognitionException [1]
    {   
        identifierStar_return retval = new identifierStar_return();
        retval.start = input.LT(1);
        int identifierStar_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT253 = null;
        IToken DOT255 = null;
        IToken STAR256 = null;
        ident_return ident252 = null;

        ident_return ident254 = null;
        
        
        CommonTree DOT253_tree=null;
        CommonTree DOT255_tree=null;
        CommonTree STAR256_tree=null;
        RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream(adaptor,"token STAR");
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 77) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:611:4: ( ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )? -> ^( IDENTIFIER ( ident )+ ( STAR )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:611:4: ident ( options {greedy=true; } : DOT ident )* ( DOT STAR )?
            {
            	PushFollow(FOLLOW_ident_in_identifierStar2688);
            	ident252 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident252.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:612:3: ( options {greedy=true; } : DOT ident )*
            	do 
            	{
            	    int alt63 = 2;
            	    int LA63_0 = input.LA(1);
            	    
            	    if ( (LA63_0 == DOT) )
            	    {
            	        int LA63_1 = input.LA(2);
            	        
            	        if ( ((LA63_1 >= GET && LA63_1 <= USE) || LA63_1 == XML || LA63_1 == IDENT || LA63_1 == DYNAMIC || (LA63_1 >= IS && LA63_1 <= AS)) )
            	        {
            	            alt63 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt63) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:613:5: DOT ident
            			    {
            			    	DOT253 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_identifierStar2705); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT253);

            			    	PushFollow(FOLLOW_ident_in_identifierStar2707);
            			    	ident254 = ident();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_ident.Add(ident254.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop63;
            	    }
            	} while (true);
            	
            	loop63:
            		;	// Stops C# compiler whinging that label 'loop63' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:615:3: ( DOT STAR )?
            	int alt64 = 2;
            	int LA64_0 = input.LA(1);
            	
            	if ( (LA64_0 == DOT) )
            	{
            	    alt64 = 1;
            	}
            	switch (alt64) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:615:5: DOT STAR
            	        {
            	        	DOT255 = (IToken)input.LT(1);
            	        	Match(input,DOT,FOLLOW_DOT_in_identifierStar2719); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DOT.Add(DOT255);

            	        	STAR256 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_identifierStar2721); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_STAR.Add(STAR256);

            	        
            	        }
            	        break;
            	
            	}

            	
            	// AST REWRITE
            	// elements:          STAR, ident
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 617:3: -> ^( IDENTIFIER ( ident )+ ( STAR )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:617:6: ^( IDENTIFIER ( ident )+ ( STAR )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(IDENTIFIER, "IDENTIFIER"), root_1);
            	    
            	    if ( !(stream_ident.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_ident.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_ident.Next());
            	    
            	    }
            	    stream_ident.Reset();
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:617:26: ( STAR )?
            	    if ( stream_STAR.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_STAR.Next());
            	    
            	    }
            	    stream_STAR.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 77, identifierStar_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end identifierStar

    public class annotations_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotations
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:620:1: annotations : ( annotation | includeDirective )+ -> ^( ANNOTATIONS ( annotation )+ ) ;
    public annotations_return annotations() // throws RecognitionException [1]
    {   
        annotations_return retval = new annotations_return();
        retval.start = input.LT(1);
        int annotations_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        annotation_return annotation257 = null;

        includeDirective_return includeDirective258 = null;
        
        
        RewriteRuleSubtreeStream stream_includeDirective = new RewriteRuleSubtreeStream(adaptor,"rule includeDirective");
        RewriteRuleSubtreeStream stream_annotation = new RewriteRuleSubtreeStream(adaptor,"rule annotation");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 78) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:4: ( ( annotation | includeDirective )+ -> ^( ANNOTATIONS ( annotation )+ ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:4: ( annotation | includeDirective )+
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:4: ( annotation | includeDirective )+
            	int cnt65 = 0;
            	do 
            	{
            	    int alt65 = 3;
            	    int LA65_0 = input.LA(1);
            	    
            	    if ( (LA65_0 == LBRACK) )
            	    {
            	        int LA65_12 = input.LA(2);
            	        
            	        if ( (synpred97()) )
            	        {
            	            alt65 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA65_0 == 176) )
            	    {
            	        int LA65_13 = input.LA(2);
            	        
            	        if ( (synpred98()) )
            	        {
            	            alt65 = 2;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt65) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:6: annotation
            			    {
            			    	PushFollow(FOLLOW_annotation_in_annotations2754);
            			    	annotation257 = annotation();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_annotation.Add(annotation257.Tree);
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:622:5: includeDirective
            			    {
            			    	PushFollow(FOLLOW_includeDirective_in_annotations2760);
            			    	includeDirective258 = includeDirective();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_includeDirective.Add(includeDirective258.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    if ( cnt65 >= 1 ) goto loop65;
            			    if ( backtracking > 0 ) {failed = true; return retval;}
            		            EarlyExitException eee =
            		                new EarlyExitException(65, input);
            		            throw eee;
            	    }
            	    cnt65++;
            	} while (true);
            	
            	loop65:
            		;	// Stops C# compiler whinging that label 'loop65' has no statements

            	
            	// AST REWRITE
            	// elements:          annotation
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 624:3: -> ^( ANNOTATIONS ( annotation )+ )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:624:6: ^( ANNOTATIONS ( annotation )+ )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATIONS, "ANNOTATIONS"), root_1);
            	    
            	    if ( !(stream_annotation.HasNext()) ) {
            	        throw new RewriteEarlyExitException();
            	    }
            	    while ( stream_annotation.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotation.Next());
            	    
            	    }
            	    stream_annotation.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 78, annotations_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotations

    public class annotation_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotation
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:627:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
    public annotation_return annotation() // throws RecognitionException [1]
    {   
        annotation_return retval = new annotation_return();
        retval.start = input.LT(1);
        int annotation_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK259 = null;
        IToken RBRACK262 = null;
        ident_return ident260 = null;

        annotationParamList_return annotationParamList261 = null;
        
        
        CommonTree LBRACK259_tree=null;
        CommonTree RBRACK262_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_annotationParamList = new RewriteRuleSubtreeStream(adaptor,"rule annotationParamList");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 79) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:628:4: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:628:4: LBRACK ident ( annotationParamList )? RBRACK
            {
            	LBRACK259 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_annotation2787); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK259);

            	PushFollow(FOLLOW_ident_in_annotation2791);
            	ident260 = ident();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_ident.Add(ident260.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:630:3: ( annotationParamList )?
            	int alt66 = 2;
            	int LA66_0 = input.LA(1);
            	
            	if ( (LA66_0 == LPAREN) )
            	{
            	    alt66 = 1;
            	}
            	switch (alt66) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: annotationParamList
            	        {
            	        	PushFollow(FOLLOW_annotationParamList_in_annotation2795);
            	        	annotationParamList261 = annotationParamList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParamList.Add(annotationParamList261.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK262 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_annotation2800); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK262);

            	
            	// AST REWRITE
            	// elements:          ident, annotationParamList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 632:3: -> ^( ANNOTATION ident ( annotationParamList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:632:6: ^( ANNOTATION ident ( annotationParamList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ident.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:632:25: ( annotationParamList )?
            	    if ( stream_annotationParamList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParamList.Next());
            	    
            	    }
            	    stream_annotationParamList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 79, annotation_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotation

    public class annotationParamList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParamList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:635:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
    public annotationParamList_return annotationParamList() // throws RecognitionException [1]
    {   
        annotationParamList_return retval = new annotationParamList_return();
        retval.start = input.LT(1);
        int annotationParamList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN263 = null;
        IToken COMMA265 = null;
        IToken RPAREN267 = null;
        annotationParam_return annotationParam264 = null;

        annotationParam_return annotationParam266 = null;
        
        
        CommonTree LPAREN263_tree=null;
        CommonTree COMMA265_tree=null;
        CommonTree RPAREN267_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_annotationParam = new RewriteRuleSubtreeStream(adaptor,"rule annotationParam");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 80) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:637:3: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:637:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
            {
            	LPAREN263 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_annotationParamList2826); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN263);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:638:3: ( annotationParam ( COMMA annotationParam )* )?
            	int alt68 = 2;
            	int LA68_0 = input.LA(1);
            	
            	if ( (LA68_0 == STRING_LITERAL || (LA68_0 >= GET && LA68_0 <= USE) || LA68_0 == XML || LA68_0 == IDENT || LA68_0 == DYNAMIC || LA68_0 == LT || (LA68_0 >= IS && LA68_0 <= AS) || LA68_0 == DIV || (LA68_0 >= TRUE && LA68_0 <= FLOAT_LITERAL)) )
            	{
            	    alt68 = 1;
            	}
            	switch (alt68) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:638:5: annotationParam ( COMMA annotationParam )*
            	        {
            	        	PushFollow(FOLLOW_annotationParam_in_annotationParamList2832);
            	        	annotationParam264 = annotationParam();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam264.Tree);
            	        	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:639:4: ( COMMA annotationParam )*
            	        	do 
            	        	{
            	        	    int alt67 = 2;
            	        	    int LA67_0 = input.LA(1);
            	        	    
            	        	    if ( (LA67_0 == COMMA) )
            	        	    {
            	        	        alt67 = 1;
            	        	    }
            	        	    
            	        	
            	        	    switch (alt67) 
            	        		{
            	        			case 1 :
            	        			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:639:5: COMMA annotationParam
            	        			    {
            	        			    	COMMA265 = (IToken)input.LT(1);
            	        			    	Match(input,COMMA,FOLLOW_COMMA_in_annotationParamList2838); if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA265);

            	        			    	PushFollow(FOLLOW_annotationParam_in_annotationParamList2840);
            	        			    	annotationParam266 = annotationParam();
            	        			    	followingStackPointer_--;
            	        			    	if (failed) return retval;
            	        			    	if ( backtracking==0 ) stream_annotationParam.Add(annotationParam266.Tree);
            	        			    
            	        			    }
            	        			    break;
            	        	
            	        			default:
            	        			    goto loop67;
            	        	    }
            	        	} while (true);
            	        	
            	        	loop67:
            	        		;	// Stops C# compiler whinging that label 'loop67' has no statements

            	        
            	        }
            	        break;
            	
            	}

            	RPAREN267 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_annotationParamList2851); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN267);

            	
            	// AST REWRITE
            	// elements:          annotationParam
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 642:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:642:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:642:26: ( annotationParam )*
            	    while ( stream_annotationParam.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_annotationParam.Next());
            	    
            	    }
            	    stream_annotationParam.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 80, annotationParamList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParamList

    public class annotationParam_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start annotationParam
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );
    public annotationParam_return annotationParam() // throws RecognitionException [1]
    {   
        annotationParam_return retval = new annotationParam_return();
        retval.start = input.LT(1);
        int annotationParam_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ASSIGN269 = null;
        ident_return ident268 = null;

        constant_return constant270 = null;

        constant_return constant271 = null;

        ident_return ident272 = null;
        
        
        CommonTree ASSIGN269_tree=null;
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor,"token ASSIGN");
        RewriteRuleSubtreeStream stream_constant = new RewriteRuleSubtreeStream(adaptor,"rule constant");
        RewriteRuleSubtreeStream stream_ident = new RewriteRuleSubtreeStream(adaptor,"rule ident");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 81) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:3: ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident )
            int alt69 = 3;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                int LA69_1 = input.LA(2);
                
                if ( (LA69_1 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else if ( (LA69_1 == EOF || LA69_1 == COMMA || LA69_1 == RPAREN) )
                {
                    alt69 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s1 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 1, input);
                
                    throw nvae_d69s1;
                }
                }
                break;
            case USE:
            	{
                int LA69_2 = input.LA(2);
                
                if ( (LA69_2 == EOF || LA69_2 == COMMA || LA69_2 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_2 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s2 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 2, input);
                
                    throw nvae_d69s2;
                }
                }
                break;
            case XML:
            	{
                int LA69_3 = input.LA(2);
                
                if ( (LA69_3 == EOF || LA69_3 == COMMA || LA69_3 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_3 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s3 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 3, input);
                
                    throw nvae_d69s3;
                }
                }
                break;
            case DYNAMIC:
            	{
                int LA69_4 = input.LA(2);
                
                if ( (LA69_4 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else if ( (LA69_4 == EOF || LA69_4 == COMMA || LA69_4 == RPAREN) )
                {
                    alt69 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s4 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 4, input);
                
                    throw nvae_d69s4;
                }
                }
                break;
            case NAMESPACE:
            	{
                int LA69_5 = input.LA(2);
                
                if ( (LA69_5 == EOF || LA69_5 == COMMA || LA69_5 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_5 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s5 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 5, input);
                
                    throw nvae_d69s5;
                }
                }
                break;
            case IS:
            	{
                int LA69_6 = input.LA(2);
                
                if ( (LA69_6 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else if ( (LA69_6 == EOF || LA69_6 == COMMA || LA69_6 == RPAREN) )
                {
                    alt69 = 3;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s6 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 6, input);
                
                    throw nvae_d69s6;
                }
                }
                break;
            case AS:
            	{
                int LA69_7 = input.LA(2);
                
                if ( (LA69_7 == EOF || LA69_7 == COMMA || LA69_7 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_7 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s7 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 7, input);
                
                    throw nvae_d69s7;
                }
                }
                break;
            case GET:
            	{
                int LA69_8 = input.LA(2);
                
                if ( (LA69_8 == EOF || LA69_8 == COMMA || LA69_8 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_8 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s8 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 8, input);
                
                    throw nvae_d69s8;
                }
                }
                break;
            case SET:
            	{
                int LA69_9 = input.LA(2);
                
                if ( (LA69_9 == EOF || LA69_9 == COMMA || LA69_9 == RPAREN) )
                {
                    alt69 = 3;
                }
                else if ( (LA69_9 == ASSIGN) )
                {
                    alt69 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d69s9 =
                        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 9, input);
                
                    throw nvae_d69s9;
                }
                }
                break;
            case STRING_LITERAL:
            case LT:
            case DIV:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt69 = 2;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d69s0 =
            	        new NoViableAltException("656:1: annotationParam : ( ident ASSIGN constant -> ^( ANNOTATION_ASSIGN ident constant ) | constant -> constant | ident -> ident );", 69, 0, input);
            
            	    throw nvae_d69s0;
            }
            
            switch (alt69) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:3: ident ASSIGN constant
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam2878);
                    	ident268 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ident268.Tree);
                    	ASSIGN269 = (IToken)input.LT(1);
                    	Match(input,ASSIGN,FOLLOW_ASSIGN_in_annotationParam2880); if (failed) return retval;
                    	if ( backtracking==0 ) stream_ASSIGN.Add(ASSIGN269);

                    	PushFollow(FOLLOW_constant_in_annotationParam2882);
                    	constant270 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(constant270.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          constant, ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 658:25: -> ^( ANNOTATION_ASSIGN ident constant )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:658:28: ^( ANNOTATION_ASSIGN ident constant )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ANNOTATION_ASSIGN, "ANNOTATION_ASSIGN"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_ident.Next());
                    	    adaptor.AddChild(root_1, stream_constant.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:659:4: constant
                    {
                    	PushFollow(FOLLOW_constant_in_annotationParam2897);
                    	constant271 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_constant.Add(constant271.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          constant
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 659:13: -> constant
                    	{
                    	    adaptor.AddChild(root_0, stream_constant.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:660:4: ident
                    {
                    	PushFollow(FOLLOW_ident_in_annotationParam2906);
                    	ident272 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_ident.Add(ident272.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          ident
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 660:10: -> ident
                    	{
                    	    adaptor.AddChild(root_0, stream_ident.Next());
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 81, annotationParam_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end annotationParam

    public class modifiers_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifiers
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:663:1: modifiers : ( modifier )* -> ^( MODIFIERS ( modifier )* ) ;
    public modifiers_return modifiers() // throws RecognitionException [1]
    {   
        modifiers_return retval = new modifiers_return();
        retval.start = input.LT(1);
        int modifiers_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        modifier_return modifier273 = null;
        
        
        RewriteRuleSubtreeStream stream_modifier = new RewriteRuleSubtreeStream(adaptor,"rule modifier");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 82) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:664:4: ( ( modifier )* -> ^( MODIFIERS ( modifier )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:664:4: ( modifier )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:664:4: ( modifier )*
            	do 
            	{
            	    int alt70 = 2;
            	    int LA70_0 = input.LA(1);
            	    
            	    if ( ((LA70_0 >= IDENT && LA70_0 <= INTERNAL) || (LA70_0 >= STATIC && LA70_0 <= DYNAMIC) || (LA70_0 >= 182 && LA70_0 <= 186)) )
            	    {
            	        alt70 = 1;
            	    }
            	    
            	
            	    switch (alt70) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: modifier
            			    {
            			    	PushFollow(FOLLOW_modifier_in_modifiers2921);
            			    	modifier273 = modifier();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_modifier.Add(modifier273.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop70;
            	    }
            	} while (true);
            	
            	loop70:
            		;	// Stops C# compiler whinging that label 'loop70' has no statements

            	
            	// AST REWRITE
            	// elements:          modifier
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 665:3: -> ^( MODIFIERS ( modifier )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:6: ^( MODIFIERS ( modifier )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MODIFIERS, "MODIFIERS"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:665:18: ( modifier )*
            	    while ( stream_modifier.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_modifier.Next());
            	    
            	    }
            	    stream_modifier.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 82, modifiers_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifiers

    public class modifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start modifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:668:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
    public modifier_return modifier() // throws RecognitionException [1]
    {   
        modifier_return retval = new modifier_return();
        retval.start = input.LT(1);
        int modifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STATIC275 = null;
        IToken string_literal276 = null;
        IToken string_literal277 = null;
        IToken string_literal278 = null;
        IToken string_literal279 = null;
        IToken DYNAMIC280 = null;
        IToken string_literal281 = null;
        namespaceName_return namespaceName274 = null;
        
        
        CommonTree STATIC275_tree=null;
        CommonTree string_literal276_tree=null;
        CommonTree string_literal277_tree=null;
        CommonTree string_literal278_tree=null;
        CommonTree string_literal279_tree=null;
        CommonTree DYNAMIC280_tree=null;
        CommonTree string_literal281_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 83) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:669:4: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
            int alt71 = 8;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            	{
                alt71 = 1;
                }
                break;
            case STATIC:
            	{
                alt71 = 2;
                }
                break;
            case 182:
            	{
                alt71 = 3;
                }
                break;
            case 183:
            	{
                alt71 = 4;
                }
                break;
            case 184:
            	{
                alt71 = 5;
                }
                break;
            case 185:
            	{
                alt71 = 6;
                }
                break;
            case DYNAMIC:
            	{
                alt71 = 7;
                }
                break;
            case 186:
            	{
                alt71 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d71s0 =
            	        new NoViableAltException("668:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );", 71, 0, input);
            
            	    throw nvae_d71s0;
            }
            
            switch (alt71) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:669:4: namespaceName
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_namespaceName_in_modifier2944);
                    	namespaceName274 = namespaceName();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, namespaceName274.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:670:4: STATIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STATIC275 = (IToken)input.LT(1);
                    	Match(input,STATIC,FOLLOW_STATIC_in_modifier2949); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STATIC275_tree = (CommonTree)adaptor.Create(STATIC275);
                    	adaptor.AddChild(root_0, STATIC275_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:671:4: 'final'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal276 = (IToken)input.LT(1);
                    	Match(input,182,FOLLOW_182_in_modifier2954); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal276_tree = (CommonTree)adaptor.Create(string_literal276);
                    	adaptor.AddChild(root_0, string_literal276_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:672:4: 'enumerable'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal277 = (IToken)input.LT(1);
                    	Match(input,183,FOLLOW_183_in_modifier2959); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal277_tree = (CommonTree)adaptor.Create(string_literal277);
                    	adaptor.AddChild(root_0, string_literal277_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:673:4: 'explicit'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal278 = (IToken)input.LT(1);
                    	Match(input,184,FOLLOW_184_in_modifier2964); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal278_tree = (CommonTree)adaptor.Create(string_literal278);
                    	adaptor.AddChild(root_0, string_literal278_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:674:4: 'override'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal279 = (IToken)input.LT(1);
                    	Match(input,185,FOLLOW_185_in_modifier2969); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal279_tree = (CommonTree)adaptor.Create(string_literal279);
                    	adaptor.AddChild(root_0, string_literal279_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:675:4: DYNAMIC
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	DYNAMIC280 = (IToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_modifier2974); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	DYNAMIC280_tree = (CommonTree)adaptor.Create(DYNAMIC280);
                    	adaptor.AddChild(root_0, DYNAMIC280_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:676:4: 'intrinsic'
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	string_literal281 = (IToken)input.LT(1);
                    	Match(input,186,FOLLOW_186_in_modifier2979); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	string_literal281_tree = (CommonTree)adaptor.Create(string_literal281);
                    	adaptor.AddChild(root_0, string_literal281_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 83, modifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end modifier

    public class arguments_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arguments
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:679:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );
    public arguments_return arguments() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        arguments_return retval = new arguments_return();
        retval.start = input.LT(1);
        int arguments_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN282 = null;
        IToken RPAREN284 = null;
        IToken LPAREN285 = null;
        IToken RPAREN286 = null;
        expressionList_return expressionList283 = null;
        
        
        CommonTree LPAREN282_tree=null;
        CommonTree RPAREN284_tree=null;
        CommonTree LPAREN285_tree=null;
        CommonTree RPAREN286_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_expressionList = new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 84) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:684:4: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS )
            int alt72 = 2;
            int LA72_0 = input.LA(1);
            
            if ( (LA72_0 == LPAREN) )
            {
                int LA72_1 = input.LA(2);
                
                if ( (LA72_1 == RPAREN) )
                {
                    alt72 = 2;
                }
                else if ( (LA72_1 == LCURLY || (LA72_1 >= STRING_LITERAL && LA72_1 <= USE) || LA72_1 == LPAREN || LA72_1 == XML || (LA72_1 >= IDENT && LA72_1 <= LBRACK) || LA72_1 == DYNAMIC || LA72_1 == LT || (LA72_1 >= IS && LA72_1 <= AS) || (LA72_1 >= PLUS && LA72_1 <= DIV) || (LA72_1 >= INC && LA72_1 <= BNOT) || (LA72_1 >= E4X_ATTRI && LA72_1 <= NEW) || LA72_1 == 181) )
                {
                    alt72 = 1;
                }
                else 
                {
                    if ( backtracking > 0 ) {failed = true; return retval;}
                    NoViableAltException nvae_d72s1 =
                        new NoViableAltException("679:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 72, 1, input);
                
                    throw nvae_d72s1;
                }
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d72s0 =
                    new NoViableAltException("679:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS expressionList ) | LPAREN RPAREN -> ARGUMENTS );", 72, 0, input);
            
                throw nvae_d72s0;
            }
            switch (alt72) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:684:4: LPAREN expressionList RPAREN
                    {
                    	LPAREN282 = (IToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3000); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN282);

                    	PushFollow(FOLLOW_expressionList_in_arguments3002);
                    	expressionList283 = expressionList();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_expressionList.Add(expressionList283.Tree);
                    	RPAREN284 = (IToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3004); if (failed) return retval;
                    	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN284);

                    	
                    	// AST REWRITE
                    	// elements:          expressionList
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 685:3: -> ^( ARGUMENTS expressionList )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:685:6: ^( ARGUMENTS expressionList )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_expressionList.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:686:4: LPAREN RPAREN
                    {
                    	LPAREN285 = (IToken)input.LT(1);
                    	Match(input,LPAREN,FOLLOW_LPAREN_in_arguments3019); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN285);

                    	RPAREN286 = (IToken)input.LT(1);
                    	Match(input,RPAREN,FOLLOW_RPAREN_in_arguments3021); if (failed) return retval;
                    	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN286);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 687:3: -> ARGUMENTS
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(ARGUMENTS, "ARGUMENTS"));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 84, arguments_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end arguments

    public class element_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start element
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:691:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
    public element_return element() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        element_return retval = new element_return();
        retval.start = input.LT(1);
        int element_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression287 = null;
        
        
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 85) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:696:4: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:696:4: assignmentExpression
            {
            	PushFollow(FOLLOW_assignmentExpression_in_element3051);
            	assignmentExpression287 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression287.Tree);
            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 697:3: -> ^( ELEMENT assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:697:6: ^( ELEMENT assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELEMENT, "ELEMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 85, element_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end element

    public class arrayLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start arrayLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:701:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) ;
    public arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {   
        arrayLiteral_return retval = new arrayLiteral_return();
        retval.start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK288 = null;
        IToken RBRACK290 = null;
        elementList_return elementList289 = null;
        
        
        CommonTree LBRACK288_tree=null;
        CommonTree RBRACK290_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleSubtreeStream stream_elementList = new RewriteRuleSubtreeStream(adaptor,"rule elementList");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 86) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:702:4: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL ( elementList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:702:4: LBRACK ( elementList )? RBRACK
            {
            	LBRACK288 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_arrayLiteral3073); if (failed) return retval;
            	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK288);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:702:11: ( elementList )?
            	int alt73 = 2;
            	int LA73_0 = input.LA(1);
            	
            	if ( (LA73_0 == LCURLY || (LA73_0 >= STRING_LITERAL && LA73_0 <= USE) || LA73_0 == LPAREN || LA73_0 == XML || (LA73_0 >= IDENT && LA73_0 <= LBRACK) || LA73_0 == DYNAMIC || LA73_0 == LT || (LA73_0 >= IS && LA73_0 <= AS) || (LA73_0 >= PLUS && LA73_0 <= DIV) || (LA73_0 >= INC && LA73_0 <= BNOT) || (LA73_0 >= E4X_ATTRI && LA73_0 <= NEW) || LA73_0 == 181) )
            	{
            	    alt73 = 1;
            	}
            	switch (alt73) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: elementList
            	        {
            	        	PushFollow(FOLLOW_elementList_in_arrayLiteral3075);
            	        	elementList289 = elementList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_elementList.Add(elementList289.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RBRACK290 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_arrayLiteral3078); if (failed) return retval;
            	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK290);

            	
            	// AST REWRITE
            	// elements:          elementList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 703:3: -> ^( ARRAY_LITERAL ( elementList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:703:6: ^( ARRAY_LITERAL ( elementList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:703:22: ( elementList )?
            	    if ( stream_elementList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_elementList.Next());
            	    
            	    }
            	    stream_elementList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 86, arrayLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end arrayLiteral

    public class elementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start elementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:706:1: elementList : nonemptyElementList ( COMMA ( nonemptyElementList )? )* ;
    public elementList_return elementList() // throws RecognitionException [1]
    {   
        elementList_return retval = new elementList_return();
        retval.start = input.LT(1);
        int elementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA292 = null;
        nonemptyElementList_return nonemptyElementList291 = null;

        nonemptyElementList_return nonemptyElementList293 = null;
        
        
        CommonTree COMMA292_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 87) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:4: ( nonemptyElementList ( COMMA ( nonemptyElementList )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:4: nonemptyElementList ( COMMA ( nonemptyElementList )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_nonemptyElementList_in_elementList3100);
            	nonemptyElementList291 = nonemptyElementList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList291.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:24: ( COMMA ( nonemptyElementList )? )*
            	do 
            	{
            	    int alt75 = 2;
            	    int LA75_0 = input.LA(1);
            	    
            	    if ( (LA75_0 == COMMA) )
            	    {
            	        alt75 = 1;
            	    }
            	    
            	
            	    switch (alt75) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:25: COMMA ( nonemptyElementList )?
            			    {
            			    	COMMA292 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_elementList3103); if (failed) return retval;
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:707:32: ( nonemptyElementList )?
            			    	int alt74 = 2;
            			    	int LA74_0 = input.LA(1);
            			    	
            			    	if ( (LA74_0 == LCURLY || (LA74_0 >= STRING_LITERAL && LA74_0 <= USE) || LA74_0 == LPAREN || LA74_0 == XML || (LA74_0 >= IDENT && LA74_0 <= LBRACK) || LA74_0 == DYNAMIC || LA74_0 == LT || (LA74_0 >= IS && LA74_0 <= AS) || (LA74_0 >= PLUS && LA74_0 <= DIV) || (LA74_0 >= INC && LA74_0 <= BNOT) || (LA74_0 >= E4X_ATTRI && LA74_0 <= NEW) || LA74_0 == 181) )
            			    	{
            			    	    alt74 = 1;
            			    	}
            			    	switch (alt74) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: nonemptyElementList
            			    	        {
            			    	        	PushFollow(FOLLOW_nonemptyElementList_in_elementList3106);
            			    	        	nonemptyElementList293 = nonemptyElementList();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, nonemptyElementList293.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop75;
            	    }
            	} while (true);
            	
            	loop75:
            		;	// Stops C# compiler whinging that label 'loop75' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 87, elementList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end elementList

    public class nonemptyElementList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start nonemptyElementList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:710:1: nonemptyElementList : assignmentExpression ( COMMA assignmentExpression )* ;
    public nonemptyElementList_return nonemptyElementList() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        nonemptyElementList_return retval = new nonemptyElementList_return();
        retval.start = input.LT(1);
        int nonemptyElementList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA295 = null;
        assignmentExpression_return assignmentExpression294 = null;

        assignmentExpression_return assignmentExpression296 = null;
        
        
        CommonTree COMMA295_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 88) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:4: ( assignmentExpression ( COMMA assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3131);
            	assignmentExpression294 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression294.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:25: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt76 = 2;
            	    int LA76_0 = input.LA(1);
            	    
            	    if ( (LA76_0 == COMMA) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA76_4 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA76_5 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA76_6 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA76_7 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA76_8 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA76_9 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA76_10 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA76_11 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA76_12 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA76_13 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA76_14 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA76_15 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA76_16 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA76_17 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA76_18 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA76_19 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA76_20 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA76_21 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA76_22 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA76_23 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA76_24 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA76_25 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA76_26 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA76_27 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA76_28 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA76_29 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA76_30 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA76_31 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA76_32 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA76_33 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA76_34 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA76_35 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA76_36 = input.LA(3);
            	            
            	            if ( (synpred116()) )
            	            {
            	                alt76 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt76) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:26: COMMA assignmentExpression
            			    {
            			    	COMMA295 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_nonemptyElementList3134); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	COMMA295_tree = (CommonTree)adaptor.Create(COMMA295);
            			    	adaptor.AddChild(root_0, COMMA295_tree);
            			    	}
            			    	PushFollow(FOLLOW_assignmentExpression_in_nonemptyElementList3136);
            			    	assignmentExpression296 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression296.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop76;
            	    }
            	} while (true);
            	
            	loop76:
            		;	// Stops C# compiler whinging that label 'loop76' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 88, nonemptyElementList_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end nonemptyElementList

    public class objectLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start objectLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:719:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
    public objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {   
        objectLiteral_return retval = new objectLiteral_return();
        retval.start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LCURLY297 = null;
        IToken RCURLY299 = null;
        fieldList_return fieldList298 = null;
        
        
        CommonTree LCURLY297_tree=null;
        CommonTree RCURLY299_tree=null;
        RewriteRuleTokenStream stream_LCURLY = new RewriteRuleTokenStream(adaptor,"token LCURLY");
        RewriteRuleTokenStream stream_RCURLY = new RewriteRuleTokenStream(adaptor,"token RCURLY");
        RewriteRuleSubtreeStream stream_fieldList = new RewriteRuleSubtreeStream(adaptor,"rule fieldList");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 89) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:720:4: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:720:4: LCURLY ( fieldList )? RCURLY
            {
            	LCURLY297 = (IToken)input.LT(1);
            	Match(input,LCURLY,FOLLOW_LCURLY_in_objectLiteral3151); if (failed) return retval;
            	if ( backtracking==0 ) stream_LCURLY.Add(LCURLY297);

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:720:11: ( fieldList )?
            	int alt77 = 2;
            	int LA77_0 = input.LA(1);
            	
            	if ( ((LA77_0 >= GET && LA77_0 <= USE) || LA77_0 == XML || LA77_0 == IDENT || LA77_0 == DYNAMIC || (LA77_0 >= IS && LA77_0 <= AS) || (LA77_0 >= HEX_LITERAL && LA77_0 <= FLOAT_LITERAL)) )
            	{
            	    alt77 = 1;
            	}
            	switch (alt77) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: fieldList
            	        {
            	        	PushFollow(FOLLOW_fieldList_in_objectLiteral3153);
            	        	fieldList298 = fieldList();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_fieldList.Add(fieldList298.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	RCURLY299 = (IToken)input.LT(1);
            	Match(input,RCURLY,FOLLOW_RCURLY_in_objectLiteral3156); if (failed) return retval;
            	if ( backtracking==0 ) stream_RCURLY.Add(RCURLY299);

            	
            	// AST REWRITE
            	// elements:          fieldList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 721:3: -> ^( OBJECT_LITERAL ( fieldList )? )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:6: ^( OBJECT_LITERAL ( fieldList )? )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);
            	    
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:721:23: ( fieldList )?
            	    if ( stream_fieldList.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_fieldList.Next());
            	    
            	    }
            	    stream_fieldList.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 89, objectLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end objectLiteral

    public class fieldList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:724:1: fieldList : literalField ( COMMA ( literalField )? )* ;
    public fieldList_return fieldList() // throws RecognitionException [1]
    {   
        fieldList_return retval = new fieldList_return();
        retval.start = input.LT(1);
        int fieldList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA301 = null;
        literalField_return literalField300 = null;

        literalField_return literalField302 = null;
        
        
        CommonTree COMMA301_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 90) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:4: ( literalField ( COMMA ( literalField )? )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:4: literalField ( COMMA ( literalField )? )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_literalField_in_fieldList3179);
            	literalField300 = literalField();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField300.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:17: ( COMMA ( literalField )? )*
            	do 
            	{
            	    int alt79 = 2;
            	    int LA79_0 = input.LA(1);
            	    
            	    if ( (LA79_0 == COMMA) )
            	    {
            	        alt79 = 1;
            	    }
            	    
            	
            	    switch (alt79) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:18: COMMA ( literalField )?
            			    {
            			    	COMMA301 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_fieldList3182); if (failed) return retval;
            			    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:725:25: ( literalField )?
            			    	int alt78 = 2;
            			    	int LA78_0 = input.LA(1);
            			    	
            			    	if ( ((LA78_0 >= GET && LA78_0 <= USE) || LA78_0 == XML || LA78_0 == IDENT || LA78_0 == DYNAMIC || (LA78_0 >= IS && LA78_0 <= AS) || (LA78_0 >= HEX_LITERAL && LA78_0 <= FLOAT_LITERAL)) )
            			    	{
            			    	    alt78 = 1;
            			    	}
            			    	switch (alt78) 
            			    	{
            			    	    case 1 :
            			    	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: literalField
            			    	        {
            			    	        	PushFollow(FOLLOW_literalField_in_fieldList3185);
            			    	        	literalField302 = literalField();
            			    	        	followingStackPointer_--;
            			    	        	if (failed) return retval;
            			    	        	if ( backtracking==0 ) adaptor.AddChild(root_0, literalField302.Tree);
            			    	        
            			    	        }
            			    	        break;
            			    	
            			    	}

            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop79;
            	    }
            	} while (true);
            	
            	loop79:
            		;	// Stops C# compiler whinging that label 'loop79' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 90, fieldList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldList

    public class literalField_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start literalField
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:728:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
    public literalField_return literalField() // throws RecognitionException [1]
    {   
        literalField_return retval = new literalField_return();
        retval.start = input.LT(1);
        int literalField_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COLON304 = null;
        fieldName_return fieldName303 = null;

        element_return element305 = null;
        
        
        CommonTree COLON304_tree=null;
        RewriteRuleTokenStream stream_COLON = new RewriteRuleTokenStream(adaptor,"token COLON");
        RewriteRuleSubtreeStream stream_element = new RewriteRuleSubtreeStream(adaptor,"rule element");
        RewriteRuleSubtreeStream stream_fieldName = new RewriteRuleSubtreeStream(adaptor,"rule fieldName");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 91) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:729:5: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:729:5: fieldName COLON element
            {
            	PushFollow(FOLLOW_fieldName_in_literalField3202);
            	fieldName303 = fieldName();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_fieldName.Add(fieldName303.Tree);
            	COLON304 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_literalField3204); if (failed) return retval;
            	if ( backtracking==0 ) stream_COLON.Add(COLON304);

            	PushFollow(FOLLOW_element_in_literalField3206);
            	element305 = element();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_element.Add(element305.Tree);
            	
            	// AST REWRITE
            	// elements:          element, fieldName
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 730:3: -> ^( OBJECT_FIELD fieldName element )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:730:6: ^( OBJECT_FIELD fieldName element )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_fieldName.Next());
            	    adaptor.AddChild(root_1, stream_element.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 91, literalField_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end literalField

    public class fieldName_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fieldName
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:733:1: fieldName : ( ident | number );
    public fieldName_return fieldName() // throws RecognitionException [1]
    {   
        fieldName_return retval = new fieldName_return();
        retval.start = input.LT(1);
        int fieldName_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        ident_return ident306 = null;

        number_return number307 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 92) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:734:4: ( ident | number )
            int alt80 = 2;
            int LA80_0 = input.LA(1);
            
            if ( ((LA80_0 >= GET && LA80_0 <= USE) || LA80_0 == XML || LA80_0 == IDENT || LA80_0 == DYNAMIC || (LA80_0 >= IS && LA80_0 <= AS)) )
            {
                alt80 = 1;
            }
            else if ( ((LA80_0 >= HEX_LITERAL && LA80_0 <= FLOAT_LITERAL)) )
            {
                alt80 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d80s0 =
                    new NoViableAltException("733:1: fieldName : ( ident | number );", 80, 0, input);
            
                throw nvae_d80s0;
            }
            switch (alt80) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:734:4: ident
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_ident_in_fieldName3230);
                    	ident306 = ident();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, ident306.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:735:4: number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_fieldName3235);
                    	number307 = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, number307.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 92, fieldName_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fieldName

    public class expression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:739:1: expression : assignmentExpression ;
    public expression_return expression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        expression_return retval = new expression_return();
        retval.start = input.LT(1);
        int expression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        assignmentExpression_return assignmentExpression308 = null;
        
        
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 93) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:4: ( assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:744:4: assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_expression3257);
            	assignmentExpression308 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression308.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 93, expression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end expression

    public class expressionList_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start expressionList
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:748:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) ;
    public expressionList_return expressionList() // throws RecognitionException [1]
    {   
        expressionList_return retval = new expressionList_return();
        retval.start = input.LT(1);
        int expressionList_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COMMA310 = null;
        assignmentExpression_return assignmentExpression309 = null;

        assignmentExpression_return assignmentExpression311 = null;
        
        
        CommonTree COMMA310_tree=null;
        RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream(adaptor,"token COMMA");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 94) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:4: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:4: assignmentExpression ( COMMA assignmentExpression )*
            {
            	PushFollow(FOLLOW_assignmentExpression_in_expressionList3269);
            	assignmentExpression309 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression309.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:25: ( COMMA assignmentExpression )*
            	do 
            	{
            	    int alt81 = 2;
            	    int LA81_0 = input.LA(1);
            	    
            	    if ( (LA81_0 == COMMA) )
            	    {
            	        alt81 = 1;
            	    }
            	    
            	
            	    switch (alt81) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:26: COMMA assignmentExpression
            			    {
            			    	COMMA310 = (IToken)input.LT(1);
            			    	Match(input,COMMA,FOLLOW_COMMA_in_expressionList3272); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_COMMA.Add(COMMA310);

            			    	PushFollow(FOLLOW_assignmentExpression_in_expressionList3274);
            			    	assignmentExpression311 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression311.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop81;
            	    }
            	} while (true);
            	
            	loop81:
            		;	// Stops C# compiler whinging that label 'loop81' has no statements

            	
            	// AST REWRITE
            	// elements:          assignmentExpression, assignmentExpression, COMMA
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 749:55: -> ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:58: ^( ELIST assignmentExpression ( COMMA assignmentExpression )* )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ELIST, "ELIST"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:749:87: ( COMMA assignmentExpression )*
            	    while ( stream_assignmentExpression.HasNext() || stream_COMMA.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_COMMA.Next());
            	        adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    }
            	    stream_assignmentExpression.Reset();
            	    stream_COMMA.Reset();
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 94, expressionList_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end expressionList

    public class assignmentExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:753:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
    public assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {   
        assignmentExpression_return retval = new assignmentExpression_return();
        retval.start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        conditionalExpression_return conditionalExpression312 = null;

        assignmentOperator_return assignmentOperator313 = null;

        assignmentExpression_return assignmentExpression314 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 95) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:754:4: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:754:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression3303);
            	conditionalExpression312 = conditionalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, conditionalExpression312.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:755:2: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
            	do 
            	{
            	    int alt82 = 2;
            	    int LA82_0 = input.LA(1);
            	    
            	    if ( (LA82_0 == ASSIGN || (LA82_0 >= STAR_ASSIGN && LA82_0 <= LOR_ASSIGN)) )
            	    {
            	        int LA82_70 = input.LA(2);
            	        
            	        if ( (synpred122()) )
            	        {
            	            alt82 = 1;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt82) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:755:4: ( assignmentOperator )=> assignmentOperator assignmentExpression
            			    {
            			    	PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression3313);
            			    	assignmentOperator313 = assignmentOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentOperator313.Tree);
            			    	PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression3317);
            			    	assignmentExpression314 = assignmentExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression314.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop82;
            	    }
            	} while (true);
            	
            	loop82:
            		;	// Stops C# compiler whinging that label 'loop82' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 95, assignmentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentExpression

    public class assignmentOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start assignmentOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:760:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
    public assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {   
        assignmentOperator_return retval = new assignmentOperator_return();
        retval.start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set315 = null;
        
        CommonTree set315_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 96) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:761:4: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set315 = (IToken)input.LT(1);
            	if ( input.LA(1) == ASSIGN || (input.LA(1) >= STAR_ASSIGN && input.LA(1) <= LOR_ASSIGN) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set315));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_assignmentOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 96, assignmentOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end assignmentOperator

    public class conditionalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:778:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
    public conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {   
        conditionalExpression_return retval = new conditionalExpression_return();
        retval.start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken QUESTION317 = null;
        logicalOrExpression_return logicalOrExpression316 = null;

        conditionalSubExpression_return conditionalSubExpression318 = null;
        
        
        CommonTree QUESTION317_tree=null;
        RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream(adaptor,"token QUESTION");
        RewriteRuleSubtreeStream stream_logicalOrExpression = new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
        RewriteRuleSubtreeStream stream_conditionalSubExpression = new RewriteRuleSubtreeStream(adaptor,"rule conditionalSubExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 97) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:779:4: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:779:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:779:4: ( logicalOrExpression -> logicalOrExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:779:5: logicalOrExpression
            	{
            		PushFollow(FOLLOW_logicalOrExpression_in_conditionalExpression3411);
            		logicalOrExpression316 = logicalOrExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_logicalOrExpression.Add(logicalOrExpression316.Tree);
            		
            		// AST REWRITE
            		// elements:          logicalOrExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 779:25: -> logicalOrExpression
            		{
            		    adaptor.AddChild(root_0, stream_logicalOrExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:780:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
            	int alt83 = 2;
            	int LA83_0 = input.LA(1);
            	
            	if ( (LA83_0 == QUESTION) )
            	{
            	    alt83 = 1;
            	}
            	switch (alt83) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:781:4: QUESTION conditionalSubExpression
            	        {
            	        	QUESTION317 = (IToken)input.LT(1);
            	        	Match(input,QUESTION,FOLLOW_QUESTION_in_conditionalExpression3425); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_QUESTION.Add(QUESTION317);

            	        	PushFollow(FOLLOW_conditionalSubExpression_in_conditionalExpression3430);
            	        	conditionalSubExpression318 = conditionalSubExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_conditionalSubExpression.Add(conditionalSubExpression318.Tree);
            	        	
            	        	// AST REWRITE
            	        	// elements:          conditionalSubExpression, QUESTION, conditionalExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 783:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:783:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.Next(), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    adaptor.AddChild(root_1, stream_conditionalSubExpression.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 97, conditionalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalExpression

    public class conditionalSubExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start conditionalSubExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:786:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
    public conditionalSubExpression_return conditionalSubExpression() // throws RecognitionException [1]
    {   
        conditionalSubExpression_return retval = new conditionalSubExpression_return();
        retval.start = input.LT(1);
        int conditionalSubExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken COLON320 = null;
        assignmentExpression_return assignmentExpression319 = null;

        assignmentExpression_return assignmentExpression321 = null;
        
        
        CommonTree COLON320_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 98) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:787:4: ( assignmentExpression COLON assignmentExpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:787:4: assignmentExpression COLON assignmentExpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3459);
            	assignmentExpression319 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression319.Tree);
            	COLON320 = (IToken)input.LT(1);
            	Match(input,COLON,FOLLOW_COLON_in_conditionalSubExpression3461); if (failed) return retval;
            	if ( backtracking==0 ) {
            	COLON320_tree = (CommonTree)adaptor.Create(COLON320);
            	root_0 = (CommonTree)adaptor.BecomeRoot(COLON320_tree, root_0);
            	}
            	PushFollow(FOLLOW_assignmentExpression_in_conditionalSubExpression3464);
            	assignmentExpression321 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, assignmentExpression321.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 98, conditionalSubExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end conditionalSubExpression

    public class logicalOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:793:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
    public logicalOrExpression_return logicalOrExpression() // throws RecognitionException [1]
    {   
        logicalOrExpression_return retval = new logicalOrExpression_return();
        retval.start = input.LT(1);
        int logicalOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        logicalAndExpression_return logicalAndExpression322 = null;

        logicalOrOperator_return logicalOrOperator323 = null;

        logicalAndExpression_return logicalAndExpression324 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 99) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:794:4: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:794:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3478);
            	logicalAndExpression322 = logicalAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression322.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:795:3: ( logicalOrOperator logicalAndExpression )*
            	do 
            	{
            	    int alt84 = 2;
            	    int LA84_0 = input.LA(1);
            	    
            	    if ( (LA84_0 == LOR || LA84_0 == 187) )
            	    {
            	        alt84 = 1;
            	    }
            	    
            	
            	    switch (alt84) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:795:4: logicalOrOperator logicalAndExpression
            			    {
            			    	PushFollow(FOLLOW_logicalOrOperator_in_logicalOrExpression3483);
            			    	logicalOrOperator323 = logicalOrOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(logicalOrOperator323.Tree, root_0);
            			    	PushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression3486);
            			    	logicalAndExpression324 = logicalAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, logicalAndExpression324.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop84;
            	    }
            	} while (true);
            	
            	loop84:
            		;	// Stops C# compiler whinging that label 'loop84' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 99, logicalOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrExpression

    public class logicalOrOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalOrOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:798:1: logicalOrOperator : ( LOR | 'or' );
    public logicalOrOperator_return logicalOrOperator() // throws RecognitionException [1]
    {   
        logicalOrOperator_return retval = new logicalOrOperator_return();
        retval.start = input.LT(1);
        int logicalOrOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set325 = null;
        
        CommonTree set325_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 100) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:799:4: ( LOR | 'or' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set325 = (IToken)input.LT(1);
            	if ( input.LA(1) == LOR || input.LA(1) == 187 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set325));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalOrOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 100, logicalOrOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalOrOperator

    public class logicalAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:803:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
    public logicalAndExpression_return logicalAndExpression() // throws RecognitionException [1]
    {   
        logicalAndExpression_return retval = new logicalAndExpression_return();
        retval.start = input.LT(1);
        int logicalAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        bitwiseOrExpression_return bitwiseOrExpression326 = null;

        logicalAndOperator_return logicalAndOperator327 = null;

        bitwiseOrExpression_return bitwiseOrExpression328 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 101) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:804:4: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:804:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3515);
            	bitwiseOrExpression326 = bitwiseOrExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression326.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:805:3: ( logicalAndOperator bitwiseOrExpression )*
            	do 
            	{
            	    int alt85 = 2;
            	    int LA85_0 = input.LA(1);
            	    
            	    if ( (LA85_0 == LAND || LA85_0 == 188) )
            	    {
            	        alt85 = 1;
            	    }
            	    
            	
            	    switch (alt85) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:805:4: logicalAndOperator bitwiseOrExpression
            			    {
            			    	PushFollow(FOLLOW_logicalAndOperator_in_logicalAndExpression3520);
            			    	logicalAndOperator327 = logicalAndOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(logicalAndOperator327.Tree, root_0);
            			    	PushFollow(FOLLOW_bitwiseOrExpression_in_logicalAndExpression3523);
            			    	bitwiseOrExpression328 = bitwiseOrExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseOrExpression328.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop85;
            	    }
            	} while (true);
            	
            	loop85:
            		;	// Stops C# compiler whinging that label 'loop85' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 101, logicalAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndExpression

    public class logicalAndOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start logicalAndOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:808:1: logicalAndOperator : ( LAND | 'and' );
    public logicalAndOperator_return logicalAndOperator() // throws RecognitionException [1]
    {   
        logicalAndOperator_return retval = new logicalAndOperator_return();
        retval.start = input.LT(1);
        int logicalAndOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set329 = null;
        
        CommonTree set329_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 102) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:809:4: ( LAND | 'and' )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set329 = (IToken)input.LT(1);
            	if ( input.LA(1) == LAND || input.LA(1) == 188 ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set329));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_logicalAndOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 102, logicalAndOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end logicalAndOperator

    public class bitwiseOrExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseOrExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:813:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
    public bitwiseOrExpression_return bitwiseOrExpression() // throws RecognitionException [1]
    {   
        bitwiseOrExpression_return retval = new bitwiseOrExpression_return();
        retval.start = input.LT(1);
        int bitwiseOrExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BOR331 = null;
        bitwiseXorExpression_return bitwiseXorExpression330 = null;

        bitwiseXorExpression_return bitwiseXorExpression332 = null;
        
        
        CommonTree BOR331_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 103) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:814:4: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:814:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3552);
            	bitwiseXorExpression330 = bitwiseXorExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression330.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:815:3: ( BOR bitwiseXorExpression )*
            	do 
            	{
            	    int alt86 = 2;
            	    int LA86_0 = input.LA(1);
            	    
            	    if ( (LA86_0 == BOR) )
            	    {
            	        alt86 = 1;
            	    }
            	    
            	
            	    switch (alt86) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:815:4: BOR bitwiseXorExpression
            			    {
            			    	BOR331 = (IToken)input.LT(1);
            			    	Match(input,BOR,FOLLOW_BOR_in_bitwiseOrExpression3557); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BOR331_tree = (CommonTree)adaptor.Create(BOR331);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BOR331_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3560);
            			    	bitwiseXorExpression332 = bitwiseXorExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseXorExpression332.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop86;
            	    }
            	} while (true);
            	
            	loop86:
            		;	// Stops C# compiler whinging that label 'loop86' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 103, bitwiseOrExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseOrExpression

    public class bitwiseXorExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseXorExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:819:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
    public bitwiseXorExpression_return bitwiseXorExpression() // throws RecognitionException [1]
    {   
        bitwiseXorExpression_return retval = new bitwiseXorExpression_return();
        retval.start = input.LT(1);
        int bitwiseXorExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BXOR334 = null;
        bitwiseAndExpression_return bitwiseAndExpression333 = null;

        bitwiseAndExpression_return bitwiseAndExpression335 = null;
        
        
        CommonTree BXOR334_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 104) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:820:4: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:820:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3574);
            	bitwiseAndExpression333 = bitwiseAndExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression333.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:821:3: ( BXOR bitwiseAndExpression )*
            	do 
            	{
            	    int alt87 = 2;
            	    int LA87_0 = input.LA(1);
            	    
            	    if ( (LA87_0 == BXOR) )
            	    {
            	        alt87 = 1;
            	    }
            	    
            	
            	    switch (alt87) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:821:4: BXOR bitwiseAndExpression
            			    {
            			    	BXOR334 = (IToken)input.LT(1);
            			    	Match(input,BXOR,FOLLOW_BXOR_in_bitwiseXorExpression3579); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BXOR334_tree = (CommonTree)adaptor.Create(BXOR334);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BXOR334_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3582);
            			    	bitwiseAndExpression335 = bitwiseAndExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, bitwiseAndExpression335.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop87;
            	    }
            	} while (true);
            	
            	loop87:
            		;	// Stops C# compiler whinging that label 'loop87' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 104, bitwiseXorExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseXorExpression

    public class bitwiseAndExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start bitwiseAndExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:825:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
    public bitwiseAndExpression_return bitwiseAndExpression() // throws RecognitionException [1]
    {   
        bitwiseAndExpression_return retval = new bitwiseAndExpression_return();
        retval.start = input.LT(1);
        int bitwiseAndExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken BAND337 = null;
        equalityExpression_return equalityExpression336 = null;

        equalityExpression_return equalityExpression338 = null;
        
        
        CommonTree BAND337_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 105) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:826:4: ( equalityExpression ( BAND equalityExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:826:4: equalityExpression ( BAND equalityExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3596);
            	equalityExpression336 = equalityExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression336.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:827:3: ( BAND equalityExpression )*
            	do 
            	{
            	    int alt88 = 2;
            	    int LA88_0 = input.LA(1);
            	    
            	    if ( (LA88_0 == BAND) )
            	    {
            	        alt88 = 1;
            	    }
            	    
            	
            	    switch (alt88) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:827:4: BAND equalityExpression
            			    {
            			    	BAND337 = (IToken)input.LT(1);
            			    	Match(input,BAND,FOLLOW_BAND_in_bitwiseAndExpression3601); if (failed) return retval;
            			    	if ( backtracking==0 ) {
            			    	BAND337_tree = (CommonTree)adaptor.Create(BAND337);
            			    	root_0 = (CommonTree)adaptor.BecomeRoot(BAND337_tree, root_0);
            			    	}
            			    	PushFollow(FOLLOW_equalityExpression_in_bitwiseAndExpression3604);
            			    	equalityExpression338 = equalityExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, equalityExpression338.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop88;
            	    }
            	} while (true);
            	
            	loop88:
            		;	// Stops C# compiler whinging that label 'loop88' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 105, bitwiseAndExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end bitwiseAndExpression

    public class equalityExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:831:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
    public equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {   
        equalityExpression_return retval = new equalityExpression_return();
        retval.start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        relationalExpression_return relationalExpression339 = null;

        equalityOperator_return equalityOperator340 = null;

        relationalExpression_return relationalExpression341 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 106) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:832:4: ( relationalExpression ( equalityOperator relationalExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:832:4: relationalExpression ( equalityOperator relationalExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_relationalExpression_in_equalityExpression3618);
            	relationalExpression339 = relationalExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression339.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:833:2: ( equalityOperator relationalExpression )*
            	do 
            	{
            	    int alt89 = 2;
            	    int LA89_0 = input.LA(1);
            	    
            	    if ( ((LA89_0 >= STRICT_EQUAL && LA89_0 <= EQUAL)) )
            	    {
            	        alt89 = 1;
            	    }
            	    
            	
            	    switch (alt89) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:833:4: equalityOperator relationalExpression
            			    {
            			    	PushFollow(FOLLOW_equalityOperator_in_equalityExpression3623);
            			    	equalityOperator340 = equalityOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(equalityOperator340.Tree, root_0);
            			    	PushFollow(FOLLOW_relationalExpression_in_equalityExpression3628);
            			    	relationalExpression341 = relationalExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, relationalExpression341.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop89;
            	    }
            	} while (true);
            	
            	loop89:
            		;	// Stops C# compiler whinging that label 'loop89' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 106, equalityExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityExpression

    public class equalityOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start equalityOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:838:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
    public equalityOperator_return equalityOperator() // throws RecognitionException [1]
    {   
        equalityOperator_return retval = new equalityOperator_return();
        retval.start = input.LT(1);
        int equalityOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set342 = null;
        
        CommonTree set342_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 107) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:839:4: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set342 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= STRICT_EQUAL && input.LA(1) <= EQUAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set342));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_equalityOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 107, equalityOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end equalityOperator

    public class relationalExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:843:1: relationalExpression : shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* ;
    public relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {   
        relationalExpression_return retval = new relationalExpression_return();
        retval.start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        shiftExpression_return shiftExpression343 = null;

        relationalOperator_return relationalOperator344 = null;

        shiftExpression_return shiftExpression345 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 108) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:844:4: ( shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:844:4: shiftExpression ( ( relationalOperator )=> relationalOperator shiftExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_shiftExpression_in_relationalExpression3668);
            	shiftExpression343 = shiftExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression343.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:3: ( ( relationalOperator )=> relationalOperator shiftExpression )*
            	do 
            	{
            	    int alt90 = 2;
            	    int LA90_0 = input.LA(1);
            	    
            	    if ( (LA90_0 == LT) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA90_83 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA90_85 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA90_86 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA90_87 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA90_88 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA90_89 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA90_92 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA90_96 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA90_97 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA90_113 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA90_115 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA90_116 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA90_117 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA90_118 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA90_119 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA90_120 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA90_121 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA90_123 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA90_124 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA90_125 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA90_126 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA90_127 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA90_128 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA90_129 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA90_130 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA90_131 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA90_132 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA90_133 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA90_134 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA90_135 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA90_136 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA90_137 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA90_138 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA90_0 == IS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA90_153 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA90_155 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA90_156 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA90_157 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA90_158 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA90_159 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA90_162 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA90_166 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA90_167 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA90_180 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA90_182 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA90_183 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA90_184 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA90_185 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA90_186 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA90_187 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA90_188 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA90_190 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA90_191 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA90_192 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA90_193 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA90_194 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA90_195 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA90_196 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA90_197 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA90_198 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA90_199 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA90_200 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA90_201 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA90_202 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA90_203 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA90_204 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA90_205 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA90_0 == AS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA90_223 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA90_225 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA90_226 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA90_227 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA90_228 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA90_229 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA90_232 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA90_236 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA90_237 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA90_253 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA90_255 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA90_256 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA90_257 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA90_258 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA90_259 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA90_260 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA90_261 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA90_263 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA90_264 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA90_265 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA90_266 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA90_267 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA90_268 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA90_269 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA90_270 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA90_271 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA90_272 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA90_273 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA90_274 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA90_275 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA90_276 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA90_277 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA90_278 = input.LA(3);
            	            
            	            if ( (synpred148()) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA90_0 == IN) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA90_293 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA90_294 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA90_295 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA90_296 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA90_297 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA90_298 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA90_299 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA90_300 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA90_301 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA90_302 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA90_303 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA90_304 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA90_305 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA90_306 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA90_307 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA90_308 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA90_309 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA90_310 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA90_311 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA90_312 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA90_313 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA90_314 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA90_315 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA90_316 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA90_317 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA90_318 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA90_319 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA90_320 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA90_321 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA90_322 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA90_323 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA90_324 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA90_325 = input.LA(3);
            	            
            	            if ( ((synpred148() && ((InOperator_scope)InOperator_stack.Peek()).allowed)) )
            	            {
            	                alt90 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA90_0 == GT) && (synpred148()) )
            	    {
            	        alt90 = 1;
            	    }
            	    else if ( (LA90_0 == LE) && (synpred148()) )
            	    {
            	        alt90 = 1;
            	    }
            	    else if ( (LA90_0 == GE) && (synpred148()) )
            	    {
            	        alt90 = 1;
            	    }
            	    else if ( (LA90_0 == INSTANCEOF) && (synpred148()) )
            	    {
            	        alt90 = 1;
            	    }
            	    
            	
            	    switch (alt90) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:4: ( relationalOperator )=> relationalOperator shiftExpression
            			    {
            			    	PushFollow(FOLLOW_relationalOperator_in_relationalExpression3678);
            			    	relationalOperator344 = relationalOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(relationalOperator344.Tree, root_0);
            			    	PushFollow(FOLLOW_shiftExpression_in_relationalExpression3681);
            			    	shiftExpression345 = shiftExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, shiftExpression345.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop90;
            	    }
            	} while (true);
            	
            	loop90:
            		;	// Stops C# compiler whinging that label 'loop90' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 108, relationalExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalExpression

    public class relationalOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start relationalOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:848:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );
    public relationalOperator_return relationalOperator() // throws RecognitionException [1]
    {   
        relationalOperator_return retval = new relationalOperator_return();
        retval.start = input.LT(1);
        int relationalOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken IN346 = null;
        IToken LT347 = null;
        IToken GT348 = null;
        IToken LE349 = null;
        IToken GE350 = null;
        IToken IS351 = null;
        IToken AS352 = null;
        IToken INSTANCEOF353 = null;
        
        CommonTree IN346_tree=null;
        CommonTree LT347_tree=null;
        CommonTree GT348_tree=null;
        CommonTree LE349_tree=null;
        CommonTree GE350_tree=null;
        CommonTree IS351_tree=null;
        CommonTree AS352_tree=null;
        CommonTree INSTANCEOF353_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 109) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:849:4: ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF )
            int alt91 = 8;
            switch ( input.LA(1) ) 
            {
            case IN:
            	{
                alt91 = 1;
                }
                break;
            case LT:
            	{
                alt91 = 2;
                }
                break;
            case GT:
            	{
                alt91 = 3;
                }
                break;
            case LE:
            	{
                alt91 = 4;
                }
                break;
            case GE:
            	{
                alt91 = 5;
                }
                break;
            case IS:
            	{
                alt91 = 6;
                }
                break;
            case AS:
            	{
                alt91 = 7;
                }
                break;
            case INSTANCEOF:
            	{
                alt91 = 8;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d91s0 =
            	        new NoViableAltException("848:1: relationalOperator : ({...}? IN | LT | GT | LE | GE | IS | AS | INSTANCEOF );", 91, 0, input);
            
            	    throw nvae_d91s0;
            }
            
            switch (alt91) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:849:4: {...}? IN
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	if ( !(((InOperator_scope)InOperator_stack.Peek()).allowed) ) 
                    	{
                    	    if ( backtracking > 0 ) {failed = true; return retval;}
                    	    throw new FailedPredicateException(input, "relationalOperator", "$InOperator::allowed");
                    	}
                    	IN346 = (IToken)input.LT(1);
                    	Match(input,IN,FOLLOW_IN_in_relationalOperator3696); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IN346_tree = (CommonTree)adaptor.Create(IN346);
                    	adaptor.AddChild(root_0, IN346_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:4: LT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LT347 = (IToken)input.LT(1);
                    	Match(input,LT,FOLLOW_LT_in_relationalOperator3701); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LT347_tree = (CommonTree)adaptor.Create(LT347);
                    	adaptor.AddChild(root_0, LT347_tree);
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:9: GT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GT348 = (IToken)input.LT(1);
                    	Match(input,GT,FOLLOW_GT_in_relationalOperator3705); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GT348_tree = (CommonTree)adaptor.Create(GT348);
                    	adaptor.AddChild(root_0, GT348_tree);
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:14: LE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	LE349 = (IToken)input.LT(1);
                    	Match(input,LE,FOLLOW_LE_in_relationalOperator3709); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	LE349_tree = (CommonTree)adaptor.Create(LE349);
                    	adaptor.AddChild(root_0, LE349_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:19: GE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	GE350 = (IToken)input.LT(1);
                    	Match(input,GE,FOLLOW_GE_in_relationalOperator3713); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	GE350_tree = (CommonTree)adaptor.Create(GE350);
                    	adaptor.AddChild(root_0, GE350_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:24: IS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IS351 = (IToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_relationalOperator3717); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IS351_tree = (CommonTree)adaptor.Create(IS351);
                    	adaptor.AddChild(root_0, IS351_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:29: AS
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	AS352 = (IToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_relationalOperator3721); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	AS352_tree = (CommonTree)adaptor.Create(AS352);
                    	adaptor.AddChild(root_0, AS352_tree);
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:850:34: INSTANCEOF
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	INSTANCEOF353 = (IToken)input.LT(1);
                    	Match(input,INSTANCEOF,FOLLOW_INSTANCEOF_in_relationalOperator3725); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	INSTANCEOF353_tree = (CommonTree)adaptor.Create(INSTANCEOF353);
                    	adaptor.AddChild(root_0, INSTANCEOF353_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 109, relationalOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end relationalOperator

    public class shiftExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:854:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
    public shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {   
        shiftExpression_return retval = new shiftExpression_return();
        retval.start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        additiveExpression_return additiveExpression354 = null;

        shiftOperator_return shiftOperator355 = null;

        additiveExpression_return additiveExpression356 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 110) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:855:4: ( additiveExpression ( shiftOperator additiveExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:855:4: additiveExpression ( shiftOperator additiveExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_additiveExpression_in_shiftExpression3737);
            	additiveExpression354 = additiveExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression354.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:3: ( shiftOperator additiveExpression )*
            	do 
            	{
            	    int alt92 = 2;
            	    int LA92_0 = input.LA(1);
            	    
            	    if ( ((LA92_0 >= SL && LA92_0 <= BSR)) )
            	    {
            	        alt92 = 1;
            	    }
            	    
            	
            	    switch (alt92) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:856:4: shiftOperator additiveExpression
            			    {
            			    	PushFollow(FOLLOW_shiftOperator_in_shiftExpression3742);
            			    	shiftOperator355 = shiftOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(shiftOperator355.Tree, root_0);
            			    	PushFollow(FOLLOW_additiveExpression_in_shiftExpression3745);
            			    	additiveExpression356 = additiveExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, additiveExpression356.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop92;
            	    }
            	} while (true);
            	
            	loop92:
            		;	// Stops C# compiler whinging that label 'loop92' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 110, shiftExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftExpression

    public class shiftOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shiftOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:859:1: shiftOperator : ( SL | SR | BSR );
    public shiftOperator_return shiftOperator() // throws RecognitionException [1]
    {   
        shiftOperator_return retval = new shiftOperator_return();
        retval.start = input.LT(1);
        int shiftOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set357 = null;
        
        CommonTree set357_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 111) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:860:4: ( SL | SR | BSR )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set357 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= SL && input.LA(1) <= BSR) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set357));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_shiftOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 111, shiftOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shiftOperator

    public class additiveExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:864:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
    public additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {   
        additiveExpression_return retval = new additiveExpression_return();
        retval.start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        multiplicativeExpression_return multiplicativeExpression358 = null;

        additiveOperator_return additiveOperator359 = null;

        multiplicativeExpression_return multiplicativeExpression360 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 112) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:865:4: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:865:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3778);
            	multiplicativeExpression358 = multiplicativeExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression358.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:3: ( additiveOperator multiplicativeExpression )*
            	do 
            	{
            	    int alt93 = 2;
            	    int LA93_0 = input.LA(1);
            	    
            	    if ( (LA93_0 == MINUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA93_83 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA93_84 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA93_85 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA93_86 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA93_87 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA93_88 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA93_89 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA93_90 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA93_91 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA93_92 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA93_93 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA93_94 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA93_95 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA93_96 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA93_97 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA93_98 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA93_99 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA93_100 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA93_101 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA93_102 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA93_103 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA93_104 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA93_105 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA93_106 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA93_107 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA93_108 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA93_109 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA93_110 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA93_111 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA93_112 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA93_113 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA93_114 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA93_115 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA93_0 == PLUS) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case INC:
            	        	{
            	            int LA93_116 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA93_117 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA93_118 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA93_119 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA93_120 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA93_121 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA93_122 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA93_123 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA93_124 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA93_125 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA93_126 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA93_127 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA93_128 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA93_129 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA93_130 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA93_131 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA93_132 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA93_133 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA93_134 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA93_135 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA93_136 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA93_137 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA93_138 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA93_139 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA93_140 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA93_141 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA93_142 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA93_143 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA93_144 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA93_145 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA93_146 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA93_147 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA93_148 = input.LA(3);
            	            
            	            if ( (synpred159()) )
            	            {
            	                alt93 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    
            	
            	    switch (alt93) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:4: additiveOperator multiplicativeExpression
            			    {
            			    	PushFollow(FOLLOW_additiveOperator_in_additiveExpression3783);
            			    	additiveOperator359 = additiveOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(additiveOperator359.Tree, root_0);
            			    	PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3786);
            			    	multiplicativeExpression360 = multiplicativeExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, multiplicativeExpression360.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop93;
            	    }
            	} while (true);
            	
            	loop93:
            		;	// Stops C# compiler whinging that label 'loop93' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 112, additiveExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveExpression

    public class additiveOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start additiveOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:869:1: additiveOperator : ( PLUS | MINUS );
    public additiveOperator_return additiveOperator() // throws RecognitionException [1]
    {   
        additiveOperator_return retval = new additiveOperator_return();
        retval.start = input.LT(1);
        int additiveOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set361 = null;
        
        CommonTree set361_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 113) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:870:4: ( PLUS | MINUS )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set361 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= PLUS && input.LA(1) <= MINUS) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set361));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_additiveOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 113, additiveOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end additiveOperator

    public class multiplicativeExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:874:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
    public multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {   
        multiplicativeExpression_return retval = new multiplicativeExpression_return();
        retval.start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        unaryExpression_return unaryExpression362 = null;

        multiplicativeOperator_return multiplicativeOperator363 = null;

        unaryExpression_return unaryExpression364 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 114) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:875:4: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:875:4: unaryExpression ( multiplicativeOperator unaryExpression )*
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3816);
            	unaryExpression362 = unaryExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression362.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:876:3: ( multiplicativeOperator unaryExpression )*
            	do 
            	{
            	    int alt94 = 2;
            	    int LA94_0 = input.LA(1);
            	    
            	    if ( (LA94_0 == DIV) )
            	    {
            	        switch ( input.LA(2) ) 
            	        {
            	        case LBRACK:
            	        	{
            	            int LA94_85 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA94_87 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA94_88 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA94_89 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA94_90 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA94_91 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA94_94 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA94_98 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA94_99 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA94_112 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA94_114 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA94_115 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA94_116 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA94_117 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA94_118 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA94_119 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA94_120 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA94_122 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA94_123 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA94_124 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA94_125 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA94_126 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA94_127 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA94_128 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA94_129 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA94_130 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA94_131 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA94_132 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA94_133 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA94_134 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA94_135 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA94_136 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA94_137 = input.LA(3);
            	            
            	            if ( (synpred161()) )
            	            {
            	                alt94 = 1;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	    }
            	    else if ( (LA94_0 == STAR || LA94_0 == MOD) )
            	    {
            	        alt94 = 1;
            	    }
            	    
            	
            	    switch (alt94) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:876:5: multiplicativeOperator unaryExpression
            			    {
            			    	PushFollow(FOLLOW_multiplicativeOperator_in_multiplicativeExpression3822);
            			    	multiplicativeOperator363 = multiplicativeOperator();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) root_0 = (CommonTree)adaptor.BecomeRoot(multiplicativeOperator363.Tree, root_0);
            			    	PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression3828);
            			    	unaryExpression364 = unaryExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpression364.Tree);
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop94;
            	    }
            	} while (true);
            	
            	loop94:
            		;	// Stops C# compiler whinging that label 'loop94' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 114, multiplicativeExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeExpression

    public class multiplicativeOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multiplicativeOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:881:1: multiplicativeOperator : ( STAR | DIV | MOD );
    public multiplicativeOperator_return multiplicativeOperator() // throws RecognitionException [1]
    {   
        multiplicativeOperator_return retval = new multiplicativeOperator_return();
        retval.start = input.LT(1);
        int multiplicativeOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set365 = null;
        
        CommonTree set365_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 115) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:882:4: ( STAR | DIV | MOD )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set365 = (IToken)input.LT(1);
            	if ( input.LA(1) == STAR || (input.LA(1) >= DIV && input.LA(1) <= MOD) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set365));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_multiplicativeOperator0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 115, multiplicativeOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multiplicativeOperator

    public class unaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:886:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );
    public unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {   
        unaryExpression_return retval = new unaryExpression_return();
        retval.start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken iin = null;
        IToken dde = null;
        IToken MINUS368 = null;
        IToken PLUS370 = null;
        unaryExpression_return unaryExpression366 = null;

        unaryExpression_return unaryExpression367 = null;

        unaryExpression_return unaryExpression369 = null;

        unaryExpression_return unaryExpression371 = null;

        unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus372 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree MINUS368_tree=null;
        CommonTree PLUS370_tree=null;
        RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream(adaptor,"token PLUS");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_MINUS = new RewriteRuleTokenStream(adaptor,"token MINUS");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 116) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:4: (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus )
            int alt95 = 5;
            switch ( input.LA(1) ) 
            {
            case INC:
            	{
                alt95 = 1;
                }
                break;
            case DEC:
            	{
                alt95 = 2;
                }
                break;
            case MINUS:
            	{
                alt95 = 3;
                }
                break;
            case PLUS:
            	{
                alt95 = 4;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case DIV:
            case DELETE:
            case TYPEOF:
            case LNOT:
            case BNOT:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            case 181:
            	{
                alt95 = 5;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d95s0 =
            	        new NoViableAltException("886:1: unaryExpression : (iin= INC unaryExpression -> ^( PRE_INC[$iin] unaryExpression ) | dde= DEC unaryExpression -> ^( PRE_DEC[$dde] unaryExpression ) | MINUS unaryExpression -> ^( UNARY_MINUS unaryExpression ) | PLUS unaryExpression -> ^( UNARY_PLUS unaryExpression ) | unaryExpressionNotPlusMinus );", 95, 0, input);
            
            	    throw nvae_d95s0;
            }
            
            switch (alt95) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:4: iin= INC unaryExpression
                    {
                    	iin = (IToken)input.LT(1);
                    	Match(input,INC,FOLLOW_INC_in_unaryExpression3866); if (failed) return retval;
                    	if ( backtracking==0 ) stream_INC.Add(iin);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression3868);
                    	unaryExpression366 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression366.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 887:28: -> ^( PRE_INC[$iin] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:887:31: ^( PRE_INC[$iin] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_INC, iin), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:888:4: dde= DEC unaryExpression
                    {
                    	dde = (IToken)input.LT(1);
                    	Match(input,DEC,FOLLOW_DEC_in_unaryExpression3884); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DEC.Add(dde);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression3886);
                    	unaryExpression367 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression367.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 888:28: -> ^( PRE_DEC[$dde] unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:888:31: ^( PRE_DEC[$dde] unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PRE_DEC, dde), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:889:4: MINUS unaryExpression
                    {
                    	MINUS368 = (IToken)input.LT(1);
                    	Match(input,MINUS,FOLLOW_MINUS_in_unaryExpression3900); if (failed) return retval;
                    	if ( backtracking==0 ) stream_MINUS.Add(MINUS368);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression3902);
                    	unaryExpression369 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression369.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 889:26: -> ^( UNARY_MINUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:889:29: ^( UNARY_MINUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:890:4: PLUS unaryExpression
                    {
                    	PLUS370 = (IToken)input.LT(1);
                    	Match(input,PLUS,FOLLOW_PLUS_in_unaryExpression3915); if (failed) return retval;
                    	if ( backtracking==0 ) stream_PLUS.Add(PLUS370);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpression3917);
                    	unaryExpression371 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression371.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 890:25: -> ^( UNARY_PLUS unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:890:28: ^( UNARY_PLUS unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(UNARY_PLUS, "UNARY_PLUS"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:891:4: unaryExpressionNotPlusMinus
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3930);
                    	unaryExpressionNotPlusMinus372 = unaryExpressionNotPlusMinus();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus372.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 116, unaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpression

    public class unaryExpressionNotPlusMinus_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start unaryExpressionNotPlusMinus
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:894:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
    public unaryExpressionNotPlusMinus_return unaryExpressionNotPlusMinus() // throws RecognitionException [1]
    {   
        unaryExpressionNotPlusMinus_return retval = new unaryExpressionNotPlusMinus_return();
        retval.start = input.LT(1);
        int unaryExpressionNotPlusMinus_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DELETE373 = null;
        IToken string_literal375 = null;
        IToken TYPEOF377 = null;
        IToken LNOT379 = null;
        IToken BNOT381 = null;
        postfixExpression_return postfixExpression374 = null;

        unaryExpression_return unaryExpression376 = null;

        unaryExpression_return unaryExpression378 = null;

        unaryExpression_return unaryExpression380 = null;

        unaryExpression_return unaryExpression382 = null;

        postfixExpression_return postfixExpression383 = null;
        
        
        CommonTree DELETE373_tree=null;
        CommonTree string_literal375_tree=null;
        CommonTree TYPEOF377_tree=null;
        CommonTree LNOT379_tree=null;
        CommonTree BNOT381_tree=null;
        RewriteRuleTokenStream stream_BNOT = new RewriteRuleTokenStream(adaptor,"token BNOT");
        RewriteRuleTokenStream stream_LNOT = new RewriteRuleTokenStream(adaptor,"token LNOT");
        RewriteRuleTokenStream stream_TYPEOF = new RewriteRuleTokenStream(adaptor,"token TYPEOF");
        RewriteRuleTokenStream stream_DELETE = new RewriteRuleTokenStream(adaptor,"token DELETE");
        RewriteRuleTokenStream stream_181 = new RewriteRuleTokenStream(adaptor,"token 181");
        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
        RewriteRuleSubtreeStream stream_postfixExpression = new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 117) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:4: ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
            int alt96 = 6;
            switch ( input.LA(1) ) 
            {
            case DELETE:
            	{
                alt96 = 1;
                }
                break;
            case 181:
            	{
                alt96 = 2;
                }
                break;
            case TYPEOF:
            	{
                alt96 = 3;
                }
                break;
            case LNOT:
            	{
                alt96 = 4;
                }
                break;
            case BNOT:
            	{
                alt96 = 5;
                }
                break;
            case LCURLY:
            case STRING_LITERAL:
            case FUNCTION:
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case LPAREN:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case LBRACK:
            case DYNAMIC:
            case LT:
            case IS:
            case AS:
            case DIV:
            case E4X_ATTRI:
            case UNDEFINED:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            case NEW:
            	{
                alt96 = 6;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d96s0 =
            	        new NoViableAltException("894:1: unaryExpressionNotPlusMinus : ( DELETE postfixExpression -> ^( DELETE postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | TYPEOF unaryExpression -> ^( TYPEOF unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );", 96, 0, input);
            
            	    throw nvae_d96s0;
            }
            
            switch (alt96) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:4: DELETE postfixExpression
                    {
                    	DELETE373 = (IToken)input.LT(1);
                    	Match(input,DELETE,FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3941); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DELETE.Add(DELETE373);

                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3943);
                    	postfixExpression374 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_postfixExpression.Add(postfixExpression374.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          postfixExpression, DELETE
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 895:29: -> ^( DELETE postfixExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:895:32: ^( DELETE postfixExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DELETE.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_postfixExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:4: 'void' unaryExpression
                    {
                    	string_literal375 = (IToken)input.LT(1);
                    	Match(input,181,FOLLOW_181_in_unaryExpressionNotPlusMinus3956); if (failed) return retval;
                    	if ( backtracking==0 ) stream_181.Add(string_literal375);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3958);
                    	unaryExpression376 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression376.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, 181
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 896:27: -> ^( 'void' unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:896:30: ^( 'void' unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_181.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:4: TYPEOF unaryExpression
                    {
                    	TYPEOF377 = (IToken)input.LT(1);
                    	Match(input,TYPEOF,FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3971); if (failed) return retval;
                    	if ( backtracking==0 ) stream_TYPEOF.Add(TYPEOF377);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3973);
                    	unaryExpression378 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression378.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, TYPEOF
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 897:27: -> ^( TYPEOF unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:897:30: ^( TYPEOF unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_TYPEOF.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:898:4: LNOT unaryExpression
                    {
                    	LNOT379 = (IToken)input.LT(1);
                    	Match(input,LNOT,FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3986); if (failed) return retval;
                    	if ( backtracking==0 ) stream_LNOT.Add(LNOT379);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3988);
                    	unaryExpression380 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression380.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          LNOT, unaryExpression
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 898:25: -> ^( LNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:898:28: ^( LNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:899:4: BNOT unaryExpression
                    {
                    	BNOT381 = (IToken)input.LT(1);
                    	Match(input,BNOT,FOLLOW_BNOT_in_unaryExpressionNotPlusMinus4001); if (failed) return retval;
                    	if ( backtracking==0 ) stream_BNOT.Add(BNOT381);

                    	PushFollow(FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4003);
                    	unaryExpression382 = unaryExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_unaryExpression.Add(unaryExpression382.Tree);
                    	
                    	// AST REWRITE
                    	// elements:          unaryExpression, BNOT
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 899:25: -> ^( BNOT unaryExpression )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:899:28: ^( BNOT unaryExpression )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.Next(), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_unaryExpression.Next());
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:900:4: postfixExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4016);
                    	postfixExpression383 = postfixExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, postfixExpression383.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 117, unaryExpressionNotPlusMinus_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end unaryExpressionNotPlusMinus

    public class postfixExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start postfixExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:904:1: postfixExpression : ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? ;
    public postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {   
        postfixExpression_return retval = new postfixExpression_return();
        retval.start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken iin = null;
        IToken dde = null;
        IToken DOT385 = null;
        IToken LBRACK387 = null;
        IToken RBRACK389 = null;
        IToken E4X_DESC390 = null;
        propOrIdent_return poi = null;

        primaryExpression_return primaryExpression384 = null;

        e4xExpression_return e4xExpression386 = null;

        expression_return expression388 = null;

        e4xExpression_return e4xExpression391 = null;

        arguments_return arguments392 = null;
        
        
        CommonTree iin_tree=null;
        CommonTree dde_tree=null;
        CommonTree DOT385_tree=null;
        CommonTree LBRACK387_tree=null;
        CommonTree RBRACK389_tree=null;
        CommonTree E4X_DESC390_tree=null;
        RewriteRuleTokenStream stream_LBRACK = new RewriteRuleTokenStream(adaptor,"token LBRACK");
        RewriteRuleTokenStream stream_E4X_DESC = new RewriteRuleTokenStream(adaptor,"token E4X_DESC");
        RewriteRuleTokenStream stream_INC = new RewriteRuleTokenStream(adaptor,"token INC");
        RewriteRuleTokenStream stream_RBRACK = new RewriteRuleTokenStream(adaptor,"token RBRACK");
        RewriteRuleTokenStream stream_DEC = new RewriteRuleTokenStream(adaptor,"token DEC");
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_arguments = new RewriteRuleSubtreeStream(adaptor,"rule arguments");
        RewriteRuleSubtreeStream stream_e4xExpression = new RewriteRuleSubtreeStream(adaptor,"rule e4xExpression");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_propOrIdent = new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
        RewriteRuleSubtreeStream stream_expression = new RewriteRuleSubtreeStream(adaptor,"rule expression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 118) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:4: ( ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )? )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:4: ( primaryExpression -> primaryExpression ) (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )* (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:905:5: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_postfixExpression4029);
            		primaryExpression384 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression384.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 905:23: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:906:3: (poi= propOrIdent[root_0, retval.start] -> $poi | DOT e4xExpression | LBRACK expression RBRACK -> ^( ARRAY_ACC $postfixExpression expression ) | E4X_DESC e4xExpression | arguments -> ^( METHOD_CALL $postfixExpression arguments ) )*
            	do 
            	{
            	    int alt97 = 6;
            	    switch ( input.LA(1) ) 
            	    {
            	    case LBRACK:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case IDENT:
            	        	{
            	            int LA97_86 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA97_87 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA97_88 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA97_89 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA97_90 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA97_91 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA97_92 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA97_93 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA97_94 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA97_95 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA97_96 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA97_97 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA97_98 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA97_99 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA97_100 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA97_101 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA97_102 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA97_103 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA97_104 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA97_105 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA97_106 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA97_107 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA97_108 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA97_109 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA97_110 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA97_111 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA97_112 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA97_113 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA97_114 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA97_115 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA97_116 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA97_117 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA97_118 = input.LA(3);
            	            
            	            if ( (synpred175()) )
            	            {
            	                alt97 = 3;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case LPAREN:
            	    	{
            	        switch ( input.LA(2) ) 
            	        {
            	        case RPAREN:
            	        	{
            	            alt97 = 5;
            	            }
            	            break;
            	        case INC:
            	        	{
            	            int LA97_121 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA97_122 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA97_123 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA97_124 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA97_125 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA97_126 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA97_127 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA97_128 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA97_129 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA97_130 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA97_131 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA97_132 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA97_133 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA97_134 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA97_135 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA97_136 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA97_137 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA97_138 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA97_139 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA97_140 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA97_141 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA97_142 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA97_143 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA97_144 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA97_145 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA97_146 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA97_147 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA97_148 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA97_149 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA97_150 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA97_151 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA97_152 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA97_153 = input.LA(3);
            	            
            	            if ( (synpred177()) )
            	            {
            	                alt97 = 5;
            	            }
            	            
            	        
            	            }
            	            break;
            	        
            	        }
            	    
            	        }
            	        break;
            	    case DOT:
            	    	{
            	        int LA97_84 = input.LA(2);
            	        
            	        if ( (LA97_84 == LPAREN || LA97_84 == STAR || LA97_84 == E4X_ATTRI) )
            	        {
            	            alt97 = 2;
            	        }
            	        else if ( ((LA97_84 >= GET && LA97_84 <= USE) || LA97_84 == XML || (LA97_84 >= IDENT && LA97_84 <= INTERNAL) || LA97_84 == DYNAMIC || (LA97_84 >= IS && LA97_84 <= AS)) )
            	        {
            	            alt97 = 1;
            	        }
            	        
            	    
            	        }
            	        break;
            	    case E4X_DESC:
            	    	{
            	        alt97 = 4;
            	        }
            	        break;
            	    
            	    }
            	
            	    switch (alt97) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:906:5: poi= propOrIdent[root_0, retval.start]
            			    {
            			    	PushFollow(FOLLOW_propOrIdent_in_postfixExpression4042);
            			    	poi = propOrIdent(root_0,  retval.start);
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_propOrIdent.Add(poi.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          poi
            			    	// token labels:      
            			    	// rule labels:       retval, poi
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	RewriteRuleSubtreeStream stream_poi = new RewriteRuleSubtreeStream(adaptor, "token poi", (poi!=null ? poi.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 906:43: -> $poi
            			    	{
            			    	    adaptor.AddChild(root_0, stream_poi.Next());
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:907:5: DOT e4xExpression
            			    {
            			    	DOT385 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_postfixExpression4054); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT385);

            			    	PushFollow(FOLLOW_e4xExpression_in_postfixExpression4056);
            			    	e4xExpression386 = e4xExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_e4xExpression.Add(e4xExpression386.Tree);
            			    
            			    }
            			    break;
            			case 3 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:908:5: LBRACK expression RBRACK
            			    {
            			    	LBRACK387 = (IToken)input.LT(1);
            			    	Match(input,LBRACK,FOLLOW_LBRACK_in_postfixExpression4062); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_LBRACK.Add(LBRACK387);

            			    	PushFollow(FOLLOW_expression_in_postfixExpression4064);
            			    	expression388 = expression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_expression.Add(expression388.Tree);
            			    	RBRACK389 = (IToken)input.LT(1);
            			    	Match(input,RBRACK,FOLLOW_RBRACK_in_postfixExpression4066); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_RBRACK.Add(RBRACK389);

            			    	
            			    	// AST REWRITE
            			    	// elements:          expression, postfixExpression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 908:30: -> ^( ARRAY_ACC $postfixExpression expression )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:908:33: ^( ARRAY_ACC $postfixExpression expression )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_expression.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 4 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:909:5: E4X_DESC e4xExpression
            			    {
            			    	E4X_DESC390 = (IToken)input.LT(1);
            			    	Match(input,E4X_DESC,FOLLOW_E4X_DESC_in_postfixExpression4083); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_E4X_DESC.Add(E4X_DESC390);

            			    	PushFollow(FOLLOW_e4xExpression_in_postfixExpression4085);
            			    	e4xExpression391 = e4xExpression();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_e4xExpression.Add(e4xExpression391.Tree);
            			    
            			    }
            			    break;
            			case 5 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:5: arguments
            			    {
            			    	PushFollow(FOLLOW_arguments_in_postfixExpression4091);
            			    	arguments392 = arguments();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_arguments.Add(arguments392.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          arguments, postfixExpression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 910:15: -> ^( METHOD_CALL $postfixExpression arguments )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:18: ^( METHOD_CALL $postfixExpression arguments )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(METHOD_CALL, "METHOD_CALL"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_arguments.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop97;
            	    }
            	} while (true);
            	
            	loop97:
            		;	// Stops C# compiler whinging that label 'loop97' has no statements

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:3: (iin= INC -> ^( POST_INC[$iin] $postfixExpression) | dde= DEC -> ^( POST_DEC[$dde] $postfixExpression) )?
            	int alt98 = 3;
            	int LA98_0 = input.LA(1);
            	
            	if ( (LA98_0 == INC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA98_84 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA98_85 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA98_86 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA98_87 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA98_88 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA98_89 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA98_90 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA98_91 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA98_92 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA98_93 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA98_94 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA98_95 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA98_96 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA98_97 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA98_98 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA98_99 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA98_100 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA98_101 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA98_102 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA98_103 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA98_104 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA98_105 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA98_106 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA98_107 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA98_108 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA98_109 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA98_110 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA98_111 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA98_112 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA98_113 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA98_114 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA98_115 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA98_116 = input.LA(3);
            	            
            	            if ( (synpred178()) )
            	            {
            	                alt98 = 1;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case RCURLY:
            	        case SEMI:
            	        case IMPORT:
            	        case CLASS:
            	        case INTERFACE:
            	        case COMMA:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 176:
            	        case 177:
            	        case 178:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        case 187:
            	        case 188:
            	        	{
            	            alt98 = 1;
            	            }
            	            break;
            	    }
            	
            	}
            	else if ( (LA98_0 == DEC) )
            	{
            	    switch ( input.LA(2) ) 
            	    {
            	        case INC:
            	        	{
            	            int LA98_167 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case DEC:
            	        	{
            	            int LA98_168 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case MINUS:
            	        	{
            	            int LA98_169 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case PLUS:
            	        	{
            	            int LA98_170 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case DELETE:
            	        	{
            	            int LA98_171 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case 181:
            	        	{
            	            int LA98_172 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case TYPEOF:
            	        	{
            	            int LA98_173 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case LNOT:
            	        	{
            	            int LA98_174 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case BNOT:
            	        	{
            	            int LA98_175 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case UNDEFINED:
            	        	{
            	            int LA98_176 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case LT:
            	        	{
            	            int LA98_177 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case DIV:
            	        	{
            	            int LA98_178 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case HEX_LITERAL:
            	        case DECIMAL_LITERAL:
            	        case OCTAL_LITERAL:
            	        case FLOAT_LITERAL:
            	        	{
            	            int LA98_179 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case STRING_LITERAL:
            	        	{
            	            int LA98_180 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case TRUE:
            	        	{
            	            int LA98_181 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case FALSE:
            	        	{
            	            int LA98_182 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case NULL:
            	        	{
            	            int LA98_183 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case LBRACK:
            	        	{
            	            int LA98_184 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case LCURLY:
            	        	{
            	            int LA98_185 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case FUNCTION:
            	        	{
            	            int LA98_186 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case NEW:
            	        	{
            	            int LA98_187 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case LPAREN:
            	        	{
            	            int LA98_188 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case E4X_ATTRI:
            	        	{
            	            int LA98_189 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case IDENT:
            	        	{
            	            int LA98_190 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case PUBLIC:
            	        case PRIVATE:
            	        case PROTECTED:
            	        case INTERNAL:
            	        	{
            	            int LA98_191 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case USE:
            	        	{
            	            int LA98_192 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case XML:
            	        	{
            	            int LA98_193 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case DYNAMIC:
            	        	{
            	            int LA98_194 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case NAMESPACE:
            	        	{
            	            int LA98_195 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case IS:
            	        	{
            	            int LA98_196 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case AS:
            	        	{
            	            int LA98_197 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case GET:
            	        	{
            	            int LA98_198 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case SET:
            	        	{
            	            int LA98_199 = input.LA(3);
            	            
            	            if ( (synpred179()) )
            	            {
            	                alt98 = 2;
            	            }
            	            }
            	            break;
            	        case EOF:
            	        case RCURLY:
            	        case SEMI:
            	        case IMPORT:
            	        case CLASS:
            	        case INTERFACE:
            	        case COMMA:
            	        case INCLUDE_DIRECTIVE:
            	        case VAR:
            	        case CONST:
            	        case ASSIGN:
            	        case RPAREN:
            	        case IF:
            	        case ELSE:
            	        case RETURN:
            	        case CONTINUE:
            	        case BREAK:
            	        case SWITCH:
            	        case CASE:
            	        case COLON:
            	        case DEFAULT:
            	        case FOR:
            	        case IN:
            	        case WHILE:
            	        case DO:
            	        case WITH:
            	        case STAR:
            	        case RBRACK:
            	        case STATIC:
            	        case STAR_ASSIGN:
            	        case DIV_ASSIGN:
            	        case MOD_ASSIGN:
            	        case PLUS_ASSIGN:
            	        case MINUS_ASSIGN:
            	        case SL_ASSIGN:
            	        case SR_ASSIGN:
            	        case BSR_ASSIGN:
            	        case BAND_ASSIGN:
            	        case BXOR_ASSIGN:
            	        case BOR_ASSIGN:
            	        case LAND_ASSIGN:
            	        case LOR_ASSIGN:
            	        case QUESTION:
            	        case LOR:
            	        case LAND:
            	        case BOR:
            	        case BXOR:
            	        case BAND:
            	        case STRICT_EQUAL:
            	        case STRICT_NOT_EQUAL:
            	        case NOT_EQUAL:
            	        case EQUAL:
            	        case GT:
            	        case LE:
            	        case GE:
            	        case INSTANCEOF:
            	        case SL:
            	        case SR:
            	        case BSR:
            	        case MOD:
            	        case SL_COMMENT:
            	        case ML_COMMENT:
            	        case 176:
            	        case 177:
            	        case 178:
            	        case 182:
            	        case 183:
            	        case 184:
            	        case 185:
            	        case 186:
            	        case 187:
            	        case 188:
            	        	{
            	            alt98 = 2;
            	            }
            	            break;
            	    }
            	
            	}
            	switch (alt98) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:6: iin= INC
            	        {
            	        	iin = (IToken)input.LT(1);
            	        	Match(input,INC,FOLLOW_INC_in_postfixExpression4117); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_INC.Add(iin);

            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 913:14: -> ^( POST_INC[$iin] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:17: ^( POST_INC[$iin] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_INC, iin), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:914:6: dde= DEC
            	        {
            	        	dde = (IToken)input.LT(1);
            	        	Match(input,DEC,FOLLOW_DEC_in_postfixExpression4136); if (failed) return retval;
            	        	if ( backtracking==0 ) stream_DEC.Add(dde);

            	        	
            	        	// AST REWRITE
            	        	// elements:          postfixExpression
            	        	// token labels:      
            	        	// rule labels:       retval
            	        	// token list labels: 
            	        	// rule list labels:  
            	        	if ( backtracking==0 ) {
            	        	retval.tree = root_0;
            	        	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	        	
            	        	root_0 = (CommonTree)adaptor.GetNilNode();
            	        	// 914:14: -> ^( POST_DEC[$dde] $postfixExpression)
            	        	{
            	        	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:914:17: ^( POST_DEC[$dde] $postfixExpression)
            	        	    {
            	        	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	        	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(POST_DEC, dde), root_1);
            	        	    
            	        	    adaptor.AddChild(root_1, stream_retval.Next());
            	        	    
            	        	    adaptor.AddChild(root_0, root_1);
            	        	    }
            	        	
            	        	}
            	        	
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 118, postfixExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end postfixExpression

    public class e4xExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:918:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
    public e4xExpression_return e4xExpression() // throws RecognitionException [1]
    {   
        e4xExpression_return retval = new e4xExpression_return();
        retval.start = input.LT(1);
        int e4xExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STAR393 = null;
        e4xAttributeIdentifier_return e4xAttributeIdentifier394 = null;

        e4xFilterPredicate_return e4xFilterPredicate395 = null;
        
        
        CommonTree STAR393_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 119) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:919:4: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
            int alt99 = 3;
            switch ( input.LA(1) ) 
            {
            case STAR:
            	{
                alt99 = 1;
                }
                break;
            case E4X_ATTRI:
            	{
                alt99 = 2;
                }
                break;
            case LPAREN:
            	{
                alt99 = 3;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d99s0 =
            	        new NoViableAltException("918:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );", 99, 0, input);
            
            	    throw nvae_d99s0;
            }
            
            switch (alt99) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:919:4: STAR
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STAR393 = (IToken)input.LT(1);
                    	Match(input,STAR,FOLLOW_STAR_in_e4xExpression4163); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STAR393_tree = (CommonTree)adaptor.Create(STAR393);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(STAR393_tree, root_0);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:920:4: e4xAttributeIdentifier
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xAttributeIdentifier_in_e4xExpression4169);
                    	e4xAttributeIdentifier394 = e4xAttributeIdentifier();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xAttributeIdentifier394.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:921:4: e4xFilterPredicate
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xFilterPredicate_in_e4xExpression4174);
                    	e4xFilterPredicate395 = e4xFilterPredicate();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xFilterPredicate395.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 119, e4xExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xExpression

    public class e4xAttributeIdentifier_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xAttributeIdentifier
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:924:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
    public e4xAttributeIdentifier_return e4xAttributeIdentifier() // throws RecognitionException [1]
    {   
        e4xAttributeIdentifier_return retval = new e4xAttributeIdentifier_return();
        retval.start = input.LT(1);
        int e4xAttributeIdentifier_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken E4X_ATTRI396 = null;
        IToken STAR398 = null;
        IToken LBRACK399 = null;
        IToken RBRACK401 = null;
        qualifiedIdent_return qualifiedIdent397 = null;

        expression_return expression400 = null;
        
        
        CommonTree E4X_ATTRI396_tree=null;
        CommonTree STAR398_tree=null;
        CommonTree LBRACK399_tree=null;
        CommonTree RBRACK401_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 120) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:925:4: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:925:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	E4X_ATTRI396 = (IToken)input.LT(1);
            	Match(input,E4X_ATTRI,FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4185); if (failed) return retval;
            	if ( backtracking==0 ) {
            	E4X_ATTRI396_tree = (CommonTree)adaptor.Create(E4X_ATTRI396);
            	adaptor.AddChild(root_0, E4X_ATTRI396_tree);
            	}
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:926:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
            	int alt100 = 3;
            	switch ( input.LA(1) ) 
            	{
            	case GET:
            	case SET:
            	case NAMESPACE:
            	case USE:
            	case XML:
            	case IDENT:
            	case PUBLIC:
            	case PRIVATE:
            	case PROTECTED:
            	case INTERNAL:
            	case DYNAMIC:
            	case IS:
            	case AS:
            		{
            	    alt100 = 1;
            	    }
            	    break;
            	case STAR:
            		{
            	    alt100 = 2;
            	    }
            	    break;
            	case LBRACK:
            		{
            	    alt100 = 3;
            	    }
            	    break;
            		default:
            		    if ( backtracking > 0 ) {failed = true; return retval;}
            		    NoViableAltException nvae_d100s0 =
            		        new NoViableAltException("926:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )", 100, 0, input);
            	
            		    throw nvae_d100s0;
            	}
            	
            	switch (alt100) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:926:5: qualifiedIdent
            	        {
            	        	PushFollow(FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4191);
            	        	qualifiedIdent397 = qualifiedIdent();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent397.Tree);
            	        
            	        }
            	        break;
            	    case 2 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:927:5: STAR
            	        {
            	        	STAR398 = (IToken)input.LT(1);
            	        	Match(input,STAR,FOLLOW_STAR_in_e4xAttributeIdentifier4197); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	STAR398_tree = (CommonTree)adaptor.Create(STAR398);
            	        	adaptor.AddChild(root_0, STAR398_tree);
            	        	}
            	        
            	        }
            	        break;
            	    case 3 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:928:5: LBRACK expression RBRACK
            	        {
            	        	LBRACK399 = (IToken)input.LT(1);
            	        	Match(input,LBRACK,FOLLOW_LBRACK_in_e4xAttributeIdentifier4203); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	LBRACK399_tree = (CommonTree)adaptor.Create(LBRACK399);
            	        	adaptor.AddChild(root_0, LBRACK399_tree);
            	        	}
            	        	PushFollow(FOLLOW_expression_in_e4xAttributeIdentifier4205);
            	        	expression400 = expression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) adaptor.AddChild(root_0, expression400.Tree);
            	        	RBRACK401 = (IToken)input.LT(1);
            	        	Match(input,RBRACK,FOLLOW_RBRACK_in_e4xAttributeIdentifier4207); if (failed) return retval;
            	        	if ( backtracking==0 ) {
            	        	RBRACK401_tree = (CommonTree)adaptor.Create(RBRACK401);
            	        	adaptor.AddChild(root_0, RBRACK401_tree);
            	        	}
            	        
            	        }
            	        break;
            	
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 120, e4xAttributeIdentifier_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xAttributeIdentifier

    public class e4xFilterPredicate_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start e4xFilterPredicate
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:932:1: e4xFilterPredicate : LPAREN expression RPAREN ;
    public e4xFilterPredicate_return e4xFilterPredicate() // throws RecognitionException [1]
    {   
        e4xFilterPredicate_return retval = new e4xFilterPredicate_return();
        retval.start = input.LT(1);
        int e4xFilterPredicate_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN402 = null;
        IToken RPAREN404 = null;
        expression_return expression403 = null;
        
        
        CommonTree LPAREN402_tree=null;
        CommonTree RPAREN404_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 121) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:933:4: ( LPAREN expression RPAREN )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:933:4: LPAREN expression RPAREN
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	LPAREN402 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_e4xFilterPredicate4222); if (failed) return retval;
            	PushFollow(FOLLOW_expression_in_e4xFilterPredicate4227);
            	expression403 = expression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expression403.Tree);
            	RPAREN404 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_e4xFilterPredicate4231); if (failed) return retval;
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 121, e4xFilterPredicate_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end e4xFilterPredicate

    public class primaryExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start primaryExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
    public primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {   
        primaryExpression_return retval = new primaryExpression_return();
        retval.start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken UNDEFINED405 = null;
        constant_return constant406 = null;

        arrayLiteral_return arrayLiteral407 = null;

        objectLiteral_return objectLiteral408 = null;

        functionDefinition_return functionDefinition409 = null;

        newFullExpression_return newFullExpression410 = null;

        newShortExpression_return newShortExpression411 = null;

        encapsulatedExpression_return encapsulatedExpression412 = null;

        e4xAttributeIdentifier_return e4xAttributeIdentifier413 = null;

        qualifiedIdent_return qualifiedIdent414 = null;
        
        
        CommonTree UNDEFINED405_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 122) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:939:4: ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
            int alt101 = 10;
            switch ( input.LA(1) ) 
            {
            case UNDEFINED:
            	{
                alt101 = 1;
                }
                break;
            case STRING_LITERAL:
            case LT:
            case DIV:
            case TRUE:
            case FALSE:
            case NULL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt101 = 2;
                }
                break;
            case LBRACK:
            	{
                alt101 = 3;
                }
                break;
            case LCURLY:
            	{
                alt101 = 4;
                }
                break;
            case FUNCTION:
            	{
                alt101 = 5;
                }
                break;
            case NEW:
            	{
                switch ( input.LA(2) ) 
                {
                case UNDEFINED:
                	{
                    int LA101_25 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s25 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 25, input);
                    
                        throw nvae_d101s25;
                    }
                    }
                    break;
                case LT:
                	{
                    int LA101_26 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s26 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 26, input);
                    
                        throw nvae_d101s26;
                    }
                    }
                    break;
                case DIV:
                	{
                    int LA101_27 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s27 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 27, input);
                    
                        throw nvae_d101s27;
                    }
                    }
                    break;
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOAT_LITERAL:
                	{
                    int LA101_28 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s28 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 28, input);
                    
                        throw nvae_d101s28;
                    }
                    }
                    break;
                case STRING_LITERAL:
                	{
                    int LA101_29 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s29 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 29, input);
                    
                        throw nvae_d101s29;
                    }
                    }
                    break;
                case TRUE:
                	{
                    int LA101_30 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s30 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 30, input);
                    
                        throw nvae_d101s30;
                    }
                    }
                    break;
                case FALSE:
                	{
                    int LA101_31 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s31 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 31, input);
                    
                        throw nvae_d101s31;
                    }
                    }
                    break;
                case NULL:
                	{
                    int LA101_32 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s32 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 32, input);
                    
                        throw nvae_d101s32;
                    }
                    }
                    break;
                case LBRACK:
                	{
                    int LA101_33 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s33 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 33, input);
                    
                        throw nvae_d101s33;
                    }
                    }
                    break;
                case LCURLY:
                	{
                    int LA101_34 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s34 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 34, input);
                    
                        throw nvae_d101s34;
                    }
                    }
                    break;
                case FUNCTION:
                	{
                    int LA101_35 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s35 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 35, input);
                    
                        throw nvae_d101s35;
                    }
                    }
                    break;
                case NEW:
                	{
                    int LA101_36 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s36 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 36, input);
                    
                        throw nvae_d101s36;
                    }
                    }
                    break;
                case LPAREN:
                	{
                    int LA101_37 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s37 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 37, input);
                    
                        throw nvae_d101s37;
                    }
                    }
                    break;
                case E4X_ATTRI:
                	{
                    int LA101_38 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s38 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 38, input);
                    
                        throw nvae_d101s38;
                    }
                    }
                    break;
                case IDENT:
                	{
                    int LA101_39 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s39 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 39, input);
                    
                        throw nvae_d101s39;
                    }
                    }
                    break;
                case PUBLIC:
                case PRIVATE:
                case PROTECTED:
                case INTERNAL:
                	{
                    int LA101_40 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s40 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 40, input);
                    
                        throw nvae_d101s40;
                    }
                    }
                    break;
                case USE:
                	{
                    int LA101_41 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s41 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 41, input);
                    
                        throw nvae_d101s41;
                    }
                    }
                    break;
                case XML:
                	{
                    int LA101_42 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s42 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 42, input);
                    
                        throw nvae_d101s42;
                    }
                    }
                    break;
                case DYNAMIC:
                	{
                    int LA101_43 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s43 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 43, input);
                    
                        throw nvae_d101s43;
                    }
                    }
                    break;
                case NAMESPACE:
                	{
                    int LA101_44 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s44 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 44, input);
                    
                        throw nvae_d101s44;
                    }
                    }
                    break;
                case IS:
                	{
                    int LA101_45 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s45 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 45, input);
                    
                        throw nvae_d101s45;
                    }
                    }
                    break;
                case AS:
                	{
                    int LA101_46 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s46 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 46, input);
                    
                        throw nvae_d101s46;
                    }
                    }
                    break;
                case GET:
                	{
                    int LA101_47 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s47 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 47, input);
                    
                        throw nvae_d101s47;
                    }
                    }
                    break;
                case SET:
                	{
                    int LA101_48 = input.LA(3);
                    
                    if ( (synpred189()) )
                    {
                        alt101 = 6;
                    }
                    else if ( (synpred190()) )
                    {
                        alt101 = 7;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d101s48 =
                            new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 48, input);
                    
                        throw nvae_d101s48;
                    }
                    }
                    break;
                	default:
                	    if ( backtracking > 0 ) {failed = true; return retval;}
                	    NoViableAltException nvae_d101s12 =
                	        new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 12, input);
                
                	    throw nvae_d101s12;
                }
            
                }
                break;
            case LPAREN:
            	{
                alt101 = 8;
                }
                break;
            case E4X_ATTRI:
            	{
                alt101 = 9;
                }
                break;
            case GET:
            case SET:
            case NAMESPACE:
            case USE:
            case XML:
            case IDENT:
            case PUBLIC:
            case PRIVATE:
            case PROTECTED:
            case INTERNAL:
            case DYNAMIC:
            case IS:
            case AS:
            	{
                alt101 = 10;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d101s0 =
            	        new NoViableAltException("938:1: primaryExpression : ( UNDEFINED | constant | arrayLiteral | objectLiteral | functionDefinition | newFullExpression | newShortExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );", 101, 0, input);
            
            	    throw nvae_d101s0;
            }
            
            switch (alt101) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:939:4: UNDEFINED
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	UNDEFINED405 = (IToken)input.LT(1);
                    	Match(input,UNDEFINED,FOLLOW_UNDEFINED_in_primaryExpression4243); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	UNDEFINED405_tree = (CommonTree)adaptor.Create(UNDEFINED405);
                    	adaptor.AddChild(root_0, UNDEFINED405_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:940:4: constant
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_constant_in_primaryExpression4248);
                    	constant406 = constant();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, constant406.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:941:4: arrayLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_arrayLiteral_in_primaryExpression4253);
                    	arrayLiteral407 = arrayLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, arrayLiteral407.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:942:4: objectLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_objectLiteral_in_primaryExpression4258);
                    	objectLiteral408 = objectLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, objectLiteral408.Tree);
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:943:4: functionDefinition
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_functionDefinition_in_primaryExpression4263);
                    	functionDefinition409 = functionDefinition();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, functionDefinition409.Tree);
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:944:4: newFullExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newFullExpression_in_primaryExpression4268);
                    	newFullExpression410 = newFullExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newFullExpression410.Tree);
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:4: newShortExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newShortExpression_in_primaryExpression4273);
                    	newShortExpression411 = newShortExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newShortExpression411.Tree);
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:946:4: encapsulatedExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_encapsulatedExpression_in_primaryExpression4278);
                    	encapsulatedExpression412 = encapsulatedExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, encapsulatedExpression412.Tree);
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:947:4: e4xAttributeIdentifier
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_e4xAttributeIdentifier_in_primaryExpression4283);
                    	e4xAttributeIdentifier413 = e4xAttributeIdentifier();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, e4xAttributeIdentifier413.Tree);
                    
                    }
                    break;
                case 10 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:948:4: qualifiedIdent
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_qualifiedIdent_in_primaryExpression4288);
                    	qualifiedIdent414 = qualifiedIdent();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent414.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 122, primaryExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end primaryExpression

    public class propOrIdent_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start propOrIdent
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:952:1: propOrIdent[CommonTree identPrimary, IToken startToken] : DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) ;
    public propOrIdent_return propOrIdent(CommonTree identPrimary, IToken startToken) // throws RecognitionException [1]
    {   
        propOrIdent_return retval = new propOrIdent_return();
        retval.start = input.LT(1);
        int propOrIdent_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT415 = null;
        qualifiedIdent_return propId = null;
        
        
        CommonTree DOT415_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 123) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:954:3: ( DOT propId= qualifiedIdent -> ^( PROPERTY_OR_IDENTIFIER $propId) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:954:3: DOT propId= qualifiedIdent
            {
            	if ( backtracking == 0 ) 
            	{
            	   retval.start = startToken; 
            	}
            	DOT415 = (IToken)input.LT(1);
            	Match(input,DOT,FOLLOW_DOT_in_propOrIdent4308); if (failed) return retval;
            	if ( backtracking==0 ) stream_DOT.Add(DOT415);

            	PushFollow(FOLLOW_qualifiedIdent_in_propOrIdent4312);
            	propId = qualifiedIdent();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_qualifiedIdent.Add(propId.Tree);
            	
            	// AST REWRITE
            	// elements:          propId
            	// token labels:      
            	// rule labels:       propId, retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_propId = new RewriteRuleSubtreeStream(adaptor, "token propId", (propId!=null ? propId.Tree : null));
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 961:3: -> ^( PROPERTY_OR_IDENTIFIER $propId)
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:961:6: ^( PROPERTY_OR_IDENTIFIER $propId)
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(PROPERTY_OR_IDENTIFIER, "PROPERTY_OR_IDENTIFIER"), root_1);
            	    
            	    adaptor.AddChild(root_1, identPrimary);
            	    adaptor.AddChild(root_1, stream_propId.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 123, propOrIdent_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end propOrIdent

    public class constant_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start constant
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:964:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );
    public constant_return constant() // throws RecognitionException [1]
    {   
        constant_return retval = new constant_return();
        retval.start = input.LT(1);
        int constant_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken STRING_LITERAL419 = null;
        IToken TRUE420 = null;
        IToken FALSE421 = null;
        IToken NULL422 = null;
        xmlLiteral_return xmlLiteral416 = null;

        regexpLiteral_return regexpLiteral417 = null;

        number_return number418 = null;
        
        
        CommonTree STRING_LITERAL419_tree=null;
        CommonTree TRUE420_tree=null;
        CommonTree FALSE421_tree=null;
        CommonTree NULL422_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 124) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:4: ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL )
            int alt102 = 7;
            switch ( input.LA(1) ) 
            {
            case LT:
            	{
                alt102 = 1;
                }
                break;
            case DIV:
            	{
                alt102 = 2;
                }
                break;
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOAT_LITERAL:
            	{
                alt102 = 3;
                }
                break;
            case STRING_LITERAL:
            	{
                alt102 = 4;
                }
                break;
            case TRUE:
            	{
                alt102 = 5;
                }
                break;
            case FALSE:
            	{
                alt102 = 6;
                }
                break;
            case NULL:
            	{
                alt102 = 7;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d102s0 =
            	        new NoViableAltException("964:1: constant : ( xmlLiteral | regexpLiteral | number | STRING_LITERAL | TRUE | FALSE | NULL );", 102, 0, input);
            
            	    throw nvae_d102s0;
            }
            
            switch (alt102) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:965:4: xmlLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_xmlLiteral_in_constant4340);
                    	xmlLiteral416 = xmlLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, xmlLiteral416.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:966:4: regexpLiteral
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_regexpLiteral_in_constant4345);
                    	regexpLiteral417 = regexpLiteral();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, regexpLiteral417.Tree);
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:967:4: number
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_number_in_constant4350);
                    	number418 = number();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, number418.Tree);
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:968:4: STRING_LITERAL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	STRING_LITERAL419 = (IToken)input.LT(1);
                    	Match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_constant4355); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	STRING_LITERAL419_tree = (CommonTree)adaptor.Create(STRING_LITERAL419);
                    	adaptor.AddChild(root_0, STRING_LITERAL419_tree);
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:969:4: TRUE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	TRUE420 = (IToken)input.LT(1);
                    	Match(input,TRUE,FOLLOW_TRUE_in_constant4360); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	TRUE420_tree = (CommonTree)adaptor.Create(TRUE420);
                    	adaptor.AddChild(root_0, TRUE420_tree);
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:970:4: FALSE
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	FALSE421 = (IToken)input.LT(1);
                    	Match(input,FALSE,FOLLOW_FALSE_in_constant4365); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	FALSE421_tree = (CommonTree)adaptor.Create(FALSE421);
                    	adaptor.AddChild(root_0, FALSE421_tree);
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:971:4: NULL
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	NULL422 = (IToken)input.LT(1);
                    	Match(input,NULL,FOLLOW_NULL_in_constant4370); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	NULL422_tree = (CommonTree)adaptor.Create(NULL422);
                    	adaptor.AddChild(root_0, NULL422_tree);
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 124, constant_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end constant

    public class number_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start number
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:974:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
    public number_return number() // throws RecognitionException [1]
    {   
        number_return retval = new number_return();
        retval.start = input.LT(1);
        int number_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken set423 = null;
        
        CommonTree set423_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 125) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:974:10: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	set423 = (IToken)input.LT(1);
            	if ( (input.LA(1) >= HEX_LITERAL && input.LA(1) <= FLOAT_LITERAL) ) 
            	{
            	    input.Consume();
            	    if ( backtracking==0 ) adaptor.AddChild(root_0, adaptor.Create(set423));
            	    errorRecovery = false;failed = false;
            	}
            	else 
            	{
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    MismatchedSetException mse =
            	        new MismatchedSetException(null,input);
            	    RecoverFromMismatchedSet(input,mse,FOLLOW_set_in_number0);    throw mse;
            	}

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 125, number_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end number

    public class xmlLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start xmlLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:981:1: xmlLiteral : LT ->;
    public xmlLiteral_return xmlLiteral() // throws RecognitionException [1]
    {   
        xmlLiteral_return retval = new xmlLiteral_return();
        retval.start = input.LT(1);
        int xmlLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LT424 = null;
        
        CommonTree LT424_tree=null;
        RewriteRuleTokenStream stream_LT = new RewriteRuleTokenStream(adaptor,"token LT");
    
        
        		CommonTree xml = null;
        	
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 126) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:988:3: ( LT ->)
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:988:3: LT
            {
            	LT424 = (IToken)input.LT(1);
            	Match(input,LT,FOLLOW_LT_in_xmlLiteral4423); if (failed) return retval;
            	if ( backtracking==0 ) stream_LT.Add(LT424);

            	if ( backtracking == 0 ) 
            	{
            	   /*xml=parseXMLLiteral();*/ 
            	}
            	
            	// AST REWRITE
            	// elements:          
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 990:3: ->
            	{
            	    adaptor.AddChild(root_0, xml);
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 126, xmlLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end xmlLiteral

    public class regexpLiteral_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start regexpLiteral
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:994:1: regexpLiteral : s= DIV -> ^() ;
    public regexpLiteral_return regexpLiteral() // throws RecognitionException [1]
    {   
        regexpLiteral_return retval = new regexpLiteral_return();
        retval.start = input.LT(1);
        int regexpLiteral_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken s = null;
        
        CommonTree s_tree=null;
        RewriteRuleTokenStream stream_DIV = new RewriteRuleTokenStream(adaptor,"token DIV");
    
        
        		CommonTree regexp = null;
        	
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 127) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:4: (s= DIV -> ^() )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:998:4: s= DIV
            {
            	s = (IToken)input.LT(1);
            	Match(input,DIV,FOLLOW_DIV_in_regexpLiteral4453); if (failed) return retval;
            	if ( backtracking==0 ) stream_DIV.Add(s);

            	if ( backtracking == 0 ) 
            	{
            	   /*regexp=parseRegexpLiteral((LinkedListToken)s);*/ 
            	}
            	
            	// AST REWRITE
            	// elements:          
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 999:3: -> ^()
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:999:6: ^()
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(regexp, root_1);
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 127, regexpLiteral_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end regexpLiteral

    public class newFullExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start newFullExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1002:1: newFullExpression : NEW fullNewSubexpression arguments ;
    public newFullExpression_return newFullExpression() // throws RecognitionException [1]
    {   
        newFullExpression_return retval = new newFullExpression_return();
        retval.start = input.LT(1);
        int newFullExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NEW425 = null;
        fullNewSubexpression_return fullNewSubexpression426 = null;

        arguments_return arguments427 = null;
        
        
        CommonTree NEW425_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 128) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1003:4: ( NEW fullNewSubexpression arguments )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1003:4: NEW fullNewSubexpression arguments
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	NEW425 = (IToken)input.LT(1);
            	Match(input,NEW,FOLLOW_NEW_in_newFullExpression4474); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NEW425_tree = (CommonTree)adaptor.Create(NEW425);
            	root_0 = (CommonTree)adaptor.BecomeRoot(NEW425_tree, root_0);
            	}
            	PushFollow(FOLLOW_fullNewSubexpression_in_newFullExpression4477);
            	fullNewSubexpression426 = fullNewSubexpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, fullNewSubexpression426.Tree);
            	PushFollow(FOLLOW_arguments_in_newFullExpression4479);
            	arguments427 = arguments();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, arguments427.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 128, newFullExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end newFullExpression

    public class fullNewSubexpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start fullNewSubexpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1006:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
    public fullNewSubexpression_return fullNewSubexpression() // throws RecognitionException [1]
    {   
        fullNewSubexpression_return retval = new fullNewSubexpression_return();
        retval.start = input.LT(1);
        int fullNewSubexpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT429 = null;
        primaryExpression_return primaryExpression428 = null;

        qualifiedIdent_return qualifiedIdent430 = null;

        brackets_return brackets431 = null;
        
        
        CommonTree DOT429_tree=null;
        RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream(adaptor,"token DOT");
        RewriteRuleSubtreeStream stream_primaryExpression = new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
        RewriteRuleSubtreeStream stream_brackets = new RewriteRuleSubtreeStream(adaptor,"rule brackets");
        RewriteRuleSubtreeStream stream_qualifiedIdent = new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 129) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:4: ( ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:4: ( primaryExpression -> primaryExpression ) ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            {
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:4: ( primaryExpression -> primaryExpression )
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1007:6: primaryExpression
            	{
            		PushFollow(FOLLOW_primaryExpression_in_fullNewSubexpression4492);
            		primaryExpression428 = primaryExpression();
            		followingStackPointer_--;
            		if (failed) return retval;
            		if ( backtracking==0 ) stream_primaryExpression.Add(primaryExpression428.Tree);
            		
            		// AST REWRITE
            		// elements:          primaryExpression
            		// token labels:      
            		// rule labels:       retval
            		// token list labels: 
            		// rule list labels:  
            		if ( backtracking==0 ) {
            		retval.tree = root_0;
            		RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            		
            		root_0 = (CommonTree)adaptor.GetNilNode();
            		// 1007:24: -> primaryExpression
            		{
            		    adaptor.AddChild(root_0, stream_primaryExpression.Next());
            		
            		}
            		
            		}
            	
            	}

            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:3: ( DOT qualifiedIdent -> ^( DOT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
            	do 
            	{
            	    int alt103 = 3;
            	    int LA103_0 = input.LA(1);
            	    
            	    if ( (LA103_0 == DOT) )
            	    {
            	        int LA103_2 = input.LA(2);
            	        
            	        if ( (synpred202()) )
            	        {
            	            alt103 = 1;
            	        }
            	        
            	    
            	    }
            	    else if ( (LA103_0 == LBRACK) )
            	    {
            	        int LA103_3 = input.LA(2);
            	        
            	        if ( (synpred203()) )
            	        {
            	            alt103 = 2;
            	        }
            	        
            	    
            	    }
            	    
            	
            	    switch (alt103) 
            		{
            			case 1 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:5: DOT qualifiedIdent
            			    {
            			    	DOT429 = (IToken)input.LT(1);
            			    	Match(input,DOT,FOLLOW_DOT_in_fullNewSubexpression4506); if (failed) return retval;
            			    	if ( backtracking==0 ) stream_DOT.Add(DOT429);

            			    	PushFollow(FOLLOW_qualifiedIdent_in_fullNewSubexpression4508);
            			    	qualifiedIdent430 = qualifiedIdent();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_qualifiedIdent.Add(qualifiedIdent430.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          DOT, qualifiedIdent, fullNewSubexpression
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1009:24: -> ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:27: ^( DOT $fullNewSubexpression qualifiedIdent )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(stream_DOT.Next(), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_qualifiedIdent.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            			case 2 :
            			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:5: brackets
            			    {
            			    	PushFollow(FOLLOW_brackets_in_fullNewSubexpression4525);
            			    	brackets431 = brackets();
            			    	followingStackPointer_--;
            			    	if (failed) return retval;
            			    	if ( backtracking==0 ) stream_brackets.Add(brackets431.Tree);
            			    	
            			    	// AST REWRITE
            			    	// elements:          fullNewSubexpression, brackets
            			    	// token labels:      
            			    	// rule labels:       retval
            			    	// token list labels: 
            			    	// rule list labels:  
            			    	if ( backtracking==0 ) {
            			    	retval.tree = root_0;
            			    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            			    	
            			    	root_0 = (CommonTree)adaptor.GetNilNode();
            			    	// 1010:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	{
            			    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
            			    	    {
            			    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            			    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);
            			    	    
            			    	    adaptor.AddChild(root_1, stream_retval.Next());
            			    	    adaptor.AddChild(root_1, stream_brackets.Next());
            			    	    
            			    	    adaptor.AddChild(root_0, root_1);
            			    	    }
            			    	
            			    	}
            			    	
            			    	}
            			    
            			    }
            			    break;
            	
            			default:
            			    goto loop103;
            	    }
            	} while (true);
            	
            	loop103:
            		;	// Stops C# compiler whinging that label 'loop103' has no statements

            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 129, fullNewSubexpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end fullNewSubexpression

    public class newShortExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start newShortExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1014:1: newShortExpression : NEW shortNewSubexpression ;
    public newShortExpression_return newShortExpression() // throws RecognitionException [1]
    {   
        newShortExpression_return retval = new newShortExpression_return();
        retval.start = input.LT(1);
        int newShortExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken NEW432 = null;
        shortNewSubexpression_return shortNewSubexpression433 = null;
        
        
        CommonTree NEW432_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 130) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1015:4: ( NEW shortNewSubexpression )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1015:4: NEW shortNewSubexpression
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	NEW432 = (IToken)input.LT(1);
            	Match(input,NEW,FOLLOW_NEW_in_newShortExpression4553); if (failed) return retval;
            	if ( backtracking==0 ) {
            	NEW432_tree = (CommonTree)adaptor.Create(NEW432);
            	root_0 = (CommonTree)adaptor.BecomeRoot(NEW432_tree, root_0);
            	}
            	PushFollow(FOLLOW_shortNewSubexpression_in_newShortExpression4556);
            	shortNewSubexpression433 = shortNewSubexpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, shortNewSubexpression433.Tree);
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 130, newShortExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end newShortExpression

    public class shortNewSubexpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start shortNewSubexpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );
    public shortNewSubexpression_return shortNewSubexpression() // throws RecognitionException [1]
    {   
        shortNewSubexpression_return retval = new shortNewSubexpression_return();
        retval.start = input.LT(1);
        int shortNewSubexpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        fullNewSubexpression_return fullNewSubexpression434 = null;

        newShortExpression_return newShortExpression435 = null;
        
        
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 131) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1019:4: ( fullNewSubexpression | newShortExpression )
            int alt104 = 2;
            int LA104_0 = input.LA(1);
            
            if ( (LA104_0 == LCURLY || (LA104_0 >= STRING_LITERAL && LA104_0 <= USE) || LA104_0 == LPAREN || LA104_0 == XML || (LA104_0 >= IDENT && LA104_0 <= LBRACK) || LA104_0 == DYNAMIC || LA104_0 == LT || (LA104_0 >= IS && LA104_0 <= AS) || LA104_0 == DIV || (LA104_0 >= E4X_ATTRI && LA104_0 <= FLOAT_LITERAL)) )
            {
                alt104 = 1;
            }
            else if ( (LA104_0 == NEW) )
            {
                switch ( input.LA(2) ) 
                {
                case UNDEFINED:
                	{
                    int LA104_25 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s25 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 25, input);
                    
                        throw nvae_d104s25;
                    }
                    }
                    break;
                case LT:
                	{
                    int LA104_26 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s26 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 26, input);
                    
                        throw nvae_d104s26;
                    }
                    }
                    break;
                case DIV:
                	{
                    int LA104_27 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s27 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 27, input);
                    
                        throw nvae_d104s27;
                    }
                    }
                    break;
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOAT_LITERAL:
                	{
                    int LA104_28 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s28 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 28, input);
                    
                        throw nvae_d104s28;
                    }
                    }
                    break;
                case STRING_LITERAL:
                	{
                    int LA104_29 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s29 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 29, input);
                    
                        throw nvae_d104s29;
                    }
                    }
                    break;
                case TRUE:
                	{
                    int LA104_30 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s30 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 30, input);
                    
                        throw nvae_d104s30;
                    }
                    }
                    break;
                case FALSE:
                	{
                    int LA104_31 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s31 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 31, input);
                    
                        throw nvae_d104s31;
                    }
                    }
                    break;
                case NULL:
                	{
                    int LA104_32 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s32 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 32, input);
                    
                        throw nvae_d104s32;
                    }
                    }
                    break;
                case LBRACK:
                	{
                    int LA104_33 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s33 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 33, input);
                    
                        throw nvae_d104s33;
                    }
                    }
                    break;
                case LCURLY:
                	{
                    int LA104_34 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s34 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 34, input);
                    
                        throw nvae_d104s34;
                    }
                    }
                    break;
                case FUNCTION:
                	{
                    int LA104_35 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s35 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 35, input);
                    
                        throw nvae_d104s35;
                    }
                    }
                    break;
                case NEW:
                	{
                    int LA104_36 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s36 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 36, input);
                    
                        throw nvae_d104s36;
                    }
                    }
                    break;
                case LPAREN:
                	{
                    int LA104_37 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s37 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 37, input);
                    
                        throw nvae_d104s37;
                    }
                    }
                    break;
                case E4X_ATTRI:
                	{
                    int LA104_38 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s38 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 38, input);
                    
                        throw nvae_d104s38;
                    }
                    }
                    break;
                case IDENT:
                	{
                    int LA104_39 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s39 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 39, input);
                    
                        throw nvae_d104s39;
                    }
                    }
                    break;
                case PUBLIC:
                case PRIVATE:
                case PROTECTED:
                case INTERNAL:
                	{
                    int LA104_40 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s40 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 40, input);
                    
                        throw nvae_d104s40;
                    }
                    }
                    break;
                case USE:
                	{
                    int LA104_41 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s41 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 41, input);
                    
                        throw nvae_d104s41;
                    }
                    }
                    break;
                case XML:
                	{
                    int LA104_42 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s42 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 42, input);
                    
                        throw nvae_d104s42;
                    }
                    }
                    break;
                case DYNAMIC:
                	{
                    int LA104_43 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s43 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 43, input);
                    
                        throw nvae_d104s43;
                    }
                    }
                    break;
                case NAMESPACE:
                	{
                    int LA104_44 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s44 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 44, input);
                    
                        throw nvae_d104s44;
                    }
                    }
                    break;
                case IS:
                	{
                    int LA104_45 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s45 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 45, input);
                    
                        throw nvae_d104s45;
                    }
                    }
                    break;
                case AS:
                	{
                    int LA104_46 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s46 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 46, input);
                    
                        throw nvae_d104s46;
                    }
                    }
                    break;
                case GET:
                	{
                    int LA104_47 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s47 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 47, input);
                    
                        throw nvae_d104s47;
                    }
                    }
                    break;
                case SET:
                	{
                    int LA104_48 = input.LA(3);
                    
                    if ( (synpred204()) )
                    {
                        alt104 = 1;
                    }
                    else if ( (true) )
                    {
                        alt104 = 2;
                    }
                    else 
                    {
                        if ( backtracking > 0 ) {failed = true; return retval;}
                        NoViableAltException nvae_d104s48 =
                            new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 48, input);
                    
                        throw nvae_d104s48;
                    }
                    }
                    break;
                	default:
                	    if ( backtracking > 0 ) {failed = true; return retval;}
                	    NoViableAltException nvae_d104s12 =
                	        new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 12, input);
                
                	    throw nvae_d104s12;
                }
            
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d104s0 =
                    new NoViableAltException("1018:1: shortNewSubexpression : ( fullNewSubexpression | newShortExpression );", 104, 0, input);
            
                throw nvae_d104s0;
            }
            switch (alt104) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1019:4: fullNewSubexpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_fullNewSubexpression_in_shortNewSubexpression4569);
                    	fullNewSubexpression434 = fullNewSubexpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, fullNewSubexpression434.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1020:4: newShortExpression
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_newShortExpression_in_shortNewSubexpression4574);
                    	newShortExpression435 = newShortExpression();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, newShortExpression435.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 131, shortNewSubexpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end shortNewSubexpression

    public class propertyOperator_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start propertyOperator
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1023:1: propertyOperator : ( DOT qualifiedIdent | brackets );
    public propertyOperator_return propertyOperator() // throws RecognitionException [1]
    {   
        propertyOperator_return retval = new propertyOperator_return();
        retval.start = input.LT(1);
        int propertyOperator_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken DOT436 = null;
        qualifiedIdent_return qualifiedIdent437 = null;

        brackets_return brackets438 = null;
        
        
        CommonTree DOT436_tree=null;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 132) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1024:4: ( DOT qualifiedIdent | brackets )
            int alt105 = 2;
            int LA105_0 = input.LA(1);
            
            if ( (LA105_0 == DOT) )
            {
                alt105 = 1;
            }
            else if ( (LA105_0 == LBRACK) )
            {
                alt105 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d105s0 =
                    new NoViableAltException("1023:1: propertyOperator : ( DOT qualifiedIdent | brackets );", 105, 0, input);
            
                throw nvae_d105s0;
            }
            switch (alt105) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1024:4: DOT qualifiedIdent
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	DOT436 = (IToken)input.LT(1);
                    	Match(input,DOT,FOLLOW_DOT_in_propertyOperator4586); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	DOT436_tree = (CommonTree)adaptor.Create(DOT436);
                    	root_0 = (CommonTree)adaptor.BecomeRoot(DOT436_tree, root_0);
                    	}
                    	PushFollow(FOLLOW_qualifiedIdent_in_propertyOperator4589);
                    	qualifiedIdent437 = qualifiedIdent();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, qualifiedIdent437.Tree);
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1025:4: brackets
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	PushFollow(FOLLOW_brackets_in_propertyOperator4594);
                    	brackets438 = brackets();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) adaptor.AddChild(root_0, brackets438.Tree);
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 132, propertyOperator_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end propertyOperator

    public class commentExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start commentExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1029:1: commentExpression : comment -> ^( COMMENT_LIST comment ) ;
    public commentExpression_return commentExpression() // throws RecognitionException [1]
    {   
        commentExpression_return retval = new commentExpression_return();
        retval.start = input.LT(1);
        int commentExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        comment_return comment439 = null;
        
        
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 133) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1030:4: ( comment -> ^( COMMENT_LIST comment ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1030:4: comment
            {
            	PushFollow(FOLLOW_comment_in_commentExpression4606);
            	comment439 = comment();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_comment.Add(comment439.Tree);
            	
            	// AST REWRITE
            	// elements:          comment
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1030:12: -> ^( COMMENT_LIST comment )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1030:15: ^( COMMENT_LIST comment )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_LIST, "COMMENT_LIST"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_comment.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 133, commentExpression_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end commentExpression

    public class comment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start comment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1033:1: comment : ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) );
    public comment_return comment() // throws RecognitionException [1]
    {   
        comment_return retval = new comment_return();
        retval.start = input.LT(1);
        int comment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        singleLineComment_return singleLineComment440 = null;

        comment_return comment441 = null;

        multilineComment_return multilineComment442 = null;

        comment_return comment443 = null;
        
        
        RewriteRuleSubtreeStream stream_multilineComment = new RewriteRuleSubtreeStream(adaptor,"rule multilineComment");
        RewriteRuleSubtreeStream stream_singleLineComment = new RewriteRuleSubtreeStream(adaptor,"rule singleLineComment");
        RewriteRuleSubtreeStream stream_comment = new RewriteRuleSubtreeStream(adaptor,"rule comment");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 134) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:4: ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) )
            int alt108 = 2;
            int LA108_0 = input.LA(1);
            
            if ( (LA108_0 == SL_COMMENT) )
            {
                alt108 = 1;
            }
            else if ( (LA108_0 == ML_COMMENT) )
            {
                alt108 = 2;
            }
            else 
            {
                if ( backtracking > 0 ) {failed = true; return retval;}
                NoViableAltException nvae_d108s0 =
                    new NoViableAltException("1033:1: comment : ( singleLineComment ( comment )* -> ^( COMMENT_ENTRY singleLineComment ( comment )* ) | multilineComment ( comment )* -> ^( COMMENT_ENTRY multilineComment ( comment )* ) );", 108, 0, input);
            
                throw nvae_d108s0;
            }
            switch (alt108) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:4: singleLineComment ( comment )*
                    {
                    	PushFollow(FOLLOW_singleLineComment_in_comment4625);
                    	singleLineComment440 = singleLineComment();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_singleLineComment.Add(singleLineComment440.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:22: ( comment )*
                    	do 
                    	{
                    	    int alt106 = 2;
                    	    int LA106_0 = input.LA(1);
                    	    
                    	    if ( (LA106_0 == SL_COMMENT) )
                    	    {
                    	        int LA106_4 = input.LA(2);
                    	        
                    	        if ( (synpred206()) )
                    	        {
                    	            alt106 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA106_0 == ML_COMMENT) )
                    	    {
                    	        int LA106_5 = input.LA(2);
                    	        
                    	        if ( (synpred206()) )
                    	        {
                    	            alt106 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt106) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment4627);
                    			    	comment441 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment441.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop106;
                    	    }
                    	} while (true);
                    	
                    	loop106:
                    		;	// Stops C# compiler whinging that label 'loop106' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          comment, singleLineComment
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1034:31: -> ^( COMMENT_ENTRY singleLineComment ( comment )* )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:34: ^( COMMENT_ENTRY singleLineComment ( comment )* )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_singleLineComment.Next());
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:68: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_1, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:4: multilineComment ( comment )*
                    {
                    	PushFollow(FOLLOW_multilineComment_in_comment4644);
                    	multilineComment442 = multilineComment();
                    	followingStackPointer_--;
                    	if (failed) return retval;
                    	if ( backtracking==0 ) stream_multilineComment.Add(multilineComment442.Tree);
                    	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:21: ( comment )*
                    	do 
                    	{
                    	    int alt107 = 2;
                    	    int LA107_0 = input.LA(1);
                    	    
                    	    if ( (LA107_0 == SL_COMMENT) )
                    	    {
                    	        int LA107_4 = input.LA(2);
                    	        
                    	        if ( (synpred208()) )
                    	        {
                    	            alt107 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    else if ( (LA107_0 == ML_COMMENT) )
                    	    {
                    	        int LA107_5 = input.LA(2);
                    	        
                    	        if ( (synpred208()) )
                    	        {
                    	            alt107 = 1;
                    	        }
                    	        
                    	    
                    	    }
                    	    
                    	
                    	    switch (alt107) 
                    		{
                    			case 1 :
                    			    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: comment
                    			    {
                    			    	PushFollow(FOLLOW_comment_in_comment4646);
                    			    	comment443 = comment();
                    			    	followingStackPointer_--;
                    			    	if (failed) return retval;
                    			    	if ( backtracking==0 ) stream_comment.Add(comment443.Tree);
                    			    
                    			    }
                    			    break;
                    	
                    			default:
                    			    goto loop107;
                    	    }
                    	} while (true);
                    	
                    	loop107:
                    		;	// Stops C# compiler whinging that label 'loop107' has no statements

                    	
                    	// AST REWRITE
                    	// elements:          multilineComment, comment
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1035:30: -> ^( COMMENT_ENTRY multilineComment ( comment )* )
                    	{
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:33: ^( COMMENT_ENTRY multilineComment ( comment )* )
                    	    {
                    	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
                    	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(COMMENT_ENTRY, "COMMENT_ENTRY"), root_1);
                    	    
                    	    adaptor.AddChild(root_1, stream_multilineComment.Next());
                    	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:66: ( comment )*
                    	    while ( stream_comment.HasNext() )
                    	    {
                    	        adaptor.AddChild(root_1, stream_comment.Next());
                    	    
                    	    }
                    	    stream_comment.Reset();
                    	    
                    	    adaptor.AddChild(root_0, root_1);
                    	    }
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 134, comment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end comment

    public class singleLineComment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start singleLineComment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1038:1: singleLineComment : SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) ;
    public singleLineComment_return singleLineComment() // throws RecognitionException [1]
    {   
        singleLineComment_return retval = new singleLineComment_return();
        retval.start = input.LT(1);
        int singleLineComment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken SL_COMMENT444 = null;
        
        CommonTree SL_COMMENT444_tree=null;
        RewriteRuleTokenStream stream_SL_COMMENT = new RewriteRuleTokenStream(adaptor,"token SL_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 135) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1039:4: ( SL_COMMENT -> ^( SINGLELINE_COMMENT SL_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1039:4: SL_COMMENT
            {
            	SL_COMMENT444 = (IToken)input.LT(1);
            	Match(input,SL_COMMENT,FOLLOW_SL_COMMENT_in_singleLineComment4669); if (failed) return retval;
            	if ( backtracking==0 ) stream_SL_COMMENT.Add(SL_COMMENT444);

            	
            	// AST REWRITE
            	// elements:          SL_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1039:15: -> ^( SINGLELINE_COMMENT SL_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1039:18: ^( SINGLELINE_COMMENT SL_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(SINGLELINE_COMMENT, "SINGLELINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_SL_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 135, singleLineComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end singleLineComment

    public class multilineComment_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start multilineComment
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1042:1: multilineComment : ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) ;
    public multilineComment_return multilineComment() // throws RecognitionException [1]
    {   
        multilineComment_return retval = new multilineComment_return();
        retval.start = input.LT(1);
        int multilineComment_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken ML_COMMENT445 = null;
        
        CommonTree ML_COMMENT445_tree=null;
        RewriteRuleTokenStream stream_ML_COMMENT = new RewriteRuleTokenStream(adaptor,"token ML_COMMENT");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 136) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1043:4: ( ML_COMMENT -> ^( MULTILINE_COMMENT ML_COMMENT ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1043:4: ML_COMMENT
            {
            	ML_COMMENT445 = (IToken)input.LT(1);
            	Match(input,ML_COMMENT,FOLLOW_ML_COMMENT_in_multilineComment4689); if (failed) return retval;
            	if ( backtracking==0 ) stream_ML_COMMENT.Add(ML_COMMENT445);

            	
            	// AST REWRITE
            	// elements:          ML_COMMENT
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1043:15: -> ^( MULTILINE_COMMENT ML_COMMENT )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1043:18: ^( MULTILINE_COMMENT ML_COMMENT )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(MULTILINE_COMMENT, "MULTILINE_COMMENT"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_ML_COMMENT.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 136, multilineComment_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end multilineComment

    public class brackets_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start brackets
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1047:1: brackets : LBRACK expressionList RBRACK ;
    public brackets_return brackets() // throws RecognitionException [1]
    {   
        brackets_return retval = new brackets_return();
        retval.start = input.LT(1);
        int brackets_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LBRACK446 = null;
        IToken RBRACK448 = null;
        expressionList_return expressionList447 = null;
        
        
        CommonTree LBRACK446_tree=null;
        CommonTree RBRACK448_tree=null;
    
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 137) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: ( LBRACK expressionList RBRACK )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1051:4: LBRACK expressionList RBRACK
            {
            	root_0 = (CommonTree)adaptor.GetNilNode();
            
            	LBRACK446 = (IToken)input.LT(1);
            	Match(input,LBRACK,FOLLOW_LBRACK_in_brackets4714); if (failed) return retval;
            	if ( backtracking==0 ) {
            	LBRACK446_tree = (CommonTree)adaptor.Create(LBRACK446);
            	adaptor.AddChild(root_0, LBRACK446_tree);
            	}
            	PushFollow(FOLLOW_expressionList_in_brackets4716);
            	expressionList447 = expressionList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) adaptor.AddChild(root_0, expressionList447.Tree);
            	RBRACK448 = (IToken)input.LT(1);
            	Match(input,RBRACK,FOLLOW_RBRACK_in_brackets4718); if (failed) return retval;
            	if ( backtracking==0 ) {
            	RBRACK448_tree = (CommonTree)adaptor.Create(RBRACK448);
            	adaptor.AddChild(root_0, RBRACK448_tree);
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 137, brackets_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end brackets

    public class encapsulatedExpression_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start encapsulatedExpression
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1054:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
    public encapsulatedExpression_return encapsulatedExpression() // throws RecognitionException [1]
    {   
        InOperator_stack.Push(new InOperator_scope());
    
        encapsulatedExpression_return retval = new encapsulatedExpression_return();
        retval.start = input.LT(1);
        int encapsulatedExpression_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken LPAREN449 = null;
        IToken RPAREN451 = null;
        assignmentExpression_return assignmentExpression450 = null;
        
        
        CommonTree LPAREN449_tree=null;
        CommonTree RPAREN451_tree=null;
        RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream(adaptor,"token RPAREN");
        RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream(adaptor,"token LPAREN");
        RewriteRuleSubtreeStream stream_assignmentExpression = new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
        
        	((InOperator_scope)InOperator_stack.Peek()).allowed =  true;
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 138) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1059:4: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1059:4: LPAREN assignmentExpression RPAREN
            {
            	LPAREN449 = (IToken)input.LT(1);
            	Match(input,LPAREN,FOLLOW_LPAREN_in_encapsulatedExpression4739); if (failed) return retval;
            	if ( backtracking==0 ) stream_LPAREN.Add(LPAREN449);

            	PushFollow(FOLLOW_assignmentExpression_in_encapsulatedExpression4741);
            	assignmentExpression450 = assignmentExpression();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_assignmentExpression.Add(assignmentExpression450.Tree);
            	RPAREN451 = (IToken)input.LT(1);
            	Match(input,RPAREN,FOLLOW_RPAREN_in_encapsulatedExpression4743); if (failed) return retval;
            	if ( backtracking==0 ) stream_RPAREN.Add(RPAREN451);

            	
            	// AST REWRITE
            	// elements:          assignmentExpression
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1060:3: -> ^( ENCPS_EXPR assignmentExpression )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1060:6: ^( ENCPS_EXPR assignmentExpression )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_assignmentExpression.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 138, encapsulatedExpression_StartIndex); 
            }
            InOperator_stack.Pop();
    
        }
        return retval;
    }
    // $ANTLR end encapsulatedExpression

    public class functionDefinition_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start functionDefinition
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1066:1: functionDefinition : FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
    public functionDefinition_return functionDefinition() // throws RecognitionException [1]
    {   
        functionDefinition_return retval = new functionDefinition_return();
        retval.start = input.LT(1);
        int functionDefinition_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken FUNCTION452 = null;
        parameterDeclarationList_return parameterDeclarationList453 = null;

        typeExpression_return typeExpression454 = null;

        block_return block455 = null;
        
        
        CommonTree FUNCTION452_tree=null;
        RewriteRuleTokenStream stream_FUNCTION = new RewriteRuleTokenStream(adaptor,"token FUNCTION");
        RewriteRuleSubtreeStream stream_parameterDeclarationList = new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
        RewriteRuleSubtreeStream stream_block = new RewriteRuleSubtreeStream(adaptor,"rule block");
        RewriteRuleSubtreeStream stream_typeExpression = new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 139) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:4: ( FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:4: FUNCTION parameterDeclarationList ( typeExpression )? block
            {
            	FUNCTION452 = (IToken)input.LT(1);
            	Match(input,FUNCTION,FOLLOW_FUNCTION_in_functionDefinition4767); if (failed) return retval;
            	if ( backtracking==0 ) stream_FUNCTION.Add(FUNCTION452);

            	PushFollow(FOLLOW_parameterDeclarationList_in_functionDefinition4769);
            	parameterDeclarationList453 = parameterDeclarationList();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_parameterDeclarationList.Add(parameterDeclarationList453.Tree);
            	// C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1067:38: ( typeExpression )?
            	int alt109 = 2;
            	int LA109_0 = input.LA(1);
            	
            	if ( (LA109_0 == COLON) )
            	{
            	    alt109 = 1;
            	}
            	switch (alt109) 
            	{
            	    case 1 :
            	        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:0:0: typeExpression
            	        {
            	        	PushFollow(FOLLOW_typeExpression_in_functionDefinition4771);
            	        	typeExpression454 = typeExpression();
            	        	followingStackPointer_--;
            	        	if (failed) return retval;
            	        	if ( backtracking==0 ) stream_typeExpression.Add(typeExpression454.Tree);
            	        
            	        }
            	        break;
            	
            	}

            	PushFollow(FOLLOW_block_in_functionDefinition4774);
            	block455 = block();
            	followingStackPointer_--;
            	if (failed) return retval;
            	if ( backtracking==0 ) stream_block.Add(block455.Tree);
            	
            	// AST REWRITE
            	// elements:          block, typeExpression, parameterDeclarationList
            	// token labels:      
            	// rule labels:       retval
            	// token list labels: 
            	// rule list labels:  
            	if ( backtracking==0 ) {
            	retval.tree = root_0;
            	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
            	
            	root_0 = (CommonTree)adaptor.GetNilNode();
            	// 1068:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
            	{
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1068:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
            	    {
            	    CommonTree root_1 = (CommonTree)adaptor.GetNilNode();
            	    root_1 = (CommonTree)adaptor.BecomeRoot(adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);
            	    
            	    adaptor.AddChild(root_1, stream_parameterDeclarationList.Next());
            	    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1068:42: ( typeExpression )?
            	    if ( stream_typeExpression.HasNext() )
            	    {
            	        adaptor.AddChild(root_1, stream_typeExpression.Next());
            	    
            	    }
            	    stream_typeExpression.Reset();
            	    adaptor.AddChild(root_1, stream_block.Next());
            	    
            	    adaptor.AddChild(root_0, root_1);
            	    }
            	
            	}
            	
            	}
            
            }
    
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 139, functionDefinition_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end functionDefinition

    public class ident_return : ParserRuleReturnScope 
    {
        internal CommonTree tree;
        override public object Tree
        {
        	get { return tree; }
        }
    };
    
    // $ANTLR start ident
    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1072:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );
    public ident_return ident() // throws RecognitionException [1]
    {   
        ident_return retval = new ident_return();
        retval.start = input.LT(1);
        int ident_StartIndex = input.Index();
        CommonTree root_0 = null;
    
        IToken i = null;
        IToken IDENT456 = null;
        
        CommonTree i_tree=null;
        CommonTree IDENT456_tree=null;
        RewriteRuleTokenStream stream_GET = new RewriteRuleTokenStream(adaptor,"token GET");
        RewriteRuleTokenStream stream_XML = new RewriteRuleTokenStream(adaptor,"token XML");
        RewriteRuleTokenStream stream_AS = new RewriteRuleTokenStream(adaptor,"token AS");
        RewriteRuleTokenStream stream_DYNAMIC = new RewriteRuleTokenStream(adaptor,"token DYNAMIC");
        RewriteRuleTokenStream stream_NAMESPACE = new RewriteRuleTokenStream(adaptor,"token NAMESPACE");
        RewriteRuleTokenStream stream_SET = new RewriteRuleTokenStream(adaptor,"token SET");
        RewriteRuleTokenStream stream_IS = new RewriteRuleTokenStream(adaptor,"token IS");
        RewriteRuleTokenStream stream_USE = new RewriteRuleTokenStream(adaptor,"token USE");
    
        try 
    	{
    	    if ( (backtracking > 0) && AlreadyParsedRule(input, 140) ) 
    	    {
    	    	return retval; 
    	    }
            // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1073:4: ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] )
            int alt110 = 9;
            switch ( input.LA(1) ) 
            {
            case IDENT:
            	{
                alt110 = 1;
                }
                break;
            case USE:
            	{
                alt110 = 2;
                }
                break;
            case XML:
            	{
                alt110 = 3;
                }
                break;
            case DYNAMIC:
            	{
                alt110 = 4;
                }
                break;
            case NAMESPACE:
            	{
                alt110 = 5;
                }
                break;
            case IS:
            	{
                alt110 = 6;
                }
                break;
            case AS:
            	{
                alt110 = 7;
                }
                break;
            case GET:
            	{
                alt110 = 8;
                }
                break;
            case SET:
            	{
                alt110 = 9;
                }
                break;
            	default:
            	    if ( backtracking > 0 ) {failed = true; return retval;}
            	    NoViableAltException nvae_d110s0 =
            	        new NoViableAltException("1072:1: ident : ( IDENT | i= USE -> IDENT[$i] | i= XML -> IDENT[$i] | i= DYNAMIC -> IDENT[$i] | i= NAMESPACE -> IDENT[$i] | i= IS -> IDENT[$i] | i= AS -> IDENT[$i] | i= GET -> IDENT[$i] | i= SET -> IDENT[$i] );", 110, 0, input);
            
            	    throw nvae_d110s0;
            }
            
            switch (alt110) 
            {
                case 1 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1073:4: IDENT
                    {
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    
                    	IDENT456 = (IToken)input.LT(1);
                    	Match(input,IDENT,FOLLOW_IDENT_in_ident4801); if (failed) return retval;
                    	if ( backtracking==0 ) {
                    	IDENT456_tree = (CommonTree)adaptor.Create(IDENT456);
                    	adaptor.AddChild(root_0, IDENT456_tree);
                    	}
                    
                    }
                    break;
                case 2 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1074:4: i= USE
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,USE,FOLLOW_USE_in_ident4808); if (failed) return retval;
                    	if ( backtracking==0 ) stream_USE.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1074:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 3 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1075:4: i= XML
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,XML,FOLLOW_XML_in_ident4820); if (failed) return retval;
                    	if ( backtracking==0 ) stream_XML.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1075:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 4 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1076:4: i= DYNAMIC
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,DYNAMIC,FOLLOW_DYNAMIC_in_ident4832); if (failed) return retval;
                    	if ( backtracking==0 ) stream_DYNAMIC.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1076:14: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 5 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1077:4: i= NAMESPACE
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,NAMESPACE,FOLLOW_NAMESPACE_in_ident4844); if (failed) return retval;
                    	if ( backtracking==0 ) stream_NAMESPACE.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1077:16: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 6 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1078:4: i= IS
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,IS,FOLLOW_IS_in_ident4856); if (failed) return retval;
                    	if ( backtracking==0 ) stream_IS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1078:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 7 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1079:4: i= AS
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,AS,FOLLOW_AS_in_ident4868); if (failed) return retval;
                    	if ( backtracking==0 ) stream_AS.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1079:9: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 8 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1080:4: i= GET
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,GET,FOLLOW_GET_in_ident4880); if (failed) return retval;
                    	if ( backtracking==0 ) stream_GET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1080:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
                case 9 :
                    // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1081:4: i= SET
                    {
                    	i = (IToken)input.LT(1);
                    	Match(input,SET,FOLLOW_SET_in_ident4892); if (failed) return retval;
                    	if ( backtracking==0 ) stream_SET.Add(i);

                    	
                    	// AST REWRITE
                    	// elements:          
                    	// token labels:      
                    	// rule labels:       retval
                    	// token list labels: 
                    	// rule list labels:  
                    	if ( backtracking==0 ) {
                    	retval.tree = root_0;
                    	RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval!=null ? retval.Tree : null));
                    	
                    	root_0 = (CommonTree)adaptor.GetNilNode();
                    	// 1081:10: -> IDENT[$i]
                    	{
                    	    adaptor.AddChild(root_0, adaptor.Create(IDENT, i));
                    	
                    	}
                    	
                    	}
                    
                    }
                    break;
            
            }
            retval.stop = input.LT(-1);
            
            if ( backtracking==0 )
            {	retval.tree = (CommonTree)adaptor.RulePostProcessing(root_0);
            	adaptor.SetTokenBoundaries(retval.Tree, retval.start, retval.stop);
            }
        }
             finally 
    	{
            if ( backtracking > 0 ) 
            {
            	Memoize(input, 140, ident_StartIndex); 
            }
        }
        return retval;
    }
    // $ANTLR end ident

    // $ANTLR start synpred1
    public void synpred1_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:109:4: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred1397);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred1

    // $ANTLR start synpred19
    public void synpred19_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: ( SEMI )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:166:4: SEMI
        {
        	Match(input,SEMI,FOLLOW_SEMI_in_synpred19663); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred19

    // $ANTLR start synpred48
    public void synpred48_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:4: ( LCURLY )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:356:5: LCURLY
        {
        	Match(input,LCURLY,FOLLOW_LCURLY_in_synpred481584); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred48

    // $ANTLR start synpred50
    public void synpred50_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: ( expressionStatement )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:358:4: expressionStatement
        {
        	PushFollow(FOLLOW_expressionStatement_in_synpred501598);
        	expressionStatement();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred50

    // $ANTLR start synpred65
    public void synpred65_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:18: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:18: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred651791);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred65

    // $ANTLR start synpred66
    public void synpred66_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:47: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:419:47: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred661796);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred66

    // $ANTLR start synpred67
    public void synpred67_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:4: ( ELSE )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:420:5: ELSE
        {
        	Match(input,ELSE,FOLLOW_ELSE_in_synpred671803); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred67

    // $ANTLR start synpred68
    public void synpred68_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:10: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:424:10: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred681822);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred68

    // $ANTLR start synpred72
    public void synpred72_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:12: ( expression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:448:12: expression
        {
        	PushFollow(FOLLOW_expression_in_synpred721919);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred72

    // $ANTLR start synpred77
    public void synpred77_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:5: ( forInClauseDecl IN )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:500:6: forInClauseDecl IN
        {
        	PushFollow(FOLLOW_forInClauseDecl_in_synpred772158);
        	forInClauseDecl();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,IN,FOLLOW_IN_in_synpred772160); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred77

    // $ANTLR start synpred83
    public void synpred83_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:22: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:564:22: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred832435);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred83

    // $ANTLR start synpred84
    public void synpred84_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:8: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:8: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred842453);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred84

    // $ANTLR start synpred85
    public void synpred85_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:55: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:568:55: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred852464);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred85

    // $ANTLR start synpred86
    public void synpred86_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:21: ( commentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:572:21: commentExpression
        {
        	PushFollow(FOLLOW_commentExpression_in_synpred862485);
        	commentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred86

    // $ANTLR start synpred97
    public void synpred97_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:6: ( annotation )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:621:6: annotation
        {
        	PushFollow(FOLLOW_annotation_in_synpred972754);
        	annotation();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred97

    // $ANTLR start synpred98
    public void synpred98_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:622:5: ( includeDirective )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:622:5: includeDirective
        {
        	PushFollow(FOLLOW_includeDirective_in_synpred982760);
        	includeDirective();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred98

    // $ANTLR start synpred116
    public void synpred116_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:26: ( COMMA assignmentExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:715:26: COMMA assignmentExpression
        {
        	Match(input,COMMA,FOLLOW_COMMA_in_synpred1163134); if (failed) return ;
        	PushFollow(FOLLOW_assignmentExpression_in_synpred1163136);
        	assignmentExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred116

    // $ANTLR start synpred122
    public void synpred122_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:755:4: ( assignmentOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:755:5: assignmentOperator
        {
        	PushFollow(FOLLOW_assignmentOperator_in_synpred1223309);
        	assignmentOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred122

    // $ANTLR start synpred148
    public void synpred148_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:4: ( relationalOperator )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:845:5: relationalOperator
        {
        	PushFollow(FOLLOW_relationalOperator_in_synpred1483674);
        	relationalOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred148

    // $ANTLR start synpred159
    public void synpred159_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:4: ( additiveOperator multiplicativeExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:866:4: additiveOperator multiplicativeExpression
        {
        	PushFollow(FOLLOW_additiveOperator_in_synpred1593783);
        	additiveOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_multiplicativeExpression_in_synpred1593786);
        	multiplicativeExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred159

    // $ANTLR start synpred161
    public void synpred161_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:876:5: ( multiplicativeOperator unaryExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:876:5: multiplicativeOperator unaryExpression
        {
        	PushFollow(FOLLOW_multiplicativeOperator_in_synpred1613822);
        	multiplicativeOperator();
        	followingStackPointer_--;
        	if (failed) return ;
        	PushFollow(FOLLOW_unaryExpression_in_synpred1613828);
        	unaryExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred161

    // $ANTLR start synpred175
    public void synpred175_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:908:5: ( LBRACK expression RBRACK )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:908:5: LBRACK expression RBRACK
        {
        	Match(input,LBRACK,FOLLOW_LBRACK_in_synpred1754062); if (failed) return ;
        	PushFollow(FOLLOW_expression_in_synpred1754064);
        	expression();
        	followingStackPointer_--;
        	if (failed) return ;
        	Match(input,RBRACK,FOLLOW_RBRACK_in_synpred1754066); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred175

    // $ANTLR start synpred177
    public void synpred177_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:5: ( arguments )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:910:5: arguments
        {
        	PushFollow(FOLLOW_arguments_in_synpred1774091);
        	arguments();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred177

    // $ANTLR start synpred178
    public void synpred178_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:6: ( INC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:913:6: INC
        {
        	Match(input,INC,FOLLOW_INC_in_synpred1784117); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred178

    // $ANTLR start synpred179
    public void synpred179_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:914:6: ( DEC )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:914:6: DEC
        {
        	Match(input,DEC,FOLLOW_DEC_in_synpred1794136); if (failed) return ;
        
        }
    }
    // $ANTLR end synpred179

    // $ANTLR start synpred189
    public void synpred189_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:944:4: ( newFullExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:944:4: newFullExpression
        {
        	PushFollow(FOLLOW_newFullExpression_in_synpred1894268);
        	newFullExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred189

    // $ANTLR start synpred190
    public void synpred190_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:4: ( newShortExpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:945:4: newShortExpression
        {
        	PushFollow(FOLLOW_newShortExpression_in_synpred1904273);
        	newShortExpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred190

    // $ANTLR start synpred202
    public void synpred202_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:5: ( DOT qualifiedIdent )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1009:5: DOT qualifiedIdent
        {
        	Match(input,DOT,FOLLOW_DOT_in_synpred2024506); if (failed) return ;
        	PushFollow(FOLLOW_qualifiedIdent_in_synpred2024508);
        	qualifiedIdent();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred202

    // $ANTLR start synpred203
    public void synpred203_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:5: ( brackets )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1010:5: brackets
        {
        	PushFollow(FOLLOW_brackets_in_synpred2034525);
        	brackets();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred203

    // $ANTLR start synpred204
    public void synpred204_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1019:4: ( fullNewSubexpression )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1019:4: fullNewSubexpression
        {
        	PushFollow(FOLLOW_fullNewSubexpression_in_synpred2044569);
        	fullNewSubexpression();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred204

    // $ANTLR start synpred206
    public void synpred206_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:22: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1034:22: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred2064627);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred206

    // $ANTLR start synpred208
    public void synpred208_fragment() //throws RecognitionException
    {   
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:21: ( comment )
        // C:\\Users\\sephiroth\\Documents\\Visual Studio 2005\\Projects\\AS3Parser\\AS3Parser\\AS.g:1035:21: comment
        {
        	PushFollow(FOLLOW_comment_in_synpred2084646);
        	comment();
        	followingStackPointer_--;
        	if (failed) return ;
        
        }
    }
    // $ANTLR end synpred208

   	public bool synpred206() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred206_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred19() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred19_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred204() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred204_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred203() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred203_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred1() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred1_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred48() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred48_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred202() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred202_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred159() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred159_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred189() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred189_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred77() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred77_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred122() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred122_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred72() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred72_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred86() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred86_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred85() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred85_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred84() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred84_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred83() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred83_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred50() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred50_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred161() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred161_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred190() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred190_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred68() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred68_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred179() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred179_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred148() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred148_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred67() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred67_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred98() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred98_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred178() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred178_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred116() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred116_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred66() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred66_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred97() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred97_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred177() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred177_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred65() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred65_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred175() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred175_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}
   	public bool synpred208() 
   	{
   	    backtracking++;
   	    int start = input.Mark();
   	    try 
   	    {
   	        synpred208_fragment(); // can never throw exception
   	    }
   	    catch (RecognitionException re) 
   	    {
   	        Console.Error.WriteLine("impossible: "+re);
   	    }
   	    bool success = !failed;
   	    input.Rewind(start);
   	    backtracking--;
   	    failed = false;
   	    return success;
   	}


	private void InitializeCyclicDFAs()
	{
	}

 

    public static readonly BitSet FOLLOW_as2CompilationUnit_in_as2Program355 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as3CompilationUnit_in_as3Program375 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as2CompilationUnit397 = new BitSet(new ulong[]{0x8000000000000000UL,0x000037E000000003UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_importDefinition_in_as2CompilationUnit403 = new BitSet(new ulong[]{0x8000000000000000UL,0x000037E000000003UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_annotations_in_as2CompilationUnit409 = new BitSet(new ulong[]{0x0000000000000000UL,0x000037E000000003UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as2CompilationUnit413 = new BitSet(new ulong[]{0x0000000000000000UL,0x000037E000000003UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_as2Type_in_as2CompilationUnit419 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_as2Type432 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000003UL});
    public static readonly BitSet FOLLOW_as2ClassDefinition_in_as2Type438 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2InterfaceDefinition_in_as2Type444 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_as3CompilationUnit462 = new BitSet(new ulong[]{0x0800000000000000UL});
    public static readonly BitSet FOLLOW_packageDecl_in_as3CompilationUnit467 = new BitSet(new ulong[]{0xC000000000000000UL,0x000037E000003C83UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_packageBlockEntry_in_as3CompilationUnit471 = new BitSet(new ulong[]{0xC000000000000000UL,0x000037E000003C83UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_EOF_in_as3CompilationUnit476 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PACKAGE_in_packageDecl488 = new BitSet(new ulong[]{0x1000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_packageDecl491 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_packageBlock_in_packageDecl496 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_packageBlock507 = new BitSet(new ulong[]{0xE000000000000000UL,0x000037E000003C83UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_packageBlockEntry_in_packageBlock511 = new BitSet(new ulong[]{0xE000000000000000UL,0x000037E000003C83UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_packageBlock516 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_packageBlockEntry540 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_packageBlockEntry546 = new BitSet(new ulong[]{0x0000000000000000UL,0x000033E000003C83UL,0x07C0000000000000UL});
    public static readonly BitSet FOLLOW_modifiers_in_packageBlockEntry554 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000003C83UL});
    public static readonly BitSet FOLLOW_classDefinition_in_packageBlockEntry562 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_interfaceDefinition_in_packageBlockEntry570 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_variableDefinition_in_packageBlockEntry578 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_methodDefinition_in_packageBlockEntry586 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_namespaceDefinition_in_packageBlockEntry594 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_useNamespaceDirective_in_packageBlockEntry602 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_packageBlockEntry613 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_packageBlockEntry624 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EOF_in_endOfFile635 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IMPORT_in_importDefinition647 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifierStar_in_importDefinition650 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_importDefinition652 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_semi663 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_classDefinition680 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_classDefinition682 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000014UL});
    public static readonly BitSet FOLLOW_classExtendsClause_in_classDefinition686 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_implementsClause_in_classDefinition690 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_classDefinition694 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CLASS_in_as2ClassDefinition724 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_as2ClassDefinition726 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000014UL});
    public static readonly BitSet FOLLOW_classExtendsClause_in_as2ClassDefinition730 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000010UL});
    public static readonly BitSet FOLLOW_implementsClause_in_as2ClassDefinition734 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_as2ClassDefinition738 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDefinition773 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_interfaceDefinition775 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_interfaceDefinition779 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_interfaceDefinition783 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INTERFACE_in_as2InterfaceDefinition816 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_as2InterfaceDefinition818 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000004UL});
    public static readonly BitSet FOLLOW_interfaceExtendsClause_in_as2InterfaceDefinition822 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_typeBlock_in_as2InterfaceDefinition826 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_classExtendsClause854 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_classExtendsClause857 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceExtendsClause870 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause873 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_interfaceExtendsClause877 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_interfaceExtendsClause880 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_implementsClause895 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause898 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_implementsClause902 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_implementsClause905 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_LCURLY_in_typeBlock919 = new BitSet(new ulong[]{0xA000000000000000UL,0x000037E0000030A0UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_typeBlockEntry_in_typeBlock923 = new BitSet(new ulong[]{0xA000000000000000UL,0x000037E0000030A0UL,0x07C1003000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_typeBlock928 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifiers_in_typeBlockEntry952 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000003080UL});
    public static readonly BitSet FOLLOW_variableDefinition_in_typeBlockEntry959 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_methodDefinition_in_typeBlockEntry966 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_importDefinition_in_typeBlockEntry976 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_as2IncludeDirective_in_typeBlockEntry981 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_typeBlockEntry986 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotations_in_typeBlockEntry991 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INCLUDE_DIRECTIVE_in_as2IncludeDirective1002 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000040UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_as2IncludeDirective1004 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_176_in_includeDirective1023 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000040UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_includeDirective1027 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_includeDirective1031 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_methodDefinition1044 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_optionalAccessorRole_in_methodDefinition1050 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_methodDefinition1054 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_methodDefinition1058 = new BitSet(new ulong[]{0x5000000000000002UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_methodDefinition1062 = new BitSet(new ulong[]{0x5000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_methodDefinition1068 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_methodDefinition1070 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_accessorRole_in_optionalAccessorRole1134 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_accessorRole0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDefinition1173 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_namespaceDefinition1175 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective1200 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective1202 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_useNamespaceDirective1204 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_useNamespaceDirective1206 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_variableDefinition1230 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1232 = new BitSet(new ulong[]{0x4000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_variableDefinition1237 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_variableDefinition1239 = new BitSet(new ulong[]{0x4000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_semi_in_variableDefinition1245 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_varOrConst0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_variableDeclarator1287 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000002004000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_variableDeclarator1290 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_variableInitializer_in_variableDeclarator1293 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_varOrConst_in_declaration1304 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declaration1307 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_declarationTail_in_declaration1311 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_declarationTail1333 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_variableDeclarator_in_declarationTail1336 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_variableInitializer1349 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableInitializer1352 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_parameterDeclarationList1365 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200032F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1371 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010008UL});
    public static readonly BitSet FOLLOW_COMMA_in_parameterDeclarationList1377 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200022F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_parameterDeclaration_in_parameterDeclarationList1379 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010008UL});
    public static readonly BitSet FOLLOW_RPAREN_in_parameterDeclarationList1390 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_basicParameterDeclaration_in_parameterDeclaration1413 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_parameterRestDeclaration_in_parameterDeclaration1417 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONST_in_basicParameterDeclaration1428 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_basicParameterDeclaration1431 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000002004000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_basicParameterDeclaration1433 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_parameterDefault_in_basicParameterDeclaration1436 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_parameterDefault1480 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_parameterDefault1483 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_REST_in_parameterRestDeclaration1494 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_parameterRestDeclaration1496 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_block1520 = new BitSet(new ulong[]{0x7000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_blockEntry_in_block1522 = new BitSet(new ulong[]{0x7000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_RCURLY_in_block1525 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_blockEntry1547 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_condition1558 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_condition1560 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_condition1562 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_block_in_statement1588 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declarationStatement_in_statement1593 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_statement1598 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ifStatement_in_statement1603 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forEachStatement_in_statement1610 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forStatement_in_statement1615 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_whileStatement_in_statement1623 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement1631 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_withStatement_in_statement1640 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_switchStatement_in_statement1649 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_breakStatement_in_statement1658 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_continueStatement_in_statement1666 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_returnStatement_in_statement1674 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_throwStatement_in_statement1682 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_tryStatement_in_statement1691 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_defaultXMLNamespaceStatement_in_statement1700 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_statement1709 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_statement1717 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_declarationStatement1739 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_declarationStatement1741 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_expressionStatement1762 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_expressionStatement1764 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IF_in_ifStatement1786 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_condition_in_ifStatement1789 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_commentExpression_in_ifStatement1791 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_ifStatement1794 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000080000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_ifStatement1796 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000080000UL});
    public static readonly BitSet FOLLOW_elseClause_in_ifStatement1806 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_elseClause1819 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_commentExpression_in_elseClause1822 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_elseClause1825 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_177_in_throwStatement1836 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_throwStatement1839 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_throwStatement1841 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_178_in_tryStatement1852 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_block_in_tryStatement1856 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0018000000000000UL});
    public static readonly BitSet FOLLOW_catchBlock_in_tryStatement1860 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0018000000000000UL});
    public static readonly BitSet FOLLOW_finallyBlock_in_tryStatement1865 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_179_in_catchBlock1877 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_catchBlock1879 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_catchBlock1882 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000002010000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_catchBlock1884 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_catchBlock1887 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_block_in_catchBlock1892 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_180_in_finallyBlock1903 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_block_in_finallyBlock1905 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement1916 = new BitSet(new ulong[]{0x5000000000000002UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_returnStatement1919 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_returnStatement1922 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement1935 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_continueStatement1938 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement1949 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_breakStatement1952 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement1963 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_condition_in_switchStatement1967 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_switchStatement1969 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_switchBlock_in_switchStatement1975 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_switchBlock1986 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000005000000UL});
    public static readonly BitSet FOLLOW_caseStatement_in_switchBlock1991 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000000005000000UL});
    public static readonly BitSet FOLLOW_defaultStatement_in_switchBlock1998 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_switchBlock2004 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_CASE_in_caseStatement2029 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_caseStatement2032 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_COLON_in_caseStatement2034 = new BitSet(new ulong[]{0x5000000000000002UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_switchStatementList_in_caseStatement2039 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultStatement2051 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_COLON_in_defaultStatement2054 = new BitSet(new ulong[]{0x5000000000000002UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_switchStatementList_in_defaultStatement2059 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_statement_in_switchStatementList2070 = new BitSet(new ulong[]{0x5000000000000002UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_FOR_in_forEachStatement2093 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000010000000UL});
    public static readonly BitSet FOLLOW_EACH_in_forEachStatement2095 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forEachStatement2099 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200003F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_forInClause_in_forEachStatement2103 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forEachStatement2107 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_forEachStatement2111 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FOR_in_forStatement2147 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement2151 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E20000BFC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_forInClause_in_forStatement2163 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2165 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2167 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_traditionalForClause_in_forStatement2188 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement2190 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_forStatement2192 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInit_in_traditionalForClause2223 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2225 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_forCond_in_traditionalForClause2233 = new BitSet(new ulong[]{0x4000000000000000UL});
    public static readonly BitSet FOLLOW_SEMI_in_traditionalForClause2235 = new BitSet(new ulong[]{0x1000000000000002UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_forIter_in_traditionalForClause2243 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_forInClause2255 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_IN_in_forInClause2257 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_forInClauseTail_in_forInClause2260 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInClauseDecl2281 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_forInClauseDecl2285 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInClauseTail2307 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_declaration_in_forInit2331 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forInit2335 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forCond2373 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionList_in_forIter2406 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement2429 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_condition_in_whileStatement2432 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_commentExpression_in_whileStatement2435 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_whileStatement2438 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement2450 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_commentExpression_in_doWhileStatement2453 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement2456 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000040000000UL});
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement2458 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_condition_in_doWhileStatement2462 = new BitSet(new ulong[]{0x4000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_commentExpression_in_doWhileStatement2464 = new BitSet(new ulong[]{0x4000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_semi_in_doWhileStatement2468 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_WITH_in_withStatement2479 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_condition_in_withStatement2482 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_commentExpression_in_withStatement2485 = new BitSet(new ulong[]{0x5000000000000000UL,0x000027E3CCF4BFC0UL,0x0026003FFDFB8620UL});
    public static readonly BitSet FOLLOW_statement_in_withStatement2488 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceStatement2500 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000200000000UL});
    public static readonly BitSet FOLLOW_XML_in_defaultXMLNamespaceStatement2502 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000400UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceStatement2504 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceStatement2506 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_defaultXMLNamespaceStatement2508 = new BitSet(new ulong[]{0x4000000000000002UL});
    public static readonly BitSet FOLLOW_semi_in_defaultXMLNamespaceStatement2510 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COLON_in_typeExpression2533 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E600000F00UL,0x0020000000000600UL});
    public static readonly BitSet FOLLOW_identifier_in_typeExpression2541 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_181_in_typeExpression2545 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_typeExpression2549 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2581 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifier2599 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_identifier2601 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL});
    public static readonly BitSet FOLLOW_namespaceName_in_qualifiedIdent2629 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000001000000000UL});
    public static readonly BitSet FOLLOW_DBL_COLON_in_qualifiedIdent2631 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_qualifiedIdent2635 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_namespaceName2647 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_reservedNamespace_in_namespaceName2651 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_reservedNamespace0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar2688 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar2705 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_identifierStar2707 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000800000000UL});
    public static readonly BitSet FOLLOW_DOT_in_identifierStar2719 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000400000000UL});
    public static readonly BitSet FOLLOW_STAR_in_identifierStar2721 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_annotations2754 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040000000000UL,0x0001000000000000UL});
    public static readonly BitSet FOLLOW_includeDirective_in_annotations2760 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040000000000UL,0x0001000000000000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_annotation2787 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_ident_in_annotation2791 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000008000UL});
    public static readonly BitSet FOLLOW_annotationParamList_in_annotation2795 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_annotation2800 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_annotationParamList2826 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200010F40UL,0x00000007F0020620UL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2832 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010008UL});
    public static readonly BitSet FOLLOW_COMMA_in_annotationParamList2838 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000202200000F40UL,0x00000007F0020620UL});
    public static readonly BitSet FOLLOW_annotationParam_in_annotationParamList2840 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010008UL});
    public static readonly BitSet FOLLOW_RPAREN_in_annotationParamList2851 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam2878 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000004000UL});
    public static readonly BitSet FOLLOW_ASSIGN_in_annotationParam2880 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000000040UL,0x00000007F0020020UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam2882 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_annotationParam2897 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_annotationParam2906 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_modifier_in_modifiers2921 = new BitSet(new ulong[]{0x0000000000000002UL,0x000033E000000000UL,0x07C0000000000000UL});
    public static readonly BitSet FOLLOW_namespaceName_in_modifier2944 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STATIC_in_modifier2949 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_182_in_modifier2954 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_183_in_modifier2959 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_184_in_modifier2964 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_185_in_modifier2969 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_modifier2974 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_186_in_modifier2979 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3000 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expressionList_in_arguments3002 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3004 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_arguments3019 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_arguments3021 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_element3051 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral3073 = new BitSet(new ulong[]{0x1000000000000000UL,0x00002FE200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral3075 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral3078 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3100 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_elementList3103 = new BitSet(new ulong[]{0x1000000000000002UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_nonemptyElementList_in_elementList3106 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3131 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_nonemptyElementList3134 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_nonemptyElementList3136 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral3151 = new BitSet(new ulong[]{0x2000000000000000UL,0x0000202200000F00UL,0x0000000780000600UL});
    public static readonly BitSet FOLLOW_fieldList_in_objectLiteral3153 = new BitSet(new ulong[]{0x2000000000000000UL});
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral3156 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList3179 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_fieldList3182 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000202200000F00UL,0x0000000780000600UL});
    public static readonly BitSet FOLLOW_literalField_in_fieldList3185 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_fieldName_in_literalField3202 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_COLON_in_literalField3204 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_element_in_literalField3206 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ident_in_fieldName3230 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_fieldName3235 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression3257 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3269 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_COMMA_in_expressionList3272 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_expressionList3274 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000008UL});
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression3303 = new BitSet(new ulong[]{0x0000000000000002UL,0x07FFC00000004000UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression3313 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression3317 = new BitSet(new ulong[]{0x0000000000000002UL,0x07FFC00000004000UL});
    public static readonly BitSet FOLLOW_set_in_assignmentOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalOrExpression_in_conditionalExpression3411 = new BitSet(new ulong[]{0x0000000000000002UL,0x0800000000000000UL});
    public static readonly BitSet FOLLOW_QUESTION_in_conditionalExpression3425 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_conditionalSubExpression_in_conditionalExpression3430 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3459 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_COLON_in_conditionalSubExpression3461 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalSubExpression3464 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3478 = new BitSet(new ulong[]{0x0000000000000002UL,0x1000000000000000UL,0x0800000000000000UL});
    public static readonly BitSet FOLLOW_logicalOrOperator_in_logicalOrExpression3483 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression3486 = new BitSet(new ulong[]{0x0000000000000002UL,0x1000000000000000UL,0x0800000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalOrOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3515 = new BitSet(new ulong[]{0x0000000000000002UL,0x2000000000000000UL,0x1000000000000000UL});
    public static readonly BitSet FOLLOW_logicalAndOperator_in_logicalAndExpression3520 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_bitwiseOrExpression_in_logicalAndExpression3523 = new BitSet(new ulong[]{0x0000000000000002UL,0x2000000000000000UL,0x1000000000000000UL});
    public static readonly BitSet FOLLOW_set_in_logicalAndOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3552 = new BitSet(new ulong[]{0x0000000000000002UL,0x4000000000000000UL});
    public static readonly BitSet FOLLOW_BOR_in_bitwiseOrExpression3557 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_bitwiseXorExpression_in_bitwiseOrExpression3560 = new BitSet(new ulong[]{0x0000000000000002UL,0x4000000000000000UL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3574 = new BitSet(new ulong[]{0x0000000000000002UL,0x8000000000000000UL});
    public static readonly BitSet FOLLOW_BXOR_in_bitwiseXorExpression3579 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_bitwiseAndExpression_in_bitwiseXorExpression3582 = new BitSet(new ulong[]{0x0000000000000002UL,0x8000000000000000UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3596 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_BAND_in_bitwiseAndExpression3601 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseAndExpression3604 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000000001UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3618 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000001EUL});
    public static readonly BitSet FOLLOW_equalityOperator_in_equalityExpression3623 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression3628 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x000000000000001EUL});
    public static readonly BitSet FOLLOW_set_in_equalityOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3668 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL,0x0000000000000FE0UL});
    public static readonly BitSet FOLLOW_relationalOperator_in_relationalExpression3678 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression3681 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000020000000UL,0x0000000000000FE0UL});
    public static readonly BitSet FOLLOW_IN_in_relationalOperator3696 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_relationalOperator3701 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GT_in_relationalOperator3705 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LE_in_relationalOperator3709 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GE_in_relationalOperator3713 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_relationalOperator3717 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_relationalOperator3721 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INSTANCEOF_in_relationalOperator3725 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3737 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000007000UL});
    public static readonly BitSet FOLLOW_shiftOperator_in_shiftExpression3742 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression3745 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000007000UL});
    public static readonly BitSet FOLLOW_set_in_shiftOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3778 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000018000UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_additiveExpression3783 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3786 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000000000018000UL});
    public static readonly BitSet FOLLOW_set_in_additiveOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3816 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL,0x0000000000060000UL});
    public static readonly BitSet FOLLOW_multiplicativeOperator_in_multiplicativeExpression3822 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression3828 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000400000000UL,0x0000000000060000UL});
    public static readonly BitSet FOLLOW_set_in_multiplicativeOperator0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_unaryExpression3866 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3868 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_unaryExpression3884 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3886 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_MINUS_in_unaryExpression3900 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3902 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_PLUS_in_unaryExpression3915 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression3917 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_unaryExpressionNotPlusMinus_in_unaryExpression3930 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DELETE_in_unaryExpressionNotPlusMinus3941 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0000000FFC020620UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus3943 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_181_in_unaryExpressionNotPlusMinus3956 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3958 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TYPEOF_in_unaryExpressionNotPlusMinus3971 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3973 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LNOT_in_unaryExpressionNotPlusMinus3986 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus3988 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_BNOT_in_unaryExpressionNotPlusMinus4001 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpressionNotPlusMinus4003 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpressionNotPlusMinus4016 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_postfixExpression4029 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_propOrIdent_in_postfixExpression4042 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_DOT_in_postfixExpression4054 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000400008000UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression4056 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_LBRACK_in_postfixExpression4062 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_postfixExpression4064 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_postfixExpression4066 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_E4X_DESC_in_postfixExpression4083 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000400008000UL,0x0000000004000000UL});
    public static readonly BitSet FOLLOW_e4xExpression_in_postfixExpression4085 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_arguments_in_postfixExpression4091 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800008000UL,0x0000000002180000UL});
    public static readonly BitSet FOLLOW_INC_in_postfixExpression4117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_postfixExpression4136 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_e4xExpression4163 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_e4xExpression4169 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xFilterPredicate_in_e4xExpression4174 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_E4X_ATTRI_in_e4xAttributeIdentifier4185 = new BitSet(new ulong[]{0x0000000000000000UL,0x000027E600000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_e4xAttributeIdentifier4191 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STAR_in_e4xAttributeIdentifier4197 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_e4xAttributeIdentifier4203 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_e4xAttributeIdentifier4205 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_e4xAttributeIdentifier4207 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_e4xFilterPredicate4222 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_e4xFilterPredicate4227 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_e4xFilterPredicate4231 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_UNDEFINED_in_primaryExpression4243 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_constant_in_primaryExpression4248 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpression4253 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpression4258 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_functionDefinition_in_primaryExpression4263 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newFullExpression_in_primaryExpression4268 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_primaryExpression4273 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_encapsulatedExpression_in_primaryExpression4278 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_e4xAttributeIdentifier_in_primaryExpression4283 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_primaryExpression4288 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propOrIdent4308 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_propOrIdent4312 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_xmlLiteral_in_constant4340 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_regexpLiteral_in_constant4345 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_number_in_constant4350 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_STRING_LITERAL_in_constant4355 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_TRUE_in_constant4360 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FALSE_in_constant4365 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NULL_in_constant4370 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_set_in_number0 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LT_in_xmlLiteral4423 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DIV_in_regexpLiteral4453 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NEW_in_newFullExpression4474 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0000000FFC020620UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_newFullExpression4477 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_arguments_in_newFullExpression4479 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_primaryExpression_in_fullNewSubexpression4492 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800000000UL});
    public static readonly BitSet FOLLOW_DOT_in_fullNewSubexpression4506 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_fullNewSubexpression4508 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800000000UL});
    public static readonly BitSet FOLLOW_brackets_in_fullNewSubexpression4525 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000040800000000UL});
    public static readonly BitSet FOLLOW_NEW_in_newShortExpression4553 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0000000FFC020620UL});
    public static readonly BitSet FOLLOW_shortNewSubexpression_in_newShortExpression4556 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_shortNewSubexpression4569 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_shortNewSubexpression4574 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_propertyOperator4586 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_propertyOperator4589 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_brackets_in_propertyOperator4594 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_commentExpression4606 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_singleLineComment_in_comment4625 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment4627 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_multilineComment_in_comment4644 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_comment_in_comment4646 = new BitSet(new ulong[]{0x0000000000000002UL,0x0000000000000000UL,0x0000003000000000UL});
    public static readonly BitSet FOLLOW_SL_COMMENT_in_singleLineComment4669 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ML_COMMENT_in_multilineComment4689 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_brackets4714 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expressionList_in_brackets4716 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_brackets4718 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LPAREN_in_encapsulatedExpression4739 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_encapsulatedExpression4741 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000010000UL});
    public static readonly BitSet FOLLOW_RPAREN_in_encapsulatedExpression4743 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDefinition4767 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000000008000UL});
    public static readonly BitSet FOLLOW_parameterDeclarationList_in_functionDefinition4769 = new BitSet(new ulong[]{0x1000000000000000UL,0x0000000002000000UL});
    public static readonly BitSet FOLLOW_typeExpression_in_functionDefinition4771 = new BitSet(new ulong[]{0x1000000000000000UL});
    public static readonly BitSet FOLLOW_block_in_functionDefinition4774 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IDENT_in_ident4801 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_USE_in_ident4808 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_XML_in_ident4820 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DYNAMIC_in_ident4832 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_NAMESPACE_in_ident4844 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_IS_in_ident4856 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_AS_in_ident4868 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_GET_in_ident4880 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SET_in_ident4892 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred1397 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_SEMI_in_synpred19663 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LCURLY_in_synpred481584 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expressionStatement_in_synpred501598 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred651791 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred661796 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_ELSE_in_synpred671803 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred681822 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_expression_in_synpred721919 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_forInClauseDecl_in_synpred772158 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000000020000000UL});
    public static readonly BitSet FOLLOW_IN_in_synpred772160 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred832435 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred842453 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred852464 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_commentExpression_in_synpred862485 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_annotation_in_synpred972754 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_includeDirective_in_synpred982760 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_COMMA_in_synpred1163134 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred1163136 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred1223309 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_relationalOperator_in_synpred1483674 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_additiveOperator_in_synpred1593783 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred1593786 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_multiplicativeOperator_in_synpred1613822 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred1613828 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_LBRACK_in_synpred1754062 = new BitSet(new ulong[]{0x1000000000000000UL,0x000027E200008FC0UL,0x0020000FFDFB8620UL});
    public static readonly BitSet FOLLOW_expression_in_synpred1754064 = new BitSet(new ulong[]{0x0000000000000000UL,0x0000080000000000UL});
    public static readonly BitSet FOLLOW_RBRACK_in_synpred1754066 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_arguments_in_synpred1774091 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_INC_in_synpred1784117 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DEC_in_synpred1794136 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newFullExpression_in_synpred1894268 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_newShortExpression_in_synpred1904273 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_DOT_in_synpred2024506 = new BitSet(new ulong[]{0x0000000000000000UL,0x000023E200000F00UL,0x0000000000000600UL});
    public static readonly BitSet FOLLOW_qualifiedIdent_in_synpred2024508 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_brackets_in_synpred2034525 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_fullNewSubexpression_in_synpred2044569 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred2064627 = new BitSet(new ulong[]{0x0000000000000002UL});
    public static readonly BitSet FOLLOW_comment_in_synpred2084646 = new BitSet(new ulong[]{0x0000000000000002UL});

}
}